---
title: 面经整理
author: jimowo
icon: write
date: 2023-08-01
order: 3
category:
  - 面经
tag:
  - Java
---

# 面经整理

### 1. Java中的继承和多态 接口和抽象类的区别 StringBuffer和StringBuilder的区别

- 继承和多态

  继承是子类继承父类的除了静态方法和静态字段的所有方法和字段。
  多态分为类的多态和方法的多态。类的多态体现为继承，方法的多态体现为对方法的重载。

- 接口和抽象类的区别

  抽象类中可以有构造函数和非抽象方法，接口不能实例化，且所有方法都是抽象方法，jdk1.8中出现了default修饰的方法。接口中的所有成员变量都是public static final修饰的。
  接口是行为的抽象，cloneable之类的，是**Like A** 的关系；
  抽象类是类的抽象，是一种模板设计，是**Is A **的关系

- StringBuffer 和StringBuilder的区别

  StringBuilder线程不安全，效率比StringBuffer 高；
  StringBuffer的所有public 方法都是synchronized 修饰的。
  底层是默认长度为16的字符数组，每次扩容为数组原长度的2倍+2

### 2. error和exception的区别 怎么处理exception

- error和exception的区别

  Error 是指程序无法处理的错误，虚拟机错误、栈溢出（SOF）、内存溢出（OOM）

  Exception 是指程序本身可以处理的异常（可以自己Throw）

- 怎么处理exception

  exception分为编译时异常和运行时异常，前者由编译器发现。后者可以通过throw和catch来自定义处理

### 3. 什么是泛型 泛型的作用 泛型的使用方式有哪几种

- 什么是泛型

  参数化类型，把类型参数化

- 泛型的作用

  代码重用：在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型。实现模板的效果

  类型安全：通过指定泛型类型参数，编译器可以在编译时检查代码的类型安全性，避免在运行时出现类型转换错误。

  减少类型转换：泛型可以避免繁琐的类型转换操作，提高代码的可读性和维护性。

- 泛型的使用方式

  泛型类：带有泛型类型属性的类 `List<T>`；
  泛型接口：带有泛型类型参数的接口 `Comparable<T>`；
  泛型方法：带有泛型类型参数的方法 `public <T> void printArray(T[] array)`

### 4. HashMap的遍历方式有哪几种 ?HashMap与HashTable的区别? HashMap底层?(为什么是8和64没答出来 为什么选择红黑树这种数据结构 介绍一下红黑树)

- HashMap的遍历方式有哪几种 4种
  1. 使用 `keySet()` 方法遍历键（key）
  2. 使用 `values()` 方法遍历值（value）
  3. 使用 `entrySet()` 方法遍历键值对（entry）
  4. 使用迭代器（Iterator）遍历键值对
- HashMap与HashTable的区别
  1. HashTable线程安全
  2. HashMap允许键和值为null
  3. HashMap实现了Map接口，HashTable是Dictionary的子类
  4. `HashMap`可以指定初始容量和负载因子。当 `HashMap` 的元素数量超过负载因子与当前容量的乘积时，`HashMap` 会自动进行扩容。`HashTable` 在构造时只能指定初始容量，默认的负载因子是 0.75。扩容时，`HashTable` 的大小必须为素数，并且会创建一个新的数组来重新分配元素。

### 5. Java中实现多线程

1. 继承Thread类，重写run方法
2. 实现Runnable接口，把任务加入Thread类，启动（线程任务与线程控制分离）

### 6. Lambda表达式

是对匿名函数的简写形式

他的写法是使用一个`->`符号，左边写的是形参列表，右边就是对抽象方法的处理

- 无返回值有形参的抽象方法

  - 可以省略方法名，IDEA会帮你自动检测方法名；
  - 可以省略方法中的形参类型；
  - 如果对抽象方法的实现逻辑只有一行，可以省略方法体的大括号，当然如果不止一行，就不能省略了；

- 有返回值的抽象方法

  有返回值的方法，如果要去掉大括号，还需要去掉return关键字

- 有一个形参的抽象方法

  形参列表中只有一个参数，可以去掉形参的括号

- Lambda表达式也可以作为参数传递

- **Lambda表达式不是万能的，他需要函数式接口的支持**

  - 函数式接口的定义是: 只包含一个抽象方法的接口，称为函数式接口
  - 4大函数式接口
    1. `Consumer<T>`：该函数式接口接受一个输入参数，并对其进行操作，但没有返回结果。常用的方法是 `accept(T t)`，用于对给定的参数执行某些操作
    2. `Supplier<T>`：该函数式接口不接受任何输入参数，但返回一个结果。常用的方法是 `get()`，用于获取结果。
    3. `Function<T, R>`：该函数式接口接受一个输入参数，并将其转换为另一种类型的结果。常用的方法是 `apply(T t)`，用于对给定的参数进行处理并返回结果。
    4. `Predicate<T>`：该函数式接口接受一个输入参数，并返回一个布尔值结果。常用的方法是 `test(T t)`，用于对给定的参数进行条件判断。

### 7. 你最擅长的Java框架,介绍一下 Spring的核心思想

Spring框架的核心思想是**IOC**（Inversion of Control，控制反转）和**AOP**（Aspect-Oriented Programming，面向切面编程）。

1. IOC（控制反转）：IOC的核心理念是将对象的创建、依赖注入和生命周期管理交给Spring容器来完成，通过配置文件或注解的方式，让Spring容器在运行时动态地管理和组装对象。能够降低代码的耦合性、提高代码的可维护性和可测试性。
2. AOP（面向切面编程）：AOP通过在不修改原有代码的情况下，增加一些额外的功能和行为。例如，日志记录、事务管理等功能可以横切于多个对象和方法。在Spring中，AOP通过**代理模式**实现，通过配置文件或注解的方式，将这些横切关注点与核心业务逻辑进行解耦，使得系统的设计更加清晰，并且能够重用这些横切关注点。

### 8. 什么是动态代理

JDK 动态代理主要涉及到 `java.lang.reflect` 包中的两个类：`Proxy` 和 `InvocationHandler`。 `InvocationHandler`是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类 的代码，**动态将横切逻辑和业务逻辑编制在一起**。`Proxy` 利用 `InvocationHandler` 动态创建 一个符合某一接口的实例，生成目标类的代理对象

动态代理拼接

### 9. 有没有遇到过OOM,如何排查

当遇到OOM（Out of Memory）错误时，表示JVM中的内存不足，无法分配更多的对象

- 什么时候会出现OOM问题
  1. 内存泄漏：内存泄漏是指应用程序中的对象占用了内存，但随着时间的推移无法被垃圾回收器释放。
  2. 内存资源不足：应用程序的内存需求超过了可用的物理内存或JVM的内存限制。
  3. 大量数据处理：如果应用程序处理大量的数据（如图片、视频、文件等），而没有适当地管理和释放这些数据的内存，就会导致内存耗尽。例如，一次性加载大型文件到内存中可能会导致OOM。
  4. 高并发和长时间运行：在高并发的情况下，如果应用程序无法有效地释放已经处理过的对象，内存使用量可能会快速增加，从而导致内存不足。此外，长时间运行的应用程序也可能因为内存占用累积而触发OOM。
- 如何排查OOM
  1. 检查错误日志：首先，查看完整的错误堆栈跟踪和错误信息，了解OOM的具体原因和位置。错误信息通常会提供一些线索来定位问题。
  2. 检查代码逻辑：审查代码，特别是与内存相关的部分，如大数据集合、缓存、文件读写等。确保没有使用过多的内存或存在内存泄漏的情况。另外，还要确保及时释放使用完毕的资源，如数据库连接、文件句柄等。
  3. 检查JVM内存配置：检查JVM的内存配置参数，如最大堆内存（-Xmx）、初始堆内存（-Xms）和永久代大小（如果使用CMS垃圾回收器）。确保这些参数足够大，以适应应用程序的内存需求。
  4. 优化内存使用：根据分析结果，考虑优化内存使用。可能的优化措施包括减少对象的创建、及时释放不再使用的对象、使用缓存技术、调整数据结构大小等。
  5. 使用内存分析工具：使用内存分析工具（如VisualVM、JProfiler、MAT）对应用程序进行实时监测和分析。这些工具可以提供更详细的内存使用情况，帮助识别哪些对象或数据结构占用大量内存，并找出潜在的内存泄漏问题。

### 10. 进程线程的区别,提示资源分配,空间占用方面

1. 资源占用：每个进程都有独立的内存空间和系统资源，而线程共享进程的资源。
2. 并发性：多个线程可以在同一个进程中并发执行，共享进程的资源。而不同进程之间的并发执行需要通过进程间通信进行数据交换。

### 11. IP地址和MAC地址区别

IP地址是用来标识网络中设备的逻辑地址。用于网络通信。**网络层**

MAC地址是用来标识网络设备的物理地址。MAC地址是设备出厂时就确定的，通常无法更改。**数据链路层**

### 12. 数据库的事务,并发事务会带来哪些问题,MySQL的默认隔离级别 如何在数据库中实现数据的备份和恢复

- 并发事务会带来哪些问题
  1. 数据不一致：并发事务可能导致数据的不一致性。当多个事务同时读取和修改同一份数据时，如果没有适当的并发控制机制，就有可能导致数据的错乱和不一致。
  2. 丢失更新：并发事务中的更新操作可能会相互覆盖，从而导致部分更新的丢失。例如，两个事务同时读取一个数据并进行修改，然后将结果写回数据库，如果没有适当的并发控制机制，其中一个事务的修改结果可能会被另一个事务的覆盖，导致数据的丢失。
  3. 脏读（Dirty Read）：脏读是指一个事务在读取了另一个事务未提交的数据之后，又进行了一次读取操作，此时可能读取到的数据是不正确或无效的。这种情况下，事务可能基于不一致或临时的数据进行后续操作，导致数据的错误处理和错误结果。
  4. 不可重复读（Non-repeatable Read）：不可重复读是指一个事务在读取了某个数据后，又进行一次读取操作，但此时读取到的数据已经发生了改变。这种情况下，事务可能会在两次读取之间对数据进行了一些操作（如修改或删除），导致前后两次读取的数据不一致。
  5. 幻读（Phantom Read）：幻读是指一个事务在同样的查询条件下，由于其他并发事务的插入或删除操作，导致前后两次查询的结果集不一致。这种情况下，事务在处理某个数据集时，可能会发现新增或删除了一些记录，导致数据的不完整性。
- 解决并发事务带来的问题
  1. 锁定机制
  2. 隔离级别
  3. 事务调度算法
- MySQL隔离级别
  1. 读未提交（Read Uncommitted）：最低的隔离级别，事务可以读取其他事务尚未提交的数据。这可能导致脏读、不可重复读和幻读的问题。
  2. 读已提交（Read Committed）：事务只能读取其他事务已经提交的数据。这解决了脏读的问题，但仍可能存在不可重复读和幻读的问题。
  3. 可重复读（Repeatable Read）：**MySQL 默认的隔离级别**。事务在启动时创建一个一致性视图，保证在整个事务期间读取的数据不受其他事务的影响，解决了不可重复读的问题。但仍可能存在幻读的问题。
  4. 串行化（Serializable）：最高的隔离级别，通过强制事务的串行执行来避免并发问题。事务会在读取和修改数据时对数据进行锁定，确保其他事务无法同时修改被锁定的数据。这可以解决脏读、不可重复读和幻读的问题，但可能降低并发性能。

### 13. 如何创建一个线程池,拒绝策略有什么,怎么设置线程池的大小(动态修改)

- 如何创建一个线程池

  可以使用 JUC的`Executors` 类来创建线程池，并使用 `Executor` 类设置线程池的属性。

- 线程池拒绝策略

  拒绝策略是在线程池无法接受新任务时采取的一种策略

  1. `ThreadPoolExecutor.AbortPolicy`（默认）：直接抛出 `RejectedExecutionException` 异常，拒绝新任务的提交。
  2. `ThreadPoolExecutor.CallerRunsPolicy`：由调用线程处理该任务。即将任务返回给调用者进行处理。
  3. `ThreadPoolExecutor.DiscardPolicy`：静默地丢弃无法处理的任务，不给予任何提示。
  4. `ThreadPoolExecutor.DiscardOldestPolicy`：丢弃最早提交的任务，然后尝试再次提交新任务。

- 怎么动态修改线程池的大小

  可以使用 `ThreadPoolExecutor` 的 `setCorePoolSize()` 和 `setMaximumPoolSize()` 方法来动态修改线程池的大小

### 14. ConcurrentHashmap如何保证线程安全

1. 分段锁机制：ConcurrentHashMap将整个**哈希表分割成多个独立的段**（Segment），每个段内部维护一个类似于HashMap的数据结构。不同的线程可以同时访问不同的段，从而减小了并发操作的粒度，并发度更高。
2. 无阻塞操作：ConcurrentHashMap在进行插入、删除和更新等操作时，采用了无阻塞算法（**CAS**、volatile等），而不是传统的加锁机制。这样可以避免了线程之间的阻塞和等待，提高了并发性能。
3. 可见性保证：ConcurrentHashMap**使用volatile变量来保证多个线程之间的可见性**，确保读取到最新的数据。

### 15. 线程池7个参数？提交任务流程？为什么不先创建临时线程而是先放进阻塞队列？

- 线程池的7个参数

  1. corePoolSize（核心线程数）：线程池中始终保持活动状态的线程数，即使这些线程是空闲的。
  2. maximumPoolSize（最大线程数）：线程池中允许存在的最大线程数。
  3. keepAliveTime（线程空闲时间）：当线程池中的线程数量大于corePoolSize时，空闲线程在被回收之前等待新任务的最长时间。超过该时间，空闲线程会被销毁。
  4. unit（时间单位）：keepAliveTime的时间单位，例如：TimeUnit.SECONDS。
  5. workQueue（阻塞队列）：用于存放等待执行的任务的阻塞队列。线程池中的线程都从该队列中获取任务进行处理。
  6. threadFactory（线程工厂）：用于创建新线程的工厂。
  7. handler（拒绝策略）：当线程池和阻塞队列都已满，无法继续接受新任务时，该策略定义了如何处理这些被拒绝的任务。

- 提交流程

  1. 当调用线程池的execute或submit方法提交一个任务时，线程池会首先判断是否已经达到了**corePoolSize限制**，如果没有，则创建一个新线程来处理该任务。
  2. 如果当前线程池中的线程数量已经达到了corePoolSize限制，任务会被添加到**阻塞队列**中。
  3. 如果阻塞队列已满，但是还没有超过**maximumPoolSize限制**，线程池会创建一个新的**临时线程**来处理该任务。
  4. 如果线程池中的线程数已经达到了maximumPoolSize限制，且阻塞队列已满，这时会根据指定的**拒绝策略**来处理无法接受的任务，比如抛出异常、丢弃任务等。

- 上面的提交流程中为什么不先创建临时线程而是先放进阻塞队列

  通过将任务放入阻塞队列，可以实现流量控制，当任务数量暂时过多时，可以通过阻塞队列的容量限制来控制任务的接受速率，避免线程过度增长。

### 16. 核心线程能否被回收

当使用了`allowCoreThreadTimeOut(true)`并且同时满足以下条件时，核心线程可能会被回收：

1. 当前线程池中的线程数大于核心线程数。
2. 核心线程在一段时间内都处于空闲状态，没有新的任务到来。

### 17. 为什么用b+树，b树缺点？

- b树和b+树
  - B树：
    - 节点既存储数据也存储关键字。
    - 内部节点和叶子节点的结构相同。
    - 拥有更高的填充度，节点利用率较高。
    - 适用于随机访问和插入操作。
  - B+树：
    - 内部节点只存储关键字。
    - 叶子节点存储所有数据，并通过指针连接形成有序链表。
    - 内部节点能容纳更多的子节点指针。
    - 适用于顺序访问和范围查询。
    - 在数据库索引中使用较为广泛。
- MySQL数据库的索引结构为什么用b+树，b树的缺点
  1. B树的内部节点存储数据：B树的每个节点都会存储关键字和对应的数据，这意味着一个节点的大小是相对较大的。当B树的高度比较大时，磁盘IO操作会变得频繁，因为每次读取一个节点时需要读取更多的数据，而不仅仅是所需的关键字。
  2. B树的查询效率相对较低：由于B树的节点即存储关键字又存储数据，因此在查找某个关键字时，可能需要在每个节点中进行比较操作，这会增加查询的时间复杂度。尤其是在高度较高的B树中，查询性能会进一步降低。
  3. B+树的查询效率更高：B+树在进行关键字查找时，只需要在内部节点中进行比较操作，然后通过叶子节点指针快速定位到对应的数据节点，减少了比较的次数，提高了查询效率。
  4. B+树的范围查询效率更高：由于B+树的叶子节点通过指针连接成有序链表，范围查询只需要遍历叶子节点链表即可，不需要在内部节点中进行遍历，大大提高了范围查询的效率。

### 18. ArrayList和LinkedList区别

1. 内部实现：ArrayList是基于数组实现的动态数组，而LinkedList是基于双向链表实现的。
2. 插入和删除操作：对于ArrayList，插入和删除元素可能需要进行数组的扩容或移动操作，因为数组的长度是固定的。而LinkedList在插入和删除元素时，只需调整节点的指针，不需要像ArrayList那样进行大量的数据移动。
3. 随机访问效率：ArrayList可以通过索引直接访问元素，因为底层数组的连续存储特性。而LinkedList需要遍历链表才能找到指定位置的元素，所以随机访问效率比ArrayList低。

### 20. 讲讲jmm内存模型，volatile作用，实现原理，为什么 volatile 能防止指令重排，为什么有可见性问题



### 21. Cookie和Session的差别

1. 存储位置：Cookie保存在客户端（浏览器）中，而Session保存在服务器端。
2. 数据的存储方式：Cookie以键值对的形式存储在客户端的浏览器中，而Session则将数据保存在服务器端的内存或者数据库中。
3. 存储容量：Cookie的存储容量有限制，一般为4KB左右。而Session的存储容量相对较大，可以根据服务器的配置进行调整。
4. 生命周期：Cookie可以设置过期时间，可以是会话级的（浏览器关闭后失效）或者持久性的（在一段时间后失效）。而Session的生命周期与用户的会话相关，通常在用户关闭浏览器或者一段时间不活动后失效。
5. 访问方式：Cookie的数据会通过HTTP请求自动发送给服务器，每次请求都会带上Cookie信息。而Session的标识符（通常是一个类似于Session ID的字符串）会在Cookie或者URL参数中传递给服务器。

### 22. HTTP和HTTPs的差别

1. 安全性：HTTP是明文传输协议，数据在传输过程中不加密，容易被窃听和篡改。而HTTPS通过使用SSL/TLS协议对通信内容进行加密，确保数据的机密性和完整性，提供更高的安全性。
2. 默认端口：HTTP默认使用80端口进行通信，而HTTPS默认使用443端口。
3. 证书：为了建立HTTPS连接，服务器需要获得一个有效的数字证书，由权威的证书颁发机构（CA）签发。这个证书用于验证服务器身份并确保通信的安全性。而HTTP不需要证书验证。

### 23. volatile和sychronized的区别

1. 语义上的差异：
   - `volatile`关键字用于修饰变量，表示该变量在多线程环境下可能被其他线程修改，因此每次使用该变量时都要直接从主内存中获取最新的值。并且，对带有`volatile`关键字修饰的变量的写操作会立即刷新到主内存中，保证可见性。
   - `synchronized`关键字用于修饰方法或代码块，表示对其修饰的部分进行加锁，保证在同一时刻只有一个线程可以执行该方法或代码块，其他线程需要等待锁释放。
2. 内存语义：
   - `volatile`关键字提供了禁止指令重排序和保证可见性的功能，保证对其修饰的变量的修改对其他线程是可见的。但`volatile`不能保证原子性，不适用于复合操作。
   - `synchronized`关键字在加锁和释放锁过程中会自动进行线程间的内存同步，保证了原子性、可见性和有序性。

### 24. Spring Bean 生命周期



### 25. runnable callable 区别，如何接收这两个线程异常



### 26. synchroized锁升级过程和实现原理



### 27. Reentrelock 实现原理，AQS实现原理



### 28. AQS队列为空时线程加入队列发生什么



### 29. countdownlanch semaphore 使用和实现原理 



### 30. Redis持久化方式,Redis集群，模式，怎么实现选举