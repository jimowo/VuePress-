---
title: 面经整理
author: jimowo
icon: write
date: 2023-08-01
order: 3
category:
  - 面经
tag:
  - Java
---

# 面经整理

### 1. Java中的继承和多态 接口和抽象类的区别 StringBuffer和StringBuilder的区别

- 继承和多态

  继承是子类继承父类的除了静态方法和静态字段的所有方法和字段。
  多态分为类的多态和方法的多态。类的多态体现为继承，方法的多态体现为对方法的重载。

- 接口和抽象类的区别

  抽象类中可以有构造函数和非抽象方法，接口不能实例化，且所有方法都是抽象方法，jdk1.8中出现了default修饰的方法。接口中的所有成员变量都是public static final修饰的。
  接口是行为的抽象，cloneable之类的，是**Like A** 的关系；
  抽象类是类的抽象，是一种模板设计，是**Is A **的关系

- StringBuffer 和StringBuilder的区别

  StringBuilder线程不安全，效率比StringBuffer 高；
  StringBuffer的所有public 方法都是synchronized 修饰的。
  底层是默认长度为16的字符数组，每次扩容为数组原长度的2倍+2

### 2. error和exception的区别 怎么处理exception

- error和exception的区别

  Error 是指程序无法处理的错误，虚拟机错误、栈溢出（SOF）、内存溢出（OOM）

  Exception 是指程序本身可以处理的异常（可以自己Throw）

- 怎么处理exception

  exception分为编译时异常和运行时异常，前者由编译器发现。后者可以通过throw和catch来自定义处理

### 3. 什么是泛型 泛型的作用 泛型的使用方式有哪几种

- 什么是泛型

  参数化类型，把类型参数化

- 泛型的作用

  代码重用：在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型。实现模板的效果

  类型安全：通过指定泛型类型参数，编译器可以在编译时检查代码的类型安全性，避免在运行时出现类型转换错误。

  减少类型转换：泛型可以避免繁琐的类型转换操作，提高代码的可读性和维护性。

- 泛型的使用方式

  泛型类：带有泛型类型属性的类 `List<T>`；
  泛型接口：带有泛型类型参数的接口 `Comparable<T>`；
  泛型方法：带有泛型类型参数的方法 `public <T> void printArray(T[] array)`

### 4. HashMap的遍历方式有哪几种 ?HashMap与HashTable的区别? HashMap底层?(为什么是8和64没答出来 为什么选择红黑树这种数据结构 介绍一下红黑树)

- HashMap的遍历方式有哪几种 4种
  1. 使用 `keySet()` 方法遍历键（key）
  2. 使用 `values()` 方法遍历值（value）
  3. 使用 `entrySet()` 方法遍历键值对（entry）
  4. 使用迭代器（Iterator）遍历键值对
- HashMap与HashTable的区别
  1. HashTable线程安全
  2. HashMap允许键和值为null
  3. HashMap实现了Map接口，HashTable是Dictionary的子类
  4. `HashMap`可以指定初始容量和负载因子。当 `HashMap` 的元素数量超过负载因子与当前容量的乘积时，`HashMap` 会自动进行扩容。`HashTable` 在构造时只能指定初始容量，默认的负载因子是 0.75。扩容时，`HashTable` 的大小必须为素数，并且会创建一个新的数组来重新分配元素。

### 5. Java中实现多线程

1. 继承Thread类，重写run方法
2. 实现Runnable接口，把任务加入Thread类，启动（线程任务与线程控制分离）

### 6. Lambda表达式

是对匿名函数的简写形式

他的写法是使用一个`->`符号，左边写的是形参列表，右边就是对抽象方法的处理

- 无返回值有形参的抽象方法

  - 可以省略方法名，IDEA会帮你自动检测方法名；
  - 可以省略方法中的形参类型；
  - 如果对抽象方法的实现逻辑只有一行，可以省略方法体的大括号，当然如果不止一行，就不能省略了；

- 有返回值的抽象方法

  有返回值的方法，如果要去掉大括号，还需要去掉return关键字

- 有一个形参的抽象方法

  形参列表中只有一个参数，可以去掉形参的括号

- Lambda表达式也可以作为参数传递

- **Lambda表达式不是万能的，他需要函数式接口的支持**

  - 函数式接口的定义是: 只包含一个抽象方法的接口，称为函数式接口
  - 4大函数式接口
    1. `Consumer<T>`：该函数式接口接受一个输入参数，并对其进行操作，但没有返回结果。常用的方法是 `accept(T t)`，用于对给定的参数执行某些操作
    2. `Supplier<T>`：该函数式接口不接受任何输入参数，但返回一个结果。常用的方法是 `get()`，用于获取结果。
    3. `Function<T, R>`：该函数式接口接受一个输入参数，并将其转换为另一种类型的结果。常用的方法是 `apply(T t)`，用于对给定的参数进行处理并返回结果。
    4. `Predicate<T>`：该函数式接口接受一个输入参数，并返回一个布尔值结果。常用的方法是 `test(T t)`，用于对给定的参数进行条件判断。

### 7. 你最擅长的Java框架,介绍一下 Spring的核心思想

Spring框架的核心思想是**IOC**（Inversion of Control，控制反转）和**AOP**（Aspect-Oriented Programming，面向切面编程）。

1. IOC（控制反转）：IOC的核心理念是将对象的创建、依赖注入和生命周期管理交给Spring容器来完成，通过配置文件或注解的方式，让Spring容器在运行时动态地管理和组装对象。能够降低代码的耦合性、提高代码的可维护性和可测试性。
2. AOP（面向切面编程）：AOP通过在不修改原有代码的情况下，增加一些额外的功能和行为。例如，日志记录、事务管理等功能可以横切于多个对象和方法。在Spring中，AOP通过**代理模式**实现，通过配置文件或注解的方式，将这些横切关注点与核心业务逻辑进行解耦，使得系统的设计更加清晰，并且能够重用这些横切关注点。

### 8. 什么是动态代理

JDK 动态代理主要涉及到 `java.lang.reflect` 包中的两个类：`Proxy` 和 `InvocationHandler`。 `InvocationHandler`是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类 的代码，**动态将横切逻辑和业务逻辑编制在一起**。`Proxy` 利用 `InvocationHandler` 动态创建 一个符合某一接口的实例，生成目标类的代理对象

动态代理拼接

### 9. 有没有遇到过OOM,如何排查

当遇到OOM（Out of Memory）错误时，表示JVM中的内存不足，无法分配更多的对象

- 什么时候会出现OOM问题
  1. 内存泄漏：内存泄漏是指应用程序中的对象占用了内存，但随着时间的推移无法被垃圾回收器释放。
  2. 内存资源不足：应用程序的内存需求超过了可用的物理内存或JVM的内存限制。
  3. 大量数据处理：如果应用程序处理大量的数据（如图片、视频、文件等），而没有适当地管理和释放这些数据的内存，就会导致内存耗尽。例如，一次性加载大型文件到内存中可能会导致OOM。
  4. 高并发和长时间运行：在高并发的情况下，如果应用程序无法有效地释放已经处理过的对象，内存使用量可能会快速增加，从而导致内存不足。此外，长时间运行的应用程序也可能因为内存占用累积而触发OOM。
- 如何排查OOM
  1. 检查错误日志：首先，查看完整的错误堆栈跟踪和错误信息，了解OOM的具体原因和位置。错误信息通常会提供一些线索来定位问题。
  2. 检查代码逻辑：审查代码，特别是与内存相关的部分，如大数据集合、缓存、文件读写等。确保没有使用过多的内存或存在内存泄漏的情况。另外，还要确保及时释放使用完毕的资源，如数据库连接、文件句柄等。
  3. 检查JVM内存配置：检查JVM的内存配置参数，如最大堆内存（-Xmx）、初始堆内存（-Xms）和永久代大小（如果使用CMS垃圾回收器）。确保这些参数足够大，以适应应用程序的内存需求。
  4. 优化内存使用：根据分析结果，考虑优化内存使用。可能的优化措施包括减少对象的创建、及时释放不再使用的对象、使用缓存技术、调整数据结构大小等。
  5. 使用内存分析工具：使用内存分析工具（如VisualVM、JProfiler、MAT）对应用程序进行实时监测和分析。这些工具可以提供更详细的内存使用情况，帮助识别哪些对象或数据结构占用大量内存，并找出潜在的内存泄漏问题。

### 10. 进程线程的区别,提示资源分配,空间占用方面

1. 资源占用：每个进程都有独立的内存空间和系统资源，而线程共享进程的资源。
2. 并发性：多个线程可以在同一个进程中并发执行，共享进程的资源。而不同进程之间的并发执行需要通过进程间通信进行数据交换。

### 11. IP地址和MAC地址区别

IP地址是用来标识网络中设备的逻辑地址。用于网络通信。**网络层**

MAC地址是用来标识网络设备的物理地址。MAC地址是设备出厂时就确定的，通常无法更改。**数据链路层**

### 12. 数据库的事务,并发事务会带来哪些问题,MySQL的默认隔离级别 如何在数据库中实现数据的备份和恢复

- 并发事务会带来哪些问题
  1. 数据不一致：并发事务可能导致数据的不一致性。当多个事务同时读取和修改同一份数据时，如果没有适当的并发控制机制，就有可能导致数据的错乱和不一致。
  2. 丢失更新：并发事务中的更新操作可能会相互覆盖，从而导致部分更新的丢失。例如，两个事务同时读取一个数据并进行修改，然后将结果写回数据库，如果没有适当的并发控制机制，其中一个事务的修改结果可能会被另一个事务的覆盖，导致数据的丢失。
  3. 脏读（Dirty Read）：脏读是指一个事务在读取了另一个事务未提交的数据之后，又进行了一次读取操作，此时可能读取到的数据是不正确或无效的。这种情况下，事务可能基于不一致或临时的数据进行后续操作，导致数据的错误处理和错误结果。
  4. 不可重复读（Non-repeatable Read）：不可重复读是指一个事务在读取了某个数据后，又进行一次读取操作，但此时读取到的数据已经发生了改变。这种情况下，事务可能会在两次读取之间对数据进行了一些操作（如修改或删除），导致前后两次读取的数据不一致。
  5. 幻读（Phantom Read）：幻读是指一个事务在同样的查询条件下，由于其他并发事务的插入或删除操作，导致前后两次查询的结果集不一致。这种情况下，事务在处理某个数据集时，可能会发现新增或删除了一些记录，导致数据的不完整性。
- 解决并发事务带来的问题
  1. 锁定机制
  2. 隔离级别
  3. 事务调度算法
- MySQL隔离级别
  1. 读未提交（Read Uncommitted）：最低的隔离级别，事务可以读取其他事务尚未提交的数据。这可能导致脏读、不可重复读和幻读的问题。
  2. 读已提交（Read Committed）：事务只能读取其他事务已经提交的数据。这解决了脏读的问题，但仍可能存在不可重复读和幻读的问题。
  3. 可重复读（Repeatable Read）：**MySQL 默认的隔离级别**。事务在启动时创建一个一致性视图，保证在整个事务期间读取的数据不受其他事务的影响，解决了不可重复读的问题。但仍可能存在幻读的问题。
  4. 串行化（Serializable）：最高的隔离级别，通过强制事务的串行执行来避免并发问题。事务会在读取和修改数据时对数据进行锁定，确保其他事务无法同时修改被锁定的数据。这可以解决脏读、不可重复读和幻读的问题，但可能降低并发性能。

### 13. 如何创建一个线程池,拒绝策略有什么,怎么设置线程池的大小(动态修改)

- 如何创建一个线程池

  可以使用 JUC的`Executors` 类来创建线程池，并使用 `Executor` 类设置线程池的属性。

- 线程池拒绝策略

  拒绝策略是在线程池无法接受新任务时采取的一种策略

  1. `ThreadPoolExecutor.AbortPolicy`（默认）：直接抛出 `RejectedExecutionException` 异常，拒绝新任务的提交。
  2. `ThreadPoolExecutor.CallerRunsPolicy`：由调用线程处理该任务。即将任务返回给调用者进行处理。
  3. `ThreadPoolExecutor.DiscardPolicy`：静默地丢弃无法处理的任务，不给予任何提示。
  4. `ThreadPoolExecutor.DiscardOldestPolicy`：丢弃最早提交的任务，然后尝试再次提交新任务。

- 怎么动态修改线程池的大小

  可以使用 `ThreadPoolExecutor` 的 `setCorePoolSize()` 和 `setMaximumPoolSize()` 方法来动态修改线程池的大小

### 14. ConcurrentHashmap如何保证线程安全

1. 分段锁机制：ConcurrentHashMap将整个**哈希表分割成多个独立的段**（Segment），每个段内部维护一个类似于HashMap的数据结构。不同的线程可以同时访问不同的段，从而减小了并发操作的粒度，并发度更高。
2. 无阻塞操作：ConcurrentHashMap在进行插入、删除和更新等操作时，采用了无阻塞算法（**CAS**、volatile等），而不是传统的加锁机制。这样可以避免了线程之间的阻塞和等待，提高了并发性能。
3. 可见性保证：ConcurrentHashMap**使用volatile变量来保证多个线程之间的可见性**，确保读取到最新的数据。

### 15. 线程池7个参数？提交任务流程？为什么不先创建临时线程而是先放进阻塞队列？

- 线程池的7个参数

  1. corePoolSize（核心线程数）：线程池中始终保持活动状态的线程数，即使这些线程是空闲的。
  2. maximumPoolSize（最大线程数）：线程池中允许存在的最大线程数。
  3. keepAliveTime（线程空闲时间）：当线程池中的线程数量大于corePoolSize时，空闲线程在被回收之前等待新任务的最长时间。超过该时间，空闲线程会被销毁。
  4. unit（时间单位）：keepAliveTime的时间单位，例如：TimeUnit.SECONDS。
  5. workQueue（阻塞队列）：用于存放等待执行的任务的阻塞队列。线程池中的线程都从该队列中获取任务进行处理。
  6. threadFactory（线程工厂）：用于创建新线程的工厂。
  7. handler（拒绝策略）：当线程池和阻塞队列都已满，无法继续接受新任务时，该策略定义了如何处理这些被拒绝的任务。

- 提交流程

  1. 当调用线程池的execute或submit方法提交一个任务时，线程池会首先判断是否已经达到了**corePoolSize限制**，如果没有，则创建一个新线程来处理该任务。
  2. 如果当前线程池中的线程数量已经达到了corePoolSize限制，任务会被添加到**阻塞队列**中。
  3. 如果阻塞队列已满，但是还没有超过**maximumPoolSize限制**，线程池会创建一个新的**临时线程**来处理该任务。
  4. 如果线程池中的线程数已经达到了maximumPoolSize限制，且阻塞队列已满，这时会根据指定的**拒绝策略**来处理无法接受的任务，比如抛出异常、丢弃任务等。

- 上面的提交流程中为什么不先创建临时线程而是先放进阻塞队列

  通过将任务放入阻塞队列，可以实现流量控制，当任务数量暂时过多时，可以通过阻塞队列的容量限制来控制任务的接受速率，避免线程过度增长。

### 16. 核心线程能否被回收

当使用了`allowCoreThreadTimeOut(true)`并且同时满足以下条件时，核心线程可能会被回收：

1. 当前线程池中的线程数大于核心线程数。
2. 核心线程在一段时间内都处于空闲状态，没有新的任务到来。

### 17. 为什么用b+树，b树缺点？

- b树和b+树
  - B树：
    - 节点既存储数据也存储关键字。
    - 内部节点和叶子节点的结构相同。
    - 拥有更高的填充度，节点利用率较高。
    - 适用于随机访问和插入操作。
  - B+树：
    - 内部节点只存储关键字。
    - 叶子节点存储所有数据，并通过指针连接形成有序链表。
    - 内部节点能容纳更多的子节点指针。
    - 适用于顺序访问和范围查询。
    - 在数据库索引中使用较为广泛。
- MySQL数据库的索引结构为什么用b+树，b树的缺点
  1. B树的内部节点存储数据：B树的每个节点都会存储关键字和对应的数据，这意味着一个节点的大小是相对较大的。当B树的高度比较大时，磁盘IO操作会变得频繁，因为每次读取一个节点时需要读取更多的数据，而不仅仅是所需的关键字。
  2. B树的查询效率相对较低：由于B树的节点即存储关键字又存储数据，因此在查找某个关键字时，可能需要在每个节点中进行比较操作，这会增加查询的时间复杂度。尤其是在高度较高的B树中，查询性能会进一步降低。
  3. B+树的查询效率更高：B+树在进行关键字查找时，只需要在内部节点中进行比较操作，然后通过叶子节点指针快速定位到对应的数据节点，减少了比较的次数，提高了查询效率。
  4. B+树的范围查询效率更高：由于B+树的叶子节点通过指针连接成有序链表，范围查询只需要遍历叶子节点链表即可，不需要在内部节点中进行遍历，大大提高了范围查询的效率。

### 18. ArrayList和LinkedList区别

1. 内部实现：ArrayList是基于数组实现的动态数组，而LinkedList是基于双向链表实现的。
2. 插入和删除操作：对于ArrayList，插入和删除元素可能需要进行数组的扩容或移动操作，因为数组的长度是固定的。而LinkedList在插入和删除元素时，只需调整节点的指针，不需要像ArrayList那样进行大量的数据移动。
3. 随机访问效率：ArrayList可以通过索引直接访问元素，因为底层数组的连续存储特性。而LinkedList需要遍历链表才能找到指定位置的元素，所以随机访问效率比ArrayList低。

### 20. 讲讲jmm内存模型，volatile作用，实现原理，为什么 volatile 能防止指令重排，为什么有可见性问题

- JMM内存模型

  JMM（Java内存模型）是Java程序中定义了线程之间共享变量的可见性、有序性和原子性的规范。

  JMM通过以下机制来实现上述目标：

  1. 原子性：JMM保证对基本数据类型（除了long和double）的读写操作具有原子性。对于volatile修饰的变量，JMM保证了对它的读写具有原子性。
  2. 可见性：JMM通过在线程之间进行内存屏障（Memory Barrier）来实现可见性。读操作和写操作都有相应的内存屏障，用于刷新变量的值到主内存或者从主内存中读取最新值。
  3. 有序性：JMM通过内存屏障来禁止指令重排序，保证程序按照代码顺序执行。

- volatile作用，实现原理

  volatile关键字在Java中用于确保共享变量的可见性和禁止指令重排。

  1. 可见性：volatile关键字保证了一个线程对volatile变量的写操作对其他线程可见。当一个线程修改了volatile变量的值时，这个值将会立即被写入主内存，并且其他线程在读取该变量时会从主内存中获取最新值而不是工作内存中的副本。
  2. 禁止指令重排：当一个写操作对一个volatile变量进行写操作时，JVM会发出一条Lock前缀的指令，将该写操作变为原子操作，并且在写操作后增加一条**Store屏障**（Memory Barrier），这个屏障会强制刷新处理器缓存，使其他线程在读取该变量时能够获取最新值。

- 多线程操作的可见性问题

  可见性问题是因为多线程的操作都是在各自的工作内存中进行的，线程之间无法直接访问对方的工作内存。当一个线程修改了共享变量的值时，其他线程可能无法立即看到这个修改，而是继续访问自己工作内存中的变量副本。这是因为处理器会对内存进行缓存，为了提高效率，处理器可能将共享变量的值缓存在寄存器或者缓存中，并不及时更新到主内存中。

### 21. Cookie和Session的差别

1. 存储位置：Cookie保存在客户端（浏览器）中，而Session保存在服务器端。
2. 数据的存储方式：Cookie以键值对的形式存储在客户端的浏览器中，而Session则将数据保存在服务器端的内存或者数据库中。
3. 存储容量：Cookie的存储容量有限制，一般为4KB左右。而Session的存储容量相对较大，可以根据服务器的配置进行调整。
4. 生命周期：Cookie可以设置过期时间，可以是会话级的（浏览器关闭后失效）或者持久性的（在一段时间后失效）。而Session的生命周期与用户的会话相关，通常在用户关闭浏览器或者一段时间不活动后失效。
5. 访问方式：Cookie的数据会通过HTTP请求自动发送给服务器，每次请求都会带上Cookie信息。而Session的标识符（通常是一个类似于Session ID的字符串）会在Cookie或者URL参数中传递给服务器。

### 22. HTTP和HTTPs的差别

1. 安全性：HTTP是明文传输协议，数据在传输过程中不加密，容易被窃听和篡改。而HTTPS通过使用SSL/TLS协议对通信内容进行加密，确保数据的机密性和完整性，提供更高的安全性。
2. 默认端口：HTTP默认使用80端口进行通信，而HTTPS默认使用443端口。
3. 证书：为了建立HTTPS连接，服务器需要获得一个有效的数字证书，由权威的证书颁发机构（CA）签发。这个证书用于验证服务器身份并确保通信的安全性。而HTTP不需要证书验证。

### 23. volatile和sychronized的区别

1. 语义上的差异：
   - `volatile`关键字用于修饰变量，表示该变量在多线程环境下可能被其他线程修改，因此每次使用该变量时都要直接从主内存中获取最新的值。并且，对带有`volatile`关键字修饰的变量的写操作会立即刷新到主内存中，保证可见性。
   - `synchronized`关键字用于修饰方法或代码块，表示对其修饰的部分进行加锁，保证在同一时刻只有一个线程可以执行该方法或代码块，其他线程需要等待锁释放。
2. 内存语义：
   - `volatile`关键字提供了禁止指令重排序和保证可见性的功能，保证对其修饰的变量的修改对其他线程是可见的。但`volatile`不能保证原子性，不适用于复合操作。
   - `synchronized`关键字在加锁和释放锁过程中会自动进行线程间的内存同步，保证了原子性、可见性和有序性。

### 24. Spring Bean 生命周期

1. 实例化（Instantiation）：在这个阶段，Spring会**根据配置文件或注解创建Bean的实例**。实例化可以通过无参数构造函数、工厂方法或者特定的实例化策略来完成。
2. 属性赋值（Population of Properties）：在实例化之后，Spring会使用**依赖注入**（Dependency Injection）机制将配置的**属性值设置**到Bean实例中。这可以通过XML配置文件、注解或者Java配置来完成。
3. 初始化（Initialization）：在属性赋值完成之后，Spring会调用**初始化回调方法**，以便Bean可以执行一些初始化的操作。常见的初始化回调方法有InitializingBean接口的afterPropertiesSet()方法和@PostConstruct注解标记的方法。
4. 使用中（In Use）：**Bean在Spring缓存中**。在初始化完成后，Bean就可以被应用程序使用了。此时，Bean可以响应业务逻辑中的方法调用和其他操作。
5. 销毁（Destruction）：当应用程序关闭或Bean不再需要时，Spring会**调用销毁回调方法**，以便Bean执行一些清理操作。常见的销毁回调方法有DisposableBean接口的destroy()方法和@PreDestroy注解标记的方法。

### 25. Runnable、Callable 区别，如何接收这两个线程异常

- Runnable、Callable的区别
  1. 返回值：Runnable接口没有返回值，而Callable接口可以返回一个结果。
  2. 异常处理：Runnable接口的run()方法不能抛出受检异常，只能在方法内部进行异常处理；而Callable接口的call()方法**可以抛出受检异常**，并且可以将异常抛给调用者处理。
  3. 使用方式：Runnable接口通常用于创建可执行的线程任务，通过实现run()方法来定义线程执行的代码；而Callable接口则通常与ExecutorService（线程池）一起使用，通过返回Future对象来获取异步计算的结果。
- 如何处理Runnable任务的异常
  1. Runnable使用try-catch来捕获异常并处理
  2. 通过Thread类的`setUncaughtExceptionHandler()`方法设置一个全局的未捕获异常处理器，来处理在Runnable中抛出的异常。
  3. 如果使用ExecutorService来执行Runnable任务，可以通过Future对象的get()方法来获取任务执行过程中的异常信息。

### 26. synchronized锁升级过程和实现原理

- synchronized实现原理

  当线程尝试进入synchronized块时，首先会尝试获取对象的Monitor锁。如果Monitor锁未被占用，则当前线程获取到锁并执行临界区代码。如果Monitor锁已被别的线程持有，则当前线程会被阻塞，直到锁被释放。当线程退出synchronized块时，会释放Monitor锁。

- synchronized锁升级过程

  1. 偏向锁（Biased Locking）：初始状态下，对象的Mark Word字段为无锁状态。**当一个线程访问同步块时**，会检查对象的Mark Word是否为无锁状态，如果是，则使用CAS操作将Mark Word设置为指向当前线程的线程ID，并标记为偏向锁。之后该线程直接进入临界区执行，不需要进行同步操作。这样可以提高单线程访问临界区的性能。
  2. 轻量级锁（Lightweight Locking）：**当第二个线程尝试获取偏向锁失败时**，会升级为轻量级锁。轻量级锁使用CAS操作将对象头部的Mark Word替换为指向锁记录的指针，将锁记录中持有锁的线程ID设置为当前线程ID。此时，线程**通过CAS操作来竞争锁**。如果竞争成功，该线程进入临界区执行。如果竞争失败，表示存在竞争，锁会膨胀为重量级锁。
  3. 重量级锁（Heavyweight Locking）：当竞争轻量级锁的线程过多或**自旋次数达到一定阈值时，轻量级锁升级为重量级锁**。重量级锁会将线程置于阻塞状态，使用操作系统提供的互斥量（Mutex）来实现同步。此时，进入临界区的线程需要在释放锁之前进行阻塞和唤醒操作，效率较低。

### 27. ReentrantLock 实现原理，AQS实现原理

- ReentrantLock实现原理

  1. 基本结构：ReentrantLock内部使用了一个非公平的AQS（AbstractQueuedSynchronizer）来实现锁的功能。AQS是一个用于构建锁和同步器的框架，通过队列和等待/唤醒机制来管理线程的竞争和等待。
  2. 状态维护：ReentrantLock内部通过一个int类型的state来维护当前锁的状态。state的高16位表示持有锁的线程数，低16位表示当前等待获取锁的线程数。
  3. 获取锁：当一个线程尝试获取锁时，会先调用ReentrantLock的lock()方法。在lock()方法内部，会先尝试用CAS操作将state的高16位增加1。如果成功，表示当前线程获取到锁，可以直接进入临界区执行。如果失败，表示有其他线程持有锁，那么当前线程会进入同步队列中等待。
  4. 释放锁：当一个线程释放锁时，会调用ReentrantLock的unlock()方法。在unlock()方法内部，会先尝试用CAS操作将state的高16位减1。如果减少后的值为0，表示当前线程已经完全释放了锁。如果减少后的值大于0，表示当前线程还持有锁，可以继续执行临界区代码。在完全释放锁后，会通过唤醒操作将同步队列中的等待线程唤醒，并允许它们去竞争获取锁。
  5. 可重入性：ReentrantLock支持可重入锁，也就是同一个线程可以多次获取同一个锁。在同一个线程再次调用lock()方法时，会增加state的高16位，并记录当前线程已经获取锁的次数。在释放锁时，会减少state的高16位，直到最后一次释放锁为止。

- **AQS实现原理**

  AQS是依赖内部的同步队列实现，也就是**FIFO双向队列**，如果当前线程竞争锁失败，那么AQS会把当前线程以及等待状态封装成一个**Node节点**加入到同步队列中（`addWaiter()`方法），同时阻塞该线程，当同步状态释放时，会把首节点唤醒，使其再次尝试获取同步状态。

  AQS使用一个volatile修饰的int类型变量state来表示当前的同步状态。state的具体含义可以由使用者自行定义和扩展。例如，对于独占锁来说，state=0表示锁未被占用，state=1表示锁已被占用；对于共享锁来说，state表示锁的可用数量等。

  当一个线程尝试获取锁时，会调用AQS的acquire()方法。在acquire()方法内部，会先根据具体的实现逻辑判断当前线程是否能够直接获取锁。如果可以直接获取锁，则直接返回；否则，当前线程会被封装成一个Node节点加入到同步队列中，并进入自旋状态，不断尝试获取锁。

  当一个线程释放锁时，会调用AQS的release()方法。在release()方法内部，会根据具体的实现逻辑将state的值进行修改，并尝试唤醒同步队列中的等待线程。

### 28. AQS队列为空时线程加入队列发生什么

1. 创建节点：线程会被封装成一个Node节点，并设置相应的线程状态和等待状态。
2. CAS操作：线程会使用CAS（Compare and Swap）操作，尝试**将该节点加入到AQS的同步队列的尾部**。这是一个原子操作，它保证了多个线程同时尝试加入队列时的竞争关系。
3. 加入队列：如果CAS操作成功，即线程成功将节点加入到同步队列的尾部，那么线程将进入**自旋或被阻塞，等待获取锁**。
4. 自旋或阻塞：线程会在自旋或阻塞状态下等待，直到它被唤醒并有机会重新尝试获取锁。自旋是指线程不断地在一个循环内尝试获取锁，而不进行线程的阻塞和切换。如**果自旋不成功或超过一定次数，线程可能会被阻塞**，即进入到操作系统的等待队列中等待唤醒。

### 29. CountDownLatch Semaphore 使用和实现原理 

- CountDownLatch（倒计时门闩） CountDownLatch是一种计数器，它允许**一个或多个线程等待其他线程完成操作后再执行**。主要包含两个方法：countDown()和await()

  - countDown()：每次调用减少计数器的值。当计数器为0时，所有在await()方法上等待的线程会被唤醒继续执行。
  - await()：调用该方法的线程会阻塞，直到计数器为0，才会继续执行。

  使用场景：CountDownLatch通常用于等待一组线程完成某项任务。

  实现原理：CountDownLatch使用了AQS（AbstractQueuedSynchronizer）来进行线程的控制和同步。在CountDownLatch内部有一个**volatile修饰的int类型变量，表示计数器的值**。await()方法会通过自旋和阻塞来等待计数器的值为0，而countDown()方法则会通过CAS操作将计数器的值减1，并唤醒等待的线程。CountDownLatch的实现原理是基于AQS提供的同步工具，利用其中的阻塞和唤醒机制实现线程的等待和通知。

- Semaphore（信号量） Semaphore是一种计数信号量，用于控制同时访问某个资源的线程数量。它可以用来**限制同时访问某个资源的线程数目**，或者用于实现线程间的通信。主要包含两个方法：acquire()和release()。

  - acquire()：尝试获取一个许可，如果没有可用许可，则线程会阻塞等待。
  - release()：释放一个许可，使得其他等待的线程可以继续执行。

  使用场景：Semaphore常用于限制资源的并发访问量，例如数据库连接池、线程池等。

  实现原理：Semaphore的实现原理也是基于AQS。Semaphore内部使用了一个计数器，表示可用的许可数量。acquire()方法会通过自旋和阻塞来等待可用的许可，而release()方法则会通过CAS操作将许可数量加1，并唤醒等待的线程。Semaphore利用AQS提供的同步机制，实现了线程的安全访问和控制。

### 30. Redis为什么快

1. Redis完全基于**内存**，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap, HashMap的优势就是查找和操作的时间复杂度是O(1)；

2. **数据结构简单**，对数据的操作也简单；

3. 采用**单线程**，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗；

4. 使用**多路复用IO**模型，非阻塞IO：传统的并发模型：每个I/O流都有一个新的线程管理；

   I/O多路复用：只有单个线程，通过追踪每个I/O流的状态，来管理多个I/O流；

5. 使用的底层模型不同，它们之间底层实现方法以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的时候，会浪费一定的事件去移动和请求。

### 31. Redis持久化方式,Redis集群，模式，怎么实现选举

Redis为了保证效率，数据存储在了内存中，但是会周期性地把更新的数据写入磁盘或者把修改操作写成追加的记录文件中，以保证数据的持久化。

Redis的持久化策略有两种：

- RDB(Redis database)：直接把内存中的数据保存到一个dump的文件中，定时保存；
- AOF(Append Only File)：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合。

Redis默认是快照RDB的持久化方式。当Redis重启的时候，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整。甚至可以关闭持久化功能，让数据只在服务器运行时保存。

RDB和AOF的区别

1. RDB是一次全量备份，AOF日志是连续的增量备份；
2. RDB是内存数据的二进制序列化形式，在存储上非常紧凑，而AOF日志记录的是内存数据修改的指令记录文本；

### 32. 布隆过滤器原理

### 33. 缓存与数据库一致性问题