---
title: 面经整理
author: jimowo
icon: write
date: 2023-08-01
order: 3
category:
  - 面经
tag:
  - Java
---

# 面经整理

### 1. Java中的继承和多态 接口和抽象类的区别 StringBuffer和StringBuilder的区别

- 继承和多态

  继承是子类继承父类的除了静态方法和静态字段的所有方法和字段。
  多态分为类的多态和方法的多态。类的多态体现为继承，方法的多态体现为对方法的重载。

- 接口和抽象类的区别

  抽象类中可以有构造函数和非抽象方法，接口不能实例化，且所有方法都是抽象方法，jdk1.8中出现了default修饰的方法。接口中的所有成员变量都是public static final修饰的。
  接口是行为的抽象，cloneable之类的，是**Like A** 的关系；
  抽象类是类的抽象，是一种模板设计，是**Is A **的关系

- StringBuffer 和StringBuilder的区别

  StringBuilder线程不安全，效率比StringBuffer 高；
  StringBuffer的所有public 方法都是synchronized 修饰的。
  底层是默认长度为16的字符数组，每次扩容为数组原长度的2倍+2

### 2. error和exception的区别 怎么处理exception

- error和exception的区别

  Error 是指程序无法处理的错误，虚拟机错误、栈溢出（SOF）、内存溢出（OOM）

  Exception 是指程序本身可以处理的异常（可以自己Throw）

- 怎么处理exception

  exception分为编译时异常和运行时异常，前者由编译器发现。后者可以通过throw和catch来自定义处理

### 3. 什么是泛型 泛型的作用 泛型的使用方式有哪几种

- 什么是泛型

  参数化类型，把类型参数化

- 泛型的作用

  代码重用：在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型。实现模板的效果

  类型安全：通过指定泛型类型参数，编译器可以在编译时检查代码的类型安全性，避免在运行时出现类型转换错误。

  减少类型转换：泛型可以避免繁琐的类型转换操作，提高代码的可读性和维护性。

- 泛型的使用方式

  泛型类：带有泛型类型属性的类 `List<T>`；
  泛型接口：带有泛型类型参数的接口 `Comparable<T>`；
  泛型方法：带有泛型类型参数的方法 `public <T> void printArray(T[] array)`

### 4. HashMap的遍历方式有哪几种 ?HashMap与HashTable的区别? HashMap底层?(为什么是8和64没答出来 为什么选择红黑树这种数据结构 介绍一下红黑树)

- HashMap的遍历方式有哪几种 4种
  1. 使用 `keySet()` 方法遍历键（key）
  2. 使用 `values()` 方法遍历值（value）
  3. 使用 `entrySet()` 方法遍历键值对（entry）
  4. 使用迭代器（Iterator）遍历键值对
- HashMap与HashTable的区别
  1. HashTable线程安全
  2. HashMap允许键和值为null
  3. HashMap实现了Map接口，HashTable是Dictionary的子类
  4. `HashMap`可以指定初始容量和负载因子。当 `HashMap` 的元素数量超过负载因子与当前容量的乘积时，`HashMap` 会自动进行扩容。`HashTable` 在构造时只能指定初始容量，默认的负载因子是 0.75。扩容时，`HashTable` 的大小必须为素数，并且会创建一个新的数组来重新分配元素。

### 5. Java中实现多线程

1. 继承Thread类，重写run方法
2. 实现Runnable接口，把任务加入Thread类，启动（线程任务与线程控制分离）

### 6. Lambda表达式

是对匿名函数的简写形式

他的写法是使用一个`->`符号，左边写的是形参列表，右边就是对抽象方法的处理

- 无返回值有形参的抽象方法

  - 可以省略方法名，IDEA会帮你自动检测方法名；
  - 可以省略方法中的形参类型；
  - 如果对抽象方法的实现逻辑只有一行，可以省略方法体的大括号，当然如果不止一行，就不能省略了；

- 有返回值的抽象方法

  有返回值的方法，如果要去掉大括号，还需要去掉return关键字

- 有一个形参的抽象方法

  形参列表中只有一个参数，可以去掉形参的括号

- Lambda表达式也可以作为参数传递

- **Lambda表达式不是万能的，他需要函数式接口的支持**

  - 函数式接口的定义是: 只包含一个抽象方法的接口，称为函数式接口
  - 4大函数式接口
    1. `Consumer<T>`：该函数式接口接受一个输入参数，并对其进行操作，但没有返回结果。常用的方法是 `accept(T t)`，用于对给定的参数执行某些操作
    2. `Supplier<T>`：该函数式接口不接受任何输入参数，但返回一个结果。常用的方法是 `get()`，用于获取结果。
    3. `Function<T, R>`：该函数式接口接受一个输入参数，并将其转换为另一种类型的结果。常用的方法是 `apply(T t)`，用于对给定的参数进行处理并返回结果。
    4. `Predicate<T>`：该函数式接口接受一个输入参数，并返回一个布尔值结果。常用的方法是 `test(T t)`，用于对给定的参数进行条件判断。

### 7. 你最擅长的Java框架,介绍一下 Spring的核心思想

Spring框架的核心思想是**IOC**（Inversion of Control，控制反转）和**AOP**（Aspect-Oriented Programming，面向切面编程）。

1. IOC（控制反转）：IOC的核心理念是将对象的创建、依赖注入和生命周期管理交给Spring容器来完成，通过配置文件或注解的方式，让Spring容器在运行时动态地管理和组装对象。能够降低代码的耦合性、提高代码的可维护性和可测试性。
2. AOP（面向切面编程）：AOP通过在不修改原有代码的情况下，增加一些额外的功能和行为。例如，日志记录、事务管理等功能可以横切于多个对象和方法。在Spring中，AOP通过**代理模式**实现，通过配置文件或注解的方式，将这些横切关注点与核心业务逻辑进行解耦，使得系统的设计更加清晰，并且能够重用这些横切关注点。

### 8. 什么是动态代理

JDK 动态代理主要涉及到 `java.lang.reflect` 包中的两个类：`Proxy` 和 `InvocationHandler`。 `InvocationHandler`是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类 的代码，**动态将横切逻辑和业务逻辑编制在一起**。`Proxy` 利用 `InvocationHandler` 动态创建 一个符合某一接口的实例，生成目标类的代理对象

动态代理拼接

### 9. 有没有遇到过OOM,如何排查

当遇到OOM（Out of Memory）错误时，表示JVM中的内存不足，无法分配更多的对象

- 什么时候会出现OOM问题
  1. 内存泄漏：内存泄漏是指应用程序中的对象占用了内存，但随着时间的推移无法被垃圾回收器释放。
  2. 内存资源不足：应用程序的内存需求超过了可用的物理内存或JVM的内存限制。
  3. 大量数据处理：如果应用程序处理大量的数据（如图片、视频、文件等），而没有适当地管理和释放这些数据的内存，就会导致内存耗尽。例如，一次性加载大型文件到内存中可能会导致OOM。
  4. 高并发和长时间运行：在高并发的情况下，如果应用程序无法有效地释放已经处理过的对象，内存使用量可能会快速增加，从而导致内存不足。此外，长时间运行的应用程序也可能因为内存占用累积而触发OOM。
- 如何排查OOM
  1. 检查错误日志：首先，查看完整的错误堆栈跟踪和错误信息，了解OOM的具体原因和位置。错误信息通常会提供一些线索来定位问题。
  2. 检查代码逻辑：审查代码，特别是与内存相关的部分，如大数据集合、缓存、文件读写等。确保没有使用过多的内存或存在内存泄漏的情况。另外，还要确保及时释放使用完毕的资源，如数据库连接、文件句柄等。
  3. 检查JVM内存配置：检查JVM的内存配置参数，如最大堆内存（-Xmx）、初始堆内存（-Xms）和永久代大小（如果使用CMS垃圾回收器）。确保这些参数足够大，以适应应用程序的内存需求。
  4. 优化内存使用：根据分析结果，考虑优化内存使用。可能的优化措施包括减少对象的创建、及时释放不再使用的对象、使用缓存技术、调整数据结构大小等。
  5. 使用内存分析工具：使用内存分析工具（如VisualVM、JProfiler、MAT）对应用程序进行实时监测和分析。这些工具可以提供更详细的内存使用情况，帮助识别哪些对象或数据结构占用大量内存，并找出潜在的内存泄漏问题。

### 10. 进程线程的区别,提示资源分配,空间占用方面

1. 资源占用：每个进程都有独立的内存空间和系统资源，而线程共享进程的资源。
2. 并发性：多个线程可以在同一个进程中并发执行，共享进程的资源。而不同进程之间的并发执行需要通过进程间通信进行数据交换。

### 11. IP地址和MAC地址区别

IP地址是用来标识网络中设备的逻辑地址。用于网络通信。**网络层**

MAC地址是用来标识网络设备的物理地址。MAC地址是设备出厂时就确定的，通常无法更改。**数据链路层**

### 12. 数据库的事务,并发事务会带来哪些问题,MySQL的默认隔离级别 如何在数据库中实现数据的备份和恢复

- 并发事务会带来哪些问题
  1. 数据不一致：并发事务可能导致数据的不一致性。当多个事务同时读取和修改同一份数据时，如果没有适当的并发控制机制，就有可能导致数据的错乱和不一致。
  2. 丢失更新：并发事务中的更新操作可能会相互覆盖，从而导致部分更新的丢失。例如，两个事务同时读取一个数据并进行修改，然后将结果写回数据库，如果没有适当的并发控制机制，其中一个事务的修改结果可能会被另一个事务的覆盖，导致数据的丢失。
  3. 脏读（Dirty Read）：脏读是指一个事务在读取了另一个事务未提交的数据之后，又进行了一次读取操作，此时可能读取到的数据是不正确或无效的。这种情况下，事务可能基于不一致或临时的数据进行后续操作，导致数据的错误处理和错误结果。
  4. 不可重复读（Non-repeatable Read）：不可重复读是指一个事务在读取了某个数据后，又进行一次读取操作，但此时读取到的数据已经发生了改变。这种情况下，事务可能会在两次读取之间对数据进行了一些操作（如修改或删除），导致前后两次读取的数据不一致。
  5. 幻读（Phantom Read）：幻读是指一个事务在同样的查询条件下，由于其他并发事务的插入或删除操作，导致前后两次查询的结果集不一致。这种情况下，事务在处理某个数据集时，可能会发现新增或删除了一些记录，导致数据的不完整性。
- 解决并发事务带来的问题
  1. 锁定机制
  2. 隔离级别
  3. 事务调度算法
- MySQL隔离级别
  1. 读未提交（Read Uncommitted）：最低的隔离级别，事务可以读取其他事务尚未提交的数据。这可能导致脏读、不可重复读和幻读的问题。
  2. 读已提交（Read Committed）：事务只能读取其他事务已经提交的数据。这解决了脏读的问题，但仍可能存在不可重复读和幻读的问题。
  3. 可重复读（Repeatable Read）：**MySQL 默认的隔离级别**。事务在启动时创建一个一致性视图，保证在整个事务期间读取的数据不受其他事务的影响，解决了不可重复读的问题。但仍可能存在幻读的问题。
  4. 串行化（Serializable）：最高的隔离级别，通过强制事务的串行执行来避免并发问题。事务会在读取和修改数据时对数据进行锁定，确保其他事务无法同时修改被锁定的数据。这可以解决脏读、不可重复读和幻读的问题，但可能降低并发性能。

### 13. 如何创建一个线程池,拒绝策略有什么,怎么设置线程池的大小(动态修改)

- 如何创建一个线程池

  可以使用 JUC的`Executors` 类来创建线程池，并使用 `Executor` 类设置线程池的属性。

- 线程池拒绝策略

  拒绝策略是在线程池无法接受新任务时采取的一种策略

  1. `ThreadPoolExecutor.AbortPolicy`（默认）：直接抛出 `RejectedExecutionException` 异常，拒绝新任务的提交。
  2. `ThreadPoolExecutor.CallerRunsPolicy`：由调用线程处理该任务。即将任务返回给调用者进行处理。
  3. `ThreadPoolExecutor.DiscardPolicy`：静默地丢弃无法处理的任务，不给予任何提示。
  4. `ThreadPoolExecutor.DiscardOldestPolicy`：丢弃最早提交的任务，然后尝试再次提交新任务。

- 怎么动态修改线程池的大小

  可以使用 `ThreadPoolExecutor` 的 `setCorePoolSize()` 和 `setMaximumPoolSize()` 方法来动态修改线程池的大小