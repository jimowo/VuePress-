const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":794,\"nextId\":794,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-8e79cd5e\",\"2\":\"v-8e79cd5e#_1-智能指针\",\"3\":\"v-8e79cd5e#_1-1-几个简单例子\",\"4\":\"v-59a19b68\",\"5\":\"v-59a19b68#_1-date数据类型的加减\",\"6\":\"v-59a19b68#_2-条件判断函数-case-when用法\",\"7\":\"v-59a19b68#_3-group-by-多字段查询\",\"8\":\"v-1473bf53\",\"9\":\"v-1473bf53#目录\",\"10\":\"v-4e65ec78\",\"11\":\"v-c151bf32\",\"12\":\"v-438ffe52\",\"13\":\"v-438ffe52#markdown-介绍\",\"14\":\"v-438ffe52#markdown-配置\",\"15\":\"v-438ffe52#markdown-扩展\",\"16\":\"v-438ffe52#vuepress-扩展\",\"17\":\"v-438ffe52#主题扩展\",\"18\":\"v-438ffe52#自定义容器\",\"19\":\"v-438ffe52#代码块\",\"20\":\"v-438ffe52#上下角标\",\"21\":\"v-438ffe52#自定义对齐\",\"22\":\"v-438ffe52#attrs\",\"23\":\"v-438ffe52#脚注\",\"24\":\"v-438ffe52#标记\",\"25\":\"v-438ffe52#任务列表\",\"26\":\"v-438ffe52#图片增强\",\"27\":\"v-438ffe52#卡片\",\"28\":\"v-438ffe52#图表\",\"29\":\"v-438ffe52#echarts\",\"30\":\"v-438ffe52#流程图\",\"31\":\"v-438ffe52#mermaid\",\"32\":\"v-438ffe52#tex-语法\",\"33\":\"v-438ffe52#导入文件\",\"34\":\"v-438ffe52#代码演示\",\"35\":\"v-438ffe52#样式化\",\"36\":\"v-438ffe52#交互演示\",\"37\":\"v-438ffe52#vue-交互演示\",\"38\":\"v-438ffe52#幻灯片\",\"39\":\"v-6e19edb7\",\"40\":\"v-6e19edb7#页面信息\",\"41\":\"v-6e19edb7#页面内容\",\"42\":\"v-6e19edb7#页面结构\",\"43\":\"v-6ee36132\",\"44\":\"v-6ee36132#_1-计算整型数组的总和\",\"45\":\"v-6ee36132#_2-数组排序\",\"46\":\"v-6ee36132#_3-找数组中的最大最小值\",\"47\":\"v-160da114\",\"48\":\"v-160da114#linux\",\"49\":\"v-160da114#_1-vmware-安装-centos7-并通过-finalshell连接\",\"50\":\"v-160da114#jvm\",\"51\":\"v-160da114#_1-java-内存分区\",\"52\":\"v-160da114#java-面向对象\",\"53\":\"v-160da114#_1-父子类的静态初始化代码块、构造代码块、构造方法执行顺序\",\"54\":\"v-160da114#java-io\",\"55\":\"v-160da114#_1-java中bufferedreader与scanner读入的区别\",\"56\":\"v-160da114#java多线程\",\"57\":\"v-160da114#java中的原子操作\",\"58\":\"v-160da114#spring\",\"59\":\"v-160da114#_1-spring-版本变化\",\"60\":\"v-160da114#_2-spring-的构成\",\"61\":\"v-160da114#_3-spring-特色功能\",\"62\":\"v-160da114#_4-使用-bean注解注入spring容器和解析xml文件注入有什么区别\",\"63\":\"v-160da114#_5-spring-ioc的原理\",\"64\":\"v-160da114#_6-spring的配置方式\",\"65\":\"v-160da114#_7-spring支持哪几种bean-scope-bean的作用域\",\"66\":\"v-160da114#_8-spring-bean的生命周期\",\"67\":\"v-160da114#_9-什么叫spring的内部bean\",\"68\":\"v-160da114#_10-spring有哪些自动装配方式\",\"69\":\"v-160da114#_11-component-controller-repository-service-有何区别\",\"70\":\"v-160da114#_12-component-bean有何区别\",\"71\":\"v-160da114#_12-qualifier-注解有什么用\",\"72\":\"v-160da114#_13-aop底层原理\",\"73\":\"v-160da114#_14-spring框架用到了哪些设计模式\",\"74\":\"v-160da114#springmvc\",\"75\":\"v-160da114#_1-springmvc是什么\",\"76\":\"v-160da114#_2-springmvc流程\",\"77\":\"v-160da114#_3-转发和重定向的区别\",\"78\":\"v-160da114#_4-继承-webmvcconfigureradapter-抽象类-常用的重写方法列举几个\",\"79\":\"v-160da114#springboot\",\"80\":\"v-160da114#_1-springboot特点\",\"81\":\"v-160da114#_2-springboot中的starters\",\"82\":\"v-160da114#_3-spring-boot-starter-parent是怎么实现它的功能的\",\"83\":\"v-160da114#_4-springboot集成mybatis这类的包-是怎么把mapper接口注入容器的\",\"84\":\"v-160da114#_5-springbootapplication-注解中的属性相当于哪几个注解\",\"85\":\"v-160da114#git\",\"86\":\"v-160da114#_1-git-fetch和git-pull的区别\",\"87\":\"v-941efb9e\",\"88\":\"v-941efb9e#_8-30-华为机考\",\"89\":\"v-941efb9e#_1-计算工作时长\",\"90\":\"v-941efb9e#_2-二叉树数组形式的遍历\",\"91\":\"v-941efb9e#_3-内存分配\",\"92\":\"v-631a2408\",\"93\":\"v-631a2408#设计模式指北\",\"94\":\"v-631a2408#适配器模式\",\"95\":\"v-631a2408#功能介绍\",\"96\":\"v-631a2408#java实现\",\"97\":\"v-631a2408#单例模式\",\"98\":\"v-631a2408#功能介绍-1\",\"99\":\"v-631a2408#java实现-1\",\"100\":\"v-631a2408#工厂模式\",\"101\":\"v-631a2408#功能介绍-2\",\"102\":\"v-631a2408#java实现-2\",\"103\":\"v-631a2408#模板模式\",\"104\":\"v-631a2408#功能介绍-3\",\"105\":\"v-631a2408#java实现-3\",\"106\":\"v-631a2408#建造者模式\",\"107\":\"v-631a2408#功能介绍-4\",\"108\":\"v-631a2408#java实现-4\",\"109\":\"v-631a2408#抽象工厂模式\",\"110\":\"v-631a2408#功能介绍-5\",\"111\":\"v-631a2408#java实现-5\",\"112\":\"v-631a2408#桥接模式\",\"113\":\"v-631a2408#功能介绍-6\",\"114\":\"v-631a2408#java实现-6\",\"115\":\"v-631a2408#原型模式\",\"116\":\"v-631a2408#功能介绍-7\",\"117\":\"v-631a2408#java实现-7\",\"118\":\"v-53cc0e56\",\"119\":\"v-53cc0e56#java基础\",\"120\":\"v-53cc0e56#java中的继承和多态-接口和抽象类的区别-stringbuffer和stringbuilder的区别\",\"121\":\"v-53cc0e56#说一下string内部结构-jdk9及之后的有什么变化\",\"122\":\"v-53cc0e56#arraylist和linkedlist区别\",\"123\":\"v-53cc0e56#什么是泛型-泛型的作用-泛型的使用方式有哪几种\",\"124\":\"v-53cc0e56#hashmap的遍历方式有哪几种-hashmap与hashtable的区别-hashmap底层-为什么是8和64没答出来-为什么选择红黑树这种数据结构-介绍一下红黑树\",\"125\":\"v-53cc0e56#concurrenthashmap如何保证线程安全\",\"126\":\"v-53cc0e56#error和exception的区别-怎么处理exception\",\"127\":\"v-53cc0e56#final关键字有什么作用\",\"128\":\"v-53cc0e56#volatile关键字有什么作用\",\"129\":\"v-53cc0e56#lambda表达式\",\"130\":\"v-53cc0e56#通过静态工厂-integer-valueof-int-来创建-integer-对象有什么好处\",\"131\":\"v-53cc0e56#java多线程\",\"132\":\"v-53cc0e56#java中实现多线程\",\"133\":\"v-53cc0e56#runnable、callable-区别-如何接收这两个线程异常\",\"134\":\"v-53cc0e56#如何创建一个线程池-拒绝策略有什么-怎么设置线程池的大小-动态修改\",\"135\":\"v-53cc0e56#线程池7个参数-提交任务流程-为什么不先创建临时线程而是先放进阻塞队列\",\"136\":\"v-53cc0e56#核心线程能否被回收\",\"137\":\"v-53cc0e56#线程池配置无界队列了之后-拒绝策略怎么搞-什么时候用到无界对列\",\"138\":\"v-53cc0e56#volatile和sychronized的区别\",\"139\":\"v-53cc0e56#synchronized锁升级过程和实现原理\",\"140\":\"v-53cc0e56#讲讲jmm内存模型-volatile作用-实现原理-为什么-volatile-能防止指令重排-为什么有可见性问题\",\"141\":\"v-53cc0e56#reentrantlock-实现原理-aqs实现原理\",\"142\":\"v-53cc0e56#sychronized和reentrantlock区别\",\"143\":\"v-53cc0e56#aqs队列为空时线程加入队列发生什么\",\"144\":\"v-53cc0e56#countdownlatch-semaphore-使用和实现原理\",\"145\":\"v-53cc0e56#jvm\",\"146\":\"v-53cc0e56#有没有遇到过oom-如何排查\",\"147\":\"v-53cc0e56#双亲委派机制的作用-jvm\",\"148\":\"v-53cc0e56#jvm垃圾回收机制\",\"149\":\"v-53cc0e56#操作系统与计算机网络\",\"150\":\"v-53cc0e56#进程线程的区别-提示资源分配-空间占用方面\",\"151\":\"v-53cc0e56#并发和并行的区别\",\"152\":\"v-53cc0e56#ip地址和mac地址区别\",\"153\":\"v-53cc0e56#cookie和session的差别\",\"154\":\"v-53cc0e56#http和https的差别\",\"155\":\"v-53cc0e56#http状态码-https怎么建立连接的\",\"156\":\"v-53cc0e56#tcp和udp区别-udp用在哪些地方\",\"157\":\"v-53cc0e56#spring框架\",\"158\":\"v-53cc0e56#你最擅长的java框架-介绍一下-spring的核心思想\",\"159\":\"v-53cc0e56#什么是动态代理-什么是cgi\",\"160\":\"v-53cc0e56#spring-bean-生命周期\",\"161\":\"v-53cc0e56#讲讲一个http请求发到controller的过程\",\"162\":\"v-53cc0e56#dispatcherservlet是干嘛的\",\"163\":\"v-53cc0e56#spring怎么解决循环依赖问题\",\"164\":\"v-53cc0e56#spring中使用多线程\",\"165\":\"v-53cc0e56#登录系统的cookie和session如何设计\",\"166\":\"v-53cc0e56#spring的-transaction-假如我一个-service-里面有两个public方法a和b-a上面没有-transaction-b有-a方法调用b方法-事务会生效吗\",\"167\":\"v-53cc0e56#mybatis的缓存机制-有哪些缓存策略\",\"168\":\"v-53cc0e56#如果没有spring怎么开发\",\"169\":\"v-53cc0e56#mysql数据库\",\"170\":\"v-53cc0e56#事务特性\",\"171\":\"v-53cc0e56#数据库的事务-并发事务会带来哪些问题-mysql的默认隔离级别-如何在数据库中实现数据的备份和恢复\",\"172\":\"v-53cc0e56#mysql数据库的索引结构为什么用b-树-b树缺点\",\"173\":\"v-53cc0e56#mysql行数多了为什么会变慢-加索引为什么会快\",\"174\":\"v-53cc0e56#怎么设计数据库索引\",\"175\":\"v-53cc0e56#最左匹配原则是什么-以及为什么这样就可以用到联合索引\",\"176\":\"v-53cc0e56#联合索引为什么要遵守前缀匹配\",\"177\":\"v-53cc0e56#mysql有哪些日志-分别起什么作用\",\"178\":\"v-53cc0e56#mysql-mvcc-原理\",\"179\":\"v-53cc0e56#mysql索引类型-什么是聚簇索引-什么是非聚簇索引\",\"180\":\"v-53cc0e56#mysql的wal原则\",\"181\":\"v-53cc0e56#redis的aof遵守wal原则吗\",\"182\":\"v-53cc0e56#mysql怎么排查慢查询\",\"183\":\"v-53cc0e56#mysql支持事务的存储引擎\",\"184\":\"v-53cc0e56#sql语句的执行顺序\",\"185\":\"v-53cc0e56#redis-缓存\",\"186\":\"v-53cc0e56#redis-为什么快-为什么能处理高并发\",\"187\":\"v-53cc0e56#redis-为什么采用单线程\",\"188\":\"v-53cc0e56#redis-基本类型\",\"189\":\"v-53cc0e56#redis-持久化方式\",\"190\":\"v-53cc0e56#redis-的扩容方式\",\"191\":\"v-53cc0e56#redis-过期键的删除策略\",\"192\":\"v-53cc0e56#redis-的缓存淘汰策略\",\"193\":\"v-53cc0e56#为何-redis-使用跳表而非红黑树实现-sortedset-zset\",\"194\":\"v-53cc0e56#布隆过滤器原理\",\"195\":\"v-53cc0e56#缓存与数据库一致性问题\",\"196\":\"v-53cc0e56#解决缓存与数据库一致性问题\",\"197\":\"v-53cc0e56#什么是缓存穿透-怎么解决\",\"198\":\"v-53cc0e56#什么是缓存雪崩-怎么解决\",\"199\":\"v-53cc0e56#redis的set元素过多怎么办\",\"200\":\"v-53cc0e56#redis内存不够了怎么办\",\"201\":\"v-53cc0e56#redis-事务的概念\",\"202\":\"v-53cc0e56#redis-事务相关指令\",\"203\":\"v-53cc0e56#redis-集群方式-哨兵选举过程\",\"204\":\"v-53cc0e56#主从复制的原理\",\"205\":\"v-53cc0e56#redis-实现分布式锁\",\"206\":\"v-53cc0e56#rabbitmq-消息队列\",\"207\":\"v-53cc0e56#为什么使用消息队列\",\"208\":\"v-53cc0e56#amqp-三层协议\",\"209\":\"v-53cc0e56#rabbitmq-构造\",\"210\":\"v-53cc0e56#消费消息的流程\",\"211\":\"v-53cc0e56#如何保证消息可靠性\",\"212\":\"v-53cc0e56#如何保证-rabbitmq-消息队列高可用\",\"213\":\"v-53cc0e56#rabbitmq-和kafka-区别\",\"214\":\"v-53cc0e56#为什么kafka吞吐量高\",\"215\":\"v-53cc0e56#微服务\",\"216\":\"v-53cc0e56#分布式锁使用场景\",\"217\":\"v-53cc0e56#zookeeper分布式锁实现原理\",\"218\":\"v-64fed591\",\"219\":\"v-64fed591#_1-线程知识\",\"220\":\"v-64fed591#_1-1-start-线程开启底层\",\"221\":\"v-64fed591#_1-2-基础概念\",\"222\":\"v-64fed591#_1-2-1-juc是什么\",\"223\":\"v-64fed591#_1-2-2-java默认有几个线程\",\"224\":\"v-64fed591#_1-2-3-并发与并行的区别\",\"225\":\"v-64fed591#_1-2-4-线程的6个状态\",\"226\":\"v-64fed591#_1-2-5-wait和sleep方法的区别\",\"227\":\"v-64fed591#_1-2-6-守护线程\",\"228\":\"v-64fed591#_2-completablefuture\",\"229\":\"v-64fed591#_2-1-future接口\",\"230\":\"v-64fed591#_2-3-futuretask类\",\"231\":\"v-64fed591#_2-3-1-futuretask类的继承实现关系\",\"232\":\"v-64fed591#_2-3-2-futuretask使用例子\",\"233\":\"v-64fed591#_2-3-3-get方法\",\"234\":\"v-64fed591#_2-3-4-isdone轮询方法\",\"235\":\"v-64fed591#_2-4-completablefuture优化future\",\"236\":\"v-64fed591#_2-5-completablefuture源码分析\",\"237\":\"v-64fed591#_2-5-1-completablefuture介绍\",\"238\":\"v-64fed591#supplyasync方法-有返回值\",\"239\":\"v-64fed591#runasync方法\",\"240\":\"v-64fed591#get方法\",\"241\":\"v-64fed591#getnow方法\",\"242\":\"v-64fed591#complete方法\",\"243\":\"v-64fed591#thenapply方法-串行化\",\"244\":\"v-64fed591#handle方法-串行化\",\"245\":\"v-64fed591#thenaccept方法\",\"246\":\"v-64fed591#thenrun方法\",\"247\":\"v-64fed591#thenrunasync方法\",\"248\":\"v-64fed591#_2-5-2-completionstage分析\",\"249\":\"v-64fed591#_2-5-3-completablefuture使用例子\",\"250\":\"v-64fed591#_2-6-函数式编程\",\"251\":\"v-64fed591#_2-6-1-函数式接口\",\"252\":\"v-64fed591#_2-6-2-链式编程\",\"253\":\"v-64fed591#_2-6-3-join与get对比\",\"254\":\"v-64fed591#_2-7-例子-电商网站比价\",\"255\":\"v-64fed591#_2-7-1-需求\",\"256\":\"v-64fed591#_2-7-2-demo\",\"257\":\"v-64fed591#_3-多线程锁\",\"258\":\"v-64fed591#_3-1-乐观锁悲观锁\",\"259\":\"v-64fed591#_3-2-传统synchronized\",\"260\":\"v-64fed591#_3-3-synchronized分析\",\"261\":\"v-64fed591#_3-4-synchronized-和-lock-的区别\",\"262\":\"v-64fed591#_3-5-公平锁和非公平锁\",\"263\":\"v-64fed591#_3-6-可重入锁-递归锁\",\"264\":\"v-64fed591#_3-7-死锁\",\"265\":\"v-64fed591#_4-中断机制\",\"266\":\"v-64fed591#_4-1-线程中断机制\",\"267\":\"v-64fed591#_4-1-1-什么是中断机制\",\"268\":\"v-64fed591#_4-1-2-面试题\",\"269\":\"v-64fed591#_5-locksupport\",\"270\":\"v-64fed591#_5-1-介绍\",\"271\":\"v-64fed591#_5-2-等待唤醒线程的三种方法\",\"272\":\"v-64fed591#_6-java内存模型jmm\",\"273\":\"v-64fed591#_6-1-带着问题学习\",\"274\":\"v-64fed591#_6-2-计算机硬件存储体系\",\"275\":\"v-64fed591#_6-3-java内存模型java-memory-model\",\"276\":\"v-64fed591#_6-4-jmm规范下-三大特性\",\"277\":\"v-64fed591#_6-4-1-可见性\",\"278\":\"v-64fed591#_6-4-2-有序性\",\"279\":\"v-64fed591#_6-5-jmm规范下-多线程对变量的独写过程\",\"280\":\"v-64fed591#_6-6-jmm规范下-多线程先行发生原则之happens-before\",\"281\":\"v-64fed591#_6-6-1-次序规则\",\"282\":\"v-64fed591#_6-6-2-锁定规则\",\"283\":\"v-64fed591#_6-6-3-volatile变量规则\",\"284\":\"v-64fed591#_6-6-4-传递规则\",\"285\":\"v-64fed591#_6-6-5-线程启动规则\",\"286\":\"v-64fed591#_6-6-6-线程中断规则\",\"287\":\"v-64fed591#_6-6-7-线程终止规则\",\"288\":\"v-64fed591#_6-6-8-对象终结规则\",\"289\":\"v-64fed591#_7-volatile与jmm\",\"290\":\"v-64fed591#_7-1-内存屏障\",\"291\":\"v-64fed591#_7-2-volatile保证可见性\",\"292\":\"v-64fed591#_7-3-volatile保证有序性\",\"293\":\"v-64fed591#_7-4-volatile不能保证原子性\",\"294\":\"v-64fed591#_8-cas机制\",\"295\":\"v-64fed591#_8-1-cas是什么-解决了什么问题\",\"296\":\"v-64fed591#_8-2-unsafe类\",\"297\":\"v-64fed591#_8-3-atomicreference类-对象的原子操作类\",\"298\":\"v-64fed591#_8-4-cas手写自旋锁\",\"299\":\"v-64fed591#_8-5-cas的缺点\",\"300\":\"v-64fed591#_8-6-缺点改进\",\"301\":\"v-64fed591#_10-threadlocal\",\"302\":\"v-64fed591#_10-1-问题\",\"303\":\"v-64fed591#_10-2-threadlocal是什么\",\"304\":\"v-64fed591#_10-3-api与调用\",\"305\":\"v-64fed591#_10-4-threadlocal的实现原理\",\"306\":\"v-64fed591#_10-4-1-set方法\",\"307\":\"v-64fed591#_10-4-2-get方法\",\"308\":\"v-64fed591#_10-4-3-threadlocalmap-关键\",\"309\":\"v-64fed591#_13-aqs队列同步器-abstractqueuedsynchronizer\",\"310\":\"v-64fed591#_13-1-问题\",\"311\":\"v-64fed591#_13-2-aqs简介\",\"312\":\"v-64fed591#_13-3-aqs原理\",\"313\":\"v-64fed591#_13-4-如何使用aqs\",\"314\":\"v-64fed591#_13-5-aqs分析\",\"315\":\"v-64fed591#_13-5-1-acquire分析\",\"316\":\"v-64fed591#_13-5-2-acquirequeue分析\",\"317\":\"v-64fed591#_13-5-3-release流程分析\",\"318\":\"v-64fed591#_13-5-4-acquireshared-和releaseshared分析\",\"319\":\"v-64fed591#_13-6-conditionobject-wait队列\",\"320\":\"v-5e6eb1ee\",\"321\":\"v-5e6eb1ee#一-简介\",\"322\":\"v-5e6eb1ee#_1-1-javaweb概念\",\"323\":\"v-5e6eb1ee#_1-2-web资源的分类\",\"324\":\"v-5e6eb1ee#_1-3-常用的服务器\",\"325\":\"v-5e6eb1ee#二、servlet\",\"326\":\"v-5e6eb1ee#_2-1-servlet技术\",\"327\":\"v-5e6eb1ee#_2-2-第一个servlet程序\",\"328\":\"v-5e6eb1ee#_2-3-servlet的生命周期\",\"329\":\"v-5e6eb1ee#_2-4-servlet的继承体系\",\"330\":\"v-5e6eb1ee#_2-5-servletconfig类\",\"331\":\"v-5e6eb1ee#_2-6-servletcontext类\",\"332\":\"v-5e6eb1ee#_2-7-区分get请求和post请求\",\"333\":\"v-5e6eb1ee#_2-8-httpservletrequest类\",\"334\":\"v-5e6eb1ee#_2-9-servlet请求转发\",\"335\":\"v-5e6eb1ee#_2-10-httpservletresponse类\",\"336\":\"v-5e6eb1ee#_2-11-请求重定向\",\"337\":\"v-5e6eb1ee#三、filter过滤器\",\"338\":\"v-5e6eb1ee#_3-1-什么是filter\",\"339\":\"v-5e6eb1ee#_3-2-filter应用\",\"340\":\"v-5e6eb1ee#_3-3-filter的生命周期\",\"341\":\"v-5e6eb1ee#_3-4-filterconfig类\",\"342\":\"v-5e6eb1ee#_3-5-filterchain类\",\"343\":\"v-5e6eb1ee#_3-6-filter的拦截路径\",\"344\":\"v-14c49b8e\",\"345\":\"v-14c49b8e#一、java基础概述\",\"346\":\"v-14c49b8e#java的重要特点\",\"347\":\"v-14c49b8e#java的运行机制及运行过程\",\"348\":\"v-14c49b8e#java核心机制-jvm\",\"349\":\"v-14c49b8e#编译运行指令\",\"350\":\"v-14c49b8e#jdk基本介绍\",\"351\":\"v-14c49b8e#java快速入门\",\"352\":\"v-14c49b8e#java开发注意事项\",\"353\":\"v-14c49b8e#java转义字符\",\"354\":\"v-14c49b8e#java注释\",\"355\":\"v-14c49b8e#二、java变量\",\"356\":\"v-14c49b8e#编码表\",\"357\":\"v-14c49b8e#java中-号的使用\",\"358\":\"v-14c49b8e#内置数据类型\",\"359\":\"v-14c49b8e#基本数据类型转换\",\"360\":\"v-14c49b8e#基本数据类型和string类型的转换\",\"361\":\"v-14c49b8e#三、java运算符\",\"362\":\"v-14c49b8e#算术运算符\",\"363\":\"v-14c49b8e#比较运算符\",\"364\":\"v-14c49b8e#逻辑运算符\",\"365\":\"v-14c49b8e#赋值运算符\",\"366\":\"v-14c49b8e#三元运算符\",\"367\":\"v-14c49b8e#运算符优先级\",\"368\":\"v-14c49b8e#键盘输入\",\"369\":\"v-14c49b8e#原码、反码、补码\",\"370\":\"v-14c49b8e#四、控制结构\",\"371\":\"v-14c49b8e#分支控制if-else\",\"372\":\"v-14c49b8e#switch分支结构\",\"373\":\"v-14c49b8e#for循环控制\",\"374\":\"v-14c49b8e#while循环控制\",\"375\":\"v-14c49b8e#do-while循环控制\",\"376\":\"v-14c49b8e#多重循环控制\",\"377\":\"v-14c49b8e#跳转控制语句-break\",\"378\":\"v-14c49b8e#跳转控制语句-continue\",\"379\":\"v-14c49b8e#跳转控制语句-return\",\"380\":\"v-14c49b8e#五、数组、排序和查找\",\"381\":\"v-14c49b8e#数组\",\"382\":\"v-14c49b8e#二维数组\",\"383\":\"v-14c49b8e#六、面向对象编程-基础\",\"384\":\"v-14c49b8e#类与对象介绍\",\"385\":\"v-14c49b8e#对象内存布局\",\"386\":\"v-14c49b8e#属性-成员变量\",\"387\":\"v-14c49b8e#如何创建对象\",\"388\":\"v-14c49b8e#类与对象的内存分配机制\",\"389\":\"v-14c49b8e#成员方法\",\"390\":\"v-14c49b8e#克隆对象\",\"391\":\"v-14c49b8e#方法递归调用\",\"392\":\"v-14c49b8e#构造器\",\"393\":\"v-14c49b8e#this关键字\",\"394\":\"v-14c49b8e#七、面向对象编程-中级\",\"395\":\"v-14c49b8e#idea的使用\",\"396\":\"v-14c49b8e#包package\",\"397\":\"v-14c49b8e#访问修饰符\",\"398\":\"v-14c49b8e#面向对象特征-封装\",\"399\":\"v-14c49b8e#面向对象特征-继承\",\"400\":\"v-14c49b8e#super关键字\",\"401\":\"v-14c49b8e#方法重写-覆盖-override\",\"402\":\"v-14c49b8e#面向对象特征-多态\",\"403\":\"v-14c49b8e#java的动态绑定机制-非常重要\",\"404\":\"v-14c49b8e#多态的应用-多态数组\",\"405\":\"v-14c49b8e#多态的应用-多态参数\",\"406\":\"v-14c49b8e#object类详解\",\"407\":\"v-14c49b8e#八、项目-房屋出租系统\",\"408\":\"v-14c49b8e#项目需求\",\"409\":\"v-14c49b8e#程序框架设计\",\"410\":\"v-14c49b8e#九、面向对象编程-高级\",\"411\":\"v-14c49b8e#类变量和类方法\",\"412\":\"v-14c49b8e#理解main方法语法\",\"413\":\"v-14c49b8e#代码块\",\"414\":\"v-14c49b8e#单例设计模式\",\"415\":\"v-14c49b8e#final关键字\",\"416\":\"v-14c49b8e#抽象类\",\"417\":\"v-14c49b8e#接口\",\"418\":\"v-14c49b8e#内部类\",\"419\":\"v-14c49b8e#代理-proxy\",\"420\":\"v-14c49b8e#枚举和注解\",\"421\":\"v-14c49b8e#枚举\",\"422\":\"v-14c49b8e#注解\",\"423\":\"v-14c49b8e#十、异常\",\"424\":\"v-14c49b8e#异常介绍\",\"425\":\"v-14c49b8e#抛出异常\",\"426\":\"v-14c49b8e#十一、常用类\",\"427\":\"v-14c49b8e#包装类\",\"428\":\"v-14c49b8e#integer类\",\"429\":\"v-14c49b8e#string类\",\"430\":\"v-14c49b8e#stringbuffer类\",\"431\":\"v-14c49b8e#stringbuilder类\",\"432\":\"v-14c49b8e#math类\",\"433\":\"v-14c49b8e#arrays类\",\"434\":\"v-14c49b8e#system类\",\"435\":\"v-14c49b8e#biginteger和bigdecimal类\",\"436\":\"v-14c49b8e#日期类\",\"437\":\"v-14c49b8e#十二、集合\",\"438\":\"v-14c49b8e#集合的理解和好处\",\"439\":\"v-14c49b8e#collection接口和常用方法\",\"440\":\"v-14c49b8e#list接口和常用方法\",\"441\":\"v-14c49b8e#arraylist底层结构和源码分析\",\"442\":\"v-14c49b8e#vector底层结构和源码剖析\",\"443\":\"v-14c49b8e#linkedlist底层结构\",\"444\":\"v-14c49b8e#set接口和常用方法\",\"445\":\"v-14c49b8e#set接口实现类-hashset\",\"446\":\"v-14c49b8e#set接口实现类-linkedhashset\",\"447\":\"v-14c49b8e#set接口实现类-treeset\",\"448\":\"v-14c49b8e#map接口和常用方法\",\"449\":\"v-14c49b8e#map接口实现类-hashtable\",\"450\":\"v-14c49b8e#map接口实现类-properties\",\"451\":\"v-14c49b8e#总结-开发中如何选择集合实现类\",\"452\":\"v-14c49b8e#collections工具类\",\"453\":\"v-14c49b8e#十三、泛型\",\"454\":\"v-14c49b8e#泛型的理解和好处\",\"455\":\"v-14c49b8e#泛型介绍\",\"456\":\"v-14c49b8e#泛型语法\",\"457\":\"v-14c49b8e#自定义泛型类\",\"458\":\"v-14c49b8e#自定义泛型接口\",\"459\":\"v-14c49b8e#自定义泛型方法\",\"460\":\"v-14c49b8e#泛型的继承和通配符\",\"461\":\"v-14c49b8e#java核心技术卷补充\",\"462\":\"v-14c49b8e#junit测试\",\"463\":\"v-14c49b8e#十四、坦克大战-1\",\"464\":\"v-14c49b8e#java绘图坐标系\",\"465\":\"v-14c49b8e#十五、多线程基础\",\"466\":\"v-14c49b8e#线程的基本使用\",\"467\":\"v-14c49b8e#线程终止\",\"468\":\"v-14c49b8e#线程常用方法\",\"469\":\"v-14c49b8e#线程的生命周期\",\"470\":\"v-14c49b8e#线程同步\",\"471\":\"v-14c49b8e#互斥锁\",\"472\":\"v-14c49b8e#释放锁\",\"473\":\"v-14c49b8e#十六、io流\",\"474\":\"v-14c49b8e#文件流\",\"475\":\"v-14c49b8e#常用文件操作\",\"476\":\"v-14c49b8e#io流原理及流的分类\",\"477\":\"v-14c49b8e#io流体系图-常用的类\",\"478\":\"v-14c49b8e#节点流和处理流\",\"479\":\"v-14c49b8e#打印流-printstream-和-printwriter\",\"480\":\"v-14c49b8e#properties类\",\"481\":\"v-14c49b8e#十七、网络编程\",\"482\":\"v-14c49b8e#网络通信相关概念\",\"483\":\"v-14c49b8e#inetaddress类\",\"484\":\"v-14c49b8e#socket-网络套接字\",\"485\":\"v-14c49b8e#tcp网络通信编程\",\"486\":\"v-14c49b8e#十八、反射\",\"487\":\"v-14c49b8e#十九、lambda表达式\",\"488\":\"v-14c49b8e#语法\",\"489\":\"v-14c49b8e#表达式实例\",\"490\":\"v-14c49b8e#函数式接口\",\"491\":\"v-14c49b8e#变量作用域\",\"492\":\"v-14c49b8e#二十、面试题\",\"493\":\"v-6b5e9bf0\",\"494\":\"v-6b5e9bf0#_1-mybatis-简介\",\"495\":\"v-6b5e9bf0#_1-1-mybatis-特性\",\"496\":\"v-6b5e9bf0#_1-2-与其他持久层技术对比\",\"497\":\"v-6b5e9bf0#_2-搭建-mybatis\",\"498\":\"v-6b5e9bf0#_2-1-配置-maven-依赖\",\"499\":\"v-6b5e9bf0#_2-2-创建-mybatis-核心配置文件\",\"500\":\"v-6b5e9bf0#_2-3-创建-mapper-接口\",\"501\":\"v-6b5e9bf0#_2-4-配置-mapper-映射\",\"502\":\"v-6b5e9bf0#_2-5-获取-sql-会话对象-测试功能\",\"503\":\"v-6b5e9bf0#_3-完善-mybatis\",\"504\":\"v-6b5e9bf0#_3-1-添加查询功能\",\"505\":\"v-6b5e9bf0#_4-mybatis-核心配置文件-mybatis-config-xml\",\"506\":\"v-6b5e9bf0#_4-1-核心配置文件之-environment\",\"507\":\"v-6b5e9bf0#_4-2-核心配置文件之-properties\",\"508\":\"v-6b5e9bf0#_4-3-核心配置文件之-typealiases\",\"509\":\"v-6b5e9bf0#_4-4-核心配置文件之-mappers\",\"510\":\"v-6b5e9bf0#_5-mybatis-获取参数值的两种方式\",\"511\":\"v-6b5e9bf0#_5-1-获取单个参数情况\",\"512\":\"v-6b5e9bf0#_5-2-获取多个参数情况\",\"513\":\"v-6b5e9bf0#_6-mybatis-查询\",\"514\":\"v-6b5e9bf0#_6-1-查询返回多条数据-mapkey\",\"515\":\"v-6b5e9bf0#_6-2-查询返回多条数据-list-map\",\"516\":\"v-6b5e9bf0#_7-mybatis-特殊功能\",\"517\":\"v-6b5e9bf0#_7-1-模糊查询\",\"518\":\"v-6b5e9bf0#_7-2-批量删除\",\"519\":\"v-6b5e9bf0#_7-3-动态设置表名\",\"520\":\"v-6b5e9bf0#_7-4-获取自增的主键\",\"521\":\"v-6b5e9bf0#_8-搭建-mybatis-框架\",\"522\":\"v-6b5e9bf0#_8-1-处理字段名和属性名不一致的情况\",\"523\":\"v-6b5e9bf0#_8-2-多对一映射处理\",\"524\":\"v-6b5e9bf0#_8-3-延迟加载\",\"525\":\"v-6b5e9bf0#_8-4-一对多映射\",\"526\":\"v-6b5e9bf0#_9-动态-sql\",\"527\":\"v-6b5e9bf0#_9-1-if\",\"528\":\"v-6b5e9bf0#_9-2-where\",\"529\":\"v-6b5e9bf0#_9-3-trim\",\"530\":\"v-6b5e9bf0#_9-4-choose、when、otherwise\",\"531\":\"v-6b5e9bf0#_9-5-foreach\",\"532\":\"v-6b5e9bf0#_9-6-sql\",\"533\":\"v-6b5e9bf0#_10-mybatis-缓存\",\"534\":\"v-6b5e9bf0#_10-1-一级缓存\",\"535\":\"v-6b5e9bf0#_10-2-二级缓存\",\"536\":\"v-6b5e9bf0#_10-3-二级缓存相关配置文件\",\"537\":\"v-6b5e9bf0#_10-4-mybatis-缓存查询顺序\",\"538\":\"v-6b5e9bf0#_10-5-整合第三方缓存-ehcache\",\"539\":\"v-6b5e9bf0#_11-mybatis-逆向工程\",\"540\":\"v-6b5e9bf0#_11-1-简洁版\",\"541\":\"v-6b5e9bf0#_11-2-奢华版\",\"542\":\"v-6b5e9bf0#_12-分页功能\",\"543\":\"v-0da3d474\",\"544\":\"v-0da3d474#_1-spring-概念\",\"545\":\"v-0da3d474#_1-1-spring-介绍\",\"546\":\"v-0da3d474#_1-2-spring-框架概述\",\"547\":\"v-0da3d474#_1-2-1-ioc-介绍\",\"548\":\"v-0da3d474#_1-2-2-aop-介绍\",\"549\":\"v-0da3d474#_1-3-spring-特点\",\"550\":\"v-0da3d474#_2-入门案例\",\"551\":\"v-0da3d474#_2-1-spring-源码下载地址\",\"552\":\"v-0da3d474#_2-2-配置基本功能\",\"553\":\"v-0da3d474#_3-ioc-容器\",\"554\":\"v-0da3d474#_3-1-ioc-概念\",\"555\":\"v-0da3d474#_3-2-ioc-底层原理\",\"556\":\"v-0da3d474#_4-bean-管理\",\"557\":\"v-0da3d474#_4-1-什么是-bean-管理\",\"558\":\"v-0da3d474#_4-2-工厂-bean-factorybean\",\"559\":\"v-0da3d474#_4-3-bean-作用域\",\"560\":\"v-0da3d474#_4-4-bean-生命周期\",\"561\":\"v-0da3d474#_4-5-bean-管理-xml自动装配\",\"562\":\"v-0da3d474#_4-6-bean管理xml-外部属性文件-数据库-配置文件\",\"563\":\"v-0da3d474#_4-7-基于注解方式操作-bean\",\"564\":\"v-0da3d474#_4-8-基于注解方式实现属性的注入\",\"565\":\"v-0da3d474#_4-9-完全注解开发\",\"566\":\"v-0da3d474#_5-aop-面向切面\",\"567\":\"v-0da3d474#_5-1-aop-概念\",\"568\":\"v-0da3d474#_5-2-aop-底层原理\",\"569\":\"v-0da3d474#_5-3-jdk-动态代理\",\"570\":\"v-0da3d474#_5-4-aop-操作术语\",\"571\":\"v-0da3d474#_5-5-aop-操作准备\",\"572\":\"v-0da3d474#_5-6-aop-操作-aspectj注解\",\"573\":\"v-0da3d474#_6-jdbctemplate\",\"574\":\"v-0da3d474#_6-1-jdbctemplate-概念\",\"575\":\"v-0da3d474#_6-2-准备工作\",\"576\":\"v-0da3d474#_6-3-添加数据库功能\",\"577\":\"v-0da3d474#_6-4-添加数据库修改、删除\",\"578\":\"v-0da3d474#_6-5-jdbc-数据库批量操作\",\"579\":\"v-0da3d474#_7-事务\",\"580\":\"v-0da3d474#_7-1-事务概念\",\"581\":\"v-0da3d474#_7-2-事务操作-搭建事务操作环境\",\"582\":\"v-0da3d474#_7-3-事务的参数\",\"583\":\"v-0da3d474#_7-4-例子-转账事务-xml-方式\",\"584\":\"v-0da3d474#_7-5-事务开发-完全注解方式\",\"585\":\"v-0da3d474#_8-spring5-新功能\",\"586\":\"v-0da3d474#_8-1-通用日志封装\",\"587\":\"v-0da3d474#_8-2-springwebflux\",\"588\":\"v-0da3d474#_8-2-1-基本概念\",\"589\":\"v-1ad306b6\",\"590\":\"v-1ad306b6#_0-微服务架构理论\",\"591\":\"v-1ad306b6#介绍\",\"592\":\"v-1ad306b6#微服务的组成\",\"593\":\"v-1ad306b6#springcloud-简介\",\"594\":\"v-1ad306b6#_1-微服务治理\",\"595\":\"v-1ad306b6#_1-1-认识微服务\",\"596\":\"v-1ad306b6#_1-2-分布式服务架构案例\",\"597\":\"v-1ad306b6#_1-3-eureka-注册中心\",\"598\":\"v-1ad306b6#_1-4-ribbon-负载均衡原理\",\"599\":\"v-1ad306b6#_1-5-nacos-注册中心\",\"600\":\"v-1ad306b6#_1-6-eureka和nacos比较\",\"601\":\"v-1ad306b6#_2-nacos配置管理\",\"602\":\"v-1ad306b6#_2-1-统一配置管理\",\"603\":\"v-1ad306b6#_2-2-配置热更新\",\"604\":\"v-1ad306b6#_2-4-配置共享\",\"605\":\"v-1ad306b6#_2-5-搭建nacos集群\",\"606\":\"v-1ad306b6#_2-6-http客户端feign\",\"607\":\"v-1ad306b6#_2-7-统一网关gateway\",\"608\":\"v-1ad306b6#_3-docker-入门\",\"609\":\"v-1ad306b6#_3-1-什么是docker\",\"610\":\"v-1ad306b6#_3-2-docker-和虚拟机的区别\",\"611\":\"v-1ad306b6#_3-3-docker-架构\",\"612\":\"v-1ad306b6#_3-4-安装docker\",\"613\":\"v-1ad306b6#_3-5-docker-基本操作\",\"614\":\"v-1ad306b6#_3-6-容器操作\",\"615\":\"v-1ad306b6#_3-7-数据卷操作\",\"616\":\"v-1ad306b6#_3-8-dockerfile-自定义镜像\",\"617\":\"v-1ad306b6#_3-9-dockercompose\",\"618\":\"v-dd2a54a2\",\"619\":\"v-dd2a54a2#_1-数组\",\"620\":\"v-dd2a54a2#_704-二分查找-左右指针法\",\"621\":\"v-dd2a54a2#_33-旋转数组的二分查找\",\"622\":\"v-dd2a54a2#_739-每日温度\",\"623\":\"v-dd2a54a2#_27-移除元素-前后指针法\",\"624\":\"v-dd2a54a2#_42-接雨水-动态规划-前后指针\",\"625\":\"v-dd2a54a2#_11-盛水最多的容器\",\"626\":\"v-dd2a54a2#_1-两数之和\",\"627\":\"v-dd2a54a2#_18-四数之和-排序后的左右指针\",\"628\":\"v-dd2a54a2#_31-下一个排列\",\"629\":\"v-dd2a54a2#_977-有序数组的平方\",\"630\":\"v-dd2a54a2#_209-长度最小的子数组-滑动窗口法\",\"631\":\"v-dd2a54a2#练习-904-水果成篮\",\"632\":\"v-dd2a54a2#_59-螺旋矩阵\",\"633\":\"v-dd2a54a2#_2-链表\",\"634\":\"v-dd2a54a2#_203-移除链表元素-虚拟头指针dummy\",\"635\":\"v-dd2a54a2#_707-设计链表\",\"636\":\"v-dd2a54a2#_206-反转链表\",\"637\":\"v-dd2a54a2#_24-两两交换链表中的节点\",\"638\":\"v-dd2a54a2#_19-删除链表的的倒数第n个节点\",\"639\":\"v-dd2a54a2#_160-链表相交\",\"640\":\"v-dd2a54a2#_142-环形链表-快慢指针\",\"641\":\"v-dd2a54a2#_3-字符串\",\"642\":\"v-dd2a54a2#_344-反转字符串\",\"643\":\"v-dd2a54a2#_541-反转字符串2\",\"644\":\"v-dd2a54a2#剑指offer-05-替换空格\",\"645\":\"v-dd2a54a2#_151-翻转字符串里的单词\",\"646\":\"v-dd2a54a2#剑指offer58-ii-左旋转字符串\",\"647\":\"v-dd2a54a2#_3-无重复字符的最长子串-滑动窗口\",\"648\":\"v-dd2a54a2#_76-最小覆盖子串-滑动窗口\",\"649\":\"v-dd2a54a2#_438-找到字符串中所有字母异位词\",\"650\":\"v-dd2a54a2#_5-最长回文子串\",\"651\":\"v-dd2a54a2#_28-实现-strstr\",\"652\":\"v-dd2a54a2#方法1-暴力遍历\",\"653\":\"v-dd2a54a2#方法2-kmp\",\"654\":\"v-dd2a54a2#_4-栈与队列\",\"655\":\"v-dd2a54a2#_232-用栈实现队列\",\"656\":\"v-dd2a54a2#_225-用队列实现栈\",\"657\":\"v-dd2a54a2#方法1-双队列实现\",\"658\":\"v-dd2a54a2#方法2-单队列实现\",\"659\":\"v-dd2a54a2#_20-有效的括号\",\"660\":\"v-dd2a54a2#_921-使括号有效的最少添加\",\"661\":\"v-dd2a54a2#_239-滑动窗口的最大值-单调队列\",\"662\":\"v-dd2a54a2#_84-柱状图中最大的矩形-单调栈\",\"663\":\"v-dd2a54a2#_5-二叉树\",\"664\":\"v-dd2a54a2#二叉树的遍历\",\"665\":\"v-dd2a54a2#二叉树迭代遍历-栈\",\"666\":\"v-dd2a54a2#二叉树层序遍历-队列\",\"667\":\"v-dd2a54a2#_226-反转二叉树\",\"668\":\"v-dd2a54a2#_101-对称二叉树\",\"669\":\"v-dd2a54a2#_104-二叉树的最大深度\",\"670\":\"v-dd2a54a2#技巧-前缀和\",\"671\":\"v-dd2a54a2#_560-和为-k-的子数组\",\"672\":\"v-dd2a54a2#_437-路径总和-二叉树中的前缀和\",\"673\":\"v-dd2a54a2#技巧-前缀树\",\"674\":\"v-dd2a54a2#基本字典树\",\"675\":\"v-dd2a54a2#_820-单词的压缩编码\",\"676\":\"v-dd2a54a2#技巧-差分数组\",\"677\":\"v-dd2a54a2#_1094-拼车\",\"678\":\"v-dd2a54a2#_1109-航班预定统计\",\"679\":\"v-dd2a54a2#技巧-并查集-集合-连通问题\",\"680\":\"v-dd2a54a2#_6-回溯算法\",\"681\":\"v-dd2a54a2#理论\",\"682\":\"v-dd2a54a2#模板\",\"683\":\"v-dd2a54a2#_77-组合问题\",\"684\":\"v-dd2a54a2#_17-电话号码的字母组合\",\"685\":\"v-dd2a54a2#_46-全排列\",\"686\":\"v-dd2a54a2#_78-子集\",\"687\":\"v-dd2a54a2#_494-目标和\",\"688\":\"v-dd2a54a2#_131-分割回文串\",\"689\":\"v-dd2a54a2#_698-划分相等子集-分割等和子集问题通用解法\",\"690\":\"v-dd2a54a2#_22-括号生成\",\"691\":\"v-dd2a54a2#_7-动态规划\",\"692\":\"v-dd2a54a2#模板-1\",\"693\":\"v-dd2a54a2#剑指-offer-42-连续子数组的最大和\",\"694\":\"v-dd2a54a2#_509-斐波那契数\",\"695\":\"v-dd2a54a2#_62-不同路径\",\"696\":\"v-dd2a54a2#_63-不同路径2\",\"697\":\"v-dd2a54a2#_198-打家劫舍\",\"698\":\"v-dd2a54a2#_213-打家劫舍2\",\"699\":\"v-dd2a54a2#_337-打家劫舍3-数组结构的动态规划\",\"700\":\"v-dd2a54a2#背包问题模板\",\"701\":\"v-dd2a54a2#_416-分割等和子集\",\"702\":\"v-dd2a54a2#_10-正则表达式匹配\",\"703\":\"v-dd2a54a2#_8-dfs深度优先搜索\",\"704\":\"v-dd2a54a2#dfs搜索框架-图论\",\"705\":\"v-dd2a54a2#剑指-offer-12-矩阵中的路径\",\"706\":\"v-dd2a54a2#_200-岛屿数量\",\"707\":\"v-dd2a54a2#_695-岛屿的最大面积\",\"708\":\"v-dd2a54a2#_1254-统计封闭岛屿的数目\",\"709\":\"v-dd2a54a2#_130-被围绕的区域-并查集\",\"710\":\"v-dd2a54a2#_9-bfs广度优先搜索\",\"711\":\"v-dd2a54a2#模板-2\",\"712\":\"v-dd2a54a2#_111-二叉树的最小深度\",\"713\":\"v-dd2a54a2#_752-打开转盘锁\",\"714\":\"v-dd2a54a2#_10-图论算法\",\"715\":\"v-dd2a54a2#_797-所有可能路径\",\"716\":\"v-dd2a54a2#_785-判断二分图-双色问题\",\"717\":\"v-dd2a54a2#_207-课程表\",\"718\":\"v-dd2a54a2#_4-26-华为笔试-批量初始化次数\",\"719\":\"v-dd2a54a2#_11-数据结构设计\",\"720\":\"v-dd2a54a2#_146-lru缓存\",\"721\":\"v-dd2a54a2#_380-o-1-时间插入、删除和获取随机元素\",\"722\":\"v-dd2a54a2#acm输入输出\",\"723\":\"v-dd2a54a2#_1-多行输入\",\"724\":\"v-dd2a54a2#示例\",\"725\":\"v-dd2a54a2#_2-数组输入\",\"726\":\"v-dd2a54a2#示例-1\",\"727\":\"v-dd2a54a2#_2-1-读取一维数组\",\"728\":\"v-dd2a54a2#_2-2-读取二维数组\",\"729\":\"v-dd2a54a2#_3-链表输入\",\"730\":\"v-dd2a54a2#_4-树的输入\",\"731\":\"v-37927d9c\",\"732\":\"v-37927d9c#剑指-offer-13-机器人的运动范围\",\"733\":\"v-37927d9c#思路\",\"734\":\"v-37927d9c#题解\",\"735\":\"v-37927d9c#剑指-offer-14-i-剪绳子\",\"736\":\"v-37927d9c#思路-1\",\"737\":\"v-37927d9c#题解-1\",\"738\":\"v-37927d9c#剑指-offer-14-ii-剪绳子-ii\",\"739\":\"v-37927d9c#思路-2\",\"740\":\"v-37927d9c#题解-2\",\"741\":\"v-37927d9c#剑指-offer-16-数值的整数次方\",\"742\":\"v-37927d9c#思路-3\",\"743\":\"v-8a3e4300\",\"744\":\"v-8a3e4300#第一章-了解web及网络基础\",\"745\":\"v-8a3e4300#_1-2-http的诞生\",\"746\":\"v-8a3e4300#_3项www构建技术\",\"747\":\"v-8a3e4300#_1-3-网络基础-tcp-ip\",\"748\":\"v-8a3e4300#tcp-ip协议族\",\"749\":\"v-8a3e4300#tcp-ip的分层管理\",\"750\":\"v-8a3e4300#tcp-ip通信传输\",\"751\":\"v-8a3e4300#_1-4-与http关系密切的协议\",\"752\":\"v-8a3e4300#负责传输的ip协议\",\"753\":\"v-8a3e4300#确保可靠性的tcp协议\",\"754\":\"v-8a3e4300#_1-5-负责域名解析的dns服务\",\"755\":\"v-8a3e4300#_1-6-http通信的流程\",\"756\":\"v-8a3e4300#_1-7-uri和url\",\"757\":\"v-8a3e4300#统一资源标识符-uri\",\"758\":\"v-8a3e4300#第二章-简单的http协议\",\"759\":\"v-8a3e4300#_2-1-http用于客户端和服务器端之间的通信\",\"760\":\"v-8a3e4300#_2-2-通过请求和响应的交换达成通信\",\"761\":\"v-8a3e4300#_2-3-http不保存之前状态\",\"762\":\"v-8a3e4300#_2-4-uri定位资源\",\"763\":\"v-8a3e4300#_2-5-告知服务器意图的-http方法\",\"764\":\"v-8a3e4300#_2-7-持久连接节省通信量\",\"765\":\"v-8a3e4300#_2-8-使用cookie的状态管理\",\"766\":\"v-8a3e4300#第三章-http报文内的http信息\",\"767\":\"v-8a3e4300#_3-1-http报文\",\"768\":\"v-8a3e4300#_3-3-编码-提升传输速率\",\"769\":\"v-8a3e4300#_3-4-发送多种数据的-多部分对象集合\",\"770\":\"v-8a3e4300#_3-5-获取部分内容的-范围请求\",\"771\":\"v-8a3e4300#_3-6-内容协商-返回最合适的内容\",\"772\":\"v-8a3e4300#第四章-返回结果的http状态码\",\"773\":\"v-8a3e4300#_4-1-状态码-告知从服务器端返回得请求结果\",\"774\":\"v-8a3e4300#_4-2-2xx-成功状态码\",\"775\":\"v-8a3e4300#_4-3-3xx-重定向状态码\",\"776\":\"v-8a3e4300#_4-4-4xx-客户端错误状态码\",\"777\":\"v-8a3e4300#_4-5-5xx-服务器错误状态码\",\"778\":\"v-8a3e4300#第五章-与-http-协作的-web-服务器\",\"779\":\"v-8a3e4300#_5-1-用单台虚拟主机实现多个域名\",\"780\":\"v-8a3e4300#_5-2-通信数据转发程序-代理、网关、隧道\",\"781\":\"v-8a3e4300#_5-3-保存资源的缓存\",\"782\":\"v-8a3e4300#第六章-http-首部\",\"783\":\"v-8a3e4300#_6-1-http-报文首部\",\"784\":\"v-8a3e4300#_6-2-http-首部字段\",\"785\":\"v-8a3e4300#_6-7-为-cookie-服务的首部字段\",\"786\":\"v-8a3e4300#_6-8-其他首部字段\",\"787\":\"v-8a3e4300#第七章-确保-web-安全的-https\",\"788\":\"v-74458165\",\"789\":\"v-2e25198a\",\"790\":\"v-7c80db8b\",\"791\":\"v-14c69af4\",\"792\":\"v-31987621\",\"793\":\"v-24f2d5ba\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,2],\"1\":[1],\"2\":[2,6],\"3\":[2,99],\"4\":[1],\"5\":[2,88],\"6\":[4,31],\"7\":[4,47],\"8\":[1],\"9\":[1,5],\"10\":[1,18],\"11\":[1,7],\"12\":[2,11],\"13\":[2,8],\"14\":[2,13],\"15\":[2,11],\"16\":[2,10],\"17\":[1,10],\"18\":[1,19],\"19\":[1,1],\"20\":[1,3],\"21\":[1,3],\"22\":[1,5],\"23\":[1,3],\"24\":[1,3],\"25\":[1,5],\"26\":[1,2],\"27\":[1,23],\"28\":[1,1],\"29\":[1,1],\"30\":[1,1],\"31\":[1,1],\"32\":[2,10],\"33\":[1,6],\"34\":[1,1],\"35\":[1,5],\"36\":[1,1],\"37\":[2,1],\"38\":[1,3],\"39\":[1,3],\"40\":[1,20],\"41\":[1,17],\"42\":[1,16],\"43\":[1],\"44\":[2,10],\"45\":[2,19],\"46\":[2,12],\"47\":[1],\"48\":[1],\"49\":[6,26],\"50\":[1],\"51\":[3,4],\"52\":[2],\"53\":[4,11],\"54\":[2],\"55\":[2,89],\"56\":[1],\"57\":[1,6],\"58\":[1],\"59\":[3,15],\"60\":[3,9],\"61\":[3,16],\"62\":[3,32],\"63\":[3,76],\"64\":[2,20],\"65\":[5,28],\"66\":[3,21],\"67\":[2,31],\"68\":[2,15],\"69\":[7,37],\"70\":[4,53],\"71\":[4,10],\"72\":[2,49],\"73\":[2,20],\"74\":[1],\"75\":[2,3],\"76\":[2,100],\"77\":[2,6],\"78\":[5,26],\"79\":[1],\"80\":[2,32],\"81\":[2,133],\"82\":[5,46],\"83\":[3,23],\"84\":[3,5],\"85\":[1],\"86\":[4,25],\"87\":[1],\"88\":[3],\"89\":[2,12],\"90\":[2,23],\"91\":[2,87],\"92\":[1],\"93\":[1,41],\"94\":[1],\"95\":[1,37],\"96\":[1,41],\"97\":[1],\"98\":[1,59],\"99\":[1,44],\"100\":[1],\"101\":[1,50],\"102\":[1,72],\"103\":[1],\"104\":[1,60],\"105\":[1,56],\"106\":[1],\"107\":[1,62],\"108\":[1,60],\"109\":[1],\"110\":[1,13],\"111\":[1,140],\"112\":[1],\"113\":[1,59],\"114\":[1,92],\"115\":[1],\"116\":[1,105],\"117\":[1,77],\"118\":[1],\"119\":[1],\"120\":[3,33],\"121\":[2,25],\"122\":[1,16],\"123\":[3,31],\"124\":[7,75],\"125\":[1,20],\"126\":[2,15],\"127\":[1,26],\"128\":[1,28],\"129\":[1,51],\"130\":[6,41],\"131\":[1],\"132\":[1,36],\"133\":[4,30],\"134\":[5,31],\"135\":[4,54],\"136\":[1,8],\"137\":[3],\"138\":[1,20],\"139\":[1,52],\"140\":[7,47],\"141\":[3,80],\"142\":[1,28],\"143\":[1,26],\"144\":[3,55],\"145\":[1],\"146\":[2,59],\"147\":[3,34],\"148\":[1,37],\"149\":[1],\"150\":[3,8],\"151\":[1,9],\"152\":[1,7],\"153\":[1,29],\"154\":[1,20],\"155\":[2,63],\"156\":[2,49],\"157\":[1],\"158\":[3,29],\"159\":[2,26],\"160\":[3,41],\"161\":[1,50],\"162\":[1,28],\"163\":[1,38],\"164\":[1,36],\"165\":[2,35],\"166\":[10,19],\"167\":[2,43],\"168\":[1,45],\"169\":[1],\"170\":[1,32],\"171\":[4,73],\"172\":[3,42],\"173\":[2,21],\"174\":[1,29],\"175\":[2,22],\"176\":[2,24],\"177\":[2,49],\"178\":[3,58],\"179\":[3,20],\"180\":[1,25],\"181\":[1,19],\"182\":[1,8],\"183\":[1,27],\"184\":[1,46],\"185\":[2],\"186\":[4,42],\"187\":[2,44],\"188\":[2,35],\"189\":[2,42],\"190\":[2,16],\"191\":[2,23],\"192\":[2,52],\"193\":[6,17],\"194\":[1,31],\"195\":[1,37],\"196\":[1,20],\"197\":[2,18],\"198\":[2,30],\"199\":[1,23],\"200\":[1,37],\"201\":[2,25],\"202\":[2,44],\"203\":[3,75],\"204\":[1,89],\"205\":[2,45],\"206\":[2],\"207\":[1,26],\"208\":[2,18],\"209\":[2,98],\"210\":[1,31],\"211\":[1,15],\"212\":[3,26],\"213\":[3,51],\"214\":[1,45],\"215\":[1],\"216\":[1,12],\"217\":[1,13],\"218\":[1],\"219\":[2],\"220\":[3,33],\"221\":[3],\"222\":[3,7],\"223\":[3,9],\"224\":[4,11],\"225\":[4,16],\"226\":[4,6],\"227\":[4,13],\"228\":[2],\"229\":[3,6],\"230\":[3],\"231\":[4,2],\"232\":[3,40],\"233\":[3,47],\"234\":[4,4],\"235\":[3,17],\"236\":[3],\"237\":[4,4],\"238\":[3,14],\"239\":[1,17],\"240\":[1,5],\"241\":[1,8],\"242\":[1,11],\"243\":[3,12],\"244\":[3,19],\"245\":[1,12],\"246\":[1,7],\"247\":[1,30],\"248\":[3,91],\"249\":[4,60],\"250\":[3],\"251\":[4,43],\"252\":[3,41],\"253\":[4,29],\"254\":[4],\"255\":[4,4],\"256\":[3,82],\"257\":[2],\"258\":[3,21],\"259\":[3,25],\"260\":[2,28],\"261\":[6,11],\"262\":[3,81],\"263\":[5,38],\"264\":[3,15],\"265\":[2],\"266\":[3],\"267\":[3,17],\"268\":[4,71],\"269\":[2],\"270\":[3,6],\"271\":[3,62],\"272\":[2],\"273\":[3,10],\"274\":[3,37],\"275\":[5],\"276\":[4],\"277\":[4,5],\"278\":[4,9],\"279\":[4,8],\"280\":[4,8],\"281\":[3,1],\"282\":[3,1],\"283\":[3,2],\"284\":[3,3],\"285\":[3,2],\"286\":[2,3],\"287\":[3,3],\"288\":[3,4],\"289\":[2],\"290\":[3,8],\"291\":[3,42],\"292\":[3,29],\"293\":[3,7],\"294\":[2],\"295\":[4,46],\"296\":[3,8],\"297\":[5,52],\"298\":[3,50],\"299\":[3,53],\"300\":[3,37],\"301\":[2],\"302\":[3,6],\"303\":[3,10],\"304\":[3,61],\"305\":[3],\"306\":[4,39],\"307\":[4,47],\"308\":[6,14],\"309\":[3],\"310\":[3,7],\"311\":[3,15],\"312\":[3,141],\"313\":[3,73],\"314\":[3],\"315\":[4],\"316\":[4,1],\"317\":[4,8],\"318\":[5,60],\"319\":[5,11],\"320\":[1],\"321\":[2],\"322\":[2,3],\"323\":[3,11],\"324\":[3,5],\"325\":[2],\"326\":[3,5],\"327\":[2,71],\"328\":[3,11],\"329\":[3,2],\"330\":[3,13],\"331\":[3,9],\"332\":[3,14],\"333\":[3,10],\"334\":[3,48],\"335\":[3,34],\"336\":[3,2],\"337\":[2],\"338\":[3,8],\"339\":[3,70],\"340\":[2,7],\"341\":[3,12],\"342\":[3,9],\"343\":[3,13],\"344\":[1],\"345\":[2],\"346\":[1,18],\"347\":[1],\"348\":[3,9],\"349\":[1,4],\"350\":[1,10],\"351\":[1,18],\"352\":[1,24],\"353\":[1,14],\"354\":[1,31],\"355\":[2],\"356\":[1,20],\"357\":[3,6],\"358\":[1,63],\"359\":[1,66],\"360\":[1,16],\"361\":[2],\"362\":[1,35],\"363\":[1,15],\"364\":[1,21],\"365\":[1,34],\"366\":[1,19],\"367\":[1,26],\"368\":[1,35],\"369\":[3,14],\"370\":[2],\"371\":[2,9],\"372\":[1,29],\"373\":[1,14],\"374\":[1,8],\"375\":[2,12],\"376\":[1,29],\"377\":[2,35],\"378\":[2,7],\"379\":[2,5],\"380\":[3],\"381\":[1,84],\"382\":[1,60],\"383\":[4],\"384\":[1,8],\"385\":[1],\"386\":[2,15],\"387\":[1,9],\"388\":[1,18],\"389\":[1,26],\"390\":[1,30],\"391\":[1,77],\"392\":[1,25],\"393\":[1,14],\"394\":[4],\"395\":[1,31],\"396\":[1,42],\"397\":[1,21],\"398\":[2,20],\"399\":[2,70],\"400\":[1,48],\"401\":[4,29],\"402\":[2,69],\"403\":[3,34],\"404\":[2,70],\"405\":[2,3],\"406\":[1,69],\"407\":[3],\"408\":[1,57],\"409\":[1,17],\"410\":[4],\"411\":[1,54],\"412\":[1,14],\"413\":[1,81],\"414\":[1,55],\"415\":[1,47],\"416\":[1,51],\"417\":[1,97],\"418\":[1,106],\"419\":[3,167],\"420\":[1],\"421\":[1,71],\"422\":[1,33],\"423\":[2],\"424\":[1,86],\"425\":[1,15],\"426\":[2],\"427\":[1,56],\"428\":[1,48],\"429\":[1,108],\"430\":[1,89],\"431\":[1,60],\"432\":[1,9],\"433\":[1,81],\"434\":[1,11],\"435\":[1,10],\"436\":[1,150],\"437\":[2],\"438\":[1,3],\"439\":[1,86],\"440\":[1,96],\"441\":[1,17],\"442\":[1,31],\"443\":[1,83],\"444\":[1,56],\"445\":[2,89],\"446\":[2,6],\"447\":[2,6],\"448\":[1,68],\"449\":[2,5],\"450\":[2,10],\"451\":[2,63],\"452\":[1,28],\"453\":[2],\"454\":[1,57],\"455\":[1,3],\"456\":[1,33],\"457\":[1,49],\"458\":[1,48],\"459\":[1,45],\"460\":[1,28],\"461\":[1,42],\"462\":[1,6],\"463\":[4],\"464\":[1],\"465\":[2],\"466\":[1,113],\"467\":[1,49],\"468\":[1,95],\"469\":[1,63],\"470\":[1,24],\"471\":[1,119],\"472\":[1,22],\"473\":[2],\"474\":[1,1],\"475\":[1,83],\"476\":[1,33],\"477\":[2,171],\"478\":[1,204],\"479\":[4,60],\"480\":[1,84],\"481\":[2],\"482\":[1,49],\"483\":[1,47],\"484\":[2,5],\"485\":[1,84],\"486\":[2,103],\"487\":[2],\"488\":[1,19],\"489\":[1,32],\"490\":[1,22],\"491\":[1,59],\"492\":[2,140],\"493\":[1],\"494\":[3],\"495\":[3,18],\"496\":[3,29],\"497\":[3],\"498\":[5,102],\"499\":[4,73],\"500\":[5,7],\"501\":[5,137],\"502\":[6,42],\"503\":[3],\"504\":[3,51],\"505\":[7],\"506\":[4,64],\"507\":[4,29],\"508\":[4,19],\"509\":[3,25],\"510\":[3,5],\"511\":[3,25],\"512\":[3,58],\"513\":[3],\"514\":[5,12],\"515\":[4,12],\"516\":[3],\"517\":[3,25],\"518\":[3,20],\"519\":[3,21],\"520\":[3,22],\"521\":[4],\"522\":[3,72],\"523\":[3,91],\"524\":[3,107],\"525\":[3,64],\"526\":[3,4],\"527\":[3,62],\"528\":[3,36],\"529\":[3,42],\"530\":[5,63],\"531\":[3,54],\"532\":[3,46],\"533\":[3],\"534\":[3,18],\"535\":[3,39],\"536\":[3,42],\"537\":[4,10],\"538\":[4,1],\"539\":[3],\"540\":[3,229],\"541\":[3,7],\"542\":[2,58],\"543\":[1],\"544\":[3],\"545\":[3,33],\"546\":[4,6],\"547\":[4,7],\"548\":[4,3],\"549\":[4,10],\"550\":[2],\"551\":[4,20],\"552\":[2,72],\"553\":[3],\"554\":[4,6],\"555\":[4,96],\"556\":[3],\"557\":[5,238],\"558\":[6,18],\"559\":[4,68],\"560\":[3,131],\"561\":[6,56],\"562\":[7,80],\"563\":[4,90],\"564\":[3,62],\"565\":[3,37],\"566\":[3],\"567\":[4,10],\"568\":[4,10],\"569\":[4,83],\"570\":[4,16],\"571\":[3,36],\"572\":[5,74],\"573\":[2],\"574\":[4,7],\"575\":[3,66],\"576\":[3,70],\"577\":[4,52],\"578\":[4,9],\"579\":[2],\"580\":[3,18],\"581\":[5,6],\"582\":[3,17],\"583\":[7,194],\"584\":[5,65],\"585\":[3],\"586\":[3,79],\"587\":[3],\"588\":[4,34],\"589\":[1],\"590\":[2],\"591\":[1,6],\"592\":[1,24],\"593\":[2,75],\"594\":[2],\"595\":[2,67],\"596\":[3,21],\"597\":[4,98],\"598\":[4,173],\"599\":[4,104],\"600\":[3,17],\"601\":[2],\"602\":[3,65],\"603\":[2,37],\"604\":[3,16],\"605\":[3,258],\"606\":[3,126],\"607\":[3,234],\"608\":[3],\"609\":[3,22],\"610\":[4,6],\"611\":[3,31],\"612\":[3],\"613\":[4,25],\"614\":[3,56],\"615\":[3,33],\"616\":[4,102],\"617\":[3,61],\"618\":[1,1],\"619\":[2],\"620\":[4,30],\"621\":[2,31],\"622\":[2,57],\"623\":[4,49],\"624\":[5,92],\"625\":[2,69],\"626\":[2,30],\"627\":[4,59],\"628\":[2,121],\"629\":[2,66],\"630\":[4,79],\"631\":[3,101],\"632\":[2,65],\"633\":[2],\"634\":[4,50],\"635\":[2,106],\"636\":[2,51],\"637\":[2,44],\"638\":[2,45],\"639\":[2,78],\"640\":[4,69],\"641\":[2],\"642\":[2,33],\"643\":[2,69],\"644\":[3,31],\"645\":[2,74],\"646\":[3,37],\"647\":[4,51],\"648\":[4,104],\"649\":[2,101],\"650\":[2,83],\"651\":[4,39],\"652\":[2,32],\"653\":[2,90],\"654\":[2],\"655\":[2,57],\"656\":[2,18],\"657\":[2,55],\"658\":[2,51],\"659\":[2,62],\"660\":[2,65],\"661\":[4,79],\"662\":[4,42],\"663\":[2],\"664\":[1,35],\"665\":[3,12],\"666\":[3,64],\"667\":[2,50],\"668\":[2,44],\"669\":[2,78],\"670\":[2],\"671\":[4,34],\"672\":[4,46],\"673\":[2],\"674\":[1,57],\"675\":[2,55],\"676\":[2,23],\"677\":[2,96],\"678\":[2,89],\"679\":[5],\"680\":[2],\"681\":[1,14],\"682\":[1,19],\"683\":[2,53],\"684\":[2,84],\"685\":[2,43],\"686\":[2,62],\"687\":[2,104],\"688\":[2,70],\"689\":[4,91],\"690\":[2,59],\"691\":[2],\"692\":[1,9],\"693\":[4,49],\"694\":[2,46],\"695\":[2,41],\"696\":[2,73],\"697\":[2,57],\"698\":[2,72],\"699\":[4,39],\"700\":[1,44],\"701\":[2,131],\"702\":[2,51],\"703\":[2],\"704\":[3,50],\"705\":[4,64],\"706\":[2,61],\"707\":[2,45],\"708\":[2,76],\"709\":[4,148],\"710\":[2],\"711\":[1,45],\"712\":[2,51],\"713\":[2,85],\"714\":[2],\"715\":[2,64],\"716\":[4,114],\"717\":[2,89],\"718\":[4,138],\"719\":[2],\"720\":[2,101],\"721\":[5,78],\"722\":[1],\"723\":[2],\"724\":[1,51],\"725\":[2],\"726\":[1,9],\"727\":[3,26],\"728\":[2,31],\"729\":[2,91],\"730\":[2,114],\"731\":[1],\"732\":[4],\"733\":[1,3],\"734\":[1,40],\"735\":[5],\"736\":[1,19],\"737\":[1,28],\"738\":[5],\"739\":[1,10],\"740\":[1,20],\"741\":[4],\"742\":[1,28],\"743\":[1],\"744\":[2],\"745\":[3],\"746\":[1,10],\"747\":[5,3],\"748\":[2,2],\"749\":[2,17],\"750\":[2,4],\"751\":[3],\"752\":[1,4],\"753\":[1,7],\"754\":[3,8],\"755\":[3,2],\"756\":[3],\"757\":[3,19],\"758\":[2],\"759\":[3,3],\"760\":[2,50],\"761\":[3,2],\"762\":[3,15],\"763\":[4,28],\"764\":[3,5],\"765\":[3,11],\"766\":[2],\"767\":[3,5],\"768\":[3,36],\"769\":[4,17],\"770\":[4,26],\"771\":[4,22],\"772\":[2],\"773\":[4,7],\"774\":[4,13],\"775\":[4,34],\"776\":[3,18],\"777\":[4,9],\"778\":[6,5],\"779\":[3,18],\"780\":[6,41],\"781\":[3,10],\"782\":[3],\"783\":[4,6],\"784\":[4,16],\"785\":[5,13],\"786\":[3,12],\"787\":[5],\"788\":[1],\"789\":[1],\"790\":[1],\"791\":[1],\"792\":[1],\"793\":[1]},\"averageFieldLength\":[2.3639798488665043,38.30050427570038],\"storedFields\":{\"0\":{\"h\":\"介绍页\",\"t\":[\"此博客用来记录看过的书，做过的项目\"]},\"1\":{\"h\":\"Cpp补完计划\"},\"2\":{\"h\":\"1 智能指针\",\"t\":[\"C++11 提供3种智能指针 unique_ptr, shared_ptr, weak_ptr\"]},\"3\":{\"h\":\"1.1 几个简单例子\",\"t\":[\"#include <memory> #include <iostream> using namespace std; int main() { unique_ ptr<int> up1 (new int (11)) ; //无法复制的unique_ ptr unique_ ptr<int> up2 = up1; //不能通过编译 cout << *up1 << endl; // 11 unique_ ptr<int> up3 = move (up1); //现在p3是数据唯- -的unique_ ptr 智能指针 cout << *up3 << endl ; // 11 cout << *up1 << endl ; //运行时错误 up3.reset(); //显式释放内存 up1.reset(); //不会导致运行时错误 cout << *up3 << endl; //运行时错误 shared_ ptr<int> sp1 (new int(22)); shared_ ptr<int> sp2 = sp1; cout << *sp1 << endl; // 22 cout << *sp2 << endl; // 22 sp1.reset() ; cout << *sp2 << endl;// 22 } \",\"直观地看来，unique_ptr 形如其名地，与所指对象的内存绑定紧密，不能与其他unique_ptr类型的指针对象共享所指对象的内存。而从实现上讲，unique_ptr 则是-一个删除了拷贝构造函数、保留了移动构造函数的指针封装类型。程序员仅可以使用右值对unique_ptr 对象进行构造，而且一旦构造成功，右值对象中的指针即被“窃取”，因此该右值对象即刻失去了对指针的“所有权”。\",\"而shared_ptr 同样形如其名，允许多个该智能指针共享地“拥有”同一堆分配对象的内存。与unique_ptr不同的是，由于在实现上采用了引用计数，所以一旦一个shared_ptr指针放弃了“所有权”(失效),其他的shared_ptr对对象内存的引用并不会受到影响。只有在引用计数归零的时候，share_ptr才会真正释放所占有的堆内存的空间。\",\"#include <memory> #include <iostream> using namespace std; void Check (weak_ ptr<int> & wp){ shared_ ptr<int> sp = wp.1ock() ; //转换为shared_ ptr<int> if (sp != nullptr) cout << \\\"still ”<< *sp << endl ; else cout << \\\"pointer is invalid.\\\" << endl; } int main() { shared_ptr<int> sp1 (new int (22)); shared_ptr<int> sp2 = sp1; weak_ptr<int> wp = sp1; //指向shared_ ptr<int> 所指对象 cout << *sp1 << endl; // 22 cout << *sp2 << endl; // 22 Check(wp); // still 22 spl.reset(); cout << *sp2 << endl; // 22 Check(wp); // still 22 sp2.reset(); Check(wp); // pointer is invalid } \",\"智能指针还包括了weak_ ptr这个类模板。weak_ ptr的使用更为复杂一点，它可以指向shared_ptr指针指向的对象内存，却并不拥有该内存。而使用weak_ptr成员lock，则可返回其指向内存的-一个shared_ptr 对象，且在所指对象内存已经无效时，返回指针空值。这在验证share_ptr智能指针的有效性上会很有作用。\"]},\"4\":{\"h\":\"MySQL补完计划\"},\"5\":{\"h\":\"1 Date数据类型的加减\",\"t\":[\"Create table If Not Exists Activity (player_id int, device_id int, event_date date, games_played int) Truncate table Activity insert into Activity (player_id, device_id, event_date, games_played) values ('1', '2', '2016-03-01', '5') insert into Activity (player_id, device_id, event_date, games_played) values ('1', '2', '2016-03-02', '6') insert into Activity (player_id, device_id, event_date, games_played) values ('2', '3', '2017-06-25', '1') insert into Activity (player_id, device_id, event_date, games_played) values ('3', '1', '2016-03-02', '0') insert into Activity (player_id, device_id, event_date, games_played) values ('3', '4', '2018-07-03', '5') \",\"+--------------+---------+ | Column Name | Type | +--------------+---------+ | player_id | int | | device_id | int | | event_date | date | | games_played | int | +--------------+---------+ （player_id，event_date）是此表的主键。 这张表显示了某些游戏的玩家的活动情况。 每一行是一个玩家的记录，他在某一天使用某个设备注销之前登录并玩了很多游戏（可能是 0）。 编写一个 SQL 查询，报告在首次登录的第二天再次登录的玩家的比率，四舍五入到小数点后两位。换句话说，您需要计算从首次登录日期开始至少连续两天登录的玩家的数量，然后除以玩家总数。 查询结果格式如下所示： Activity table: +-----------+-----------+------------+--------------+ | player_id | device_id | event_date | games_played | +-----------+-----------+------------+--------------+ | 1 | 2 | 2016-03-01 | 5 | | 1 | 2 | 2016-03-02 | 6 | | 2 | 3 | 2017-06-25 | 1 | | 3 | 1 | 2016-03-02 | 0 | | 3 | 4 | 2018-07-03 | 5 | +-----------+-----------+------------+--------------+ Result table: +-----------+ | fraction | +-----------+ | 0.33 | +-----------+ 只有 ID 为 1 的玩家在第一天登录后才重新登录，所以答案是 1/3 = 0.33 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/game-play-analysis-iv \",\"使用select player_id, Date(min(event_date+1)), INTERVAL 1 DAY) from Activity group by player_id来查出第二天登录表时，Date(min(event_date+1))对于月末的日期的加减会有问题，使用函数DATE_ADD(min(event_date)就不会有这种问题\"]},\"6\":{\"h\":\"2 条件判断函数-CASE WHEN用法\",\"t\":[\"1、简单函数\",\"CASE 字段 WHEN 预期值 THEN 结果1 ELSE 结果2 END \",\"2、条件表达式\",\"CASE的简单函数使用简便，但无法应对较为复杂的场景，这就需要用到条件表达式了，其语法结构如下：\",\"CASE WHEN condition THEN result1 ELSE result2 END \",\"解释一下，语句中的condition是条件判断，如果该判断结果为true，那么CASE语句将返回result，否则返回result2，如果没有ELSE，则返回null。CASE与END之间可以有多个WHEN…THEN…ELSE语句。END表示CASE语句结束。\"]},\"7\":{\"h\":\"3 GROUP BY 多字段查询\",\"t\":[\"参考1050. 合作过至少三次的演员和导演\",\"写一条SQL查询语句获取合作过至少三次的演员和导演的 id 对 (actor_id, director_id)\",\"ActorDirector 表： +-------------+-------------+-------------+ | actor_id | director_id | timestamp | +-------------+-------------+-------------+ | 1 | 1 | 0 | | 1 | 1 | 1 | | 1 | 1 | 2 | | 1 | 2 | 3 | | 1 | 2 | 4 | | 2 | 1 | 5 | | 2 | 1 | 6 | +-------------+-------------+-------------+ Result 表： +-------------+-------------+ | actor_id | director_id | +-------------+-------------+ | 1 | 1 | +-------------+-------------+ 唯一的 id 对是 (1, 1)，他们恰好合作了 3 次。 \",\"因为需要根据 actor_id, director_id 来分组，两种处理方法，一个是直接使用group by，另一种是使用CONCAT_WS(spector, str1, str2)，把actor_id, director_id合成一个字段来查询\",\"CONCAT_WS 和普通的CONCAT 函数的区别是，前者可以在拼接的字符间添加连接符，后者不能添加会导致拼接的字符串无法表示唯一的对应关系（比如 1 和11 拼接为111，而111 还可以表示11 1）\"]},\"8\":{\"h\":\"主要功能与配置演示\"},\"9\":{\"h\":\"目录\",\"t\":[\"Markdown 展示\",\"页面展示\",\"禁用展示\",\"加密展示\"]},\"10\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"11\":{\"h\":\"密码加密的文章\",\"t\":[\"实际的文章内容。\",\"段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。\",\"段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。\"]},\"12\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"13\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"14\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"相关信息\",\"Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 Frontmatter 介绍。\"]},\"15\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"16\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"17\":{\"h\":\"主题扩展\",\"t\":[\"通过 vuepress-plugin-md-enhance，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"18\":{\"h\":\"自定义容器\",\"t\":[\"安全的在 Markdown 中使用 {{ variable }}。\",\"自定义标题\",\"信息容器，包含 代码 与 链接。\",\"const a = 1; \",\"自定义标题\",\"提示容器\",\"自定义标题\",\"警告容器\",\"自定义标题\",\"危险容器\",\"自定义标题\",\"详情容器\",\"查看详情\"]},\"19\":{\"h\":\"代码块\",\"t\":[\"查看详情\"]},\"20\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"21\":{\"h\":\"自定义对齐\",\"t\":[\"我是居中的\",\"我在右对齐\",\"查看详情\"]},\"22\":{\"h\":\"Attrs\",\"t\":[\"一个拥有 ID 的 单词。\",\"查看详情\"]},\"23\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注[1].\",\"查看详情\"]},\"24\":{\"h\":\"标记\",\"t\":[\"你可以标记 重要的内容 。\",\"查看详情\"]},\"25\":{\"h\":\"任务列表\",\"t\":[\" 计划 1\",\" 计划 2\",\"查看详情\"]},\"26\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小\",\"查看详情\"]},\"27\":{\"h\":\"卡片\",\"t\":[\"title: Mr.Hope desc: Where there is light, there is hope logo: https://mister-hope.com/logo.svg link: https://mister-hope.com color: rgba(253, 230, 138, 0.15) \",\"查看详情\"]},\"28\":{\"h\":\"图表\",\"t\":[\"查看详情\"]},\"29\":{\"h\":\"Echarts\",\"t\":[\"查看详情\"]},\"30\":{\"h\":\"流程图\",\"t\":[\"查看详情\"]},\"31\":{\"h\":\"Mermaid\",\"t\":[\"查看详情\"]},\"32\":{\"h\":\"Tex 语法\",\"t\":[\"∂ωr∂r​(ωyω​)=(ωyω​){(logy)r+i=1∑r​ωi(−1)ir⋯(r−i+1)(logy)r−i​}\",\"查看详情\"]},\"33\":{\"h\":\"导入文件\",\"t\":[\"Markdown 展示\",\"页面展示\",\"禁用展示\",\"加密展示\",\"查看详情\"]},\"34\":{\"h\":\"代码演示\",\"t\":[\"查看详情\"]},\"35\":{\"h\":\"样式化\",\"t\":[\"向 Mr.Hope 捐赠一杯咖啡。 \",\"查看详情\"]},\"36\":{\"h\":\"交互演示\",\"t\":[\"查看详情\"]},\"37\":{\"h\":\"Vue 交互演示\",\"t\":[\"查看详情\"]},\"38\":{\"h\":\"幻灯片\",\"t\":[\"查看详情\",\"这是脚注内容 ↩︎\"]},\"39\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"40\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"41\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"提示\",\"你可以将图片和 Markdown 文件放置在一起，但是你需要使用相对链接./ 进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\",\"主题包含了一个自定义徽章可以使用:\",\"文字结尾应该有深蓝色的 徽章文字 徽章。 \"]},\"42\":{\"h\":\"页面结构\",\"t\":[\"此页面应当包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"导航栏\",\"侧边栏\",\"页脚\",\"返回顶部按钮\",\"你可以通过主题选项和页面 Frontmatter 自定义它们。\"]},\"43\":{\"h\":\"一些数组操作\"},\"44\":{\"h\":\"1 计算整型数组的总和\",\"t\":[\"int[] arrary = new int[n]; Arrays.stream(array).sum(); \"]},\"45\":{\"h\":\"2 数组排序\",\"t\":[\"int[] arrary = new int[n]; Arrays.sort(array, new Comparator<T>() { @Override public int compare(T t1, T t2) { // 可以设置自己的比较策略 // 排序任意类型 return t1 - t2; } })； \"]},\"46\":{\"h\":\"3 找数组中的最大最小值\",\"t\":[\"Integer[] array = new Integer[n]; (int) Collections.min(Arrays.asList(array)); (int) Collections.max(Arrays.asList(array)); \"]},\"47\":{\"h\":\"朝花夕拾\"},\"48\":{\"h\":\"Linux\"},\"49\":{\"h\":\"1 VMware 安装 CentOS7 并通过 FinalShell连接\",\"t\":[\"首先是版本的选择，我使用的是VMware player 17，安装时一开始选用的是CentOS7 2009的版本，发现安装有问题，换成了2207版后安装成功。\",\"关闭CentOS 防火墙\",\"# 关闭 systemctl stop firewalld # 禁止开机启动防火墙 systemctl disable firewalld \",\"使用ifconfig命令查看主机的ip地址，如果提示没有ifconfig命令的先安装sudo yum install net-tools\",\"在FinalShell 中新建SSH 连接，输入上一步得到的ip地址和虚拟机的用户名和密码即可登录\"]},\"50\":{\"h\":\"JVM\"},\"51\":{\"h\":\"1 Java 内存分区\",\"t\":[\"image-20230724151325568\",\"java内存分区\",\"PC寄存器就是程序计数器\"]},\"52\":{\"h\":\"Java 面向对象\"},\"53\":{\"h\":\"1 父子类的静态初始化代码块、构造代码块、构造方法执行顺序\",\"t\":[\"静态初始化代码块、构造代码块、构造方法 当涉及到继承时，按照如下顺序执行：\",\"执行父类的静态代码块\",\"执行子类的静态代码块\",\"执行父类的构造代码块\",\"执行父类的构造函数\",\"执行子类的构造代码块\",\"执行子类的构造函数\"]},\"54\":{\"h\":\"Java IO\"},\"55\":{\"h\":\"1 Java中BufferedReader与Scanner读入的区别\",\"t\":[\"4.26号华为机考第二题，使用Scanner读入数据一直超时,ORZ\",\"Java中可以使用BufferedReader和Scanner来进行文件或者输入流的读取操作。二者有以下区别：\",\"BufferedReader是基于字符流的，而Scanner即可以基于字符流，也可以基于字节流。\",\"BufferedReader比Scanner更快、更适合读取大量数据。因为它读取字符时直接将字符存入内存缓冲区，再从内存缓冲区中读取数据。Scanner则需要对输入进行解析，并且其还存在一些缓存和正则表达式等开销，可能会降低性能，同时也会增加代码的复杂度。\",\"Scanner可以方便地进行分词等操作，支持各种类型的数据输入，包括int、float、double、boolean、String等。而BufferedReader只能够读取字符串类型的数据，如果需要进行类型转换，需要手动进行。\",\"读取示例\",\"请给出两者读取以下数据的示例 第一行代表 接下来要出现的数据的行数 第二行开始每一行第一个数代表 后面出现数的个数 要求将第二行开始的数据存入数组 3\",\"1 2\",\"1 3\",\"1 1\",\"import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class BufferedReaderExample { public static void main(String[] args) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(reader.readLine()); int[][] nums = new int[n][]; for (int i = 0; i < n; i++) { String[] line = reader.readLine().split(\\\" \\\"); int m = Integer.parseInt(line[0]); nums[i] = new int[m]; for (int j = 0; j < m; j++) { nums[i][j] = Integer.parseInt(line[j + 1]); } } // 输出结果 for (int i = 0; i < n; i++) { for (int j = 0; j < nums[i].length; j++) { System.out.print(nums[i][j] + \\\" \\\"); } System.out.println(); } } } // 使用Scanner读取示例： import java.util.Scanner; public class ScannerExample { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); scanner.nextLine(); // 必须加上，否则下面的读取会有问题 int[][] nums = new int[n][]; for (int i = 0; i < n; i++) { String[] line = scanner.nextLine().split(\\\" \\\"); int m = Integer.parseInt(line[0]); nums[i] = new int[m]; for (int j = 0; j < m; j++) { nums[i][j] = Integer.parseInt(line[j + 1]); } } // 输出结果 for (int i = 0; i < n; i++) { for (int j = 0; j < nums[i].length; j++) { System.out.print(nums[i][j] + \\\" \\\"); } System.out.println(); } } } \"]},\"56\":{\"h\":\"Java多线程\"},\"57\":{\"h\":\"Java中的原子操作\",\"t\":[\"除long和double之外的基本类型的赋值操作\",\"所有引用reference的赋值操作\",\"java.concurrent.Atomic.* 包中所有类的一切操作\"]},\"58\":{\"h\":\"Spring\"},\"59\":{\"h\":\"1 Spring 版本变化\",\"t\":[\"Version\",\"Spring 2.5\",\"2007 第一个支持注解的版本\",\"Spring 3.0\",\"2009 Java5 为JEE6提供支持\",\"Spring 4.0\",\"2013 JAVA8\",\"Spring 5.0\",\"支持响应式编程\"]},\"60\":{\"h\":\"2 Spring 的构成\",\"t\":[\"image-20230413202903759\",\"Spring 核心容器 \",\"Spring Core\",\"Spring Bean\",\"Spring Expression Language\",\"Spring Context\"]},\"61\":{\"h\":\"3 Spring 特色功能\",\"t\":[\"轻量级：代码量轻便\",\"IOC：控制反转\",\"AOP：面向切面编程可以将应用业务逻辑和系统服务分离\",\"容器：Spring负责创建和管理Bean对象的生命周期和配置\",\"MVC：用于配置Web应用，非常方便\",\"事务管理：提供了用于事务管理的通用抽象层\",\"JDBC异常：Spring的JDBC抽象层提供了一个异常层次结构，简化了错误处理策略\"]},\"62\":{\"h\":\"4 使用@Bean注解注入Spring容器和解析xml文件注入有什么区别\",\"t\":[\"使用@Bean注解注入Spring容器和解析XML文件注入的区别如下：\",\"配置方式不同：使用@Bean注解，需要在一个Java配置类中定义Bean；而解析XML文件，则需在Spring XML配置文件中定义Bean。\",\"语法不同：使用@Bean注解时，只需在方法上添加@Bean注解即可，而在XML文件中，则需要使用特定的标签以及属性来定义Bean。\",\"错误检查不同：在使用@Bean注解时，Spring会在应用启动时对Bean进行一些基本的错误检查，例如是否存在循环引用；而在XML文件中定义Bean时，这些错误只能在程序运行时才能被检查出来。\",\"繁琐程度不同：使用@Bean注解时，通常只需要在一个类中添加几个注解即可完成Bean的定义；而在XML文件中定义Bean时，可能需要同时定义多个XML标签，并且需要手动指定Bean之间的关系。\",\"总的来说，使用@Bean注解能够更加方便地定义Bean，并且Spring会在应用启动时自动检查Bean是否正确；而在XML文件中定义Bean虽然更加繁琐，但是也具有灵活性和可读性。实际使用中，可以根据具体情况选择合适的方式来定义Bean。\"]},\"63\":{\"h\":\"5 Spring IOC的原理\",\"t\":[\"XML解析 + 工厂模式 + 反射机制\",\"**使用技术：**XML解析、工厂模式、反射\",\"**工厂模式：**解耦\",\"// UserService.java class UserService { execute() { UserAdd add = UserFactory.getAdd(); } } \",\"// UserAdd.java class UserAdd { add() { // todo } } \",\"// UserFactory.java class UserFactory { public static UserAdd getAdd() { return new UserAdd(); } } \",\"IOC 的过程\",\"配置 XML 文件\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <!--配置 User 对象创建--> <bean id=\\\"user\\\" class=\\\"com.ymk.learnSpring.User\\\"></bean> </beans> \",\"创建工厂类\",\"// UserFactory.java class UserFactory { public static UserAdd getAdd() { String classValue = class属性值; // xml解析得到对象名 Class clazz = Class.forName(classValue); // 通过反射创建对象 return (UserAdd)clazz.newInstance(); } } \"]},\"64\":{\"h\":\"6 Spring的配置方式\",\"t\":[\"基于XML的配置：通过XML文件配置应用程序上下文（Application Context），定义bean之间的关系，指定属性来装配bean之间的依赖关系。\",\"基于注解的配置：使用注解来简化配置，允许通过添加注解来自动装配bean之间的依赖关系。注解配置包括@Service、@Component、@Repository、@Controller等。\",\"基于Java的配置：使用基于Java的编程模式来配置Spring应用程序上下文。通过调用@Configuration类中的@Bean方法声明bean并指定依赖关系。\"]},\"65\":{\"h\":\"7 Spring支持哪几种bean scope（bean的作用域）\",\"t\":[\"\\\"Bean scope\\\"指的是Spring中定义bean的作用域。它定义了bean的生命周期和可见范围，在系统运行时决定Spring容器如何创建和管理bean实例。\",\"Spring中最常用的bean scopes有：\",\"singleton：默认值，表示在整个应用程序上下文中只存在一个共享的bean实例。\",\"prototype：表示每次调用时都会创建一个新的bean实例。\",\"request：表示每个HTTP请求都将创建一个新的bean实例，该bean仅在当前请求的范围内可见。\",\"session：表示每个HTTP会话都将创建一个新的bean实例，该bean仅在当前会话的范围内可见。\",\"global-session：类似于标准的 HTTP Session 作用域，不过它仅仅在基于portlet 的 web 应用中才有意义。\"]},\"66\":{\"h\":\"8 Spring bean的生命周期\",\"t\":[\"通过构造器创建 bean 实例（无参数构造）\",\"为 bean 的属性设置值和对其他 bean 的引用（调用 set 方法）\",\"（可选）bean 前置处理器\",\"调用 bean 的初始化方法（需要自己配置初始化方法）\",\"（可选）bean 后置处理器\",\"bean 可以使用了（对象已经获取到了）\",\"当容器关闭时，调用 bean 销毁的方法（需要自己配置销毁的方法）\"]},\"67\":{\"h\":\"9 什么叫Spring的内部Bean\",\"t\":[\"只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。\",\"<bean id=“StudentBean\\\" class=\\\"com.edureka.Student\\\"> <property name=\\\"person\\\"> <!--This is inner bean --> <bean class=\\\"com.edureka.Person\\\"> <property name=\\\"name\\\" value=\\\"Scott\\\"></property> <property name=\\\"address\\\" value= \\\"Bangalore\\\"></property> </bean> </property> </bean> \"]},\"68\":{\"h\":\"10 Spring有哪些自动装配方式\",\"t\":[\"Spring中实现自动装配的方式有两种：\",\"XML配置文件\",\"注解\",\"其中，XML配置文件的实现方式在XML文件中使用<bean>等标签手动指定依赖关系；而注解的实现方式则是使用各种注解，如@Autowired、@Resource等，在Java类中指定和注入依赖。需要注意的是，使用注解进行自动装配时需要在配置类中使用@ComponentScan或@EnableAutoConfiguration等注解来开启自动扫描和自动装配的功能。\"]},\"69\":{\"h\":\"11 @Component, @Controller, @Repository @Service 有何区别？\",\"t\":[\"用途不同\",\"@Component：通用注解，表示一个受Spring容器管理的组件。\",\"@Controller：主要用于标识Spring MVC中的控制器组件。\",\"@Repository：主要用于标识数据访问组件，例如DAO层。\",\"@Service：主要用于标识服务层组件，即业务逻辑层。\",\"角色不同\",\"@Component和@Service和@Repository注解类似，都是注入bean的注解，而@Controller是用于定义控制器，负责完成接收HTTP请求、调用业务逻辑处理模块、返回HTTP响应等工作。\",\"自动扫描时的不同\",\"Spring在进行组件扫描时，会自动将标注了@Component、@Controller、@Repository和@Service注解的类扫描到Spring容器中，其中@Component是最基础的注解，其他三个注解是@Component的衍生注解。但是在扫描时，Spring会根据注解名称的不同，将它们分配到不同的命名空间中，以便在后续的处理中能够使用更加精确的语义来描述这些组件。\"]},\"70\":{\"h\":\"12 @Component,@Bean有何区别？\",\"t\":[\"作用对象不同：@Component 注解作用于类，而 @Bean 注解作用于方法、\",\"@Component 通常是通过路径扫描来自动侦测以及自动装配到 Spring 容器中(我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中)。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean 告诉了 Spring 这是某个类的实例，当我们需要用它的时候还给我。\",\"@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring 容器时，只能通过 @Bean 来实现。\",\"@Bean 注解使用示例：\",\"@Configuration public class AppConfig { @Bean public TransferService transferService() { return new TransferServiceImpl(); } } \",\"@Component 注解使用示例：\",\"@Component public class ServiceImpl implements AService { .... ) \",\"下面这个例子是通过 @Component 无法实现的：\",\"@Bean public OneService getService(status) { case (status) { when 1: return new serviceImpl1(); when 2: return new serviceImpl2(); when 3: return new serviceImpl3(); } } \"]},\"71\":{\"h\":\"12 @Qualifier 注解有什么用？\",\"t\":[\"当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪 个确切的 bean\"]},\"72\":{\"h\":\"13 AOP底层原理\",\"t\":[\"AOP 底层使用代理\",\"有接口情况，使用 JDK 动态代理 创建一个接口实现类代理对象\",\"JDK 动态代理主要涉及到 java.lang.reflect 包中的两个类：Proxy 和 InvocationHandler。 InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类 的代码，动态将横切逻辑和业务逻辑编制在一起。Proxy 利用 InvocationHandler 动态创建 一个符合某一接口的实例，生成目标类的代理对象\",\"没有接口情况，使用 CGLIB 动态代理 创建当前类子类的代理对象\",\"CGLib 全称为 Code Generation Library，是一个强大的高性能，高质量的代码生成类库， 可以在运行期扩展 Java 类与实现 Java 接口，CGLib 封装了 asm，可以再运行期动态生成新 的 class。和 JDK 动态代理相比较：JDK 创建代理有一个限制，就是只能为接口创建代理实例， 而对于没有通过接口定义业务方法的类，则可以通过 CGLib 创建动态代理\"]},\"73\":{\"h\":\"14 Spring框架用到了哪些设计模式\",\"t\":[\"工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；\",\"单例模式：Bean默认为单例模式。\",\"代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；\",\"模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。\",\"观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如 Spring中listener的实现--ApplicationListener\"]},\"74\":{\"h\":\"SpringMVC\"},\"75\":{\"h\":\"1 SpringMVC是什么\",\"t\":[\"springMVC是一个MVC的开源框架，springMVC=struts2+spring，springMVC就相当于是Struts2加上spring的整合\"]},\"76\":{\"h\":\"2 SpringMVC流程\",\"t\":[\"用户发送请求至前端控制器DispatcherServlet。\",\"DispatcherServlet收到请求调用HandlerMapping处理器映射器。\",\"处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。\",\"DispatcherServlet调用HandlerAdapter处理器适配器。\",\"HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。\",\"Controller执行完成返回ModelAndView。\",\"HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。\",\"DispatcherServlet将ModelAndView传给ViewReslover视图解析器。\",\"ViewReslover解析后返回具体View。\",\"DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。\",\"DispatcherServlet响应用户。\",\"img\",\"组件：\",\"1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供 作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。 用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求， dispatcherServlet的存在降低了组件之间的耦合性。\",\"2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供 作用：根据请求的url查找Handler HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式， 实现接口方式，注解方式等。\",\"3、处理器适配器HandlerAdapter 作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。\",\"4、处理器Handler(需要工程师开发) 注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。\",\"5、视图解析器View resolver(不需要工程师开发),由框架提供 作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。springmvc框架提供了很多的View视图类型，包括：jstlView、 freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求 开发具体的页面。\",\"6、视图View(需要工程师开发jsp...) View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf...）核心架构的具体流程步骤如下： 1、首先用户发送请求——>DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访 问点，进行全局的流程控制\"]},\"77\":{\"h\":\"3 转发和重定向的区别\",\"t\":[\"转发指的是在原始请求的基础上将其转发到其他URL上，接收者看到的还是原始请求的URL。\",\"重定向则是将原始请求的响应被替换为一个新的响应，新的响应里包含了一个指向新URL的Location头字段，浏览器会重新发起一个新的请求去获取这个新URL的资源。\"]},\"78\":{\"h\":\"4 继承 WebMvcConfigurerAdapter 抽象类，常用的重写方法列举几个\",\"t\":[\"/** 解决跨域问题 **/ public void addCorsMappings(CorsRegistry registry) ; /** 添加拦截器 **/ void addInterceptors(InterceptorRegistry registry); /** 这里配置视图解析器 **/ void configureViewResolvers(ViewResolverRegistry registry); /** 配置内容裁决的一些选项 **/ void configureContentNegotiation(ContentNegotiationConfigurer configurer); /** 视图跳转控制器 **/ void addViewControllers(ViewControllerRegistry registry); /** 静态资源处理 **/ void addResourceHandlers(ResourceHandlerRegistry registry); /** 默认静态资源处理器 **/ void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer); \"]},\"79\":{\"h\":\"SpringBoot\"},\"80\":{\"h\":\"1 SpringBoot特点\",\"t\":[\"独立运行\",\"Spring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的 jar包就能独立运行，所有的依赖包都在一个jar包内。\",\"简化配置\",\"spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置。\",\"自动配置 Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他 配置。\",\"无代码生成和XML配置\",\"Spring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的 核心功能之一。\",\"应用监控\",\"Spring Boot提供一系列端点可以监控服务及应用，做健康检测\"]},\"81\":{\"h\":\"2 SpringBoot中的Starters\",\"t\":[\"Starters是什么：\",\"Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成Spring及其他技术，而不需要到处找示例代 码和依赖包。如你想使用Spring JPA访问数据库，只要加入springboot-starter-data-jpa启动器依赖就能使用了。Starters包含了许多项目中 需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。\",\"Starters命名：\",\"Spring Boot官方的启动器都是以spring-boot-starter-命名的，代表了一个特定的应用类型。第三方的 启动器不能以spring-boot开头命名，它们都被Spring Boot官方保留。一般一个第三方的应该这样命 名，像mybatis的mybatis-spring-boot-starter。\",\"以下是Spring Boot中各个启动器的名称和简要功能列表：\",\"启动器\",\"功能描述\",\"spring-boot-starter\",\"默认的Starter，包含自动配置，日志记录和YAML支持等。\",\"spring-boot-starter-actuator\",\"用于监视和管理配置、指标和其他运行时属性的模块。\",\"spring-boot-starter-amqp\",\"使用AMQP（高级消息队列协议）发送和接收消息的支持。\",\"spring-boot-starter-aop\",\"面向切面编程的依赖库，提供了对Spring AOP和AspectJ的集成支持。\",\"spring-boot-starter-artemis\",\"使用Apache Artemis进行消息传递的支持。\",\"spring-boot-starter-batch\",\"Spring Batch批处理框架的支持。\",\"spring-boot-starter-cache\",\"Spring框架缓存抽象层的支持。\",\"spring-boot-starter-data-elasticsearch\",\"使用Elasticsearch搜索引擎进行索引和搜索文档的支持。\",\"spring-boot-starter-data-jdbc\",\"使用JDBC进行数据库访问的支持。\",\"spring-boot-starter-data-jpa\",\"使用Java Persistence API进行数据库访问的支持。\",\"spring-boot-starter-data-ldap\",\"LDAP（轻型目录访问协议）支持。\",\"spring-boot-starter-data-mongodb\",\"MongoDB文档数据库的支持。\",\"spring-boot-starter-data-neo4j\",\"Neo4j图形数据库的支持。\",\"spring-boot-starter-data-redis\",\"Redis键值数据存储的支持。\",\"spring-boot-starter-data-rest\",\"用于快速创建RESTful Web服务的库，基于Spring Data概念。\",\"spring-boot-starter-freemarker\",\"使用FreeMarker模板引擎进行Web视图的支持。\",\"spring-boot-starter-groovy-templates\",\"使用Groovy模板引擎进行Web视图的支持。\",\"spring-boot-starter-hateoas\",\"提供了一些开箱即用的API来实现超媒体驱动的Web服务。\",\"spring-boot-starter-integration\",\"Spring Integration消息和事件驱动的解决方案的支持。\",\"spring-boot-starter-jdbc\",\"使用JDBC进行数据库访问的支持。\",\"spring-boot-starter-jersey\",\"使用JAX-RS和Jersey进行RESTful Web服务的支持。\",\"spring-boot-starter-jooq\",\"JOOQ（Java对象的SQL查询）的支持。\",\"spring-boot-starter-json\",\"Jackson JSON处理器的支持。\",\"spring-boot-starter-jsonp\",\"JSONP的支持。\",\"spring-boot-starter-mail\",\"JavaMail发送电子邮件的支持。\",\"spring-boot-starter-mustache\",\"使用Mustache模板引擎进行Web视图的支持。\",\"spring-boot-starter-oauth2-client\",\"OAuth 2.0客户端的支持。\",\"spring-boot-starter-oauth2-resource-server\",\"OAuth 2.0资源服务器的支持。\",\"spring-boot-starter-quartz\",\"Quartz调度框架的支持。\",\"spring-boot-starter-security\",\"Spring Security的支持，实现Web和方法级别的安全性。\",\"spring-boot-starter-test\",\"用于编写和运行单元测试和集成测试的支持。\",\"spring-boot-starter-thymeleaf\",\"使用Thymeleaf模板引擎进行Web视图的支持。\",\"spring-boot-starter-validation\",\"Bean验证API（JSR 303）的支持。\",\"spring-boot-starter-web\",\"提供了Spring MVC和REST Web服务的支持。\",\"spring-boot-starter-web-services\",\"使用Spring Web服务进行SOAP风格的Web服务的支持。\"]},\"82\":{\"h\":\"3 spring-boot-starter-parent是怎么实现它的功能的\",\"t\":[\"spring-boot-starter-parent是一个特殊的Starter项目，它为我们的应用程序提供默认配置和完整的依赖树，以快速构建Spring Boot项目。它还提供了Maven插件的默认配置，例如maven-failsafe-plugin、maven-jar-plugin、maven-surefire-plugin和maven-war-plugin。该项目提供了一个优秀、稳健的基础，方便我们构建Spring Boot应用程序。\",\"Spring Boot Starter Parent是通过继承pom.xml文件，为Spring Boot应用程序提供默认设置和约定的依赖管理。这些默认设置和约定包括常用的插件及其配置、插件版本、项目结构、构建工具等。当我们使用Spring Boot Starter Parent作为我们Maven项目的父级时，它将自动提供一些默认的依赖关系，这使得编写Spring Boot应用程序变得更加简单快捷。同时，它还提供了Maven插件的默认配置，使得我们无需手动配置大量的插件来构建一个完整的Spring Boot应用程序。此外，Spring Boot Starter Parent还定义了许多属性，可以在我们的pom.xml文件中直接使用，方便我们使用。这些功能可以通过Spring Boot Starter Parent的POM文件中的配置来实现。\"]},\"83\":{\"h\":\"4 SpringBoot集成Mybatis这类的包 是怎么把Mapper接口注入容器的\",\"t\":[\"集成使用Mybatis非常简单\",\"1.pom中添加依赖\",\"2.在mapper接口上添加@Mapper注解\",\"分析(每一个mapper底层其实是mapper工厂)\",\"**@MapperScanner**注解\",\"导入了MapperScannerRegistrar这个类，这个类实现了Spring提供的ImportBeanDefinitionRegistrar接口\",\"在这个类中，重写的registerBeanDefinitions()方法获取了@MapperScanner注解的类，判断不为空后，把MapperScannerConfigurer的类注册进了spring容器中，再通过Mapper扫描配置类把扫描到的Mapper接口注册为MapperFactoryBean，实现了自动化配置。\",\"每次获取mapper时，其实是通过MapperFactoryBean内部的getObject()方法获得mapper实例\"]},\"84\":{\"h\":\"5 @SpringBootApplication 注解中的属性相当于哪几个注解\",\"t\":[\"等价于以默认属性使用 @Configuration，@EnableAutoConfiguration 和 @ComponentScan\"]},\"85\":{\"h\":\"Git\"},\"86\":{\"h\":\"1 git fetch和git pull的区别\",\"t\":[\"git fetch: 相当于是从远程获取最新版本到本地，不会自动merge\",\"git fetch origin master git log -p master..origin/master git merge origin/master 以上命令的含义： 首先从远程的origin的master主分支下载最新的版本到origin/master分支上 然后比较本地的master分支和origin/master分支的差别 最后进行合并 \",\"git pull: 相当于是从远程获取最新版本并merge到本地\",\"git pull origin master 上述命令其实相当于git fetch 和 git merge 在实际使用中，git fetch更安全一些 因为在merge前，我们可以查看更新情况，然后再决定是否合并 \"]},\"87\":{\"h\":\"机考记录\"},\"88\":{\"h\":\"8.30 华为机考\"},\"89\":{\"h\":\"1 计算工作时长\",\"t\":[\"输入 员工当日进出门禁的时间\",\"格式\",\"进门禁次数 n 进门禁的所有时间 出门禁次数 m 出门禁的所有时间 空格分隔 \",\"输出 工作时长\"]},\"90\":{\"h\":\"2 二叉树数组形式的遍历\",\"t\":[\"完全二叉树已知所有路径的和 求出每个节点的值\",\"已知公式：当前节点的值 = 该节点所在路径和中最大值和最小值的平均值 - 所有父节点的值\",\"输入 叶子节点的数目和路径和\",\"格式\",\"数目 n 路径和 1 2 3 ... \",\"输出 该二叉树的数组表示\",\"解法\",\"使用 BFS 遍历二叉树数组，根据公式从上往下计算节点值\"]},\"91\":{\"h\":\"3 内存分配\",\"t\":[\"执行任务，任务占用一定内存，任务之间相互依赖，计算执行所有任务所需要的最小内存\",\"输入\",\"格式\",\"任务个数 n 每个任务需要的内存大小 后面 n 行 n 列表示任务之间的依赖 \",\"输出 系统执行所有任务需要的最小内存\",\"解法\",\"拓扑排序 按照入度从小到大执行任务，相同入度的任务同时执行，求得同时执行需要的最大内存值即为答案\",\"import java.io.*; import java.util.*; import java.text.*; import java.math.*; public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); int n = sc.nextInt(); // 任务个数 int[] mem = new int[n]; // 每个任务内存大小 for (int i = 0; i < n; i++) { mem[i] = sc.nextInt(); } int[][] grid = new int[n][n]; // 任务依赖关系 int[] indegree = new int[n]; // 存储每个节点的入度 for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { grid[i][j] = sc.nextInt(); if (grid[i][j] == 1) indegree[i]++; } } Queue<Integer> q = new LinkedList<>(); // 根据入度遍历 int maxTime = 0; Set<Integer> used = new HashSet<>(); for (int i = 0; i < n; i++) { if (indegree[i] == 0) { q.offer(i); used.add(i); } } while (!q.isEmpty()) { int sz = q.size(); int time = 0; for (int j = 0; j < sz; j++) { int r = q.poll(); time += mem[r]; // 相同入度内存相加 // 相邻节点入度减 1，为 0 的节点入队列 for (int i = 0; i < n; i++) { if (used.contains(i)) continue; if (grid[i][r] == 1) { indegree[i]--; if (indegree[i] == 0) q.offer(i); } } } maxTime = Math.max(maxTime, time); } System.out.println(maxTime); } } \"]},\"92\":{\"h\":\"设计模式\"},\"93\":{\"h\":\"设计模式指北\",\"t\":[\"面向对象当然也有缺点，比如，最常见的，人与人对世界的认识不同，所以每个人设计的对象结构都不尽相同，于是阅读其他人的代码时，效率就会比较低。长时间面向对象编程之后，一些前辈达人总结出来能够更进一步改善代码结构的方式方法，便是设计模式。\",\"理解和学会设计模式，对我们之后开发会有很大的帮助。\",\"实际上，设计模式离我们并不远。设计模式提出于1990年，距今将近30年，早已渗入各种流行软件的设计当中。以我们 Web 前端为例，除了本文将重点讲述的几个设计模式之外，DOM 事件机制就是观察者模式（Observer）的实现，而 JS 也是基于原型链模式（Prototype）打造的。\",\"如果您使用过现代 MVVM 框架，那么你多半也用过其中的状态管理工具，比如 Vuex。它是从中介者模式（Mediator）演化而来的。\",\"综上所述，其实我们日常开发中已经在享受设计模式带来的便利性和高效率了。\"]},\"94\":{\"h\":\"适配器模式\"},\"95\":{\"h\":\"功能介绍\",\"t\":[\"适配器，其实还有一个不那么文邹邹的翻译：转接头。\",\"如果你有过出国旅行的经验，应该知道，很多国家的插座跟我们不一样，比如香港，采用的是英制的插头，也就是图中这一款。如果你带着自己的设备，想在国外插线充电，就必须用转接头。\",\"事实上适配器模式的工作原理也差不多：比如有个类 A 提供若干个接口，跟我们预期的接口不一致，我们希望对这些接口进行修改，那么有两个方案：\",\"修改类 A，对于浏览器来说几乎不可能\",\"创建类 B，提供新的、符合要求的接口，计算后调用 A 的接口\",\"适配器模式就是后者。\",\"适配器可以方便我们和其它系统进行集成，尤其在新老系统交替的时候，可以达到平滑升级的效果。它也方便我们把程序移植到不同平台，在主程序保持稳定的基础上，我们只要调整适配器里的接口转换代码即可，可以大大提升开发效率、节省维护成本。\"]},\"96\":{\"h\":\"Java实现\",\"t\":[\"package com.ymk.jicheng; public class Banner { private String string; public Banner(String string) { this.string = string; } public void showWithParen() { System.out.println(\\\"(\\\" + string + \\\")\\\"); } public void showWithAster() { System.out.println(\\\"*\\\" + string + \\\"*\\\"); } } \",\"package com.ymk.jicheng; public interface Print { public abstract void printWeak(); public abstract void printStrong(); } \",\"package com.ymk.jicheng; public class PrintBanner extends Banner implements Print{ public PrintBanner(String string) { super(string); } @Override public void printWeak() { showWithParen(); } @Override public void printStrong() { showWithAster(); } } \",\"package com.ymk.jicheng; public class Main { public static void main(String[] args) { Print p = new PrintBanner(\\\"Hello\\\"); p.printWeak(); p.printStrong(); } } \",\"通过新的Banner类，和继承Banner并实现print接口的PrintBanner类，我们让Print实现了满足我们要求的方法，使用了面向对象的多态。\"]},\"97\":{\"h\":\"单例模式\"},\"98\":{\"h\":\"功能介绍\",\"t\":[\"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\",\"这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\",\"注意：\",\"1、单例类只能有一个实例。\",\"2、单例类必须自己创建自己的唯一实例。\",\"3、单例类必须给所有其他对象提供这一实例。\",\"**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。\",\"**主要解决：**一个全局使用的类频繁地创建与销毁。\",\"**何时使用：**当您想控制实例数目，节省系统资源的时候。\",\"**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\",\"**关键代码：**构造函数是私有的。\",\"应用实例：\",\"1、一个班级只有一个班主任。\",\"2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。\",\"3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\",\"优点：\",\"1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\",\"2、避免对资源的多重占用（比如写文件操作）。\",\"**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\"]},\"99\":{\"h\":\"Java实现\",\"t\":[\"package com.ymk; public class Singleton { /** * 单实例类 * 成员和构造函数都是私有的 * 提供一个公共方法来获取实例 */ private static Singleton singleton = new Singleton(); private Singleton() { System.out.println(\\\"生成了一个单实例对象\\\"); } public static Singleton getInstance() { return singleton; } } \",\"package com.ymk; import com.ymk.zuoye.Triple; import org.junit.jupiter.api.Test; public class Main { public static void main(String[] args) { Singleton instance1 = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); if (instance1 == instance2) { System.out.println(\\\"instance1 和 instance2 是同一个对象\\\"); } else { System.out.println(\\\"instance1 和 instance2 是不同的对象\\\"); } } } \",\"Singleton类对外提供一个getInstance方法来获取类的实例，实际上获得的都是同一个实例。\"]},\"100\":{\"h\":\"工厂模式\"},\"101\":{\"h\":\"功能介绍\",\"t\":[\"工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\",\"在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\",\"**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\",\"**主要解决：**主要解决接口选择的问题。\",\"**何时使用：**我们明确地计划不同条件下创建不同实例时。\",\"**如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。\",\"**关键代码：**创建过程在其子类执行。\",\"应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。\",\"优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。\",\"**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\"]},\"102\":{\"h\":\"Java实现\",\"t\":[\"package com.ymk.framework; public abstract class Product { public abstract void use(); } \",\"package com.ymk.framework; public abstract class Factory { public final Product create(String owner) { Product p = createProduct(owner); registerProduct(p); return p; } protected abstract Product createProduct(String owner); protected abstract void registerProduct(Product product); } \",\"package com.ymk.idcard; import com.ymk.framework.Product; public class IDCard extends Product { private Integer id; private String owner; IDCard(String owner, Integer id) { this.owner = owner; this.id = id; System.out.println(\\\"制作\\\" + owner + \\\"的 ID 卡，编号为 \\\" + id); } @Override public void use() { System.out.println(\\\"使用\\\" + owner + \\\"的 ID 卡，编号为 \\\" + id); } public Integer getId() { return id; } public String getOwner() { return owner; } } \",\"package com.ymk.idcard; import com.ymk.framework.Factory; import com.ymk.framework.Product; import java.util.HashMap; import java.util.Map; public class IDCardFactory extends Factory { private Map<Integer, String> owners = new HashMap<>(); private static Integer id = 0; @Override protected Product createProduct(String owner) { return new IDCard(owner, id++); } @Override protected void registerProduct(Product product) { owners.put(((IDCard) product).getId(), ((IDCard) product).getOwner()); } public Map<Integer, String> getOwners() { return owners; } } \",\"package com.ymk; import com.ymk.framework.Factory; import com.ymk.framework.Product; import com.ymk.idcard.IDCardFactory; import org.junit.jupiter.api.Test; public class Main { @Test public void testIdCard() { Factory factory = new IDCardFactory(); Product card1 = factory.create(\\\"ymk\\\"); Product card2 = factory.create(\\\"cfh\\\"); Product card3 = factory.create(\\\"tyh\\\"); card1.use(); card2.use(); card3.use(); } } \"]},\"103\":{\"h\":\"模板模式\"},\"104\":{\"h\":\"功能介绍\",\"t\":[\"在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。\",\"**意图：**定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\",\"**主要解决：**一些方法通用，却在每一个子类都重新写了这一方法。\",\"**何时使用：**有一些通用的方法。\",\"**如何解决：**将这些通用算法抽象出来。\",\"**关键代码：**在抽象类实现，其他步骤在子类实现。\",\"应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。\",\"优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\",\"**缺点：**每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\"]},\"105\":{\"h\":\"Java实现\",\"t\":[\"上一节的工厂抽象类实际上用的就是模板模式，定义了对外的create方法，它的子类需要实现其他基础方法。\",\"package com.ymk; public abstract class AbstractDisplay { /** * 下面3个抽象的方法交给子类去实现 */ public abstract void open(); public abstract void print(); public abstract void close(); /** * 实体方法 */ public final void display() { open(); for (int i = 0; i < 5; i++) { print(); } close(); } } \",\"package com.ymk; public class CharDisplay extends AbstractDisplay{ private char ch; public CharDisplay(char ch) { this.ch = ch; } @Override public void open() { System.out.print(\\\"<<\\\"); } @Override public void print() { System.out.print(ch); } @Override public void close() { System.out.println(\\\">>\\\"); } } \",\"package com.ymk; public class StringDisplay extends AbstractDisplay{ private String str; private int width; public StringDisplay(String str) { this.str = str; this.width = str.getBytes().length; } @Override public void open() { printLine(); } @Override public void print() { System.out.println(\\\"|\\\" + str + \\\"|\\\"); } @Override public void close() { printLine(); } private void printLine() { System.out.print(\\\"+\\\"); for (int i = 0; i < width; i++) { System.out.print(\\\"-\\\"); } System.out.println(\\\"+\\\"); } } \",\"package com.ymk; public class Main { public static void main(String[] args) { AbstractDisplay charDis = new CharDisplay('y'); charDis.display(); AbstractDisplay strDis = new StringDisplay(\\\"ymk\\\"); strDis.display(); } } \"]},\"106\":{\"h\":\"建造者模式\"},\"107\":{\"h\":\"功能介绍\",\"t\":[\"建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\",\"一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。\",\"**意图：**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。\",\"**主要解决：**主要解决在软件系统中，有时候面临着\\\"一个复杂对象\\\"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。\",\"**何时使用：**一些基本部件不会变，而其组合经常变化的时候。\",\"**如何解决：**将变与不变分离开。\",\"**关键代码：**建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。\",\"应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的\\\"套餐\\\"。 2、JAVA 中的 StringBuilder。\",\"优点： 1、建造者独立，易扩展。 2、便于控制细节风险。\",\"缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。\",\"使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。\",\"**注意事项：**与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。\"]},\"108\":{\"h\":\"Java实现\",\"t\":[\"package com.ymk.example; public interface Builder { public void makeTitle(String title); public void makeString(String str); public void makeItems(String[] items); public void close(); } \",\"package com.ymk.example; public class HtmlBuilder implements Builder{ @Override public void makeTitle(String title) { } @Override public void makeString(String str) { } @Override public void makeItems(String[] items) { } @Override public void close() { } } \",\"package com.ymk.example; public class TextBuilder implements Builder{ private StringBuffer buffer = new StringBuffer(); // 保存文档内容 @Override public void makeTitle(String title) { buffer.append(\\\"=========================================================\\\\n\\\"); buffer.append(\\\"[\\\" + title + \\\"]\\\\n\\\"); buffer.append(\\\"\\\\n\\\"); } @Override public void makeString(String str) { buffer.append('@' + str + \\\"\\\\n\\\"); buffer.append(\\\"\\\\n\\\"); } @Override public void makeItems(String[] items) { for (String item : items) { buffer.append(\\\" ^\\\" + item + \\\"\\\\n\\\"); } buffer.append(\\\"\\\\n\\\"); } @Override public void close() { buffer.append(\\\"=========================================================\\\\n\\\"); buffer.append(\\\"\\\\n\\\"); } public StringBuffer getBuffer() { return buffer; } } \",\"package com.ymk.example; public class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } public void construct() { builder.makeTitle(\\\"Greetings\\\"); builder.makeString(\\\"从早上至下午\\\"); builder.makeItems(new String[]{\\\"早上好\\\", \\\"下午好\\\", \\\"晚上好\\\"}); builder.close(); } } \",\"package com.ymk.example; public class Main { public static void main(String[] args) { TextBuilder textBuilder = new TextBuilder(); Director director = new Director(textBuilder); director.construct(); System.out.println(textBuilder.getBuffer()); } } \",\"Director类独立于Builder类和它的两个实现，Builder类定义了这一类型的固定方法，它的实现类需要将这些方法实现，所以Builder的两个实现类，TextBuilder和HtmlBuilder都可以被Director类调用。\"]},\"109\":{\"h\":\"抽象工厂模式\"},\"110\":{\"h\":\"功能介绍\",\"t\":[\"抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\",\"在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。\"]},\"111\":{\"h\":\"Java实现\",\"t\":[\"image-20230413093716561\",\"package com.ymk.example.factory; public interface HTMLable { public String makeHTML(); } \",\"package com.ymk.example.factory; public abstract class Item implements HTMLable{ protected String caption; public Item(String caption) { this.caption = caption; } } \",\"package com.ymk.example.factory; public abstract class Link extends Item{ protected String url; public Link(String caption, String url) { super(caption); this.url = url; } } \",\"package com.ymk.example.factory; import java.util.ArrayList; public abstract class Tray extends Item{ protected ArrayList tray = new ArrayList<>(); public Tray(String caption) { super(caption); } public void add(Item item) { tray.add(item); } } \",\"package com.ymk.example.factory; import java.io.FileWriter; import java.io.IOException; import java.util.ArrayList; public abstract class Page implements HTMLable{ protected String title; protected String author; protected ArrayList content = new ArrayList<>(); public Page(String title, String author) { this.title = title; this.author = author; } public void add(Item item) { content.add(item); } public void output() { try { String fileName = title + \\\".html\\\"; FileWriter writer = new FileWriter(fileName); writer.write(this.makeHTML()); writer.close(); System.out.println(fileName + \\\" 编写完成！\\\"); } catch (IOException e) { e.printStackTrace(); } } } \",\"package com.ymk.example.factory; public abstract class Factory { public static Factory getFactory(String className) { Factory factory = null; try { factory = (Factory) Class.forName(className).newInstance(); } catch (ClassNotFoundException e) { System.err.println(\\\"没有找到 \\\" + className + \\\" 类！\\\"); } catch (Exception e) { e.printStackTrace(); } return factory; } public Page createYahooPage() { Link us_yahoo = this.createLink(\\\"Yahoo!\\\", \\\"https://www.yahoo.com/\\\"); Link jp_yahoo = this.createLink(\\\"Yahoo!Japan\\\", \\\"https://www.yahoo.co.jp/\\\"); Tray trayYahoo = this.createTray(\\\"Yahoo\\\"); trayYahoo.add(us_yahoo); trayYahoo.add(jp_yahoo); Page page = this.createPage(\\\"Yahoo\\\", \\\"Yahoo\\\"); page.add(trayYahoo); return page; } public abstract Link createLink(String caption, String url); public abstract Tray createTray(String caption); public abstract Page createPage(String title, String author); } \",\"package com.ymk.example.listfactory; import com.ymk.example.factory.Link; public class ListLink extends Link { public ListLink(String caption, String url) { super(caption, url); } @Override public String makeHTML() { return \\\" <li><a href=\\\\\\\"\\\" + url + \\\"\\\\\\\">\\\" + caption + \\\"</a></li>\\\\n\\\"; } } \",\"package com.ymk.example.listfactory; import com.ymk.example.factory.Item; import com.ymk.example.factory.Tray; import java.util.Iterator; public class ListTray extends Tray { public ListTray(String caption) { super(caption); } @Override public String makeHTML() { StringBuffer buffer = new StringBuffer(); buffer.append(\\\"<li>\\\\n\\\"); buffer.append(caption + \\\"\\\\n\\\"); buffer.append(\\\"<ul>\\\\n\\\"); Iterator it = tray.iterator(); while (it.hasNext()) { Item item = (Item) it.next(); buffer.append(item.makeHTML()); } buffer.append(\\\"</ul>\\\\n\\\"); buffer.append(\\\"</li\\\\n\\\"); return buffer.toString(); } } \",\"package com.ymk.example.listfactory; import com.ymk.example.factory.Item; import com.ymk.example.factory.Page; import java.util.Iterator; public class ListPage extends Page { public ListPage(String title, String author) { super(title, author); } @Override public String makeHTML() { StringBuffer buffer = new StringBuffer(); buffer.append(\\\"<html><head><title>\\\" + title + \\\"</title></head>\\\\n\\\"); buffer.append(\\\"<body>\\\\n\\\"); buffer.append(\\\"<h1>\\\" + title + \\\"</h1>\\\\n\\\"); buffer.append(\\\"<ul>\\\\n\\\"); Iterator it = content.iterator(); while (it.hasNext()) { Item item = (Item) it.next(); buffer.append(item.makeHTML()); } buffer.append(\\\"</ul>\\\\n\\\"); buffer.append(\\\"<hr><address>\\\" + author + \\\"</address>\\\"); buffer.append(\\\"</body></html>\\\\n\\\"); return buffer.toString(); } } \",\"package com.ymk.example.listfactory; import com.ymk.example.factory.Factory; import com.ymk.example.factory.Link; import com.ymk.example.factory.Page; import com.ymk.example.factory.Tray; public class ListFactory { @Override public Link createLink(String caption, String url) { return new ListLink(caption, url); } @Override public Tray createTray(String caption) { return new ListTray(caption); } @Override public Page createPage(String title, String author) { return new ListPage(title, author); } } \",\"package com.ymk.example; import com.ymk.example.factory.Factory; import com.ymk.example.factory.Link; import com.ymk.example.factory.Page; import com.ymk.example.factory.Tray; public class Main { public static void main(String[] args) { Factory factory = Factory.getFactory(\\\"com.ymk.example.listfactory.ListFactory\\\"); // Link people = factory.createLink(\\\"人民日报\\\", \\\"https://www.people.com.cn/\\\"); // Link gmw = factory.createLink(\\\"光明日报\\\", \\\"https://www.gmw.com.cn/\\\"); // Link us_yahoo = factory.createLink(\\\"Yahoo!\\\", \\\"https://www.yahoo.com/\\\"); // Link jp_yahoo = factory.createLink(\\\"Yahoo!Japan\\\", \\\"https://www.yahoo.co.jp/\\\"); // Link excite = factory.createLink(\\\"Excite\\\", \\\"https://www.excite.com/\\\"); // Link google = factory.createLink(\\\"Google\\\", \\\"https://www.google.com/\\\"); // // Tray trayNews = factory.createTray(\\\"日报\\\"); // trayNews.add(people); // trayNews.add(gmw); // // Tray trayYahoo = factory.createTray(\\\"Yahoo\\\"); // trayYahoo.add(us_yahoo); // trayYahoo.add(jp_yahoo); // // Tray traySearch = factory.createTray(\\\"搜索引擎\\\"); // traySearch.add(excite); // traySearch.add(google); // // Page page = factory.createPage(\\\"LinkPage\\\", \\\"ymk\\\"); // page.add(trayNews); // page.add(trayYahoo); // page.add(traySearch); Page page = factory.createYahooPage(); page.output(); } } \"]},\"112\":{\"h\":\"桥接模式\"},\"113\":{\"h\":\"功能介绍\",\"t\":[\"桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。\",\"这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。\",\"我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。\",\"**意图：**将抽象部分与实现部分分离，使它们都可以独立的变化。\",\"**主要解决：**在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。\",\"**何时使用：**实现系统可能有多个角度分类，每一种角度都可能变化。\",\"**如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。\",\"**关键代码：**抽象类依赖实现类。\",\"应用实例： 墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。\",\"优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。\",\"**缺点：**桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。\",\"使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。\",\"**注意事项：**对于两个独立变化的维度，使用桥接模式再适合不过了。\"]},\"114\":{\"h\":\"Java实现\",\"t\":[\"image-20230413095523029\",\"package com.ymk.example; public interface DisplayImpl { public void rawOpen(); public void rawPrint(); public void rawClose(); } \",\"package com.ymk.example; public class StringDisplayImpl implements DisplayImpl{ private String string; private int width; public StringDisplayImpl(String string) { this.string = string; this.width = string.getBytes().length; } @Override public void rawOpen() { printLine(); } @Override public void rawPrint() { System.out.println(\\\"|\\\" + string + \\\"|\\\"); } @Override public void rawClose() { printLine(); } private void printLine() { System.out.print(\\\"+\\\"); for (int i = 0; i < width; i++) { System.out.print(\\\"-\\\"); } System.out.println(\\\"+\\\"); } } \",\"package com.ymk.example; import java.io.*; public class TxtDisplayImpl implements DisplayImpl{ private String pathName; private BufferedReader bufferedReader = null; public TxtDisplayImpl(String pathName) { this.pathName = pathName; } @Override public void rawOpen() { try { this.bufferedReader = new BufferedReader(new FileReader(pathName)); bufferedReader.mark(4096); } catch (IOException e) { e.printStackTrace(); } System.out.println(\\\"打开 TXT 文件\\\"); } @Override public void rawPrint() { String dataLine; try { bufferedReader.reset(); while (((dataLine = bufferedReader.readLine()) != null)) { System.out.println(\\\"> \\\" + dataLine); } } catch (IOException e) { e.printStackTrace(); } } @Override public void rawClose() { if (bufferedReader != null) { try { bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } } System.out.println(\\\"关闭 TXT 文件\\\"); } } \",\"package com.ymk.example; public class Display { private DisplayImpl impl; public Display(DisplayImpl impl) { this.impl = impl; } public void open() { impl.rawOpen(); } public void print() { impl.rawPrint(); } public void close() { impl.rawClose(); } public final void display() { open(); print(); close(); } } \",\"package com.ymk.example; import java.util.Random; public class RandomDisplay extends Display{ public RandomDisplay(DisplayImpl impl) { super(impl); } /** * 随机打印20次以内 */ public void randomDisplay(int times) { Random r = new Random(); int i1 = r.nextInt(times); // 生成[0,10]区间的整数 open(); for (int i = 0; i < i1; i++) { print(); } close(); } } \",\"package com.ymk.example; public class CountDisplay extends Display{ public CountDisplay(DisplayImpl impl) { super(impl); } /** * 多次显示 * @param times */ public void multiDisplay(int times) { open(); for (int i = 0; i < times; i++) { print(); } close(); } } \",\"DisplayImpl的实现类StringDisplayImpl和TxtDisplayImpl是用来显示不同类型，Display的子类CountDisplay和RandomDisplay用来实现不同的显示效果。\"]},\"115\":{\"h\":\"原型模式\"},\"116\":{\"h\":\"功能介绍\",\"t\":[\"原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。\",\"这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。\",\"**意图：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\",\"**主要解决：**在运行期建立和删除原型。\",\"何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。\",\"**如何解决：**利用已有的一个原型对象，快速地生成和原型对象一样的实例。\",\"关键代码： 1、实现克隆操作，在 JAVA 实现 Cloneable 接口，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些\\\"易变类\\\"拥有稳定的接口。\",\"应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。\",\"优点： 1、性能提高。 2、逃避构造函数的约束。\",\"缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。\",\"使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。\",\"**注意事项：**与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。\"]},\"117\":{\"h\":\"Java实现\",\"t\":[\"package com.ymk.example.framework; public abstract class Product implements Cloneable{ public abstract void use(String str); public Product createClone() { Product p = null; try { p = (Product) clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return p; } } \",\"package com.ymk.example.framework; import java.util.HashMap; public class Manager { private HashMap showcase = new HashMap(); public void register(String name, Product proto) { showcase.put(name, proto); } public Product create(String protoName) { Product p = (Product) showcase.get(protoName); return p.createClone(); } } \",\"package com.ymk.example.proto; import com.ymk.example.framework.Product; public class MessageBox extends Product { private char decoChar; public MessageBox(char decoChar) { this.decoChar = decoChar; } @Override public void use(String str) { int length = str.getBytes().length; printDecoChar(length); System.out.println(); System.out.println(decoChar + \\\" \\\" + str + \\\" \\\" + decoChar); printDecoChar(length); System.out.println(); } private void printDecoChar(int length) { for (int i = 0; i < length + 4; i++) { System.out.print(decoChar); } } } \",\"package com.ymk.example.proto; import com.ymk.example.framework.Product; public class UnderlinePen extends Product { @Override public void use(String str) { } } \",\"package com.ymk.example; import com.ymk.example.framework.Manager; import com.ymk.example.framework.Product; import com.ymk.example.proto.MessageBox; import org.junit.jupiter.api.Test; public class MyTest { @Test public void testMsgBox() { MessageBox messageBox1 = new MessageBox('&'); MessageBox messageBox2 = new MessageBox('*'); Manager manager = new Manager(); manager.register(\\\"Information Message\\\", messageBox1); manager.register(\\\"Warning Message\\\", messageBox2); Product clone = manager.create(\\\"Warning Message\\\"); clone.use(\\\"clone\\\"); } } \"]},\"118\":{\"h\":\"面经整理\"},\"119\":{\"h\":\"Java基础\"},\"120\":{\"h\":\"Java中的继承和多态 接口和抽象类的区别 StringBuffer和StringBuilder的区别\",\"t\":[\"继承和多态\",\"继承是子类继承父类的除了静态方法和静态字段的所有方法和字段。 多态分为类的多态和方法的多态。类的多态体现为继承，方法的多态体现为对方法的重载。\",\"接口和抽象类的区别\",\"抽象类中可以有构造函数和非抽象方法，接口不能实例化，且所有方法都是抽象方法，jdk1.8中出现了default修饰的方法。接口中的所有成员变量都是public static final修饰的。 接口是行为的抽象，cloneable之类的，是Like A 的关系； 抽象类是类的抽象，是一种模板设计，是**Is A **的关系\",\"StringBuffer 和StringBuilder的区别\",\"StringBuilder线程不安全，效率比StringBuffer 高； StringBuffer的所有public 方法都是synchronized 修饰的。 底层是默认长度为16的字符数组，每次扩容为数组原长度的2倍+2\"]},\"121\":{\"h\":\"说一下String内部结构，JDK9及之后的有什么变化\",\"t\":[\"在JDK9及之前的版本中，String的内部使用字符数组来存储字符串的字符序列。通过char[]数组，可以按索引访问每个字符。\",\"在JDK9中，引入了一个新的内部数据结构——紧凑字符串（Compact Strings）。对于拉丁字符（Latin-1字符集中的字符，包括大部分常用的英文字符），JDK9及之后的版本使用字节数组（byte[]）来存储。由于拉丁字符在编码时只需要占用一个字节，相比于使用字符数组存储，这样可以节省一半的空间。而对于非拉丁字符，仍然使用字符数组来存储。\",\"紧凑字符串的引入主要是为了减少String对象的内存占用，尤其是在处理大量拉丁字符的场景下可以显著降低内存消耗。\"]},\"122\":{\"h\":\"ArrayList和LinkedList区别\",\"t\":[\"内部实现：ArrayList是基于数组实现的动态数组，而LinkedList是基于双向链表实现的。\",\"插入和删除操作：对于ArrayList，插入和删除元素可能需要进行数组的扩容或移动操作，因为数组的长度是固定的。而LinkedList在插入和删除元素时，只需调整节点的指针，不需要像ArrayList那样进行大量的数据移动。\",\"随机访问效率：ArrayList可以通过索引直接访问元素，因为底层数组的连续存储特性。而LinkedList需要遍历链表才能找到指定位置的元素，所以随机访问效率比ArrayList低。\"]},\"123\":{\"h\":\"什么是泛型 泛型的作用 泛型的使用方式有哪几种\",\"t\":[\"什么是泛型\",\"参数化类型，把类型参数化\",\"泛型的作用\",\"代码重用：在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型。实现模板的效果\",\"类型安全：通过指定泛型类型参数，编译器可以在编译时检查代码的类型安全性，避免在运行时出现类型转换错误。\",\"减少类型转换：泛型可以避免繁琐的类型转换操作，提高代码的可读性和维护性。\",\"泛型的使用方式\",\"泛型类：带有泛型类型属性的类 List<T>； 泛型接口：带有泛型类型参数的接口 Comparable<T>； 泛型方法：带有泛型类型参数的方法 public <T> void printArray(T[] array)\"]},\"124\":{\"h\":\"HashMap的遍历方式有哪几种 ?HashMap与HashTable的区别? HashMap底层?(为什么是8和64没答出来 为什么选择红黑树这种数据结构 介绍一下红黑树)\",\"t\":[\"HashMap的遍历方式有哪几种 4种\",\"使用 keySet() 方法遍历键（key）\",\"使用 values() 方法遍历值（value）\",\"使用 entrySet() 方法遍历键值对（entry）\",\"使用迭代器（Iterator）遍历键值对\",\"HashMap与HashTable的区别\",\"HashTable线程安全\",\"HashMap允许键和值为null\",\"HashMap实现了Map接口，HashTable是Dictionary的子类\",\"HashMap可以指定初始容量和负载因子。当 HashMap 的元素数量超过负载因子与当前容量的乘积时，HashMap 会自动进行扩容。HashTable 在构造时只能指定初始容量，默认的负载因子是 0.75。扩容时，HashTable 的大小必须为素数，并且会创建一个新的数组来重新分配元素。\",\"HashMap底层原理\",\"数组 + 链表（红黑树） = 散列表\",\"存储结构：在将键值对存储到哈希表中时，需要经过哈希函数的计算来确定元素在数组中的位置。哈希函数将键对象映射为数组索引，使得元素能够均匀地分布在不同的桶中。（对于相同的键对象，哈希函数应该返回相同的哈希码）\",\"当多个键对象映射到同一个桶时（数组的同一个位置），HashMap 使用链表或红黑树来解决键冲突问题。当链表中的元素较少时，使用链表存储键值对；当链表中的元素较多时（默认阈值为 8），将链表转换为红黑树，以提高查找效率。\",\"HashMap为什么在链表长度大于8，且数组长度大于64时将链表转换为红黑树\",\"这是因为当链表长度过长时，使用链表进行查找的性能可能变得很差。链表的查找时间复杂度是O(n)，转化为红黑树后，查找的效率会比链表高，但是转化红黑树这个过程是耗时的，而且在扩容时还要对红黑树重新的左旋右旋保持平衡，相对耗时。所以需要到一定阈值时再转换。\",\"链表长度在大于8以后再出现hash碰撞的可能性几乎为0\",\"数组长度至少应为4 * TREEIFY_THRESHOLD\",\"当链表长度为8和数组长度为64再转换时，此时的hash碰撞概率已经很小接近0\"]},\"125\":{\"h\":\"ConcurrentHashMap如何保证线程安全\",\"t\":[\"分段锁机制：ConcurrentHashMap将整个哈希表分割成多个独立的段（Segment），每个段内部维护一个类似于HashMap的数据结构。不同的线程可以同时访问不同的段，从而减小了并发操作的粒度，并发度更高。\",\"无阻塞操作：ConcurrentHashMap在进行插入、删除和更新等操作时，采用了无阻塞算法（CAS、volatile等），而不是传统的加锁机制。这样可以避免了线程之间的阻塞和等待，提高了并发性能。\",\"可见性保证：ConcurrentHashMap使用volatile变量来保证多个线程之间的可见性，确保读取到最新的数据。\"]},\"126\":{\"h\":\"error和exception的区别 怎么处理exception\",\"t\":[\"error和exception的区别\",\"Error 是指程序无法处理的错误，虚拟机错误、栈溢出（SOF）、内存溢出（OOM）\",\"Exception 是指程序本身可以处理的异常（可以自己Throw）\",\"怎么处理exception\",\"exception分为编译时异常和运行时异常，前者由编译器发现。后者可以通过throw和catch来自定义处理\"]},\"127\":{\"h\":\"final关键字有什么作用\",\"t\":[\"修饰变量：当final关键字修饰一个变量时，该变量就成为一个常量，其值不能再被修改。一旦被初始化赋值后，就无法再改变。这样可以确保常量的值在使用过程中不会被意外修改，提高代码的可读性和安全性。\",\"修饰方法：当final关键字修饰一个方法时，该方法就不能被子类重写或覆盖。这样可以防止子类修改父类的行为，保护方法的稳定性和一致性。\",\"修饰类：当final关键字修饰一个类时，该类就不能被继承，即不能有子类。这样可以直接阻止其他类对该类的继承，保护类的完整性和安全性。\",\"修饰参数：当final关键字修饰方法的参数时，表示参数是只读的，即在方法内部不能对参数进行赋值操作。这样可以避免在方法内部意外修改参数的值，增强方法的可靠性和可理解性。\"]},\"128\":{\"h\":\"volatile关键字有什么作用\",\"t\":[\"可见性：volatile关键字保证了多线程环境下的可见性。当一个变量被声明为volatile时，在一个线程修改了该变量的值后，其他线程能够立即看到最新的值，而不会使用缓存中的旧值。\",\"禁止指令重排序：volatile关键字可以防止指令重排序优化。在单线程环境中，编译器和处理器可能会对指令进行重排序，以提高执行效率。但在多线程环境中，指令重排序可能导致线程间操作顺序的错乱。通过使用volatile关键字，可以禁止编译器和处理器对被修饰变量相关指令的重排序，从而确保线程间操作的正确顺序。\",\"不能保证原子性：volatile关键字不能保证操作的原子性。例如，对一个volatile变量进行自增操作，虽然保证了可见性，但是多个线程同时进行自增操作仍然会产生竞态条件。要保证原子性，需要使用synchronized关键字或java.util.concurrent.atomic包中的原子操作类。\"]},\"129\":{\"h\":\"Lambda表达式\",\"t\":[\"是对匿名函数的简写形式\",\"他的写法是使用一个->符号，左边写的是形参列表，右边就是对抽象方法的处理\",\"无返回值有形参的抽象方法\",\"可以省略方法名，IDEA会帮你自动检测方法名；\",\"可以省略方法中的形参类型；\",\"如果对抽象方法的实现逻辑只有一行，可以省略方法体的大括号，当然如果不止一行，就不能省略了；\",\"有返回值的抽象方法\",\"有返回值的方法，如果要去掉大括号，还需要去掉return关键字\",\"有一个形参的抽象方法\",\"形参列表中只有一个参数，可以去掉形参的括号\",\"Lambda表达式也可以作为参数传递\",\"Lambda表达式不是万能的，他需要函数式接口的支持\",\"函数式接口的定义是: 只包含一个抽象方法的接口，称为函数式接口\",\"4大函数式接口 \",\"Consumer<T>：该函数式接口接受一个输入参数，并对其进行操作，但没有返回结果。常用的方法是 accept(T t)，用于对给定的参数执行某些操作\",\"Supplier<T>：该函数式接口不接受任何输入参数，但返回一个结果。常用的方法是 get()，用于获取结果。\",\"Function<T, R>：该函数式接口接受一个输入参数，并将其转换为另一种类型的结果。常用的方法是 apply(T t)，用于对给定的参数进行处理并返回结果。\",\"Predicate<T>：该函数式接口接受一个输入参数，并返回一个布尔值结果。常用的方法是 test(T t)，用于对给定的参数进行条件判断。\"]},\"130\":{\"h\":\"通过静态工厂 Integer.valueOf(int) 来创建 Integer 对象有什么好处\",\"t\":[\"如果我们通过静态工厂 Integer.valueOf(int) 来创建 Integer 对象，首先会判断创建的对象值是否在 IntegerCache 中有缓存，有的话直接取缓存中的值，否则通过标准对象创建语法 new Interger(int) 创建并返回。\",\"所以默认情况下，如果使用 Integer.valueOf(int) 创建的 Integer 对象值在 -128 ～ 127 之间，那么无论创建多少次，创建的每一个对象使用== 关系操作符得到的结果都是true，否则都是false。\",\"注：如果修改过java.lang.Integer.IntegerCache.high属性值，那么结果就另当别论了。\",\"静态工厂 Integer.valueOf(int) 的设计正是对享元模式的应用\",\"Integer.valueOf(int) 通过享元模式缓存频繁请求的值来显着提高空间和时间性能，效率远远高于通过 new Integer() 创建对象的方式。所以 Java 9 中直接弃用了new Integer()\"]},\"131\":{\"h\":\"Java多线程\"},\"132\":{\"h\":\"Java中实现多线程\",\"t\":[\"继承Thread类，重写run方法\",\"实现Runnable接口，把任务加入Thread类，启动（线程任务与线程控制分离）\",\"使用 Callable 和 Future：Callable 是一个带有泛型的接口，可以返回一个结果，并且可以通过 Future 对象来获取返回值。可以通过创建实现 Callable 接口的类，并实现其中的 call() 方法来定义线程的执行逻辑。然后使用 ExecutorService 提交 Callable 任务，并通过 Future 对象获取任务的返回结果。\",\"使用线程池：使用 Java 提供的线程池框架可以方便地管理和复用线程资源。通过创建 ExecutorService 对象，并调用其 execute() 方法或 submit() 方法来提交任务，线程池会自动分配可用的线程来执行任务\"]},\"133\":{\"h\":\"Runnable、Callable 区别，如何接收这两个线程异常\",\"t\":[\"Runnable、Callable的区别 \",\"返回值：Runnable接口没有返回值，而Callable接口可以返回一个结果。\",\"异常处理：Runnable接口的run()方法不能抛出受检异常，只能在方法内部进行异常处理；而Callable接口的call()方法可以抛出受检异常，并且可以将异常抛给调用者处理。\",\"使用方式：Runnable接口通常用于创建可执行的线程任务，通过实现run()方法来定义线程执行的代码；而Callable接口则通常与ExecutorService（线程池）一起使用，通过返回Future对象来获取异步计算的结果。\",\"如何处理Runnable任务的异常 \",\"Runnable使用try-catch来捕获异常并处理\",\"通过Thread类的setUncaughtExceptionHandler()方法设置一个全局的未捕获异常处理器，来处理在Runnable中抛出的异常。\",\"如果使用ExecutorService来执行Runnable任务，可以通过Future对象的get()方法来获取任务执行过程中的异常信息。\"]},\"134\":{\"h\":\"如何创建一个线程池,拒绝策略有什么,怎么设置线程池的大小(动态修改)\",\"t\":[\"如何创建一个线程池\",\"可以使用 JUC的Executors 类来创建线程池，并使用 Executor 类设置线程池的属性。\",\"线程池拒绝策略\",\"拒绝策略是在线程池无法接受新任务时采取的一种策略\",\"ThreadPoolExecutor.AbortPolicy（默认）：直接抛出 RejectedExecutionException 异常，拒绝新任务的提交。\",\"ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。即将任务返回给调用者进行处理。\",\"ThreadPoolExecutor.DiscardPolicy：静默地丢弃无法处理的任务，不给予任何提示。\",\"ThreadPoolExecutor.DiscardOldestPolicy：丢弃最早提交的任务，然后尝试再次提交新任务。\",\"怎么动态修改线程池的大小\",\"可以使用 ThreadPoolExecutor 的 setCorePoolSize() 和 setMaximumPoolSize() 方法来动态修改线程池的大小\"]},\"135\":{\"h\":\"线程池7个参数？提交任务流程？为什么不先创建临时线程而是先放进阻塞队列？\",\"t\":[\"线程池的7个参数\",\"corePoolSize（核心线程数）：线程池中始终保持活动状态的线程数，即使这些线程是空闲的。\",\"maximumPoolSize（最大线程数）：线程池中允许存在的最大线程数。\",\"keepAliveTime（线程空闲时间）：当线程池中的线程数量大于corePoolSize时，空闲线程在被回收之前等待新任务的最长时间。超过该时间，空闲线程会被销毁。\",\"unit（时间单位）：keepAliveTime的时间单位，例如：TimeUnit.SECONDS。\",\"workQueue（阻塞队列）：用于存放等待执行的任务的阻塞队列。线程池中的线程都从该队列中获取任务进行处理。\",\"threadFactory（线程工厂）：用于创建新线程的工厂。\",\"handler（拒绝策略）：当线程池和阻塞队列都已满，无法继续接受新任务时，该策略定义了如何处理这些被拒绝的任务。\",\"提交流程\",\"当调用线程池的execute或submit方法提交一个任务时，线程池会首先判断是否已经达到了corePoolSize限制，如果没有，则创建一个新线程来处理该任务。\",\"如果当前线程池中的线程数量已经达到了corePoolSize限制，任务会被添加到阻塞队列中。\",\"如果阻塞队列已满，但是还没有超过maximumPoolSize限制，线程池会创建一个新的临时线程来处理该任务。\",\"如果线程池中的线程数已经达到了maximumPoolSize限制，且阻塞队列已满，这时会根据指定的拒绝策略来处理无法接受的任务，比如抛出异常、丢弃任务等。\",\"上面的提交流程中为什么不先创建临时线程而是先放进阻塞队列\",\"通过将任务放入阻塞队列，可以实现流量控制，当任务数量暂时过多时，可以通过阻塞队列的容量限制来控制任务的接受速率，避免线程过度增长。\"]},\"136\":{\"h\":\"核心线程能否被回收\",\"t\":[\"当使用了allowCoreThreadTimeOut(true)并且同时满足以下条件时，核心线程可能会被回收：\",\"当前线程池中的线程数大于核心线程数。\",\"核心线程在一段时间内都处于空闲状态，没有新的任务到来。\"]},\"137\":{\"h\":\"线程池配置无界队列了之后，拒绝策略怎么搞，什么时候用到无界对列\"},\"138\":{\"h\":\"volatile和sychronized的区别\",\"t\":[\"语义上的差异： \",\"volatile关键字用于修饰变量，表示该变量在多线程环境下可能被其他线程修改，因此每次使用该变量时都要直接从主内存中获取最新的值。并且，对带有volatile关键字修饰的变量的写操作会立即刷新到主内存中，保证可见性。\",\"synchronized关键字用于修饰方法或代码块，表示对其修饰的部分进行加锁，保证在同一时刻只有一个线程可以执行该方法或代码块，其他线程需要等待锁释放。\",\"内存语义： \",\"volatile关键字提供了禁止指令重排序和保证可见性的功能，保证对其修饰的变量的修改对其他线程是可见的。但volatile不能保证原子性，不适用于复合操作。\",\"synchronized关键字在加锁和释放锁过程中会自动进行线程间的内存同步，保证了原子性、可见性和有序性。\"]},\"139\":{\"h\":\"synchronized锁升级过程和实现原理\",\"t\":[\"synchronized实现原理\",\"当线程尝试进入synchronized块时，首先会尝试获取对象的Monitor锁。如果Monitor锁未被占用，则当前线程获取到锁并执行临界区代码。如果Monitor锁已被别的线程持有，则当前线程会被阻塞，直到锁被释放。当线程退出synchronized块时，会释放Monitor锁。\",\"synchronized锁升级过程\",\"偏向锁（Biased Locking）：初始状态下，对象的Mark Word字段为无锁状态。当一个线程访问同步块时，会检查对象的Mark Word是否为无锁状态，如果是，则使用CAS操作将Mark Word设置为指向当前线程的线程ID，并标记为偏向锁。之后该线程直接进入临界区执行，不需要进行同步操作。这样可以提高单线程访问临界区的性能。\",\"轻量级锁（Lightweight Locking）：当第二个线程尝试获取偏向锁失败时，会升级为轻量级锁。轻量级锁使用CAS操作将对象头部的Mark Word替换为指向锁记录的指针，将锁记录中持有锁的线程ID设置为当前线程ID。此时，线程通过CAS操作来竞争锁。如果竞争成功，该线程进入临界区执行。如果竞争失败，表示存在竞争，锁会膨胀为重量级锁。\",\"重量级锁（Heavyweight Locking）：当竞争轻量级锁的线程过多或自旋次数达到一定阈值时，轻量级锁升级为重量级锁。重量级锁会将线程置于阻塞状态，使用操作系统提供的互斥量（Mutex）来实现同步。此时，进入临界区的线程需要在释放锁之前进行阻塞和唤醒操作，效率较低。\"]},\"140\":{\"h\":\"讲讲jmm内存模型，volatile作用，实现原理，为什么 volatile 能防止指令重排，为什么有可见性问题\",\"t\":[\"JMM内存模型\",\"JMM（Java内存模型）是Java程序中定义了线程之间共享变量的可见性、有序性和原子性的规范。\",\"JMM通过以下机制来实现上述目标：\",\"原子性：JMM保证对基本数据类型（除了long和double）的读写操作具有原子性。对于volatile修饰的变量，JMM保证了对它的读写具有原子性。\",\"可见性：JMM通过在线程之间进行内存屏障（Memory Barrier）来实现可见性。读操作和写操作都有相应的内存屏障，用于刷新变量的值到主内存或者从主内存中读取最新值。\",\"有序性：JMM通过内存屏障来禁止指令重排序，保证程序按照代码顺序执行。\",\"volatile作用，实现原理\",\"volatile关键字在Java中用于确保共享变量的可见性和禁止指令重排。\",\"可见性：volatile关键字保证了一个线程对volatile变量的写操作对其他线程可见。当一个线程修改了volatile变量的值时，这个值将会立即被写入主内存，并且其他线程在读取该变量时会从主内存中获取最新值而不是工作内存中的副本。\",\"禁止指令重排：当一个写操作对一个volatile变量进行写操作时，JVM会发出一条Lock前缀的指令，将该写操作变为原子操作，并且在写操作后增加一条Store屏障（Memory Barrier），这个屏障会强制刷新处理器缓存，使其他线程在读取该变量时能够获取最新值。\",\"多线程操作的可见性问题\",\"可见性问题是因为多线程的操作都是在各自的工作内存中进行的，线程之间无法直接访问对方的工作内存。当一个线程修改了共享变量的值时，其他线程可能无法立即看到这个修改，而是继续访问自己工作内存中的变量副本。这是因为处理器会对内存进行缓存，为了提高效率，处理器可能将共享变量的值缓存在寄存器或者缓存中，并不及时更新到主内存中。\"]},\"141\":{\"h\":\"ReentrantLock 实现原理，AQS实现原理\",\"t\":[\"ReentrantLock实现原理\",\"基本结构：ReentrantLock内部使用了一个非公平的AQS（AbstractQueuedSynchronizer）来实现锁的功能。AQS是一个用于构建锁和同步器的框架，通过队列和等待/唤醒机制来管理线程的竞争和等待。\",\"状态维护：ReentrantLock内部通过一个int类型的state来维护当前锁的状态。state的高16位表示持有锁的线程数，低16位表示当前等待获取锁的线程数。\",\"获取锁：当一个线程尝试获取锁时，会先调用ReentrantLock的lock()方法。在lock()方法内部，会先尝试用CAS操作将state的高16位增加1。如果成功，表示当前线程获取到锁，可以直接进入临界区执行。如果失败，表示有其他线程持有锁，那么当前线程会进入同步队列中等待。\",\"释放锁：当一个线程释放锁时，会调用ReentrantLock的unlock()方法。在unlock()方法内部，会先尝试用CAS操作将state的高16位减1。如果减少后的值为0，表示当前线程已经完全释放了锁。如果减少后的值大于0，表示当前线程还持有锁，可以继续执行临界区代码。在完全释放锁后，会通过唤醒操作将同步队列中的等待线程唤醒，并允许它们去竞争获取锁。\",\"可重入性：ReentrantLock支持可重入锁，也就是同一个线程可以多次获取同一个锁。在同一个线程再次调用lock()方法时，会增加state的高16位，并记录当前线程已经获取锁的次数。在释放锁时，会减少state的高16位，直到最后一次释放锁为止。\",\"AQS实现原理\",\"AQS是依赖内部的同步队列实现，也就是FIFO双向队列，如果当前线程竞争锁失败，那么AQS会把当前线程以及等待状态封装成一个Node节点加入到同步队列中（addWaiter()方法），同时阻塞该线程，当同步状态释放时，会把首节点唤醒，使其再次尝试获取同步状态。\",\"AQS使用一个volatile修饰的int类型变量state来表示当前的同步状态。state的具体含义可以由使用者自行定义和扩展。例如，对于独占锁来说，state=0表示锁未被占用，state=1表示锁已被占用；对于共享锁来说，state表示锁的可用数量等。\",\"当一个线程尝试获取锁时，会调用AQS的acquire()方法。在acquire()方法内部，会先根据具体的实现逻辑判断当前线程是否能够直接获取锁。如果可以直接获取锁，则直接返回；否则，当前线程会被封装成一个Node节点加入到同步队列中，并进入自旋状态，不断尝试获取锁。\",\"当一个线程释放锁时，会调用AQS的release()方法。在release()方法内部，会根据具体的实现逻辑将state的值进行修改，并尝试唤醒同步队列中的等待线程。\"]},\"142\":{\"h\":\"sychronized和ReentrantLock区别\",\"t\":[\"锁的获取方式：synchronized是隐式锁，即通过关键字直接修饰方法或代码块，当线程进入被synchronized修饰的代码块时，会自动获取锁。而ReentrantLock是显式锁，需要手动调用lock()方法获取锁，并且在使用完毕后需要调用unlock()方法释放锁。\",\"锁的灵活性：ReentrantLock提供了更多的高级特性，例如可指定公平性（fairness）和超时（timeout），可以更加灵活地控制锁的行为。ReentrantLock提供了更细粒度的控制。而synchronized则相对简单，不提供这些特性。\",\"性能：在低竞争的情况下，synchronized的性能通常比ReentrantLock好，因为synchronized是JVM层面的内置特性。但在高竞争环境下，ReentrantLock可能更优，因为它提供了更细粒度的控制和高级特性。\"]},\"143\":{\"h\":\"AQS队列为空时线程加入队列发生什么\",\"t\":[\"创建节点：线程会被封装成一个Node节点，并设置相应的线程状态和等待状态。\",\"CAS操作：线程会使用CAS（Compare and Swap）操作，尝试将该节点加入到AQS的同步队列的尾部。这是一个原子操作，它保证了多个线程同时尝试加入队列时的竞争关系。\",\"加入队列：如果CAS操作成功，即线程成功将节点加入到同步队列的尾部，那么线程将进入自旋或被阻塞，等待获取锁。\",\"自旋或阻塞：线程会在自旋或阻塞状态下等待，直到它被唤醒并有机会重新尝试获取锁。自旋是指线程不断地在一个循环内尝试获取锁，而不进行线程的阻塞和切换。如果自旋不成功或超过一定次数，线程可能会被阻塞，即进入到操作系统的等待队列中等待唤醒。\"]},\"144\":{\"h\":\"CountDownLatch Semaphore 使用和实现原理\",\"t\":[\"CountDownLatch（倒计时门闩） CountDownLatch是一种计数器，它允许一个或多个线程等待其他线程完成操作后再执行。主要包含两个方法：countDown()和await()\",\"countDown()：每次调用减少计数器的值。当计数器为0时，所有在await()方法上等待的线程会被唤醒继续执行。\",\"await()：调用该方法的线程会阻塞，直到计数器为0，才会继续执行。\",\"使用场景：CountDownLatch通常用于等待一组线程完成某项任务。\",\"实现原理：CountDownLatch使用了AQS（AbstractQueuedSynchronizer）来进行线程的控制和同步。在CountDownLatch内部有一个volatile修饰的int类型变量，表示计数器的值。await()方法会通过自旋和阻塞来等待计数器的值为0，而countDown()方法则会通过CAS操作将计数器的值减1，并唤醒等待的线程。CountDownLatch的实现原理是基于AQS提供的同步工具，利用其中的阻塞和唤醒机制实现线程的等待和通知。\",\"Semaphore（信号量） Semaphore是一种计数信号量，用于控制同时访问某个资源的线程数量。它可以用来限制同时访问某个资源的线程数目，或者用于实现线程间的通信。主要包含两个方法：acquire()和release()。\",\"acquire()：尝试获取一个许可，如果没有可用许可，则线程会阻塞等待。\",\"release()：释放一个许可，使得其他等待的线程可以继续执行。\",\"使用场景：Semaphore常用于限制资源的并发访问量，例如数据库连接池、线程池等。\",\"实现原理：Semaphore的实现原理也是基于AQS。Semaphore内部使用了一个计数器，表示可用的许可数量。acquire()方法会通过自旋和阻塞来等待可用的许可，而release()方法则会通过CAS操作将许可数量加1，并唤醒等待的线程。Semaphore利用AQS提供的同步机制，实现了线程的安全访问和控制。\"]},\"145\":{\"h\":\"JVM\"},\"146\":{\"h\":\"有没有遇到过OOM,如何排查\",\"t\":[\"当遇到OOM（Out of Memory）错误时，表示JVM中的内存不足，无法分配更多的对象\",\"什么时候会出现OOM问题 \",\"内存泄漏：内存泄漏是指应用程序中的对象占用了内存，但随着时间的推移无法被垃圾回收器释放。\",\"内存不足：应用程序的内存需求超过了可用的物理内存或JVM的内存限制。 \",\"大量数据处理\",\"高并发导致程序无法有效地释放已经处理过的对象\",\"长时间运行导致内存占用累积而触发OOM\",\"如何排查OOM \",\"检查错误日志：首先，查看完整的错误堆栈跟踪和错误信息，了解OOM的具体原因和位置。错误信息通常会提供一些线索来定位问题。\",\"检查代码逻辑：审查代码，特别是与内存相关的部分，如大数据集合、缓存、文件读写等。确保没有使用过多的内存或存在内存泄漏的情况。另外，还要确保及时释放使用完毕的资源，如数据库连接、文件句柄等。\",\"检查JVM内存配置：检查JVM的内存配置参数，如最大堆内存（-Xmx）、初始堆内存（-Xms）和永久代大小（如果使用CMS垃圾回收器）。确保这些参数足够大，以适应应用程序的内存需求。\",\"优化内存使用：根据分析结果，考虑优化内存使用。可能的优化措施包括减少对象的创建、及时释放不再使用的对象、使用缓存技术、调整数据结构大小等。\",\"使用内存分析工具：使用内存分析工具（如VisualVM、JProfiler、MAT）对应用程序进行实时监测和分析。这些工具可以提供更详细的内存使用情况，帮助识别哪些对象或数据结构占用大量内存，并找出潜在的内存泄漏问题。\"]},\"147\":{\"h\":\"双亲委派机制的作用（JVM）\",\"t\":[\"双亲委派机制（Parent Delegation Model）是 Java 类加载器的一种工作方式，用于保证类的唯一性、安全性和隔离性。\",\"当一个类需要被加载时，首先会由当前类加载器（比如应用程序类加载器）检查自己是否已经加载过这个类。如果已经加载过，则直接返回已加载的类。如果没有加载过，则委托父类加载器（比如扩展类加载器）去加载。父类加载器也会按照同样的逻辑继续向上委派，直到达到最顶层的启动类加载器（Bootstrap ClassLoader）。\",\"如果所有的父类加载器都无法完成加载请求，即找不到所需的类，那么当前类加载器会尝试自己去加载类。如果加载成功，则将类添加到自己的命名空间中，并返回加载的类。如果加载失败，则会抛出 ClassNotFoundException 异常。\"]},\"148\":{\"h\":\"JVM垃圾回收机制\",\"t\":[\"分代回收算法（Generational Collection）：JVM中采用了分代回收的思想。将内存划分为不同的代，如新生代和老年代。新生代通常使用复制算法，因为新生代中的对象生命周期短暂，适合频繁回收。老年代通常使用标记-压缩算法，因为老年代中的对象生命周期较长。\",\"复制算法（Copying）：这是一种适用于新生代的垃圾回收算法。将内存分为两个相等大小的区域，一次只使用其中一个，当一个区域满了后，将存活的对象复制到另一个区域，同时对整个区域进行内存回收。这种算法的特点是高效、简单，但是对于存活对象较多的情况，复制算法的效率会降低。\",\"标记-压缩算法（Mark and Compact）：这是一种适用于老年代的垃圾回收算法。与标记-清除算法类似，先标记出所有可达对象，然后将存活对象压缩到一端，然后清理掉末端的全部内存。这样可以消除内存碎片，提高内存利用率。\"]},\"149\":{\"h\":\"操作系统与计算机网络\"},\"150\":{\"h\":\"进程线程的区别,提示资源分配,空间占用方面\",\"t\":[\"资源占用：每个进程都有独立的内存空间和系统资源，而线程共享进程的资源。\",\"并发性：多个线程可以在同一个进程中并发执行，共享进程的资源。而不同进程之间的并发执行需要通过进程间通信进行数据交换。\"]},\"151\":{\"h\":\"并发和并行的区别\",\"t\":[\"并发是指多个任务在同一时间段内交替执行，但在任意给定的时间点只有一个任务在执行。\",\"并行是指多个任务在同一时刻同时执行，利用多个处理单元或多台计算机来同时处理不同的任务。\",\"并发通过任务切换来提高系统的吞吐量和性能，使得多个任务可以同时进行处理。\",\"并行通过同时执行多个任务来加速任务的完成，提高整体的处理能力。\"]},\"152\":{\"h\":\"IP地址和MAC地址区别\",\"t\":[\"IP地址是用来标识网络中设备的逻辑地址。用于网络通信。网络层\",\"MAC地址是用来标识网络设备的物理地址。MAC地址是设备出厂时就确定的，通常无法更改。数据链路层\"]},\"153\":{\"h\":\"Cookie和Session的差别\",\"t\":[\"存储位置：Cookie保存在客户端（浏览器）中，而Session保存在服务器端。\",\"数据的存储方式：Cookie以键值对的形式存储在客户端的浏览器中，而Session则将数据保存在服务器端的内存或者数据库中。\",\"存储容量：Cookie的存储容量有限制，一般为4KB左右。而Session的存储容量相对较大，可以根据服务器的配置进行调整。\",\"生命周期：Cookie可以设置过期时间，可以是会话级的（浏览器关闭后失效）或者持久性的（在一段时间后失效）。而Session的生命周期与用户的会话相关，通常在用户关闭浏览器或者一段时间不活动后失效。\",\"访问方式：Cookie的数据会通过HTTP请求自动发送给服务器，每次请求都会带上Cookie信息。而Session的标识符（通常是一个类似于Session ID的字符串）会在Cookie或者URL参数中传递给服务器。\"]},\"154\":{\"h\":\"HTTP和HTTPs的差别\",\"t\":[\"安全性：HTTP是明文传输协议，数据在传输过程中不加密，容易被窃听和篡改。而HTTPS通过使用SSL/TLS协议对通信内容进行加密，确保数据的机密性和完整性，提供更高的安全性。\",\"默认端口：HTTP默认使用80端口进行通信，而HTTPS默认使用443端口。\",\"证书：为了建立HTTPS连接，服务器需要获得一个有效的数字证书，由权威的证书颁发机构（CA）签发。这个证书用于验证服务器身份并确保通信的安全性。而HTTP不需要证书验证。\"]},\"155\":{\"h\":\"http状态码，https怎么建立连接的\",\"t\":[\"HTTP状态码 \",\"2XX：成功状态码 （200 OK）\",\"3XX：重定向状态码\",\"4XX：客户端错误状态码 （400 Bad Reque、403 Forbidden、404 NotFound）\",\"https怎么建立连接的 \",\"客户端发起连接：客户端向服务器发送HTTPS请求时，会将其通信协议指定为HTTPS，即使用默认的443端口。\",\"服务器配置SSL/TLS证书：服务器需要配置有效的SSL/TLS证书，并将其与特定的域名关联。证书通常由可信任的第三方机构（如CA认证机构）签发，用于证明服务器的身份。\",\"发送服务器证书：服务器在响应客户端请求时，会将自己的SSL/TLS证书发送给客户端。这个证书包含了服务器的公钥以及其相关信息（如证书颁发机构等）。\",\"验证服务器证书：客户端收到服务器证书后，会验证其合法性和真实性。验证包括检查证书的签名是否有效、证书是否过期等。如果验证失败，客户端会发出警告或终止连接。\",\"协商加密算法：客户端选择与服务器进行安全通信所使用的加密算法和密钥长度。通常，客户端会提供一组支持的加密算法供服务器选择。\",\"生成密钥：客户端和服务器都会生成用于加密通信的会话密钥（对称密钥），这个密钥只在当前会话中使用，提供会话级别的安全性。\",\"使用服务器公钥加密：客户端使用服务器的公钥对会话密钥进行加密，并将其发送给服务器。\",\"使用私钥解密：服务器接收到加密的会话密钥后，使用自己的私钥进行解密，得到对称密钥。\",\"安全通信：在随后的HTTPS通信过程中，客户端和服务器使用对称密钥来加密和解密传输的数据，以确保数据的保密性和完整性。\"]},\"156\":{\"h\":\"tcp和udp区别，udp用在哪些地方\",\"t\":[\"tcp和udp区别 \",\"连接性：TCP是面向连接的协议，而UDP是无连接的协议。TCP通过在通信双方之间建立可靠的连接来传输数据，而UDP则没有连接的概念，每个数据包都独立发送。\",\"可靠性：TCP提供可靠的数据传输，使用数据确认、序列号和重传机制来确保数据的正确性和完整性。UDP不提供这些特性，因此对数据传输的可靠性没有严格要求。\",\"速度和效率：由于TCP提供的可靠性和保证数据顺序到达的机制，它会引入一定的延迟，并可能消耗更多的网络资源。相比之下，UDP没有这些机制，因此传输速度更快，效率更高。\",\"数据包顺序：TCP保证数据包按发送顺序到达目标设备，不会出现乱序的情况。而UDP不提供这个保证，数据包可能以任意顺序到达。\",\"UDP用在哪些地方 \",\"实时应用：UDP适合用于实时应用，如音频和视频流传输，因为在这些应用中，即使丢失一些数据包，也不会对整体体验产生重大影响。例如，语音通话、视频会议和直播等。\",\"广播和多播：UDP支持广播和多播，可以将数据同时发送给多个接收者。这在流媒体服务、在线游戏和网络广播等场景中经常使用。\",\"DNS解析：域名系统（DNS）使用UDP进行域名解析，因为在通信过程中，需要快速地查询和获取数据，而不需要确保数据的完整性。\"]},\"157\":{\"h\":\"Spring框架\"},\"158\":{\"h\":\"你最擅长的Java框架,介绍一下 Spring的核心思想\",\"t\":[\"Spring框架的核心思想是IOC（Inversion of Control，控制反转）和AOP（Aspect-Oriented Programming，面向切面编程）。\",\"IOC（控制反转）：IOC的核心理念是将对象的创建、依赖注入和生命周期管理交给Spring容器来完成，通过配置文件或注解的方式，让Spring容器在运行时动态地管理和组装对象。能够降低代码的耦合性、提高代码的可维护性和可测试性。\",\"AOP（面向切面编程）：AOP通过在不修改原有代码的情况下，增加一些额外的功能和行为。例如，日志记录、事务管理等功能可以横切于多个对象和方法。在Spring中，AOP通过代理模式实现，通过配置文件或注解的方式，将这些横切关注点与核心业务逻辑进行解耦，使得系统的设计更加清晰，并且能够重用这些横切关注点。\"]},\"159\":{\"h\":\"什么是动态代理 什么是CGI\",\"t\":[\"动态代理 基于接口的代理\",\"JDK 动态代理主要涉及到 java.lang.reflect 包中的两个类：Proxy 和 InvocationHandler。 InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类 的代码，动态将横切逻辑和业务逻辑编制在一起。Proxy 利用 InvocationHandler 动态创建 一个符合某一接口的实例，生成目标类的代理对象动态代理拼接\",\"CGLIB（字节码生成库）基于类的代理\",\"CGLIB 会生成目标对象的子类，并重写目标对象的方法来实现代理逻辑。\"]},\"160\":{\"h\":\"Spring Bean 生命周期\",\"t\":[\"实例化（Instantiation）：在这个阶段，Spring会根据配置文件或注解创建Bean的实例。实例化可以通过无参数构造函数、工厂方法或者特定的实例化策略来完成。\",\"属性赋值（Population of Properties）：在实例化之后，Spring会使用依赖注入（Dependency Injection）机制将配置的属性值设置到Bean实例中。这可以通过XML配置文件、注解或者Java配置来完成。\",\"初始化（Initialization）：在属性赋值完成之后，Spring会调用初始化回调方法，以便Bean可以执行一些初始化的操作。常见的初始化回调方法有InitializingBean接口的afterPropertiesSet()方法和@PostConstruct注解标记的方法。\",\"使用中（In Use）：Bean在Spring缓存中。在初始化完成后，Bean就可以被应用程序使用了。此时，Bean可以响应业务逻辑中的方法调用和其他操作。\",\"销毁（Destruction）：当应用程序关闭或Bean不再需要时，Spring会调用销毁回调方法，以便Bean执行一些清理操作。常见的销毁回调方法有DisposableBean接口的destroy()方法和@PreDestroy注解标记的方法。\"]},\"161\":{\"h\":\"讲讲一个http请求发到controller的过程\",\"t\":[\"客户端发送请求：客户端通过 HTTP 协议向服务器发送请求，包括请求的 URL、请求方法（GET、POST 等）、请求头、请求体等信息。\",\"DispatcherServlet 拦截请求：Spring Boot 的核心组件 DispatcherServlet 拦截到客户端发送的请求。DispatcherServlet 是一个前置控制器，负责处理所有的请求分发和委派。\",\"HandlerMapping 查找处理器：DispatcherServlet 调用 HandlerMapping 来查找适合处理当前请求的处理器（即 Controller）。HandlerMapping 根据请求的 URL、请求方法等信息来确定对应的处理器。\",\"HandlerAdapter 执行处理器：一旦找到了匹配的处理器，DispatcherServlet 就会调用 HandlerAdapter 来执行该处理器。HandlerAdapter 是适配器模式的实现，它能够使得不同类型的处理器能够统一执行。\",\"执行业务逻辑：Controller 接收到请求后，根据业务逻辑进行处理。它会处理请求参数、调用 Service 层或其他相关组件进行业务处理，并返回处理结果。\",\"处理响应：Controller 处理完成后，会将处理结果封装成一个 ModelAndView 对象（包含响应的数据和视图信息），然后返回给 DispatcherServlet。\"]},\"162\":{\"h\":\"DispatcherServlet是干嘛的\",\"t\":[\"DispatcherServlet充当了前端控制器（Front Controller）的角色，负责协调和管理Spring MVC框架中的各个组件，实现了请求的统一入口和全局的请求处理逻辑\",\"请求分发：当客户端发送一个HTTP请求时，DispatcherServlet接收到该请求并根据配置的URL映射规则，将请求转发给对应的控制器（Handler）进行处理。\",\"视图解析：在控制器方法处理完请求后，DispatcherServlet会根据配置的视图解析器（View Resolver）将处理结果转化为具体的视图对象（如JSP页面、Thymeleaf模板等）。\",\"异常处理：DispatcherServlet还负责处理请求过程中可能产生的异常，并通过配置的异常处理器（Exception Resolver）来选择合适的方式进行异常处理，如返回错误页面或JSON格式的错误信息。\"]},\"163\":{\"h\":\"Spring怎么解决循环依赖问题\",\"t\":[\"Spring中两个或多个 Bean 互相之间持有对方的引用就会发生循 环依赖。循环的依赖将会导致注入死循环。\",\"当Spring创建一个Bean时，首先检查singletonObjects（一级缓存）缓存中是否存在该Bean的实例。如果存在，直接返回实例。如果不存在，则继续下一步。\",\"Spring将正在创建的Bean对象存放在早期暴露的对象缓存earlySingletonObjects（二级缓存）中，但此时只是占位符（early-stage object）。\",\"接下来，Spring继续创建Bean的过程，如果发现循环依赖，即A依赖B，B又依赖A，那么Spring将返回earlySingletonObjects缓存中的占位符。\",\"此时，Spring开始解决循环依赖，通过调用构造函数或者setter方法，将所需的依赖注入到占位符中。\",\"当依赖注入完成后，Spring将真正创建好的Bean对象放置到singletonObjects缓存中。这时，其他需要此Bean的组件就可以通过singletonObjects缓存获取到该Bean的实例。\",\"最后，Spring根据循环依赖链的深度进行逐级清理，将earlySingletonObjects缓存中的占位符替换为真正的Bean对象。\"]},\"164\":{\"h\":\"Spring中使用多线程\",\"t\":[\"SpringBoot应用中需要添加@EnableAsync注解，来开启异步调用，一般还会配置一个线程池，异步的方法交给特定的线程池完成。\",\"获取异步方法返回值\",\"当异步方法有返回值时，如何获取异步方法执行的返回结果呢？这时需要异步调用的方法带有返回值CompletableFuture。\",\"CompletableFuture是对Feature的增强，Feature只能处理简单的异步任务，而CompletableFuture可以将多个异步任务进行复杂的组合。\",\"注意事项\",\"@Async注解会在以下几个场景失效，也就是说明明使用了@Async注解，但就没有走多线程。\",\"异步方法使用static关键词修饰；\",\"异步类不是一个Spring容器的bean（一般使用注解@Component和@Service，并且能被Spring扫描到）；\",\"SpringBoot应用中没有添加@EnableAsync注解；\",\"在同一个类中，一个方法调用另外一个有@Async注解的方法，注解不会生效。原因是@Async注解的方法，是在代理类中执行的。\",\"需要注意的是： 异步方法使用注解@Async的返回值只能为void或者Future及其子类，当返回结果为其他类型时，方法还是会异步执行，但是返回值都是null\"]},\"165\":{\"h\":\"登录系统的Cookie和Session如何设计？\",\"t\":[\"用户登录：用户通过提供用户名和密码进行登录，服务器验证用户凭据，如果通过验证，则生成一个唯一的 Session ID，并将该 ID 保存到服务器端。\",\"Cookie 的设置：在服务器返回响应给客户端时，将 Session ID 添加到 Cookie 中，并设置 Cookie 的有效期。将 Cookie 发送给客户端保存。\",\"客户端请求：客户端在后续的请求中会自动将 Cookie 带上，发送给服务器。\",\"服务器验证：服务器接收到请求时，会从 Cookie 中获取 Session ID，并与服务器端存储的 Session ID 进行比较。\",\"Session 管理：服务器端维护一个 Session 数据库或者缓存，用于存储每个 Session ID 对应的用户信息和其他需要保存的数据。（可以用Redis存储）\"]},\"166\":{\"h\":\"Spring的@Transaction，假如我一个@Service，里面有两个public方法A和B，A上面没有@Transaction，B有，A方法调用B方法，事务会生效吗？\",\"t\":[\"不会\",\"当一个类被标记为 @Service 时，Spring会为该类创建一个代理对象。这个代理对象会拦截所有对该类的方法调用，并在方法执行前后进行一些额外的处理，如开启和提交事务。但是这个代理对象只能拦截从外部类调用的方法，而无法拦截类内部方法之间的相互调用。\",\"怎么使事务生效 \",\"可以通过将方法B提取到另一个类中，并通过在类上添加 @Transactional 注解，确保代理机制能够拦截方法B的调用\",\"或者在方法A上也添加 @Transactional 注解，确保方法A和B都处于同一个事务的管理下。\"]},\"167\":{\"h\":\"MyBatis的缓存机制，有哪些缓存策略\",\"t\":[\"缓存机制\",\"一级缓存（Local Cache）： \",\"默认开启，是在同一个 SqlSession 内部的缓存。\",\"作用范围是 Session 级别，同一个 Session 内部的多次查询可以复用缓存。\",\"一级缓存是基于对象引用来实现的，当数据发生变化时，缓存会失效。\",\"二级缓存（Second Level Cache）： \",\"可以配置全局的缓存，作用范围是多个 SqlSession 之间的缓存。\",\"默认不开启，需要手动进行配置和启用。\",\"对于经常被查询的数据，可以放到二级缓存中，在多个 SqlSession 之间共享缓存。\",\"二级缓存是基于序列化来实现的，数据变化时需要更新缓存。\",\"缓存策略\",\"MyBatis 提供了多种缓存策略，例如 LRU（最近最少使用）、FIFO（先进先出）、SOFT（软引用）和WEAK（弱引用）等\"]},\"168\":{\"h\":\"如果没有Spring怎么开发\",\"t\":[\"选择其他框架：Java EE\",\"数据库操作： \",\"使用 JDBC：Java Database Connectivity（JDBC）是 Java 提供的标准数据库连接接口，可以直接使用 JDBC 进行数据库操作。\",\"使用 ORM 框架：选择其他 ORM（对象关系映射）框架，如 Hibernate、MyBatis 等，它们可以简化数据库访问和操作。\",\"Web 开发： \",\"使用 Servlet 和 JSP：Java 的标准技术，可以进行 Web 开发。使用 Servlet 处理请求和生成响应，使用 JSP 进行页面展示和动态内容生成。\",\"依赖注入： \",\"手动依赖管理\",\"使用其他轻量级的依赖注入框架：选择其他的依赖注入框架，如 Google Guice、PicoContainer 等，它们提供类似于 Spring 的依赖注入功能。\",\"AOP（面向切面编程）： \",\"使用其他 AOP 框架：如 AspectJ 等。\"]},\"169\":{\"h\":\"MySQL数据库\"},\"170\":{\"h\":\"事务特性\",\"t\":[\"原子性（Atomicity） • 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。\",\"一致性（Consistency） • 事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。\",\"隔离性（Isolation） • 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。 持久性（Durability） • 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\"]},\"171\":{\"h\":\"数据库的事务,并发事务会带来哪些问题,MySQL的默认隔离级别 如何在数据库中实现数据的备份和恢复\",\"t\":[\"并发事务会带来哪些问题 \",\"数据不一致：并发事务可能导致数据的不一致性。当多个事务同时读取和修改同一份数据时，如果没有适当的并发控制机制，就有可能导致数据的错乱和不一致。\",\"丢失更新：并发事务中的更新操作可能会相互覆盖，从而导致部分更新的丢失。例如，两个事务同时读取一个数据并进行修改，然后将结果写回数据库，如果没有适当的并发控制机制，其中一个事务的修改结果可能会被另一个事务的覆盖，导致数据的丢失。\",\"脏读（Dirty Read）：脏读是指一个事务在读取了另一个事务未提交的数据之后，又进行了一次读取操作，此时可能读取到的数据是不正确或无效的。这种情况下，事务可能基于不一致或临时的数据进行后续操作，导致数据的错误处理和错误结果。\",\"不可重复读（Non-repeatable Read）：不可重复读是指一个事务在读取了某个数据后，又进行一次读取操作，但此时读取到的数据已经发生了改变。这种情况下，事务可能会在两次读取之间对数据进行了一些操作（如修改或删除），导致前后两次读取的数据不一致。\",\"幻读（Phantom Read）：幻读是指一个事务在同样的查询条件下，由于其他并发事务的插入或删除操作，导致前后两次查询的结果集不一致。这种情况下，事务在处理某个数据集时，可能会发现新增或删除了一些记录，导致数据的不完整性。\",\"解决并发事务带来的问题 \",\"锁定机制\",\"隔离级别\",\"事务调度算法\",\"MySQL隔离级别 \",\"读未提交（Read Uncommitted）：最低的隔离级别，事务可以读取其他事务尚未提交的数据。这可能导致脏读、不可重复读和幻读的问题。\",\"读已提交（Read Committed）：事务只能读取其他事务已经提交的数据。这解决了脏读的问题，但仍可能存在不可重复读和幻读的问题。\",\"可重复读（Repeatable Read）：MySQL 默认的隔离级别。事务在启动时创建一个一致性视图，保证在整个事务期间读取的数据不受其他事务的影响，解决了不可重复读的问题。但仍可能存在幻读的问题。\",\"串行化（Serializable）：最高的隔离级别，通过强制事务的串行执行来避免并发问题。事务会在读取和修改数据时对数据进行锁定，确保其他事务无法同时修改被锁定的数据。这可以解决脏读、不可重复读和幻读的问题，但可能降低并发性能。\"]},\"172\":{\"h\":\"MySQL数据库的索引结构为什么用b+树，b树缺点？\",\"t\":[\"b树和b+树 \",\"B树： \",\"节点既存储数据也存储关键字。\",\"内部节点和叶子节点的结构相同。\",\"拥有更高的填充度，节点利用率较高。\",\"适用于随机访问和插入操作。\",\"B+树： \",\"内部节点只存储关键字。\",\"叶子节点存储所有数据，并通过指针连接形成有序链表。\",\"内部节点能容纳更多的子节点指针。\",\"适用于顺序访问和范围查询。\",\"在数据库索引中使用较为广泛。\",\"MySQL数据库的索引结构为什么用b+树，b树的缺点 \",\"B树的内部节点存储数据：B树的每个节点都会存储关键字和对应的数据，这意味着一个节点的大小是相对较大的。当B树的高度比较大时，磁盘IO操作会变得频繁，因为每次读取一个节点时需要读取更多的数据，而不仅仅是所需的关键字。\",\"B树的查询效率相对较低：由于B树的节点即存储关键字又存储数据，因此在查找某个关键字时，可能需要在每个节点中进行比较操作，这会增加查询的时间复杂度。尤其是在高度较高的B树中，查询性能会进一步降低。\",\"B+树的查询效率更高：B+树在进行关键字查找时，只需要在内部节点中进行比较操作，然后通过叶子节点指针快速定位到对应的数据节点，减少了比较的次数，提高了查询效率。\",\"B+树的范围查询效率更高：由于B+树的叶子节点通过指针连接成有序链表，范围查询只需要遍历叶子节点链表即可，不需要在内部节点中进行遍历，大大提高了范围查询的效率。\"]},\"173\":{\"h\":\"MySQL行数多了为什么会变慢 加索引为什么会快\",\"t\":[\"MySQL行数多了为什么会变慢\",\"磁盘IO：随着行数的增加，磁盘IO操作可能会变得更频繁。当数据无法完全加载到内存中时，MySQL需要从硬盘读取数据，而硬盘读取速度相对较慢，会导致查询速度下降。\",\"索引失效：如果数据库表没有适当的索引或索引选择不当，随着行数的增加，MySQL可能需要进行全表扫描来找到匹配的数据。全表扫描需要遍历每一行数据，耗时较长，导致查询性能下降。\",\"锁竞争：当多个并发事务同时查询或修改同一个表时，随着行数的增加，锁竞争的概率也增大。如果锁竞争过于激烈，可能导致查询被阻塞，从而影响查询性能。\",\"加索引为什么会快\"]},\"174\":{\"h\":\"怎么设计数据库索引\",\"t\":[\"使用频率高得列作为索引：索引应该选择在经常使用的查询条件\",\"考虑列的选择性：选择性是指索引列中不同值的数量与总行数的比例。即大部分行都有不同的值，建立索引会更有优势。\",\"注意索引列的大小：索引列的大小应尽可能小，这样可以减少索引占用的存储空间，并提高索引查询的效率。一般来说，整数类型比字符类型更适合作为索引列。\",\"考虑多列索引（复合索引）：当多个列组合在一起用于查询时，可以考虑创建复合索引。复合索引可以提高多个列组合查询的效率，并且在某些情况下比单列索引更有效。\",\"避免过多的索引：过多的索引会增加维护成本，并且可能导致性能下降。只创建必要的索引，避免创建过多冗余的索引。\",\"定期更新和重新组织索引：随着数据的插入、更新和删除，索引可能会变得不均衡或不连续。定期对索引进行更新和重新组织可以保持索引的效率。\"]},\"175\":{\"h\":\"最左匹配原则是什么，以及为什么这样就可以用到联合索引\",\"t\":[\"“最左匹配原则”是指在联合索引中，如果查询条件涉及到联合索引的多个列，那么查询时只能使用联合索引的最左边的列开始匹配。也就是说，对于一个联合索引 (A, B, C)，如果查询条件只涉及到 A 和 B，而不包括 C，那么这个联合索引可以被用到；但是如果查询条件只涉及到 B 和 C，而不包括 A，那么这个联合索引将无法被用到。\",\"这是因为联合索引的数据结构是按照索引的列顺序进行排序和存储的。当查询时，数据库引擎会根据最左匹配原则来定位索引中的数据。如果查询条件只涉及到联合索引的最左边的列，数据库可以直接使用索引定位到对应的数据行，从而提高查询效率。\"]},\"176\":{\"h\":\"联合索引为什么要遵守前缀匹配？\",\"t\":[\"当使用联合索引进行查询时，如果查询条件只涉及到索引的前缀列，即根据索引的最左边的几列进行匹配，那么数据库可以直接利用索引定位到符合条件的数据行，从而大大减少了扫描的数据量\",\"举个例子，假设有一个联合索引 (A, B, C)，我们有以下两种查询条件：\",\"查询条件为 A = 1：这个查询可以利用索引的最左前缀 A 进行匹配，即可以快速定位到符合条件的数据行。\",\"查询条件为 B = 2：这个查询无法利用索引进行快速定位，需要扫描索引中所有 B 列等于 2 的数据行，效率相对较低。\"]},\"177\":{\"h\":\"MySQL有哪些日志，分别起什么作用\",\"t\":[\"二进制日志（Binary Log）： \",\"作用：记录对数据库的修改操作，包括增删改表数据的语句。\",\"使用场景：用于数据恢复、数据复制和主从同步。\",\"错误日志（Error Log）： \",\"作用：记录 MySQL 服务器运行过程中出现的错误和异常信息。\",\"使用场景：用于故障排查和问题分析。\",\"查询日志（General Query Log）： \",\"作用：记录所有进入 MySQL 服务器的查询语句，包括 SELECT、INSERT、UPDATE、DELETE 等。\",\"使用场景：用于排查慢查询和审计查询的使用情况。\",\"慢查询日志（Slow Query Log）： \",\"作用：记录执行时间超过阈值的查询语句，通常用于优化和改进查询性能。\",\"使用场景：用于定位和优化数据库中的慢查询语句。\",\"事务日志（Transaction Log）或重做日志（Redo Log）： \",\"作用：记录已提交事务的修改，以确保数据持久性和一致性。\",\"使用场景：用于崩溃恢复和故障恢复，保证数据的完整性。\",\"撤销日志（Undo Log）： \",\"作用：记录事务中对数据的修改，在事务回滚或 MVCC（多版本并发控制）时使用。\",\"使用场景：用于撤销已提交事务的修改或提供读一致性视图。\"]},\"178\":{\"h\":\"MySQL MVCC 原理\",\"t\":[\"MVCC（Multi-Version Concurrency Control）是一种并发控制机制\",\"版本号：每个数据行在插入或更新时都会有一个版本号，在InnoDB中使用6字节的数字表示。这个版本号是基于事务ID（Transaction ID）来分配的。\",\"Undo日志：InnoDB使用Undo日志来记录对数据行的修改，通过回滚这些Undo日志可以撤销已提交的事务对数据行的修改。Undo日志存储了旧版本的数据值，用于回滚操作和读取已提交的旧版本数据。\",\"Read View（读视图）：每个事务在开始时会创建一个Read View，用于确定事务可见的数据行版本。Read View包含事务启动时系统中有效的活跃事务列表和已提交事务列表。事务只能看到已提交事务开始之前的版本。\",\"Consistent Read（一致性读）：对于一致性读操作（例如SELECT），InnoDB会根据事务的Read View找到符合条件的最新版本数据行。如果某个数据行的版本在事务的Read View之后，那么这个数据行对于该事务来说是不可见的。\",\"Read Committed隔离级别：InnoDB的默认隔离级别是Read Committed，它保证每个查询都使用当前的Read View来获取数据，从而提供了一致性的读取。\",\"快照读（Snapshot Read）：当事务执行SELECT语句时，它会使用当前的Read View来确定可见的数据行版本。这个操作称为快照读，它允许在事务执行期间保持数据的一致性状态。\",\"间隙锁（Gap Lock）：MVCC机制在一定程度上避免了写操作之间的冲突，但可能存在幻读问题（即在一个事务中两次执行相同查询，第二次查询会返回额外的行）。为了解决幻读问题，InnoDB引入了间隙锁，用于防止其他事务在范围内插入新记录。\"]},\"179\":{\"h\":\"MySQL索引类型，什么是聚簇索引，什么是非聚簇索引\",\"t\":[\"聚簇索引（Clustered Index）： 聚簇索引是一种特殊的索引类型，它决定了数据在磁盘上的物理存储顺序。每个表只能有一个聚簇索引。聚簇索引的叶子节点存储了实际的数据行，而非叶子节点存储了索引键值及指向下一级节点的指针。聚簇索引对于频繁基于范围查询和排序的操作非常有效。\",\"非聚簇索引（Non-clustered Index）： 非聚簇索引是另一种常见的索引类型。与聚簇索引不同，非聚簇索引的叶子节点并不存储实际的数据行，而是存储了索引键及指向对应数据行的指针。因此，通过非聚簇索引可以快速定位到满足查询条件的数据行，然后再使用指针获取相应的数据。\"]},\"180\":{\"h\":\"MySQL的WAL原则\",\"t\":[\"WAL（Write-Ahead Logging）是一种数据库事务日志机制，用于确保事务的持久性和恢复能力。\",\"MySQL使用了两个关键的日志文件，即重做日志（Redo Log）和回滚日志（Undo Log）。\",\"重做日志（Redo Log）：在WAL原则中，重做日志用于记录在事务提交之前对数据所做的修改操作。在事务提交之前，相关的修改操作首先被写入重做日志中，然后才将其应用到数据库中。这样即使在系统发生故障或崩溃时，MySQL也可以使用重做日志来恢复数据，并确保数据的一致性和完整性。\",\"回滚日志（Undo Log）：回滚日志记录了事务所做的修改操作的反向操作，也就是撤销操作。\"]},\"181\":{\"h\":\"Redis的AOF遵守WAL原则吗\",\"t\":[\"Redis的AOF（Append-Only File）持久化机制可以说是部分地遵守WAL（Write-Ahead Logging）原则。\",\"在AOF持久化模式下，Redis将所有写操作追加到AOF文件的末尾，而不是像传统的数据库系统一样先写日志文件再修改内存数据。这意味着 Redis 的 AOF 日志记录的是最终状态，而不是每个独立的操作。\"]},\"182\":{\"h\":\"MySQL怎么排查慢查询\",\"t\":[\"查询慢查询日志，分析导致慢查询的语句\",\"可以使用EXPLAIN关键字来了解MySQL优化器的查询执行计划。通过执行EXPLAIN加上需要分析的SQL语句，可以获取到查询计划的详细信息，包括索引使用情况、表扫描方式等。\"]},\"183\":{\"h\":\"MySQL支持事务的存储引擎\",\"t\":[\"MySQL支持多种存储引擎，其中一些支持事务的存储引擎包括：\",\"InnoDB：InnoDB是MySQL的默认存储引擎，也是最常用的支持事务的引擎。它提供了ACID（原子性、一致性、隔离性和持久性）特性，并支持行级锁定，具有较好的并发性能和数据完整性。\",\"NDB Cluster：NDB Cluster（也称为MySQL Cluster）是为分布式环境设计的高可用性存储引擎。它使用多个节点共同存储和处理数据，提供了实时复制和故障恢复功能，支持事务和并发性。\",\"MyRocks：MyRocks是一个基于RocksDB引擎的存储引擎，它使用了写优化和压缩算法来提供高效的存储和查询性能。MyRocks在MySQL 5.6版本之后成为可用的存储引擎，并且支持事务。\"]},\"184\":{\"h\":\"SQL语句的执行顺序\",\"t\":[\"在 SQL 语句中，通常是先执行远离 WHERE 语句的部分，然后再执行 WHERE 语句。具体执行顺序如下：\",\"FROM 子句中指定的表：SQL 语句首先从 FROM 子句中指定的表开始执行。这一步涉及从表中获取相关的数据。\",\"JOIN 子句（如果有的话）：如果 SQL 语句包含 JOIN 子句，那么表之间的连接会在获取数据之前进行计算。这一步将数据从多个表连接起来。\",\"WHERE 子句：一旦表和连接准备好，WHERE 子句中的条件将被应用于结果集。这一步筛选出满足条件的数据行。\",\"GROUP BY 子句（如果有的话）：如果 SQL 语句包含 GROUP BY 子句，那么数据将按照 GROUP BY 子句中的列进行分组。\",\"HAVING 子句（如果有的话）：HAVING 子句用于筛选 GROUP BY 后的结果集。它与 WHERE 子句不同，WHERE 子句在 GROUP BY 之前应用，而 HAVING 子句在 GROUP BY 之后应用。\",\"SELECT 子句：SELECT 子句用于选择需要返回的列，并可以对数据进行计算、排序等操作。这一步执行的是选择和处理列的操作。\",\"ORDER BY 子句（如果有的话）：如果 SQL 语句包含 ORDER BY 子句，那么数据将按照 ORDER BY 子句指定的列进行排序。\",\"LIMIT 子句（如果有的话）：LIMIT 子句用于限制结果集的数量\"]},\"185\":{\"h\":\"Redis 缓存\"},\"186\":{\"h\":\"Redis 为什么快，为什么能处理高并发？\",\"t\":[\"Redis 完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于 HashMap, HashMap 的优势就是查找和操作的时间复杂度是O(1)；\",\"数据结构简单，对数据的操作也简单；\",\"采用单线程，Redis 的命令都是原子操作，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗；\",\"使用**多路复用 IO **模型，非阻塞 IO：传统的并发模型：每个 I/O 流都有一个新的线程管理；\",\"I/O多路复用：只有单个线程，通过追踪每个 I/O 流的状态，来管理多个 I/O 流；\",\"使用的底层模型不同，它们之间底层实现方法以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制，因为一般的系统调用系统函数的时候，会浪费一定的事件去移动和请求。\"]},\"187\":{\"h\":\"Redis 为什么采用单线程\",\"t\":[\"对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 IO 密集型。具体到 Redis的话，如果不考虑 RDB/AOF 等持久化方案，Redis 是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis 真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟，因此 Redis选择了单线程的 I/O 多路复用来实现它的核心网络模型。\",\"1.Redisv4.0(引入多线程处理异步任务) 2.Redis 6.0(在网络模型中实现多线程 I/O ) 所以，网络上说的Redis是单线程，通常是指在Redis 6.0之前，其核心网络模型使用的是单线程。 目Redis6.0引入多线程I/O，只是用来处理网络数据的读写和协议的解析，而执行命令依旧是单线程。\"]},\"188\":{\"h\":\"Redis 基本类型\",\"t\":[\"字符串（String）：用于存储单个值，可以是字符串、整数或浮点数。\",\"哈希（Hash）：用于存储字段和值的映射关系，类似于关联数组或字典。适合存储对象。\",\"列表（List）：按照插入顺序存储的字符串元素列表。可以在列表头部或尾部插入、删除元素，还可以根据索引获取范围内的元素。\",\"集合（Set）：无序的字符串集合，不允许重复的元素。可以对集合执行添加、删除、查找等操作。\",\"有序集合（Sorted Set）：与集合类似，每个元素都会关联一个分数，根据该分数进行排序。可以根据分数范围获取元素，也可以根据排名获取元素。\",\"位图（Bitmap）：位图是由二进制位组成的数据结构，可以表示一系列的开关状态或标记。\"]},\"189\":{\"h\":\"Redis 持久化方式\",\"t\":[\"Redis为了保证效率，数据存储在了内存中，但是会周期性地把更新的数据写入磁盘或者把修改操作写成追加的记录文件中，以保证数据的持久化。\",\"Redis的持久化策略有两种： \",\"RDB(Redis database)：直接把内存中的数据保存到一个dump的文件中，定时保存；\",\"AOF(Append Only File)：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合。\",\"Redis默认是快照RDB的持久化方式。当Redis重启的时候，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整。\",\"RDB和AOF的区别 \",\"RDB是一次全量备份，AOF日志是连续的增量备份；\",\"RDB是内存数据的二进制序列化形式，在存储上非常紧凑，而AOF日志记录的是内存数据修改的指令记录文本；\",\"如何选择合适的持久化方式 \",\"如果是数据比较重要，不想再从其他地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只使用RDB。\",\"如果是用做内存数据库，建议是RDB和AOF都开启，或者定期执行bgsave做快照备份，RDB方式更适合做数据的备份，AOF可以保证数据的不丢失。\",\"Redis 4.0 更新了混合了 RDB 和 AOF 格式的增量数据\"]},\"190\":{\"h\":\"Redis 的扩容方式\",\"t\":[\"如果 Redis 被当作缓存使用，使用一致性哈希实现动态扩容缩容。\",\"如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话，必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。\"]},\"191\":{\"h\":\"Redis 过期键的删除策略\",\"t\":[\"Redis 的过期删除策略就是: 惰性删除和定期删除两种策略配合使用。\",\"惰性删除: 惰性删除不会去主动删除数据，而是在访问数据的时候，再检查当前键值是否过期，如果过期则执行删除并返回 null 给客户端，如果没有过期则返回正常信息给客户端。它的优点是简单，不需要对过期的数据做额外的处理，只有在每次访问的时候才会检查键值是否过期，缺点是删除过期键不及时，造成了一定的空间浪费。\",\"定期删除: Redis 会周期性的随机测试一批设置了过期时间的 key 并进行处理。测试到的已过期的 key 将被删除。\"]},\"192\":{\"h\":\"Redis 的缓存淘汰策略\",\"t\":[\"常用策略\",\"FIFO（First In, First Out）：先进先出策略，即淘汰最早添加的缓存数据。\",\"LRU（Least Recently Used）：最近最少使用策略，即淘汰最久未被使用的缓存数据。\",\"LFU（Least Frequently Used）：最不经常使用策略，即淘汰使用频率最低的缓存数据。\",\"Random（随机策略）：随机选择要淘汰的缓存数据。\",\"Redis 内置策略\",\"volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。\",\"volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。\",\"volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。\",\"volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。\",\"allkeys-lru：从数据集中挑选最近最少使用的数据淘汰\",\"allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。\",\"allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰\",\"no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。\"]},\"193\":{\"h\":\"为何 Redis 使用跳表而非红黑树实现 SortedSet （zset）？\",\"t\":[\"Redis中的有序集合支持的核心操作主要支持：\",\"插入一个数据\",\"删除一个数据\",\"查找一个数据\",\"迭代输出有序序列 以上操作，红黑树也能完成，时间复杂度跟跳表一样O(log n)。\",\"按照区间查找数据 红黑树的效率低于跳表。跳表可以做到O(logn)定位区间的起点，然后在原始链表顺序往后遍历即可。\"]},\"194\":{\"h\":\"布隆过滤器原理\",\"t\":[\"布隆过滤器（Bloom Filter）是一种空间效率非常高的概率型数据结构，用于判断一个元素是否存在于一个集合中。\",\"初始化：创建一个位数组（bit array），长度为 m，并将所有位初始化为 0。\",\"添加元素：当要向布隆过滤器中添加一个元素时，使用多个独立的哈希函数将该元素映射到位数组的不同位置，并将对应位置的位设为 1。\",\"检查元素：当要检查一个元素是否存在于布隆过滤器中时，使用相同的哈希函数计算该元素对应的位数组位置，并检查对应位置的位值。如果其中有任何一位为 0，则可以确定该元素一定不存在于布隆过滤器中；如果所有位都为 1，则表示该元素可能存在于布隆过滤器中。\",\"因为多个元素可能映射到位数组上相同的位，从而导致某些元素的存在被错误地判断为存在。误判率取决于位数组的大小、哈希函数的数量和哈希函数的质量。因为多个元素可能映射到位数组上相同的位，从而导致某些元素的存在被错误地判断为存在。误判率取决于位数组的大小、哈希函数的数量和哈希函数的质量。\"]},\"195\":{\"h\":\"缓存与数据库一致性问题\",\"t\":[\"先更新数据库，再更新缓存\",\"先更新缓存，再更新数据库\",\"先删除缓存，后更新数据库\",\"先更新数据库，后删除缓存\",\"第一种和第二种方案，没有人使用的，因为第一种方案存在问题是: 并发更新数据库场景下，会将脏数据读到缓存。\",\"第二种方案存在的问题是: 如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。\",\"目前主要用第三和第四种方案\",\"第三种方案也存在问题\",\"该方案也会出问题，此时来了两个请求，请求 A(更新操作) 和请求 B(查询操作)\",\"请求A进行写操作，删除缓存\",\"请求B查询发现缓存不存在\",\"请求B去数据库查询得到旧值\",\"请求B将旧值写入缓存\",\"请求A将新值写入数据库\",\"上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。\"]},\"196\":{\"h\":\"解决缓存与数据库一致性问题\",\"t\":[\"延时双删（针对先删缓存后更新数据）\",\"(1) 先淘汰缓存 (2) 再写数据库《这两步和原来一样) (3) 休眠1秒，再次淘汰缓存，这么做，可以将1秒内所造成的缓存脏数据，再次删除。确保读请求结束，写请求可以删除读请求造成的缓存脏数据。\",\"消息队列发送缓存删除补偿\",\"Redis 删除时报错，通过消息队列通知系统，系统接受到消息后再次删除\"]},\"197\":{\"h\":\"什么是缓存穿透 怎么解决\",\"t\":[\"缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。\",\"方法1：将无效的 key 存入 Redis 中\",\"方法2：布隆过滤器，在查询 Redis 前先去布隆过滤器查询 key 是否存在\"]},\"198\":{\"h\":\"什么是缓存雪崩 怎么解决\",\"t\":[\"如果缓存在某一个时刻出现大规模的 key 失效，那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。\",\"主要有两种可能: 第一种是Redis宕机，第二种可能就是采用了相同的过期时间。\",\"方法 \",\"事前 \",\"均匀过期：设置不同的过期时间\",\"分级缓存：多级缓存，每层缓存失效时间不同\",\"热点数据永不过期\",\"Redis 集群避免全盘崩溃\",\"事中 \",\"互斥锁：缓存失效后，控制互斥锁或者消息队列来控制读写缓存的线程数量\",\"熔断机制：流量达到阈值直接返回系统拥挤\",\"事后 \",\"通过 Redis 持久化机制，尽快恢复缓存\"]},\"199\":{\"h\":\"Redis的Set元素过多怎么办\",\"t\":[\"分页查询：通过使用 Redis 的分页查询功能，将 Set 元素按照一定的数量进行分页处理。可以使用命令如 ZRANGE 或 ZREVRANGE 来获取指定范围内的元素，然后再根据需要进行展示或处理。\",\"使用有序集合（Sorted Set）：如果对元素有排序需求，可以将 Set 转换为 Sorted Set。Sorted Set 中的每个元素都有一个分数（score），可以根据分数进行排序和范围查询。这样可以更加高效地处理大量的元素。\"]},\"200\":{\"h\":\"Redis内存不够了怎么办\",\"t\":[\"设置合理的过期时间：对于不再需要的键值对，可以通过设置合理的过期时间来自动释放内存。这样可以避免内存被长时间占用。\",\"持久化到磁盘：使用 Redis 的持久化功能将部分数据存储到磁盘中。这样可以释放内存，并且在需要时可以从磁盘加载回内存。可以选择使用 RDB 持久化或 AOF 持久化，或者两者结合使用。\",\"使用内存淘汰策略：当内存不足时，Redis 提供了多种内存淘汰策略，可根据实际情况选择合适的策略。例如，可以设置使用 LRU（最近最少使用）策略或 LFU（最近最不常用）策略等来淘汰不常用的数据。\",\"分片或集群化：如果单个 Redis 实例无法满足需求，可以考虑将数据进行分片或搭建 Redis 集群。将数据分散到多个 Redis 节点上，提高整体的内存处理能力。\"]},\"201\":{\"h\":\"Redis 事务的概念\",\"t\":[\"Redis 事务中如果有某一条命令执行失败，之前的命令不会回滚，其后的命令仍然会被继续执行。鉴于这个原因，所以说 Redis 的事务严格意义上来说是不具备原子性的。\",\"Redis 事务中所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\",\"在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语占都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命今都会被服务器执行\",\"Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。\"]},\"202\":{\"h\":\"Redis 事务相关指令\",\"t\":[\"WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set (CAS) 行为，可以监控一个或多个键，一旦事务执行前有一个键被修改(或删除)，之后的事务就不会执行，监控一直持续到 EXEC 命令\",\"MULTI 命令用于开启一个事务，它总是返回OK。MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行。\",\"EXEC: 执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。\",\"通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。\",\"UNWATCH 命令可以取消 watch 对所有 key 的监控。\"]},\"203\":{\"h\":\"Redis 集群方式，哨兵选举过程\",\"t\":[\"单机 Redis 的风险与问题\",\"问题一：机器故障\",\"硬盘故障，系统崩溃\",\"本质：数据丢失，可能对业务造成灾难性打击\",\"问题二：容量瓶颈\",\"内存不足，一台 Redis 内存是有限的\",\"Redis 集群方式\",\"主从模式： 建立连接阶段-建立 slave 到 master 的连接，使 master 能够识别 slave，并保存 slave 端口号 数据同步阶段-在 slave 初次连接 master 后，复制 master 中的所有数据到slave 命令传播阶段-当 master 数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态\",\"哨兵模式（Sentinel Mode）：在哨兵模式下，Redis集群中会有若干个哨兵节点监控主节点和从节点的状态。当主节点不可用时，哨兵会自动进行选举，选出一个新的主节点，并将其他节点设置为从节点。哨兵会通过互相交流来达成共识，并使用选举算法选出新的主节点。\",\"Cluster 模式（Cluster Mode）：在 Cluster 模式下，Redis 集群中的节点被组织成多个揭示槽（slot）的哈希槽。数据根据键名的哈希值被分配到对应的揭示槽上。Redis Cluster 使用 Gossip 协议进行节点之间的通信，通过交换信息来达成一致，并动态调整节点分布，保证高可用性和扩展性。\",\"哨兵选举过程\",\"如果一个哨兵节点确定主节点不可用，它会向其他哨兵节点发送SENTINEL is-master-down-by-addr命令，请求其他哨兵节点确认主节点的不可用情况。\",\"如果多数的哨兵节点都确认主节点不可用，那么它们会通过选举算法选择一个新的主节点，并将其他节点设置为从节点。\",\"当选出新的主节点后，哨兵节点会使用SENTINEL failover命令通知其他Redis实例进行主从切换\"]},\"204\":{\"h\":\"主从复制的原理\",\"t\":[\"主从架构的核心原理\",\"当启动一个slave node的时候，它会发送一个PSYNC命令给master node\",\"如果这是 slave node 重新连接 master node，那么master node仅仅会复制给slave 部分缺少的数据;否则如果是 slave node 第一次连接 master node，那么会触发一次 full resynchronization\",\"开始 full resynchronization 的时候，master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端收到的所有写命今缓存在内存中。RDB 文件生成完毕之后，master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后 master 会将内存中缓存的写命令发送给 slave，slave 也会同步这些数据。\",\"slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，master如果发现有多人 slave node 都来重新连接，仅仅会启动一个 rdb save 操作，用一份数据服务所有 slave node。\",\"主从复制的断点续传\",\"从Redis 2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份\",\"master node 会在内存中常见一个 backlog，master和slave都会保存一个replica offset还有一个master id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的 replica offset开始继续复制\",\"但是如果没有找到对应的offset，那么就会执行一次resynchronization\",\"无磁盘化复制\",\"master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了\",\"repl-diskless-sync repldiskless-sync-delay，等待一定时长再开始复制，因为要等更多slave重新连按过来\",\"过期 key 处理\",\"slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。\"]},\"205\":{\"h\":\"Redis 实现分布式锁\",\"t\":[\"加锁 使用 setnx 来加锁。key是锁的唯一标识，按业务来决定命名，value这里设置为test。setnx key \\\"mutex\\\"\",\"当一个线程执行 setnx 返回1，说明 key 原本不存在，该线程成功得到了锁;当一个线程执行 setnx 返回0说明 key 已经存在，该线程抢锁失败。\",\"解锁\",\"释放锁的最简单方式就是执行 del 指令。del key\",\"锁超时\",\"锁超时知道的是: 如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住。 所以，setnx 的 key 必须设置一个超时时间，以保证即使没有被显式释放，这把锁也要在一段时间后自动释放。setnx 不支持超时参数，所以需要额外指今。\",\"expire key 30\",\"如果先加锁再设置超时时间，会有原子性问题，使用SET key value [Ex seconds][px mi1iseconds] [Nx|xX]直接设置超时时间\"]},\"206\":{\"h\":\"RabbitMQ 消息队列\"},\"207\":{\"h\":\"为什么使用消息队列\",\"t\":[\"三个使用场景\",\"解耦：解耦发送消息的功能，生产的数据直接发送到 MQ，消费者直接从 MQ 里获得就行，提高灵活性\",\"异步：将一些非核心的流程，比如日志，短信，邮件通过 MQ 异步处理\",\"削峰：面对高并发情况，所有的请求都会在 MQ 中排队等待，避免压垮系统组件（比如说注册功能要写 SQL，突然有5k个请求，MySQL 每秒钟最多处理2k个，注册服务就会垮掉）\"]},\"208\":{\"h\":\"AMQP 三层协议\",\"t\":[\"Module Layer : 协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。\",\"Session Laver : 中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。\",\"TransportLaver : 最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。\"]},\"209\":{\"h\":\"RabbitMQ 构造\",\"t\":[\"image-20230823113257933\",\"生产者Publisher：生产消息，就是投递消息的一方。消息一般包含两个部分：消息体（payload）和标签（Label）\",\"消费者Consumer：消费消息，也就是接收消息的一方。消费者连接到RabbitMQ服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。\",\"*Broker服务节点：表示消息队列服务器实体。一般情况下一个Broker可以看做一个RabbitMQ服务器。\",\"*Queue：消息队列，用来存放消息。一个消息可投入一个或多个队列，多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。\",\"*Exchange：交换器，接受生产者发送的消息，根据路由键将消息路由到绑定的队列上。\",\"Routing Key： 路由关键字，用于指定这个消息的路由规则，需要与交换器类型和绑定键(Binding Key)联合使用才能最终生效。\",\"Binding：绑定，通过绑定将交换器和队列关联起来，一般会指定一个BindingKey，通过BindingKey，交换器就知道将消息路由给哪个队列了。\",\"Connection ：网络连接，比如一个TCP连接，用于连接到具体broker\",\"Channel： 信道，AMQP 命令都是在信道中进行的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接，一个TCP连接可以用多个信道。客户端可以建立多个channel，每个channel表示一个会话任务。\",\"Message：消息，由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。\",\"Virtual host：虚拟主机，用于逻辑隔离，表示一批独立的交换器、消息队列和相关对象。一个Virtual host可以有若干个Exchange和Queue，同一个Virtual host不能有同名的Exchange或Queue。最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段\"]},\"210\":{\"h\":\"消费消息的流程\",\"t\":[\"1.Producer 先连接到Broker,建立连接Connection,开启一个信道(Channel)。 2.Producer 声明一个交换器并设置好相关属性。 3.Producer 声明一个队列并设置好相关属性。 4.Producer 通过路由键将交换器和队列绑定起来。 5.Producer 发送消息到 Broker ,其中包含路由键、交换器等信息 6.相应的交换器根据接收到的路由键查找匹配的队列 7.如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。\",\"8.消费者确认收到的消息,ack。 9.RabbitMQ 从队列中删除已经确定的消息。\"]},\"211\":{\"h\":\"如何保证消息可靠性\",\"t\":[\"分三个环节保证可靠性\",\"生产者到 RabbitMQ：事务机制或者 Confirm 机制\",\"RabbitMQ 自身：持久化、集群、普通模式、镜像模式\",\"RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制\"]},\"212\":{\"h\":\"如何保证 RabbitMQ 消息队列高可用\",\"t\":[\"RabbitMQ 有三种模式: 单机模式 ，普通集群模式， 镜像集群模式\",\"单机模式:就是demo级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式\",\"普通集群模式: 意思就是在多台机器上启动多个RabbitMO实例，每人机器启动一个。\",\"镜像集群模式: 这种模式，才是所谓的 RabbitMQ 的高可用模式，跟普通集群模式不一样的是，你创建的 queue，无论元数据（元数据指 RabbitMQ 的配置数据）还是 queue 里的消息都会存在于多个实例上，然后每次你写消息到 queue 的时候，都会自动把消息到多个实例的 queue 里进行消息同步。\"]},\"213\":{\"h\":\"RabbitMQ 和kafka 区别\",\"t\":[\"RabbitMQ和Kafka是两种常用的消息队列系统，它们在设计和功能上有一些区别。下面是RabbitMQ和Kafka之间的主要区别：\",\"数据处理模式： \",\"RabbitMQ：RabbitMQ 基于传统的消息队列模型，它使用生产者-消费者模式将消息通过中间件传递。消息发布者（生产者）将消息发送到队列，然后由消息订阅者（消费者）从队列中接收和处理消息。\",\"Kafka：Kafka采用发布-订阅模型，它通过主题（topic）将消息持久化到日志文件中。消息发布者将消息写入主题的分区中，而消息订阅者可以随时从指定的偏移量开始消费消息。\",\"数据保证： \",\"RabbitMQ：RabbitMQ 提供可靠性消息传递（reliable message delivery），支持事务和消息确认机制。消费者在接收到消息后需要发送确认回执，以确保消息被正确处理。\",\"Kafka：Kafka通过分布式日志存储和复制机制来保证数据的持久性和高可用性。它将消息持久化到磁盘中，并且可以在集群中进行复制，从而避免数据丢失。\",\"消息传输延迟： \",\"RabbitMQ：RabbitMQ在传输消息时通常具有较低的延迟，适合对实时性要求较高的应用场景。\",\"Kafka：由于Kafka采用了批量写入和顺序写入的方式，一般具有较低的写入延迟，但读取消息可能会有一定的延迟。相对于RabbitMQ，Kafka更注重吞吐量和持久性。\",\"综上所述，选择RabbitMQ还是Kafka取决于具体的应用场景和需求。如果需要实时性较高、单播或广播的消息传递，可以选择RabbitMQ；如果需要大规模、高吞吐量的流式数据处理，可以选择Kafka。\"]},\"214\":{\"h\":\"为什么Kafka吞吐量高\",\"t\":[\"分布式架构：Kafka采用分布式的设计，可以将负载和数据分布到多个服务器上。这使得它可以通过横向扩展（即增加服务器数量）来提高整体吞吐量。通过增加分区和副本等方式将数据分散存储和处理，进一步提升了系统的并发性和容错性。\",\"顺序写入与零拷贝：Kafka将消息以连续的方式追加写入日志文件（log segments），实现了高效的顺序写入。这种顺序写入的方式相对于随机写入可以获得更好的磁盘性能。同时，Kafka还采用零拷贝技术，减少了数据在内核空间和用户空间之间的复制，提高了存储和检索的效率。\",\"批量发送和压缩：Kafka支持批量发送消息，即生产者可以一次性发送多条消息，减少网络开销。此外，Kafka还提供了消息压缩功能，可以在网络传输和磁盘存储上进行有效压缩，减少了数据的大小，提高网络传输和磁盘IO的效率。\",\"集群式消费和水平扩展：Kafka使用消费者组（consumer group）的方式进行消息消费。消费者组可以订阅相同的主题，每个消费者负责处理一部分分区的消息。这种集群式消费模型使得多个消费者可以并行地处理消息，从而提高吞吐量。同时，通过增加消费者或增加分区等方式，可以水平扩展系统的处理能力。\",\"高效的消息存储和检索：Kafka使用了一种基于磁盘的持久化存储方式，使得可以长时间保留大量的消息。它采用了索引和位移的方式来管理消息，可以快速地定位和检索消息。这种高效的存储和检索机制使得Kafka能够应对高吞吐量的数据流。\"]},\"215\":{\"h\":\"微服务\"},\"216\":{\"h\":\"分布式锁使用场景\",\"t\":[\"在单体项目中jvm中的锁即可完成需要，但是微服务、分布式环境下，同一个服务可能部署在多台服务器上，多个jvm之间无法通过常用的jvm锁来完成同步操作，需要借用分布式锁来完成上锁、释放锁。例如在订单服务中，我们需要根据日期来生成订单号流水，就有可能产生相同的时间日期，从而出现重复订单号。\"]},\"217\":{\"h\":\"zookeeper分布式锁实现原理\",\"t\":[\"1、zookeeper中规定，在同一时刻，不能有多个客户端创建同一个节点，我们可以利用这个特性实现分布式锁。zookeeper临时节点只在session生命周期存在，session一结束会自动销毁。\",\"2、watcher机制，在代表锁资源的节点被删除，即可以触发watcher解除阻塞重新去获取锁，这也是zookeeper分布式锁较其他分布式锁方案的一大优势。\"]},\"218\":{\"h\":\"JUC并发编程\"},\"219\":{\"h\":\"1 线程知识\"},\"220\":{\"h\":\"1.1 start() 线程开启底层\",\"t\":[\"源码分析\",\"public synchronized void start() { if (threadStatus != 0) throw new IllegalThreadStateException(); group.add(this); boolean started = false; try { start0(); // 调用了start0方法 这个方法在下面展示 started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { } } } // native关键字表示这是一个本地方法 // 底层是jvm中分配了一个线程 private native void start0(); \"]},\"221\":{\"h\":\"1.2 基础概念\"},\"222\":{\"h\":\"1.2.1 JUC是什么\",\"t\":[\"JUC是java.util.concurrent包的简称，在Java5.0添加，目的就是为了更好的支持高并发任务。让开发者进行多线程编程时减少竞争条件和死锁的问题\"]},\"223\":{\"h\":\"1.2.2 java默认有几个线程\",\"t\":[\"两个 main线程 gc线程\",\"java会调用本地方法private native void start0()来开启线程，java无法直接操作硬件\"]},\"224\":{\"h\":\"1.2.3 并发与并行的区别\",\"t\":[\"并发：多线程操作同一个资源，交替执行（CPU一核, 模拟出来多条线程，就像一般的嵌入式操作系统）\",\"并行：多个线程同时进行（CPU多核,多个线程同时进行 ; 使用线程池操作）\"]},\"225\":{\"h\":\"1.2.4 线程的6个状态\",\"t\":[\"public enum State { // 新生 NEW, // 运行 RUNNABLE, // 阻塞 BLOCKED, // 等待 WAITING, //超时等待 TIMED_WAITING, //终止 TERMINATED; } \"]},\"226\":{\"h\":\"1.2.5 wait和sleep方法的区别\",\"t\":[\"wait是Object类的方法，sleep是Thread类的方法\",\"wait会释放锁，sleep不会释放锁\",\"wait必须在同步代码块中使用，sleep可以在任何地方使用\"]},\"227\":{\"h\":\"1.2.6 守护线程\",\"t\":[\"用户线程\",\"系统工作线程\",\"守护线程\",\"一种特殊的线程，为其他线程服务比如GC垃圾回收线程\",\"守护线程作为一个服务线程，当用户线程全部结束了，java虚拟机会自动退出\",\"isDaemon()方法可以判断该线程是否为守护线程\",\"setDaemon(true)方法可以将某个线程设置为守护线程\"]},\"228\":{\"h\":\"2 CompletableFuture\"},\"229\":{\"h\":\"2.1 Future接口\",\"t\":[\"Future接口功能\",\"定义了异步任务执行的一些方法\",\"获取异步任务执行的结果\",\"取消任务的执行\",\"判断任务是否被取消\",\"判断任务是否执行完毕\"]},\"230\":{\"h\":\"2.3 FutureTask类\"},\"231\":{\"h\":\"2.3.1 FutureTask类的继承实现关系\",\"t\":[\"image-20230526102154164\"]},\"232\":{\"h\":\"2.3.2 FutureTask使用例子\",\"t\":[\"import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class CallableDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask<Integer> futureTask = new FutureTask<>(new MyThread()); new Thread(futureTask, \\\"a\\\").start(); System.out.println(futureTask.get()); } } class MyThread implements Callable<Integer> { @Override public Integer call() throws Exception { System.out.println(\\\"call()方法被调用了\\\"); return 10; } } \"]},\"233\":{\"h\":\"2.3.3 get方法\",\"t\":[\"get方法会引起阻塞，可以设置超时时间\",\"import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; import java.util.concurrent.TimeUnit; public class FutureAPIDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask<String> futureTask = new FutureTask<String>( () -> { System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----start\\\"); // 暂停 try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } return Thread.currentThread().getName() + \\\"\\\\t ----end\\\"; }); new Thread(futureTask, \\\"t1\\\").start(); System.out.println(futureTask.get()); // get方法会引起阻塞 System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----执行其他任务\\\"); } } \"]},\"234\":{\"h\":\"2.3.4 isDone轮询方法\",\"t\":[\"轮询的方式会耗费无谓的CPU资源，而且也不见得能及时地得到计算机资源\",\"如果想要异步获取结果，通常都会以轮询地方式去获取结果尽量不要阻塞\"]},\"235\":{\"h\":\"2.4 CompletableFuture优化Future\",\"t\":[\"Future接口的缺点\",\"Future接口对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果\",\"CompletableFuture的优化方法\",\"Future中get()方法会阻塞，isDone()方法容易耗费CPU资源\",\"对于真正的异步处理我们希望可以通过传入回调函数，在Future结束时自动调用该函数，这样，我们就不用等待结果。\",\"CompletableFuture提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方\",\"CompletableFuture使用场景\",\"image.png\"]},\"236\":{\"h\":\"2.5 CompletableFuture源码分析\"},\"237\":{\"h\":\"2.5.1 CompletableFuture介绍\",\"t\":[\"CompletableFuture继承实现关系\",\"image-20230526173657051\",\"常用方法\"]},\"238\":{\"h\":\"supplyAsync方法（有返回值）\",\"t\":[\"//使用默认内置线程池ForkJoinPool.commonPool()，根据supplier构建执行任务 public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier) //自定义线程，根据supplier构建执行任务 public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor) \"]},\"239\":{\"h\":\"runAsync方法\",\"t\":[\"//使用默认内置线程池ForkJoinPool.commonPool()，根据runnable构建执行任务 public static CompletableFuture<Void> runAsync(Runnable runnable) //自定义线程，根据runnable构建执行任务 public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor) \",\"上面两个方法如果不指定线程池，则默认使用ForkJoinPool.commonPool\",\"1.获取结果和触发计算\"]},\"240\":{\"h\":\"get方法\",\"t\":[\"阻塞获取结果\",\"public T get() \"]},\"241\":{\"h\":\"getNow方法\",\"t\":[\"立马获取结果，可以设置默认值，即没有得到真正结果返回的替代值\",\"public T getNow(T valueIfAbsent) \"]},\"242\":{\"h\":\"complete方法\",\"t\":[\"如果阶段没有运行完，则打断运行过程把value值作为阶段的结果\",\"public boolean complete(T value) \",\"2.对计算结果进行处理(有返回值)\"]},\"243\":{\"h\":\"thenApply方法（串行化）\",\"t\":[\"计算结果作为输入参数传给下一个阶段\",\"public <U> CompletableFuture<U> thenApply( Function<? super T,? extends U> fn) \"]},\"244\":{\"h\":\"handle方法（串行化）\",\"t\":[\"与thenApply()区别，有异常也可以继续执行，根据异常参数进一步处理\",\"public <U> CompletableFuture<U> handle( BiFunction<? super T, Throwable, ? extends U> fn) \",\"3.对计算结果进行消费(无返回值)\"]},\"245\":{\"h\":\"thenAccept方法\",\"t\":[\"消费前一个阶段的计算结果\",\"public CompletableFuture<Void> thenAccept(Consumer<? super T> action) \",\"4.执行下一阶段(无参数无返回值)\"]},\"246\":{\"h\":\"thenRun方法\",\"t\":[\"public CompletableFuture<Void> thenRun(Runnable action) \",\"5.异步方法\"]},\"247\":{\"h\":\"thenRunAsync方法\",\"t\":[\"如果不传入自定义线程池，所有阶段都用默认线程池；如果传入自定义线程池，则第一阶段用自定义线程池，之后的then异步阶段传入默认线程池ForkJoinPool（PS：有可能因为系统优化切换原则，使用main线程处理）\",\"// 查看源码可以看到 传入了一个异步线程池 public CompletableFuture<Void> thenRunAsync(Runnable action) { return uniRunStage(asyncPool, action); } // asyncPool的源码 private static final Executor asyncPool = useCommonPool ? ForkJoinPool.commonPool() : new ThreadPerTaskExecutor(); \"]},\"248\":{\"h\":\"2.5.2 CompletionStage分析\",\"t\":[\"CompletionStage接口源码\",\"//依赖单个阶段 public <U> CompletionStage<U> thenApply(Function<? super T,? extends U> fn); // 默认执行方式 public <U> CompletionStage<U> thenApplyAsync(Function<? super T,? extends U> fn);// 默认的异步执行方式 public <U> CompletionStage<U> thenApplyAsync(Function<? super T,? extends U> fn,Executor executor); //自定义的执行方式 //依赖两个阶段都完成 public <U,V> CompletionStage<V> thenCombine(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn); public <U,V> CompletionStage<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn); public <U,V> CompletionStage<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn, Executor executor); //依赖两个阶段中的任何一个完成 public <U> CompletionStage<U> applyToEither(CompletionStage<? extends T> other,Function<? super T, U> fn); public <U> CompletionStage<U> applyToEitherAsync(CompletionStage<? extends T> other,Function<? super T, U> fn); public <U> CompletionStage<U> applyToEitherAsync(CompletionStage<? extends T> other,Function<? super T, U> fn,Executor executor); \",\"CompletionStage接口源码demo\",\"package ymkedu.auc; import org.junit.jupiter.api.Test; import java.util.concurrent.*; public class CompletableFutureDemo { // 前一个阶段执行完才能执行下一个阶段 @Test public void thenApply() throws ExecutionException, InterruptedException { CompletableFuture<String> stage = CompletableFuture.supplyAsync(() -> \\\"hello\\\") .thenApply(s -> s + \\\" world\\\"); String result = stage.get(); System.out.println(result); } // 两个阶段都完成才能输出结果 @Test public void thenCombine() { String result = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } return \\\"hello\\\"; }).thenCombine(CompletableFuture.supplyAsync(() -> { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } return \\\"world\\\"; }), (s1, s2) -> s1 + \\\" \\\" + s2).join(); System.out.println(result); } // 两个阶段谁先完成就输出结果 @Test public void applyToEither() { String result = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } return \\\"Tom\\\"; }).applyToEither(CompletableFuture.supplyAsync(() -> { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } return \\\"John\\\"; }), s -> \\\"hello \\\" + s).join(); System.out.println(result); } } \",\"thenCombine作业\",\"@Test public void thenCombine() { String result = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } return \\\"hello\\\"; }).thenCombine(CompletableFuture.supplyAsync(() -> { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } return \\\"world\\\"; }), (s1, s2) -> s1 + \\\" \\\" + s2).thenCombine((CompletableFuture.supplyAsync(() -> { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } return \\\"then combine\\\"; })), (a, b) -> a + b).join(); System.out.println(result); } \"]},\"249\":{\"h\":\"2.5.3 CompletableFuture使用例子\",\"t\":[\"import java.util.concurrent.*; public class CompletableFutureUse { public static void main(String[] args) { ExecutorService threadPool = Executors.newFixedThreadPool(3); try { CompletableFuture.supplyAsync(() -> { System.out.println(Thread.currentThread().getName() + \\\"----start\\\"); int res = ThreadLocalRandom.current().nextInt(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return res; }, threadPool).whenComplete((v, e) -> { if (e == null) { System.out.println(\\\"----计算完成 结果为 -> \\\" + v); } }).exceptionally((e) -> { System.out.println(\\\"----异常 -> \\\" + e.getMessage()); return null; }); } finally { // 自定义的线程池 记得要关闭 threadPool.shutdown(); } System.out.println(\\\"----main线程\\\"); } } \"]},\"250\":{\"h\":\"2.6 函数式编程\"},\"251\":{\"h\":\"2.6.1 函数式接口\",\"t\":[\"Runnable接口(无参数无返回值)\",\"@FunctionalInterface public interface Runnable { public abstract void run(); } \",\"Function<T, R>\",\"@FunctionalInterface public interface Function<T, R> { R apply(T t); default <V> Function<V, R> compose(Function<? super V, ? extends T> before) { Objects.requireNonNull(before); return (V v) -> apply(before.apply(v)); } default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) { Objects.requireNonNull(after); return (T t) -> after.apply(apply(t)); } static <T> Function<T, T> identity() { return t -> t; } } \",\"Consumer<T>\",\"@FunctionalInterface public interface Consumer<T> { void accept(T t); default Consumer<T> andThen(Consumer<? super T> after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } \",\"Supplier\",\"@FunctionalInterface public interface Supplier<T> { T get(); } \"]},\"252\":{\"h\":\"2.6.2 链式编程\",\"t\":[\"一个简单的例子\",\"import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import lombok.experimental.Accessors; public class CompletableFutureMall { public static void main(String[] args) { Student student = new Student(); // 传统赋值 student.setId(1); student.setName(\\\"ZhangSan\\\"); student.setMajor(\\\"Math\\\"); // 链式 student.setId(2).setName(\\\"LiSi\\\").setMajor(\\\"English\\\"); } } @Data @NoArgsConstructor @AllArgsConstructor @Accessors(chain = true) class Student { private Integer id; private String name; private String major; } \",\"链式编程原理\",\"返回类型与当前变量类型相同，或者直接返回this\"]},\"253\":{\"h\":\"2.6.3 join与get对比\",\"t\":[\"join()与get()的区别，join()不会报异常\",\"import java.util.concurrent.CompletableFuture; public class CompletableFutureMall { public static void main(String[] args) { CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> { return \\\"hello\\\"; }); // System.out.println(completableFuture.get()); System.out.println(completableFuture.join()); } } \"]},\"254\":{\"h\":\"2.7 例子：电商网站比价\"},\"255\":{\"h\":\"2.7.1 需求\",\"t\":[\"同一款产品，同时搜索出各个电商平台的售价\",\"同一款产品，同时搜索出在同一个平台的所有卖家的售价\",\"输出结果返回一个List<String>\"]},\"256\":{\"h\":\"2.7.2 demo\",\"t\":[\"import lombok.*; import java.util.Arrays; import java.util.List; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ThreadLocalRandom; import java.util.concurrent.TimeUnit; import java.util.stream.Collectors; public class CompletableFutureMall { static List<NetMall> netMalls = Arrays.asList( new NetMall(\\\"jd\\\"), new NetMall(\\\"taobao\\\"), new NetMall(\\\"dangdang\\\"), new NetMall(\\\"pdd\\\") ); public static List<String> getPrice(List<NetMall> netMalls, String productName) { return netMalls .stream() .map(netMall -> String.format(productName + \\\"in %s price is %.2f\\\", netMall.getNetMallName(), netMall.calcPrice(productName))) .collect(Collectors.toList()); } public static List<String> getPriceByCompletableFuture(List<NetMall> netMalls, String productName) { return netMalls .stream() .map(netMall -> CompletableFuture.supplyAsync(() -> String.format(productName + \\\"in %s price is %.2f\\\", netMall.getNetMallName(), netMall.calcPrice(productName)))) .collect(Collectors.toList()) .stream() .map(s -> s.join()) .collect(Collectors.toList()); } public static void main(String[] args) { long startTime = System.currentTimeMillis(); System.out.println(getPrice(netMalls, \\\"mysql\\\")); long endTime = System.currentTimeMillis(); System.out.println(\\\"运行消耗 \\\" + (endTime - startTime) + \\\" 毫秒\\\"); startTime = System.currentTimeMillis(); System.out.println(getPriceByCompletableFuture(netMalls, \\\"mysql\\\")); endTime = System.currentTimeMillis(); System.out.println(\\\"运行消耗 \\\" + (endTime - startTime) + \\\" 毫秒\\\"); } } @Data @NoArgsConstructor @AllArgsConstructor class NetMall { private String netMallName; public double calcPrice(String productName) { // 假设计算需要1s try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return ThreadLocalRandom.current().nextDouble() * 2 + productName.charAt(0); } } \"]},\"257\":{\"h\":\"3 多线程锁\"},\"258\":{\"h\":\"3.1 乐观锁悲观锁\",\"t\":[\"悲观锁\",\"介绍：认为自己在使用数据的时候一定有别的线程来修改数据，因此在获得数据的时候会先加锁，确保数据不会被别的线程修改\",\"使用场景：适合写操作多的场景\",\"例子：synchronized关键字和Lock的实现类都是悲观锁\",\"乐观锁\",\"介绍：认为自己在使用数据的时候不会有别的线程来修改数据，不会添加锁\",\"如果这个数据在操作过程中没有更新，则当前线程修改的数据成功写入\",\"如果这个数据被其他线程更新，则根据不同的实现方式执行不同的操作，比如放弃更改，重试抢锁等\",\"使用场景：适合读操作多的场景，\",\"例子：版本号机制Version，CAS算法\"]},\"259\":{\"h\":\"3.2 传统synchronized\",\"t\":[\"synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：\",\" 1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是**大括号{}括起来的代码**，作用的对象是**调用这个代码块的对象**； 2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是**整个方法**，作用的对象是**调用这个方法的对象**； 3. 修饰一个静态的方法，其作用的范围是**整个静态方法**，作用的对象是**这个类的所有对象**； 4. 修饰一个类，其作用的范围是**synchronized后面括号括起来的部分**，作用主的对象是**这个类的所有对象**。 \"]},\"260\":{\"h\":\"3.3 Synchronized分析\",\"t\":[\"面试题：为什么任何一个对象都可以变成一个锁\",\"首先，Java中的每个对象都派生自Object类，而每个Java Object在JVM内部都有一个native的C++对象 oop/oopDesc进行对应。\",\"线程在获取锁的时候，实际上就是获得一个监视器对象(monitor) ,monitor可以认为是一个同步对象，所有的Java对象是天生携带monitor。在hotspot源码的 markOop.hpp文件中，可以看到下面这段代码。\",\"ObjectMonitor* monitor() const { assert(has_monitor(), \\\"check\\\"); return (ObjectMonitor*) (value() ^ monitor_value); } \",\"多个线程访问同步代码块时，相当于去争抢对象监视器修改对象中的锁标识,上面的代码中ObjectMonitor这个对象和线程争抢锁的逻辑有密切的关系\"]},\"261\":{\"h\":\"3.4 Synchronized 和 Lock 的区别\",\"t\":[\"Synchronized 内置java关键字，Lock 是一个java类\",\"Synchronized 无法判断获取锁的状态\",\"Synchronized 会自动释放锁，Lock 必须手动释放锁\",\"Synchronized 非公平锁 其他线程会死等\",\"Synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码\"]},\"262\":{\"h\":\"3.5 公平锁和非公平锁\",\"t\":[\"公平锁\",\"多个线程按照申请锁的顺序获取锁\",\"非公平锁\",\"不按照申请锁的顺序获取锁\",\"面试题\",\"为什么会有公平锁/非公平锁，为什么默认非公平\",\"恢复挂起的线程到真正锁的获取还是有时间差的，非公平锁能更充分的利用CPU时间片，减少CPU的空闲状态时间\",\"什么时候用公平锁？什么时候用非公平锁？\",\"使用多线程很重点的考量点是切换线程的开销，当采用非公平锁时，当一个线程请求获取锁的同步状态，然后释放同步状态，所以刚释放的锁的线程在此刻再次获取同步状态的概率就非常大，减少了线程开销\",\"买票小程序Demo\",\"import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class SaleTicketDemo { public static void main(String[] args) { Ticket ticket = new Ticket(); new Thread(() -> { for (int i = 0; i < 40; i++) ticket.sale(); }, \\\"a\\\").start(); new Thread(() -> { for (int i = 0; i < 40; i++) ticket.sale(); }, \\\"b\\\").start(); new Thread(() -> { for (int i = 0; i < 40; i++) ticket.sale(); }, \\\"c\\\").start(); } } class Ticket { private int ticketNum = 30; private Lock lock = new ReentrantLock(true); // 无参数默认非公平锁 public void sale() { lock.lock(); try { if (this.ticketNum > 0) { System.out.println(Thread.currentThread().getName() + \\\"购得第\\\" + (ticketNum--) + \\\"张票，剩余\\\" + ticketNum + \\\"张\\\"); } // 增加错误发生的概率 Thread.sleep(10); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } } \"]},\"263\":{\"h\":\"3.6 可重入锁（递归锁）\",\"t\":[\"介绍\",\"是指同一个线程在外层方法获取锁的时候，再进入该线程的内层方法（同一个锁）会自动获取锁，不会因为外层已经获取的锁没有释放而阻塞。（Synchronized关键字和ReentrantLock都是可重入锁）\",\"可重入锁种类\",\"隐式锁（Synchronized关键字使用的锁）\",\"public class ReEntryLockDemo { public static void main(String[] args) { final Object o = new Object(); new Thread(() -> { synchronized (o) { System.out.println(\\\"1层\\\"); synchronized (o) { System.out.println(\\\"2层\\\"); synchronized (o) { System.out.println(\\\"3层\\\"); } } } }, \\\"thread1\\\").start(); } } // 结果 //1层 //2层 //3层 \",\"显式锁（Lock类）\"]},\"264\":{\"h\":\"3.7 死锁\",\"t\":[\"造成死锁的原因\",\"1.系统资源不足，比如锁再被占用时\",\"检测死锁\",\"在终端中\",\"线用jps -l查找我们需要排查的线程\",\"根据线程号使用jstack 线程号来查找死锁\",\"使用jconsole\",\"通过win+r打开运行，输入jconsole打开java控制台\",\"image-20230605144910144\"]},\"265\":{\"h\":\"4 中断机制\"},\"266\":{\"h\":\"4.1 线程中断机制\"},\"267\":{\"h\":\"4.1.1 什么是中断机制\",\"t\":[\"首先，一个线程不应该由其他线程来中断或停止，所以Thread. stop, Thread.suspend, Thread.resume这些方法都被废弃了\",\"其次，java提供了一个停止线程的协商机制---中断，中断需要程序员自己实现\",\"若要中断一个线程，首先调用interupt方法，此时线程中断标志位被置为1，应该在该线程内部实现一个判断interupted方法是否已被中断，然后自行了断。\"]},\"268\":{\"h\":\"4.1.2 面试题\",\"t\":[\"如何停止中断运行中的线程\",\"import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class InterruptDemo { static volatile boolean isStop = false; public static void main(String[] args) { ExecutorService pool = Executors.newFixedThreadPool(5); CompletableFuture<Void> future = CompletableFuture.runAsync(() -> { System.out.println(Thread.currentThread().getName() + \\\"----start\\\"); while (true) { if (isStop) { System.out.println(Thread.currentThread().getName() + \\\"结束\\\"); break; } System.out.println(\\\"hello volatile\\\"); } }, pool); CompletableFuture<Void> future2 = CompletableFuture.runAsync(() -> { System.out.println(Thread.currentThread().getName() + \\\"----start\\\"); // 延迟3秒后 停止上面的线程 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \\\"申请停止线程\\\"); isStop = true; }, pool); } } \",\"import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicBoolean; public class InterruptDemo { // 使用atomic布尔值同样可以 static AtomicBoolean aBoolean = new AtomicBoolean(false); public static void main(String[] args) { ExecutorService pool = Executors.newFixedThreadPool(5); CompletableFuture<Void> future = CompletableFuture.runAsync(() -> { System.out.println(Thread.currentThread().getName() + \\\"----start\\\"); while (true) { if (aBoolean.get()) { System.out.println(Thread.currentThread().getName() + \\\"结束\\\"); break; } System.out.println(\\\"hello atomic\\\"); } return; }, pool); CompletableFuture<Void> future2 = CompletableFuture.runAsync(() -> { System.out.println(Thread.currentThread().getName() + \\\"----start\\\"); // 延迟3秒后 停止上面的线程 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \\\"申请停止线程\\\"); aBoolean.set(true); return; }, pool); } } \",\"import java.util.concurrent.TimeUnit; public class InterruptDemo { public static void main(String[] args) { // 判断中断标志位是否置1 Thread thread = new Thread(() -> { System.out.println(Thread.currentThread().getName() + \\\"----start\\\"); while (true) { if (Thread.currentThread().isInterrupted()) { System.out.println(Thread.currentThread().getName() + \\\"结束\\\"); break; } System.out.println(\\\"hello atomic\\\"); } return; }, \\\"thread1\\\"); thread.start(); new Thread(() -> { System.out.println(Thread.currentThread().getName() + \\\"----start\\\"); // 延迟3秒后 停止上面的线程 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \\\"申请停止线程\\\"); thread.interrupt(); return; }, \\\"thread2\\\").start(); } } \"]},\"269\":{\"h\":\"5 LockSupport\"},\"270\":{\"h\":\"5.1 介绍\",\"t\":[\"LockSupport用于创建锁和其他同步类的基本线程阻塞原语，就是对线程等待唤醒机制的优化\",\"park()阻塞线程\",\"unpark()解除阻塞\"]},\"271\":{\"h\":\"5.2 等待唤醒线程的三种方法\",\"t\":[\"使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程\",\"public class LockSupportDemo { public static void main(String[] args) { Object objectLock = new Object(); new Thread(() -> { synchronized (objectLock) { System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----come in\\\"); try { objectLock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----被唤醒\\\"); } }, \\\"t1\\\").start(); new Thread(() -> { synchronized (objectLock) { System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----come in\\\"); objectLock.notify(); System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----发出通知\\\"); } }, \\\"t2\\\").start(); } } \",\"使用JUC包中的Condition的await()方法让线程等待，使用signal()方法唤醒线程\",\"public class LockSupportDemo { public static void main(String[] args) { Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); new Thread(() -> { lock.lock(); System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----come in\\\"); try { condition.await(); System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----被唤醒\\\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }, \\\"t1\\\").start(); new Thread(() -> { lock.lock(); System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----come in\\\"); try { condition.signal(); System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----发出通知\\\"); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } }, \\\"t2\\\").start(); } } \",\"LockSupport类park()和unpark()\",\"public class LockSupportDemo { public static void main(String[] args) { Thread t1 = new Thread(() -> { System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----come in\\\"); LockSupport.park(); System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----被唤醒\\\"); }, \\\"t1\\\"); t1.start(); new Thread(() -> { System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----come in\\\"); LockSupport.unpark(t1); System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----发出通知\\\"); }, \\\"t2\\\").start(); } } \",\"**支持先唤醒后等待 **park方法消耗许可证 unpark方法增加凭证 同一时间最多只有一个凭证累加无效\"]},\"272\":{\"h\":\"6 JAVA内存模型JMM\"},\"273\":{\"h\":\"6.1 带着问题学习\",\"t\":[\"JMM与Volatile之间的关系\",\"JMM有哪些特性和它的三大特征\",\"原子性、可见性、有序性\",\"JMM为什么会出现，作用和功能是什么\",\"屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。\",\"happens-before先行发生原则\"]},\"274\":{\"h\":\"6.2 计算机硬件存储体系\",\"t\":[\"CPU在运行时，会首先从内存中取出运算指令，然后解码并确定其类型和操作数，最后执行该指令。在指令执行完毕后，CPU会将计算所得数据写入内存。\",\"然而，在计算机系统中存在一个CPU的运算速度与内存读写速度不匹配的问题，即CPU的运算速度远比内存的读写速度快。由于读写速度缓慢，严重拖累了计算机的运行效率。为了解决这一问题，现代计算机系统在CPU与内存之间加入了一层或多层高速缓存，而高速缓存的读写速度与CPU的运算速度几乎相当。在加入高速缓存后，CPU在执行指令前，需要先将要运算的数据从内存读取（即复制）到高速缓存中，接着CPU对数据进行处理，然后再将运算后的数据写入到高速缓存，最后再从缓存同步回内存中。\",\"在多CPU的系统中，每个处理器都有自己的高速缓存，而它们又共享同一个主内存，如下图。当多个处理器的运算任务都涉及到同一块主内存区域时，将可能导致各自缓存数据不一致的问题。例如，处理器1与处理器2都从主内存读取了同一个数据分别存储到自己的高速缓存区域，然后，两个处理器都对这一数据进行了修改。那么再同步回主内存的时候应该以哪条数据为准呢？这一问题就是缓存一致性问题。为了解决缓存一致性问题，需要遵循缓存一致性协议。\"]},\"275\":{\"h\":\"6.3 Java内存模型Java Memory Model\"},\"276\":{\"h\":\"6.4 JMM规范下 三大特性\"},\"277\":{\"h\":\"6.4.1 可见性\",\"t\":[\"当一个线程修改了某一个共享变量的值，其他线程能够立即知道，JMM规定线程间变量值的传递需要通过主内存来完成。每个线程在自己的工作内存中有个操作变量的副本。\"]},\"278\":{\"h\":\"6.4.2 有序性\",\"t\":[\"对于一个线程内代码的执行并不一定是从上到下有序执行，为了提升性能，编译器和处理器会对指令序列进行重排序。\",\"问题：JVM可一个根据处理器特性对机器指令重排。但是指令重排可一个保证单线程的语义一致，但是多线程间可能产生问题。\",\"方法：在重排序时需考虑指令之间的依赖性\"]},\"279\":{\"h\":\"6.5 JMM规范下 多线程对变量的独写过程\",\"t\":[\"JMM规定所有变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了被线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。不同线程之间也无法直接访问对方的工作内存中的变量，线程间变量值的传递需要通过主内存来完成。\"]},\"280\":{\"h\":\"6.6 JMM规范下 多线程先行发生原则之happens-before\",\"t\":[\"在JMM中，如果一个操作执行的结果需要对另一个操作可见性，或者代码重排序，那么这两个操作之间必须存在happens-before(先行发生)原则。\"]},\"281\":{\"h\":\"6.6.1 次序规则\",\"t\":[\"写后读\"]},\"282\":{\"h\":\"6.6.2 锁定规则\",\"t\":[\"一个unlock操作先行发生于lock之后\"]},\"283\":{\"h\":\"6.6.3 volatile变量规则\",\"t\":[\"对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的\"]},\"284\":{\"h\":\"6.6.4 传递规则\",\"t\":[\"如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\"]},\"285\":{\"h\":\"6.6.5 线程启动规则\",\"t\":[\"Thread对象的start()方法先行发生于此线程的每一个动作\"]},\"286\":{\"h\":\"6.6.6 线程中断规则\",\"t\":[\"先用interupt()方法调用先行发生于interrupted()之前\"]},\"287\":{\"h\":\"6.6.7 线程终止规则\",\"t\":[\"线程中的所有操作都先行发生于对此线程的终止检测，isAlive()检测线程是否终止执行\"]},\"288\":{\"h\":\"6.6.8 对象终结规则\",\"t\":[\"一个对象的初始化完成(构造函数执行结束)，先行发生于它的finalize()方法的开始\"]},\"289\":{\"h\":\"7 Volatile与JMM\"},\"290\":{\"h\":\"7.1 内存屏障\",\"t\":[\"内存屏障是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有独写操作都执行后才可以开始执行此点之后的操作。\",\"Java内存模型的排序规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。\"]},\"291\":{\"h\":\"7.2 Volatile保证可见性\",\"t\":[\"当两个线程共用一个共享变量时，如果其中一个线程修改了这个共享变量的值。但是由于另外一个线程在自己的工作内存中已经保留了一份该共享变量的副本，因此它无法感知该变量的值已经被修改\",\"public class VolatileDemo { private static boolean ready; public static class MyThread extends Thread { @Override public void run() { System.out.println(\\\"MyThread is running...\\\"); while (!ready) ; // 如果ready为false，则死循环 System.out.println(\\\"MyThread is end\\\"); } } public static void main(String[] args) throws InterruptedException { new MyThread().start(); Thread.sleep(1000); ready = true; System.out.println(\\\"ready = \\\" + ready); Thread.sleep(5000); System.out.println(\\\"main thread is end.\\\"); } } \",\"上面这个例子子线程就感知不到ready的变化，当把ready改为Volatile关键字后就能够感知\"]},\"292\":{\"h\":\"7.3 Volatile保证有序性\",\"t\":[\"编译器为了优化程序性能，可能会在编译时对字节码指令进行重排序。重排序后的指令在单线程中运行时没有问题的，但是如果在多线程中，重排序后的代码则可能会出现问题。因此，一般在多线程并发情况下我们都应该禁止指令重排序的优化。而volatile关键字就可以禁止编译器对字节码进行重排序。\",\"public class DoubleCheckLock { private volatile static DoubleCheckLock instance; private DoubleCheckLock(){} public static DoubleCheckLock getInstance(){ //第一次检测 if (instance==null){ //同步 synchronized (DoubleCheckLock.class){ if (instance == null){ //多线程环境下可能会出现问题的地方 instance = new DoubleCheckLock(); } } } return instance; } } \",\"上面是一个经典的例子 双重校验锁\"]},\"293\":{\"h\":\"7.4 Volatile不能保证原子性\",\"t\":[\"对于原子操作，volatile关键字是无能为力的。如果需要保证原子操作，则需要使用synchronized关键字、Lock锁 或者Atom相关类来确保操作的原子性。\"]},\"294\":{\"h\":\"8 CAS机制\"},\"295\":{\"h\":\"8.1 CAS是什么 解决了什么问题\",\"t\":[\"没有CAS时怎么保证数据的原子性\",\"写入共享数据时 加锁保证原子性\",\"使用CAS后\",\"使用原子类AtomicInteger\",\"悲观锁与乐观锁（阻塞与非阻塞）\",\"悲观锁认为更新数据时，大概率会有其他线程来争抢，所以第一个获取到资源的线程会将资源锁定起来，即其他没有获取到资源的线程会阻塞。synchronized就是java中悲观锁的典型实现\",\"乐观锁认为不会有线程来争抢，所以更新数据的时候不会对共享数据加锁。但是在正式更新数据之前会检查数据是否被其他线程改变过，如果未被其他线程改变过就将共享变量更新成最新值，如果发现共享变量已经被其他线程更新过了，就重试，直到成功为止。CAS机制就是乐观锁的典型实现。\",\"CAS是什么\",\"compare and swap 比较并交换\",\"包含三个操作数--内存位置、预期原值、更新值\",\"执行CAS操作时（写入），将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值；如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功\",\"CAS底层原理\",\"非阻塞原子性操作，通过硬件保证了CAS的原子性。所以效率更高，且更可靠。\",\"底层为一条CPU原子指令（cmpxchg指令），Java提供的CAS操作类--Unsafe\"]},\"296\":{\"h\":\"8.2 Unsafe类\",\"t\":[\"CAS核心类，提供操作特定内存数据的方法\",\"调用Unsafe类的CAS方法，JVM会编译出汇编指令，且这是一条CPU原子指令，执行是连续的，不会导致数据不一致问题。\"]},\"297\":{\"h\":\"8.3 AtomicReference类（对象的原子操作类）\",\"t\":[\"AtomicReference和AtomicInteger非常类似，不同之处就在于AtomicInteger是对整数的封装，而AtomicReference则对应普通的对象引用。也就是它可以保证你在修改对象引用时的线程安全性。\",\"AtomicReference是作用是对”对象”进行原子操作。 提供了一种读和写都是原子性的对象引用变量。原子意味着多个线程试图改变同一个AtomicReference(例如比较和交换操作)将不会使得AtomicReference处于不一致的状态。\",\"import lombok.AllArgsConstructor; import lombok.Data; import org.junit.jupiter.api.Test; import java.util.concurrent.atomic.AtomicReference; @AllArgsConstructor @Data class User { String name; int age; } public class AtomicDemo { @Test public void testAtomicReference() { AtomicReference<User> atomicReference = new AtomicReference<>(); User z3 = new User(\\\"z3\\\", 22); User l4 = new User(\\\"l4\\\", 23); atomicReference.set(z3); System.out.println(atomicReference.compareAndSet(z3, l4)); System.out.println(atomicReference.get().toString()); } } \"]},\"298\":{\"h\":\"8.4 CAS手写自旋锁\",\"t\":[\"/** * 实现一个自旋锁：循环获取锁不会阻塞 * A线程先进来调用lock方法锁5秒钟，B随后进来发现当前线程持有锁，自旋等待 */ class SpinLockDemo { AtomicReference<Thread> atomicReference = new AtomicReference<>(); public void lock() { Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----come in\\\"); while (!atomicReference.compareAndSet(null, thread)) { } System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----get lock\\\"); } public void unlock() { Thread thread = Thread.currentThread(); atomicReference.compareAndSet(thread, null); System.out.println(Thread.currentThread().getName() + \\\"\\\\t ----unlock\\\"); } @Test public void testSpinLockDemo() { SpinLockDemo demo = new SpinLockDemo(); new Thread(() -> { demo.lock(); try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } demo.unlock(); }, \\\"A\\\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -> { demo.lock(); demo.unlock(); }, \\\"B\\\").start(); try { TimeUnit.SECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } } \"]},\"299\":{\"h\":\"8.5 CAS的缺点\",\"t\":[\"1. ABA问题 ABA问题：CAS在操作的时候会检查变量的值是否被更改过，如果没有则更新值，但是带来一个问题，最开始的值是A，接着变成B，最后又变成了A。经过检查这个值确实没有修改过，因为最后的值还是A，但是实际上这个值确实已经被修改过了。为了解决这个问题，在每次进行操作的时候加上一个版本号，每次操作的就是两个值，一个版本号和某个值，A——>B——>A问题就变成了1A——>2B——>3A。在jdk中提供了AtomicStampedReference类解决ABA问题，用Pair这个内部类实现，包含两个属性，分别代表版本号和引用，在compareAndSet中先对当前引用进行检查，再对版本号标志进行检查，只有全部相等才更新值。\",\"2. 可能会消耗较高的CPU 看起来CAS比锁的效率高，从阻塞机制变成了非阻塞机制，减少了线程之间等待的时间。每个方法不能绝对的比另一个好，在线程之间竞争程度大的时候，如果使用CAS，每次都有很多的线程在竞争，也就是说CAS机制不能更新成功。这种情况下CAS机制会一直重试，这样就会比较耗费CPU。因此可以看出，如果线程之间竞争程度小，使用CAS是一个很好的选择；但是如果竞争很大，使用锁可能是个更好的选择。在并发量非常高的环境中，如果仍然想通过原子类来更新的话，可以使用AtomicLong的替代类：LongAdder。\",\"3. 不能保证代码块的原子性 Java中的CAS机制只能保证共享变量操作的原子性，而不能保证代码块的原子性。\"]},\"300\":{\"h\":\"8.6 缺点改进\",\"t\":[\"改进ABA问题\",\"AtomicStampedReference版本号 时间戳\",\"@Data @AllArgsConstructor class Book { private int id; private String name; } public class ABADemo { public static void main(String[] args) { Book jdk = new Book(1, \\\"jdk\\\"); AtomicStampedReference<Book> stampedReference = new AtomicStampedReference<>(jdk, 1); System.out.println(stampedReference.getReference() + \\\"\\\\t\\\" + stampedReference.getStamp()); Book mysql = new Book(1, \\\"mysql\\\"); boolean b = stampedReference.compareAndSet(jdk, mysql, stampedReference.getStamp(), stampedReference.getStamp() + 1); System.out.println(b + \\\"\\\\t\\\" + stampedReference.getReference() + \\\"\\\\t\\\" + stampedReference.getStamp()); } } \"]},\"301\":{\"h\":\"10 ThreadLocal\"},\"302\":{\"h\":\"10.1 问题\",\"t\":[\"ThreadLocal中ThreadlocalMap的数据结构和关系?\",\"ThreadLocal的key是弱引用，这是为什么?\",\"ThreadLocal内存泄露问题你知道吗?\",\"ThreadLocal中最后为什么要加remove方法?\"]},\"303\":{\"h\":\"10.2 ThreadLocal是什么\",\"t\":[\"ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程访问ThreadLocal实例时，都有一个自己的副本（JMM）。\",\"ThreadLocal的目的是希望将状态（用户ID 事务ID）与各自的线程相关联。\"]},\"304\":{\"h\":\"10.3 API与调用\",\"t\":[\"变量和类型\",\"方法\",\"描述\",\"T\",\"get()\",\"返回当前线程的此线程局部变量副本中的值。\",\"protected T\",\"initialValue()\",\"返回此线程局部变量的当前线程的“初始值”。\",\"void\",\"remove()\",\"删除此线程局部变量的当前线程值。\",\"void\",\"set(T value)\",\"将此线程局部变量的当前线程副本设置为指定值。\",\"static <S> ThreadLocal<S>\",\"withInitial(Supplier<? extends S> supplier)\",\"创建一个线程局部变量。\",\"public static void main(String[] args) { ThreadLocal<Integer> threadLocal = new ThreadLocal<>(); new Thread(() -> { threadLocal.set(10); try { Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \\\" value = \\\" + threadLocal.get()); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); try { Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \\\" value = \\\" + threadLocal.get()); } catch (InterruptedException e) { e.printStackTrace(); } } \",\"结果\",\"Thread-0 value = 10 main value = null \",\"可以看到，我们在子线程中通过ThreadLocal存储了一个10，则子线程中可以取到这个值。而主线程中取到的却是null。这意味着通过某个线程通过ThreadLocal存储的数据，只有在这个线程中才能访问的到。\"]},\"305\":{\"h\":\"10.4 ThreadLocal的实现原理\"},\"306\":{\"h\":\"10.4.1 set方法\",\"t\":[\"public void set(T value) { // 获取当前线程 Thread t = Thread.currentThread(); // 获取线程中的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) { // 将值存储到ThreadLocalMap中 map.set(this, value); } else { // 创建ThreadLocalMap，并存储值 createMap(t, value); } } void createMap(Thread t, T firstValue) { // 实例化当前线程中的ThreadLocalMap t.threadLocals = new ThreadLocalMap(this, firstValue); } \",\"上述代码首先获取到了当前线程，然后从当前线程中获取ThreadLocalMap，ThreadLocalMap是一个存储K-V的集合，我们后边分析。如果此时ThreadLocalMap不为空，那么就通过ThreadLocalMap的set方法将值存储到当前线程对应的ThreadLocalMap中。如果ThreadLocalMap为空，那么就创建ThreadLcoalMap，然后将值存储到ThreadLocalMap中。并且，这里我们注意到ThreadLocalMap的key是当前的ThreadLocal。\"]},\"307\":{\"h\":\"10.4.2 get方法\",\"t\":[\"public T get() { // 获取当前线程 Thread t = Thread.currentThread(); // 获取当前线程对应的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) { // 从ThreadLocalMap中取出值 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\\\"unchecked\\\") T result = (T)e.value; return result; } } // 如果值为空则返回初始值 return setInitialValue(); } // 为ThreadLocal设置初始值 private T setInitialValue() { // 初始值为null T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { map.set(this, value); } else { // 创建ThreadLocalMap createMap(t, value); } if (this instanceof TerminatingThreadLocal) { TerminatingThreadLocal.register((TerminatingThreadLocal<?>) this); } return value; } // 初始值为空 protected T initialValue() { return null; } \",\"get方法依然是先获取到当前线程，然后拿到当前线程的ThreadLocalMap，并通过ThreadLocalMap的getEntry方法将这个ThreadLocal作为key来取值。如果ThreadLocalMap为null，则会通过setInitialValue方法返回了一个null值。\"]},\"308\":{\"h\":\"10.4.3 ThreadLocalMap（关键）\",\"t\":[\"ThreadLocalMap是一个存储K-V类型的数据结构，并且Thread类中维护了一个ThreadLocalMap的成员变量\",\"public class Thread implements Runnable { ThreadLocal.ThreadLocalMap threadLocals = null; // ... } \"]},\"309\":{\"h\":\"13 AQS队列同步器-AbstractQueuedSynchronizer\"},\"310\":{\"h\":\"13.1 问题\",\"t\":[\"什么是AQS，它有什么作用，核心思想是什么\",\"AQS独占锁和共享锁的原理，AQS提供的是公平锁还是非公平锁\",\"AQS在java中有哪些实现类\",\"AQS除了锁框架外还提供什么能力\"]},\"311\":{\"h\":\"13.2 AQS简介\",\"t\":[\"AbstractQueuedSynchronizer(AQS)提供了一套可用于实现锁同步机制的框架，不夸张地说，AQS是JUC同步框架的基石。AQS通过一个FIFO队列维护线程同步状态，实现类只需要继承该类，并重写指定方法即可实现一套线程同步机制。\",\"AQS根据资源互斥级别提供了独占和共享两种资源访问模式；同时其定义Condition结构提供了wait/signal等待唤醒机制。在JUC中，诸如ReentrantLock、CountDownLatch等都基于AQS实现。\"]},\"312\":{\"h\":\"13.3 AQS原理\",\"t\":[\"AQS是依赖内部的同步队列实现，也就是FIFO双向队列，如果当前线程竞争锁失败，那么AQS会把当前线程以及等待状态封装成一个Node节点加入到同步队列中（addWaiter()方法），同时阻塞该线程，当同步状态释放时，会把首节点唤醒，使其再次尝试获取同步状态。\",\"image-20230710214419984\",\"其中Node节点的结构如下：\",\"static final class Node { /** 表示节点正在以共享模式等待的标记 */ static final Node SHARED = new Node(); /** 表示节点正在以独占模式等待的标记 */ static final Node EXCLUSIVE = null; /** 等待状态，表示线程已取消 */ static final int CANCELLED = 1; /** 等待状态，表示后继节点的线程需要唤醒 */ static final int SIGNAL = -1; /** 等待状态，表示线程正在等待条件 */ static final int CONDITION = -2; /** * 等待状态，表示下一个acquireShared操作应该无条件地传播 */ static final int PROPAGATE = -3; /** * 状态字段，只能取以下值之一： * SIGNAL: 后继节点（即将）被阻塞（通过park方法），所以当前节点必须在释放或取消时唤醒其后继节点。 * 为了避免竞争，acquire方法首先必须表明它们需要一个信号量，然后重试原子性的acquire操作， * 在失败时进行阻塞。 * CANCELLED: 由于超时或中断，此节点被取消。节点永远不会离开此状态。 * 特别地，带有被取消节点的线程永远不会再次被阻塞。 * CONDITION: 此节点目前位于条件队列上。 * 它不会被用作同步队列节点，直到被转移时，此时状态将设置为0。 * （此处使用该值与字段的其他用途无关，但简化了机制。） * PROPAGATE: 应该将releaseShared传播到其他节点。仅在doReleaseShared中为头节点设置， * 以确保传播继续，即使其他操作已经介入。 * 0: 上述都不是 * * 值按数字顺序排列，以简化使用。非负值表示节点不需要信号量。 * 因此，大多数代码不需要检查特定的值，只需检查符号即可。 * * 对于普通同步节点，该字段被初始化为0；对于条件节点，该字段被初始化为CONDITION。 * 它使用CAS进行修改（或在可能时使用无条件的volatile写操作）。 */ volatile int waitStatus; /** * 当前节点/线程依赖的前置节点的链接，用于检查waitStatus。 * 在入队时分配，并在出队时清空（为了垃圾回收的目的）。 * 当前节点的前置节点被取消时，我们会进行短路操作以查找一个未取消的前置节点， * 因为头节点永远不会被取消：节点只有在成功获取后才会成为头节点。 * 取消的线程永远不会成功获取，并且只有线程自己才可以取消，没有其他节点可以取消。 */ volatile Node prev; /** * 当前节点/线程释放时要唤醒的后继节点的链接。 * 在入队时分配，在绕过已取消的前置节点时进行调整，并在出队时清空（为了垃圾回收的目的）。 * 入队操作在附加之前不会为前置节点的next字段分配值， * 所以看到null的next字段并不一定意味着节点位于队列末尾。 * 但是，如果next字段似乎是null，我们可以从尾部向前扫描prev节点进行双重检查。 * 已取消节点的next字段被设置为指向节点本身而不是null，以使isOnSyncQueue方法更容易处理。 */ volatile Node next; /** * 入队此节点的线程。在构造函数中初始化，并在使用后清空。 */ volatile Thread thread; /** * 链接到在条件上等待的下一个节点，或特殊值SHARED。 * 因为条件队列只在持有独占模式时访问，所以我们只需要一个简单的链表队列来保存正在等待条件的节点。 * 然后将它们转移到队列以便重新获取。由于条件只能是独占的，所以使用特殊值来表示共享模式可以节省一个字段。 */ Node nextWaiter; /** * 如果节点正在以共享模式等待，则返回true。 */ final boolean isShared() { return nextWaiter == SHARED; } /** * 返回前置节点，如果为null则抛出NullPointerException异常。 * 在前置节点不可能为null的情况下使用。可以省略null检查，但它有助于虚拟机。 * * @return 此节点的前置节点 */ final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } Node() { // 用于建立初始头节点或SHARED标记 } Node(Thread thread, Node mode) { // 由addWaiter方法使用 this.nextWaiter = mode; this.thread = thread; } Node(Thread thread, int waitStatus) { // 由Condition使用 this.waitStatus = waitStatus; this.thread = thread; } } \"]},\"313\":{\"h\":\"13.4 如何使用AQS\",\"t\":[\"AQS内部封装了队列维护逻辑，采用模版方法的模式提供实现类以下方法：\",\"tryAcquire(int); // 尝试获取独占锁，可获取返回true，否则false tryRelease(int); // 尝试释放独占锁，可释放返回true，否则false tryAcquireShared(int); // 尝试以共享方式获取锁，失败返回负数，只能获取一次返回0，否则返回个数 tryReleaseShared(int); // 尝试释放共享锁，可获取返回true，否则false isHeldExclusively(); // 判断线程是否独占资源 \",\"如实现类只需实现独占锁/共享锁功能，可只实现tryAcquire/tryRelease或tryAcquireShared/tryReleaseShared。虽然实现tryAcquire/tryRelease可自行设定逻辑，但建议使用state方法对state变量进行操作以实现同步类。\",\"/** * 使用AQS模板实现一个简单的互斥锁 */ class MyMutex extends AbstractQueuedSynchronizer { @Override protected boolean tryAcquire(int arg) { return compareAndSetState(0, 1); } @Override protected boolean tryRelease(int arg) { return compareAndSetState(1, 0); } } public class AQSDemo { public static void main(String[] args) throws InterruptedException { final MyMutex mutex = new MyMutex(); new Thread(() -> { mutex.acquire(1); System.out.println(Thread.currentThread().getName() + \\\" acquire mutex\\\"); try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { } System.out.println(Thread.currentThread().getName() + \\\" release mutex\\\"); mutex.release(1); }, \\\"t1\\\").start(); new Thread(() -> { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { } mutex.acquire(1); System.out.println(Thread.currentThread().getName() + \\\" acquire mutex\\\"); mutex.release(1); System.out.println(Thread.currentThread().getName() + \\\" release mutex\\\"); }, \\\"t2\\\").start(); } } \"]},\"314\":{\"h\":\"13.5 AQS分析\"},\"315\":{\"h\":\"13.5.1 acquire分析\"},\"316\":{\"h\":\"13.5.2 acquireQueue分析\",\"t\":[\"队列中的节点循环等待前驱节点为头节点时方可获取资源\"]},\"317\":{\"h\":\"13.5.3 release流程分析\",\"t\":[\"尝试释放成功后，即从头结点开始唤醒其后继节点，如后继节点被取消，则转为从尾部开始找阻塞的节点将其唤醒。阻塞节点被唤醒后，即进入acquireQueued中的for(;;)循环开始新一轮的资源竞争。\"]},\"318\":{\"h\":\"13.5.4 acquireShared 和releaseShared分析\",\"t\":[\"acquireShared和releaseShared整体流程与独占锁类似，tryAcquireShared获取失败后以Node.SHARED挂载到队尾阻塞，直到队头节点将其唤醒。在doAcquireShared与独占锁不同的是，由于共享锁是可以被多个线程获取的，因此在首个阻塞节点被唤醒后，会通过setHeadAndPropagate传递唤醒后续的阻塞节点。\",\"进入setHeadAndPropagate，首先需要明确的是，该函数的传入参数propagate一定是非负数，接下来其唤醒主要为两个判断逻辑：\",\"如果propagate > 0，表示存在多个共享锁可以获取，可直接进行doReleaseShared唤醒阻塞节点。\",\"如果propagate = 0，表示仅当前节点可被唤醒，则有两种情况：\",\"h == null || h.waitStatus < 0\",\"假设资源数量为2（A，B）持有，此时有两个线程（C，D）在阻塞队列等待\",\"1）线程A释放锁，此时doReleaseShared先将head的ws置为0，然后unpark线程C\",\"2）线程C尝试获取锁tryAcquiredShared，进入setHeadAndPropagate，此时线程B也释放锁，根据doReleaseShared因为此时的head的ws已经被置为0，所以把head的ws置为Node.PROPAGATE=-3\",\"3）线程C判断h == null || h.waitStatus < 0，符合上述情况，新head指向C，并且因为队列中的线程D为SHARE共享锁，继续释放线程D\",\"(h = head) == null || h.waitStatus < 0\",\"假设资源数量为2（A，B）持有，此时有线程C在阻塞队列等待\",\"1）线程A释放锁，此时doReleaseShared先将head的ws置为0，然后unpark线程C\",\"2）线程C尝试获取锁tryAcquiredShared，进入setHeadAndPropagate已经setHead，线程D这时请求资源将D挂载到阻塞队列队尾。\",\"3）线程B也释放锁，根据doReleaseShared因为此时的head的ws已经被置为0，所以把head的ws置为Node.PROPAGATE=-3，由于经过了setHead，满足(h=head) == null，可以继续释放线程D。\"]},\"319\":{\"h\":\"13.6 ConditionObject（wait队列）\",\"t\":[\"img\",\"ConditionObject机制如上图，在条件队列中，Node采用nextWaiter组成单向链表，当持有锁的线程发起condition.await调用后，会包装为Node挂载到Condition条件阻塞队列中；当对应condition.signal被触发后，条件阻塞队列中的节点将被唤醒并挂载到锁阻塞队列中。\"]},\"320\":{\"h\":\"JavaWeb\"},\"321\":{\"h\":\"一 简介\"},\"322\":{\"h\":\"1.1 JavaWeb概念\",\"t\":[\"通过Java语言编写的，可以通过浏览器访问的程序\",\"JavaWeb是基于请求和响应开发的\"]},\"323\":{\"h\":\"1.2 Web资源的分类\",\"t\":[\"**静态资源：**html、css、js、txt、图片、视频\",\"**动态资源：**jsp页面、servlet程序\"]},\"324\":{\"h\":\"1.3 常用的服务器\",\"t\":[\"Tomcat\",\"Jboss\",\"GlashFish\",\"Resin\",\"WebLogic\"]},\"325\":{\"h\":\"二、Servlet\"},\"326\":{\"h\":\"2.1 Servlet技术\",\"t\":[\"Servlet是JavaEE规范之一，就是接口\",\"Servlet是运行在服务器上的java小程序，可以接收客户端发送过来的请求，并响应数据给客户端\"]},\"327\":{\"h\":\"2.2 第一个Servlet程序\",\"t\":[\"编写一个类去实现Servlet接口\",\"实现service方法\",\"到web.xml配置Servlet的地址\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <web-app xmlns=\\\"http://xmlns.jcp.org/xml/ns/javaee\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\\\" version=\\\"4.0\\\"> <!--属于整个Web工程--> <context-param> <param-name>username</param-name> <param-value>yanmingkui</param-value> </context-param> <context-param> <param-name>password</param-name> <param-value>123456</param-value> </context-param> <servlet> <!--给servlet标签起个别名 一般是类名--> <servlet-name>HelloServlet</servlet-name> <servlet-class>com.example.tcdemo.HelloServlet</servlet-class> <!--只能在init()中获取--> <init-param> <param-name>username</param-name> <param-value>jimowo</param-value> </init-param> </servlet> <!--给servlet程序配置访问地址--> <servlet-mapping> <!--告诉服务器当前配置的地址给哪个程序使用--> <servlet-name>HelloServlet</servlet-name> <url-pattern>/hello</url-pattern> </servlet-mapping> </web-app> \"]},\"328\":{\"h\":\"2.3 Servlet的生命周期\",\"t\":[\"执行 Servlet 构造器方法\",\"init 初始化方法\",\"service 方法\",\"destory 方法\",\"第1、2步只有在第一次创建实例时会调用\",\"service方法每次访问都会调用\"]},\"329\":{\"h\":\"2.4 Servlet的继承体系\",\"t\":[\"image-20220829160037207\"]},\"330\":{\"h\":\"2.5 ServletConfig类\",\"t\":[\"servlet程序的配置信息\",\"public interface ServletConfig { String getServletName(); ServletContext getServletContext(); String getInitParameter(String var1); Enumeration<String> getInitParameterNames(); } \"]},\"331\":{\"h\":\"2.6 ServletContext类\",\"t\":[\"ServletContext是一个域对象，表示Servlet的上下文\",\"一个Web工程只有一个Servlet对象实例\",\"域对象可以像Map一样存取数据\",\"包含的信息：context-param、当前工程的路径、工程部署在硬盘的绝对路径\"]},\"332\":{\"h\":\"2.7 区分Get请求和Post请求\",\"t\":[\"Get\",\"form标签 method=post\",\"a标签\",\"link标签 引入css\",\"script标签 引入js\",\"img标签 引入图片\",\"iframe标签 引入html页面\",\"在浏览器地址栏中输入地址后敲回车\",\"Post\",\"form标签 method=post\"]},\"333\":{\"h\":\"2.8 HttpServletRequest类\",\"t\":[\"可以通过HttpServletRequest类获得多有请求的信息\",\"getHeader方法获得头\",\"getParameter方法获得对应参数\",\"getParameterValues获得一个参数的数组\",\"解决POST请求的乱码问题\",\"request.setCharacterEncoding(\\\"UTF-8\\\"); \"]},\"334\":{\"h\":\"2.9 Servlet请求转发\",\"t\":[\"只能在自己的工程里跳转\",\"@WebServlet(name = \\\"TransServlet1\\\", value = \\\"/TransServlet1\\\") public class TransServlet1 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 获取请求的参数 String username = request.getParameter(\\\"username\\\"); System.out.println(\\\"servlet 1 username: \\\" + username); // 给材料盖一个章，传送到transServlet2 request.setAttribute(\\\"key\\\",\\\"柜台1的章\\\"); // 问路 Servlet2 怎么走 RequestDispatcher requestDispatcher = request.getRequestDispatcher(\\\"/TransServlet2\\\"); requestDispatcher.forward(request, response); } } \",\"@WebServlet(name = \\\"TransServlet2\\\", value = \\\"/TransServlet2\\\") public class TransServlet2 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 获取请求的参数 String username = request.getParameter(\\\"username\\\"); System.out.println(\\\"servlet 1 username: \\\" + username); // 查看transServlet1的章 Object key = request.getAttribute(\\\"key\\\"); System.out.println(key); } } \"]},\"335\":{\"h\":\"2.10 HttpServletResponse类\",\"t\":[\"HttpServletRequest表示请求信息，HttpServletResponse表示响应信息\",\"两个输出流\",\"字节流 getOutputStream() 常用于下载\",\"字符流 getWriter() 常用于回传字符串\",\"两个流同时只能使用一个\",\"如何向客户端回传数据\",\"response.setCharacterEncoding(\\\"UTF-8\\\"); // 显示中文 默认编码ISO-8859-1 response.setContentType(\\\"text/html\\\"); // Hello out.println(\\\"<html><body>\\\"); out.println(\\\"<h1>\\\" + message + \\\"</h1>\\\"); out.println(\\\"</body></html>\\\"); \"]},\"336\":{\"h\":\"2.11 请求重定向\",\"t\":[\"指客户端给服务器发请求，然后服务器让客户端重新定向到新地址\"]},\"337\":{\"h\":\"三、Filter过滤器\"},\"338\":{\"h\":\"3.1 什么是Filter\",\"t\":[\"filter过滤器也是个接口，作用是拦截请求、过滤响应\",\"拦截请求的场景有：\",\"权限检查\",\"日记操作\",\"事务管理\",\"。。。\"]},\"339\":{\"h\":\"3.2 Filter应用\",\"t\":[\"要求：Web工程下，有一个admin目录。这个目录下的资源必须是用户登录后才允许访问\",\"image-20220902165619031\",\"Filter使用步骤\",\"编写一个Filter类去实现Filter接口，并实现doFilter()方法\",\"public class AdminFilter implements Filter { public void init(FilterConfig config) throws ServletException { } public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest httpServletRequest = (HttpServletRequest) request; HttpSession session = httpServletRequest.getSession(); Object user = session.getAttribute(\\\"user\\\"); // 判读是否登录 if (user == null) { request.getRequestDispatcher(\\\"/login.jsp\\\").forward(request, response); } else { // 让程序继续访问用户的目标资源 chain.doFilter(request, response); } } } \",\"配置web.xml\",\"<filter> <filter-name>AdminFilter</filter-name> <filter-class>com.example.tcdemo.AdminFilter</filter-class> </filter> <filter-mapping> <filter-name>AdminFilter</filter-name> <url-pattern>/admin/*</url-pattern> </filter-mapping> \"]},\"340\":{\"h\":\"3.3 Filter的生命周期\",\"t\":[\"Filter的生命周期包含几个方法：\",\"构造器方法\",\"init初始化方法\",\"doFilter方法\",\"destory方法\",\"1、2在创建时就会调用\"]},\"341\":{\"h\":\"3.4 FilterConfig类\",\"t\":[\"Filter过滤器的配置文件类，Tomcat每次创建Filter的时候，也会同时创建一个FilterConfig类，包含了Filter配置文件的配置信息\",\"获取 Filter 的filter name\",\"获取init parameter\",\"获取Servlet context对象\"]},\"342\":{\"h\":\"3.5 FilterChain类\",\"t\":[\"FilterChain.doFilter() 方法的作用\",\"执行下一个Filter过滤器\",\"执行目标资源\",\"Filter执行顺序\",\"在多个Filter过滤器执行的时候，它们的执行顺序是由他们在web.xml中从上到下的配置顺序决定的\"]},\"343\":{\"h\":\"3.6 Filter的拦截路径\",\"t\":[\"精确匹配\",\"<url-pattern>target.jsp</url-pattern> \",\"目录匹配\",\"<url-pattern>/admin/*</url-pattern> \",\"目录下的全部资源\",\"后缀名匹配\",\"<url-pattern>*.html</url-pattern> \",\"匹配所有的html结尾的文件\"]},\"344\":{\"h\":\"Java基础\"},\"345\":{\"h\":\"一、Java基础概述\"},\"346\":{\"h\":\"Java的重要特点\",\"t\":[\"面向对象\",\"Java是健壮的（强类型机制、异常处理、垃圾的自动收集）\",\"跨平台性（编译生成的 class 文件可以通过JVM（Java虚拟机）直接在 windows 平台或 linux 平台运行）\",\"解释型语言（解释型语言，编译后的代码不能被机器直接执行需要通过解释器来执行）\"]},\"347\":{\"h\":\"Java的运行机制及运行过程\"},\"348\":{\"h\":\"Java 核心机制 - JVM\",\"t\":[\"JVM是一个虚拟计算机，具有指令集并使用不同的存储区域。负责执行指令、管理数据、内存、寄存器，包含在JDK中\",\"不同平台有不同虚拟机，实现了一次编译全平台通用\"]},\"349\":{\"h\":\"编译运行指令\",\"t\":[\"编译 javac\",\"运行 java\"]},\"350\":{\"h\":\"JDK基本介绍\",\"t\":[\"JDK = JRE + java开发工具（javac、java等）\",\"JRE = JVM + Java SE标准类库\"]},\"351\":{\"h\":\"Java快速入门\",\"t\":[\"// 1. pubulic hello 共有类 public class hello { // public static void main(String[] args) 主方法 程序入口 public static void main(String[] args) { System.out.println(\\\"hello world\\\"); } } \"]},\"352\":{\"h\":\"Java开发注意事项\",\"t\":[\"一个源文件中只能有一个public类\",\"文件名必须与public类同名\",\"可以将main方法写在非public类中，并指定运行该方法\",\"// 每一个类编译后都会生成一个对应的 class 文件，编译后用 java dog 即可执行 dog 类里的主方法 class dog { public static void main(String[] args) { System.out.println(\\\"hello dog\\\"); } } // 编译后用 java cat 即可执行 cat 类里的主方法 class cat { public static void main(String[] args) { System.out.println(\\\"hello cat\\\"); } } \"]},\"353\":{\"h\":\"Java转义字符\",\"t\":[\"\\\\t : 制表符\",\"\\\\n: 换行符\",\"\\\\\\\\ : 一个 \\\\ ，编译器的会把第一个 \\\\ 当做转义字符，所以输出一个斜杠需要打两个斜杆，输出两个则需要四个\",\"\\\\\\\" : 一个 \\\"\",\"\\\\' : 一个 '\",\"\\\\r : 一个回车，回车与换行不同，是将光标重新回到当前行开头\"]},\"354\":{\"h\":\"Java注释\",\"t\":[\"单行注释 // 注释文字\",\"多行注释 /* 注释文字 */\",\"文档注释 类的说明文档，可以被javadoc解析 解析格式：javadoc -d 路径名 -xx -yy comment.java\",\"/** * @author Jimowo * @version 1.0.1beta */ public class comment { public static void main(String[] args) { System.out.println(\\\"文档注释\\\"); } } \"]},\"355\":{\"h\":\"二、Java变量\"},\"356\":{\"h\":\"编码表\",\"t\":[\"ASCII码，128个字符（包含英语字符）\",\"缺点：不能表示所有字符\",\"Unicode码，65536个字符（包含世界上所有字符）\",\"编码0 - 127位都与ASCII码相同，所以兼容ASCII码\",\"缺点：英文字母和汉字都占用2个字节，浪费空间\",\"UTF-8编码，使用1-6个字节来表示字符，根据不同符号来变化字节长度\",\"其中字母占一个字节，汉字占3个字节\"]},\"357\":{\"h\":\"Java中 + 号的使用\",\"t\":[\"当加号左右两侧都是数值型时，则做加法运算\",\"当加号两侧有一方是字符串时，则做拼接运算（会把其中的数值型转为字符串）\"]},\"358\":{\"h\":\"内置数据类型\",\"t\":[\"整型类型（1byte = 8bit）\",\"byte（8位），short（16位），int（32位），long（64位）\",\"整型在内存中第一位存放符号位\",\"int n1 = 1; // int n2 = 1L; // 后缀L表示这是一个长整型，所以不能复制给int类型 long n2 = 1L; \",\"浮点类型\",\"float（32位，单精度），double（64位，双精度）\",\"浮点类型在内存中存放形式：符号位 + 指数位 + 尾数位\",\"// float num1 = 1.1; // 报错，因为浮点数默认是double类型 double num1 = 1.1; float num2 = 1.1f; double num3 = 1.1f; // 正确 double num4 = 5.12e4 // 科学计数法 \",\"布尔类型\",\"boolean（1位，只有 true 和 false 两个值）\",\"字符类型\",\"char（16位，最小值为0）\",\"char c1 = 'a'; // 字符常量用单引号括起来 char c2 = 97; // 本质上char类型保存的是整数，输出的是对应的unicode码 System.out.println(c1); System.out.println(c2); // 上面两个输出都是a \"]},\"359\":{\"h\":\"基本数据类型转换\",\"t\":[\"自动类型转换\",\"java在进行赋值或运算时，精度小的类型自动转换为精度大的类型\",\"顺序：\",\"​ char → int → long → float → double\",\"byte → short → int → long → float → double\",\"细节：\",\"当有多种数据类型进行混合运算时，系统首先自动将数据转换成容量最大（精度最高）的类型\",\"int n1 = 10; float n2 = n1 + 1.1; // 错误，因为1.1默认为double类型，所以n1和1.1会变成double类型计算 \",\"精度高的类型也不能赋值给精度低的类型，例如double赋给int\",\"（byte、short）和char之间不会相互转化（范围不同），但是可以进行计算，计算时会都转换为int类型\",\"byte b1 = 10; // 正确，虽然10默认是int类型，但是具体值在byte范围内就可以赋值 char n2 = 10; byte b2 = n2; // 错误，char变量不能赋值给byte n2 += b1; b1 += n2; // 这两个计算都是正确的 n2 = n2 + b1; // 错误 ？ \",\"boolean不参与转换\",\"强制类型转换\",\"强制将高精度转换为低精度，使用时要加上强制转换符（类型），可能会造成精度降低或溢出\",\"int i = (int)1.9; // double类型强制转换为int类型 System.out.println(i); // 输出为1，精度降低 byte b1 = (byte)130; System.out.println(b1); // 输出为-126，因为130超过byte的最大值127所以造成了溢出 \",\"细节：\",\"char类型可以保存int的常量值，但是不能保存int变量值\",\"char c1 = 10; // 正确 int n1 = 10; char c2 = n1; // 错误 char c2 = (char)n1; // 正确 \"]},\"360\":{\"h\":\"基本数据类型和String类型的转换\",\"t\":[\"基本类型转String\",\"基本类型 + \\\"\\\"即可\",\"int n1 = 10; String str1 = n1 + ''; \",\"String转基本类型\",\"调用类型对应的parseXXX方法即可\",\"String str1 = \\\"123\\\"; int n1 = Integer.parseInt(str1); \"]},\"361\":{\"h\":\"三、Java运算符\"},\"362\":{\"h\":\"算术运算符\",\"t\":[\"算数运算符一览：\",\"运算符\",\"运算\",\"范例\",\"结果\",\"+\",\"正号\",\"+7\",\"7\",\"-\",\"负号\",\"b = 11；- b\",\"-11\",\"+\",\"加\",\"1 + 2\",\"3\",\"-\",\"减\",\"3 - 2\",\"1\",\"*\",\"乘\",\"2 * 3\",\"6\",\"/\",\"除\",\"6 * 2\",\"3\",\"%\",\"取余\",\"5 * 2\",\"3\",\"++++\",\"自增（前）自增（后）\",\"int a = 1; ++ a;int b = a ++;\",\"a = 3;b = 2;\",\"----\",\"自减（前）自减（后）\",\"+\",\"字符串相加\",\"\\\" 12 \\\" + \\\"12\\\"\",\"\\\"1212\\\"\"]},\"363\":{\"h\":\"比较运算符\",\"t\":[\"比较运算符一览：\",\"==, !=, <, >, <=, >=\",\"特殊的：instanceof， 检查是否为类的对象， \\\"str\\\" is instanceof String → true\"]},\"364\":{\"h\":\"逻辑运算符\",\"t\":[\"逻辑运算符一览：\",\"短路与 &&，短路或 ||，取反 ！\",\"逻辑与 &，逻辑或 |，逻辑异或 ^\",\"细节：\",\"java中&&与&的区别在于，&不管左边是否为真，都会计算&左右两边的表达式，&&则是当左侧表达式为false时，就不计算右边表达式，效率更高\",\"|| 同上\"]},\"365\":{\"h\":\"赋值运算符\",\"t\":[\"基本赋值运算符\",\"=\",\"复合赋值运算符\",\"+=，-=，*=，/=，%=等\",\"a += b 等价于 a = a + b\",\"细节：\",\"运算顺序从右向左，int a = 1 + 2 + 3;\",\"赋值运算符 = 的左边只能是变量，右边可以是变量、表达式、常量\",\"符合赋值运算符会进行类型转换\",\"byte b1 = 10; // 正确，虽然10默认是int类型，但是常量在byte范围内就可以赋值 char n2 = 10; n2 += b1; b1 += n2; // 这两个计算都是正确的，因为 += 会进行类型转换 n2 = n2 + b1; // 错误 \"]},\"366\":{\"h\":\"三元运算符\",\"t\":[\"语法：条件表达式 ？ 表达式1 ：表达式2 ，如果条件表达式为true则结果为表达式1结果\",\"细节：\",\"三元运算符的嵌套\",\"// 找三个数中的最大值 int a = 5, b = 3, c = 8; int result = a > b ? (a > c ? a : c) : (b > c ? b : c); \"]},\"367\":{\"h\":\"运算符优先级\",\"t\":[\"（），{} 等\",\"单目运行 ++，--，~，！（优先级从右向左）\",\"算数运算符 *，/，%，+，-\",\"位移运算符 <<，>>，>>>\",\"比较运算符 <，>，<=，>=，instanceof\",\"逻辑运算符 ==，!=，&，^，|，&&，||\",\"三元运算符 ? :\",\"赋值运算符 =，*=，/=，%= 等（优先级从右向左）\"]},\"368\":{\"h\":\"键盘输入\",\"t\":[\"需要导入 java.util.Scanner\",\"import java.util.Scanner; public class inputDetail { public static void main(String[] args) { Scanner sc1 = new Scanner(System.in); // 创建一个扫描仪接收键盘输入 System.out.println(\\\"please enter\\\"); String name = sc1.next(); // next()表示接收下一个数 int age = sc1.nextInt(); double salary = sc1.nextDouble(); sc1.close(); System.out.println(\\\"name: \\\" + name + \\\" age: \\\" + age + \\\" salary: \\\" + salary); } } \"]},\"369\":{\"h\":\"原码、反码、补码\",\"t\":[\"正数的原码、反码、补码都一样\",\"负数的反码 = 原码符号位不变，其他位取反\",\"负数的补码 = 反码 + 1\",\"0的反码、补码都是0\",\"java没有无符号数\",\"计算机运算时都是用补码运算的\"]},\"370\":{\"h\":\"四、控制结构\"},\"371\":{\"h\":\"分支控制if - else\",\"t\":[\"双分支语法：\",\"if（条件表达式）{\",\"​ 执行代码块；// 可以有多条语句\",\"}\",\"else {\",\"​ 执行代码块；\",\"}\",\"多分支语法\",\"if（条件表达式）{\",\"​ 执行代码块；// 可以有多条语句\",\"}\",\"else if {\",\"​ 执行代码块；\",\"}\",\"……\",\"else {\",\"​ 执行代码块；\",\"}\"]},\"372\":{\"h\":\"switch分支结构\",\"t\":[\"基本语法：\",\"switch（表达式）{\",\"​ case 常量1：\",\"​ 语句块1；\",\"​ break；// 退出switch，若没有break则会顺序执行下一个语句块\",\"​ case 常量2：\",\"​ 语句块2；\",\"​ break；\",\"​ ……\",\"​ default：// 如果case都不满足，则会进default默认语句块\",\"​ 默认语句块；\",\"​ break；\",\"}\",\"细节：\",\"switch（表达式），表达式中的返回值必须是byte，short，int，char，enum，String\",\"case 子句中的值必须是常量，不能是变量\",\"default可有可无\",\"没有break，执行完一个case后，会顺序执行语句块到末尾\"]},\"373\":{\"h\":\"for循环控制\",\"t\":[\"基本语法：\",\"for（循环变量初始化；循环条件；循环变量迭代）{\",\"​ 循环操作语句；\",\"}\",\"细节：\",\"for循环可以简写成for（；循环判断条件；）分号不能省略\",\"for循环可以有多条初始化语句，但要求类型相同，并用逗号隔开\"]},\"374\":{\"h\":\"while循环控制\",\"t\":[\"基本语法：\",\"while（循环条件）{\",\"​ 循环体语句；\",\"​ 变量迭代语句；\",\"}\",\"细节：\",\"先判断再执行\"]},\"375\":{\"h\":\"do - while循环控制\",\"t\":[\"基本语法：\",\"do {\",\"​ 循环体语句；\",\"​ 循环变量迭代；\",\"} while（循环条件）；\",\"细节：\",\"先执行，再判断，所以一定会执行一次\",\"结尾有分号\"]},\"376\":{\"h\":\"多重循环控制\",\"t\":[\"九九乘法表\",\"public class chengFaBiao { public static void main(String[] args) { int cols = 9; for (int c = 1; c <= cols; c++) { for (int r = 1; r <= c; r++) { System.out.print(r + \\\" x \\\" + c + \\\" = \\\" + r*c + \\\"\\\\t\\\"); } System.out.println(\\\"\\\"); } } } \",\"空心三角形\",\" \"]},\"377\":{\"h\":\"跳转控制语句 - break\",\"t\":[\"基本语法：\",\"{\",\"​ ……\",\"​ break；\",\"​ ……\",\"}\",\"跳出循环\",\"细节：\",\"break语句出现在多层嵌套语句块中时，可以通过标签指明要终止于哪一层语句块\",\" public static void main(String[] args) { label1: for (int j = 0; j < 4; j ++) { label2: for (int i = 0; i < 10; i++) { if (i == 2) { break label2; } } System.out.println(\\\"j = \\\" + j); } } } \",\"若没有指定break，默认退出最近的循环体\"]},\"378\":{\"h\":\"跳转控制语句 - continue\",\"t\":[\"基本语法：\",\"{\",\"​ ……\",\"​ continue；\",\"​ ……\",\"}\",\"用于结束本次循环，继续执行下次循环，同break可以通过标签来指定跳过的循环。\"]},\"379\":{\"h\":\"跳转控制语句 - return\",\"t\":[\"return使用在方法，表示跳出所在方法，写在main方法中，则会退出程序。\"]},\"380\":{\"h\":\"五、数组、排序和查找\"},\"381\":{\"h\":\"数组\",\"t\":[\"数组的动态初始化方法一\",\"语法：数据类型 数组名[] = new 数据类型 [大小]\",\"int a[] = new int[6]; // 创建一个int数组，存放6个int\",\"动态初始化方法二\",\"先声明数组 int a[];，再初始化a = new int[10]；\",\"数组的静态初始化\",\"语法：数据类型 数组名[] =\",\"数组的赋值机制\",\"数组的赋值是引用传递，赋的是地址\",\"例如：\",\"public class arrayAssign { public static void main(String[] args) { int[] arr1 = {1, 2, 3}; int[] arr2 = arr1; // 此时arr1和arr2指向的是同一片地址，所以改变arr2的值，也会改变arr1的值 System.out.println(arr1[0]); // 输出为1 arr2[0] = 4; System.out.println(arr1[0]); // 输出为4 } } \",\"数组拷贝\",\"public class arrayAssign { public static void main(String[] args) { int[] arr1 = {1, 2, 3}; // 正确的数组赋值方法 // 开辟新空间 int[] arr2 = new int[arr1.length]; // 遍历复制 int i = 0; for (int num : arr1) { arr2[i] = num; i ++; } // 查看两数组地址 System.out.println(arr1); System.out.println(arr2); } } \",\"数组扩容\",\"需要通过创建新数组的方式来扩容\",\"冒泡排序\",\"/** * @apiNote 冒泡排序 */ public class bubbleSort { public static void main(String[] args) { int[] arrSort = {24, 69, 87, 53, 12}; int temp; for (int i = 0; i < arrSort.length-1; i++) { for (int j = 0; j < arrSort.length-i-1; j++) { if (arrSort[j] > arrSort[j+1]) { temp = arrSort[j+1]; arrSort[j+1] = arrSort[j]; arrSort[j] = temp; } } } for (int i : arrSort) { System.out.println(i); } } } \",\"查找\",\"顺序查找\",\"数组挨个判断，找到了则返回下标\",\"二分法查找\",\"先升序排序，再从数组中间位置开始比较，比查找的数小则说明查找的数在右半边，比查找的数大则说明在左半边，这样不断寻找，最多只需log2N次\"]},\"382\":{\"h\":\"二维数组\",\"t\":[\"二维数组动态初始化\",\"语法：类型[][] 数组名 = new 类型[大小][大小]\",\"二维数组的初始化（特殊）\",\"java允许动态创建以下的数组\",\"i \\\\ j\",\"j = 0\",\"j = 1\",\"j = 2\",\"i = 0\",\"1\",\"i = 1\",\"2\",\"2\",\"i = 2\",\"3\",\"3\",\"3\",\"public class twoDemensionArr { public static void main(String[] args) { int[][] arr2 = new int[3][]; // 创建一个不确定列数的二维数组 for (int i = 0; i < arr2.length; i++) { arr2[i] = new int[i+1]; // 可以为每个子数组设置不同的列数 } for (int i = 0; i < arr2.length; i++) { for (int j = 0; j < arr2[i].length; j++) { arr2[i][j] = i+1; } } } } \",\"二维数组的遍历\",\"public class twoDemensionArr { public static void main(String[] args) { for (int[] is : arr1) { for (int is2 : is) { System.out.println(is2); } } } } \",\"杨辉三角\",\"public class yangHui { public static void main(String[] args) { // 打印杨辉三角 // 初始化 int[][] arrTri = new int[10][]; for (int i = 0; i < arrTri.length; i++) { arrTri[i] = new int[i + 1]; } // 赋值 for (int i = 0; i < arrTri.length; i++) { for (int j = 0; j < arrTri[i].length; j++) { if ((j == 0) || (j == arrTri[i].length-1)) { arrTri[i][j] = 1; } else { arrTri[i][j] = arrTri[i-1][j-1] + arrTri[i-1][j]; } } } // 打印显示 for (int[] is : arrTri) { for (int is2 : is) { System.out.print(is2 + \\\" \\\"); } System.out.println(); } } } \",\"细节\",\"二维数组的声明方式有：\",\"int [][] arr, int[] arr[], int arr[][]\",\"二维数组实际上是由多个一维数组组成，它的各个一维数组长度可以相同也可以不同\"]},\"383\":{\"h\":\"六、面向对象编程（基础）\"},\"384\":{\"h\":\"类与对象介绍\",\"t\":[\"类是对象的模板，对象是类的实例\",\"类的五大成员\",\"属性\",\"方法\",\"构造器\",\"代码块\",\"内部类\"]},\"385\":{\"h\":\"对象内存布局\"},\"386\":{\"h\":\"属性/成员变量\",\"t\":[\"基本介绍\",\"成员变量 = 属性 = 字段（field）\",\"属性是类的组成部分，可以是基本数据类型也可以是引用数据类型\",\"属性的定义语法同变量，访问修饰符 属性类型 属性名；\",\"属性如果不赋值，则实例会有默认值，规则和数组类似\"]},\"387\":{\"h\":\"如何创建对象\",\"t\":[\"先声明再创建\",\"Cat cat；// 声明对象\",\"cat = new Cat（）；// 创建\",\"直接创建\",\"Cat cat = new Cat（）；\"]},\"388\":{\"h\":\"类与对象的内存分配机制\",\"t\":[\"Person p1 = new Person;\",\"Person p2 = p1;\",\"上述代码就像数组的赋值，对于引用型变量只是把变量的地址传递，不是又给p2开辟了新的内存空间\",\"java内存结构分析\",\"栈：一般存放基本数据类型（局部变量）\",\"堆：存放对象、数组等\",\"方法区：常量池、类加载信息\"]},\"389\":{\"h\":\"成员方法\",\"t\":[\"方法的调用机制\",\"当main函数执行到方法时，会在栈中再开辟一个新的独立空间来执行方法\",\"成员方法的定义\",\"public 返回数据类型 方法名（形参列表） {\",\"​ 语句；\",\"​ return 返回值；// return语句不是必须\",\"}\",\"细节：\",\"一个方法最多有一个返回值\",\"返回类型可以为任意类型，包含基本类型和引用类型（数组、对象）\",\"返回数据类型为void时可以不写return\",\"同一个类中的方法可以直接调用，不同类的方法需要通过实例化对象来调用\",\"基本类型形参的改变不会改变原来实参，但是引用类型形参传递的是指向内存的地址，所以改变内存，也会引起实参的改变\"]},\"390\":{\"h\":\"克隆对象\",\"t\":[\"public class cloneObject { public static void main(String[] args) { Person p1 = new Person(\\\"ymk\\\", 23); p1.printInfo(); Person p2 = p1.personCpy(); p2.printInfo(); } } class Person { String name; int age; int cnt = 0; Person(String name, int age) { this.name = name; this.age = age; } public void printInfo() { System.out.println(name + \\\" \\\" + age); } public Person personCpy() { Person cpyP = new Person(name, age); return cpyP; } } \"]},\"391\":{\"h\":\"方法递归调用\",\"t\":[\"打印问题\",\"public class recusionMeasure { public static void main(String[] args) { T t = new T(); t.test(5); } } class T { public void test(int num) { if (num > 0) { test(num-1); } System.out.println(num); } } \",\"上段代码输出为0到5，不断的递归，test(5)->test(4)->test(3)->test(2)->test(1)->test(0)，到0结束递归\",\"阶乘问题\",\"public class recusionMeasure { public static void main(String[] args) { T t = new T(); System.out.println(t.factorial(5)); } } class T { public int factorial(int num) { if (num == 1) { return 1; } else { return factorial(num-1)*num; } } } \",\"递归的重要规则\",\"执行一个方法时，就创建一个新的受保护的独立栈空间\",\"方法的局部变量时独立的，不会相互影响，但是引用类型变量则会产生影响\",\"斐波那契数列\",\"public class recusionMeasure { public static void main(String[] args) { T t = new T(); System.out.println(t.fabonachi(7)); } } class T { // 斐波那契数列 public int fabonachi(int n) { if (n == 1 || n == 2) { return 1; } else { return fabonachi(n-1) + fabonachi(n-2); } } } \",\"方法重载\",\"介绍：java允许同一个类中多个同名方法存在，但要求形参不一致\",\"class OvLoad { public int m(int x, int y) { return x*y; } public int m(int x) { return x*x; } public void m(String info) { System.out.println(info); } } \",\"可变参数\",\"介绍：java允许将同一个类中多个同名同功能但参数个数不同的方法封装成一个方法\",\"class OvLoad { public int add(int... nums) { // 接收的nums为一个int数组 int sum = 0; for (int num : nums) { sum += num; } return sum; } } \",\"作用域\",\"主要的变量就是属性（成员变量）和局部变量\",\"局部变量一般是指在方法中定义的变量\",\"全局变量就是属性，作用域为整个类体\",\"局部变量作用域在代码块中\",\"全局变量可以不赋值直接使用，因为有默认值，局部变量必须赋值后使用\",\"全局变量可以加修饰符\"]},\"392\":{\"h\":\"构造器\",\"t\":[\"介绍：构造器用于类的初始化\",\"class Person { String name; int age; int cnt = 0; Person(String name, int age) { // 构造器可以不用写修饰符，不能写返回值 this.name = name; this.age = age; Person(String name) { // 可以构造器重载 this.name = name; } } \",\"细节：\",\"一个类可以定义多个构造器，即构造器重载\",\"创建对象时，系统自动调用该类的构造，构造器完成对象的初始化\",\"若不定义构造器，系统会提供默认的构造器，一旦定义了自己的构造，默认的就失效\"]},\"393\":{\"h\":\"this关键字\",\"t\":[\"介绍：java虚拟机给每个对象分配一个this，代表当前对象，存储了当前对象的地址\",\"细节：\",\"this关键字可以用来访问本类的属性，方法，构造器\",\"this只能在类定义的方法中使用\",\"this用于区分全局变量和局部变量\",\"用this访问构造器：this（参数列表）只能在构造器中使用\"]},\"394\":{\"h\":\"七、面向对象编程（中级）\"},\"395\":{\"h\":\"IDEA的使用\",\"t\":[\"IDEA快捷键\",\"删除当前行 ctrl + d\",\"复制当前行 ctrl + alt + ⬇\",\"补全代码 alt + /\",\"添加 / 取消注释 ctrl + /\",\"自动导入对应包 alt + enter\",\"快速格式化代码 ctrl + alt + L\",\"生成构造器 alt + insert\",\"查看继承关系 ctrl + H\",\"快速跳转方法的定义 ctrl + B\",\"模板 / 自定义模板\",\"fie -> settings -> editor -> live templates ->\",\"sout模板\",\"fori模板\"]},\"396\":{\"h\":\"包Package\",\"t\":[\"包的三大作用\",\"区分名字相同的类\",\"当类很多时，可以很好的管理类\",\"控制访问范围\",\"包基本语法\",\"package com.ymk\",\"(关键字) (包名) com是一级目录 ymk是二级目录\",\"包的本质\",\"创建不同的文件夹目录来保存类文件\",\"命名规范\",\"com.公司名.项目名.业务模块名\",\"常用的包\",\"java.lang // 基本包，默认引入\",\"java.util // util包，工具包\",\"java.net // 网络包，做网络开发\",\"java.awt // java界面开发\",\"Java核心技术卷补充\",\"静态导入：\",\"import static java.lang.System.*;// 导入了System类的所有静态方法和静态成员 out.println(\\\"hello\\\") \"]},\"397\":{\"h\":\"访问修饰符\",\"t\":[\"基本介绍\",\"控制方法和属性的访问权限\",\"public\",\"protected\",\"默认级别\",\"private\",\"访问级别\",\"访问控制修饰符\",\"同类\",\"同包\",\"子类\",\"不同包\",\"公开\",\"public\",\"✔\",\"✔\",\"✔\",\"✔\",\"受保护\",\"protected\",\"✔\",\"✔\",\"✔\",\"❌\",\"默认\",\"没有修饰符\",\"✔\",\"✔\",\"❌\",\"❌\",\"私有\",\"private\",\"✔\",\"❌\",\"❌\",\"❌\",\"细节\",\"只有public和默认才能修饰类\"]},\"398\":{\"h\":\"面向对象特征 --- 封装\",\"t\":[\"介绍 封装就是把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（方法），才能对数据进行操作\",\"好处\",\"隐藏实现细节\",\"可以对数据进行验证\",\"封装实现步骤\",\"将属性进行私有化private（除了该类的方法外，无法修改属性）\",\"提供一个公共的set方法，来对属性进行判断赋值\",\"提供一个公共的get方法，来获取属性的值\"]},\"399\":{\"h\":\"面向对象特征 --- 继承\",\"t\":[\"介绍\",\"当两个类中很多属性和方法都可以共用，这时候就需要继承。子类通过继承父类中的共有属性和方法\",\"基本语法\",\"class 子类 extends 父类 {\",\"}\",\"细节\",\"子类继承了所有的属性和方法，但是私有属性不能在子类直接访问，要通过公共的方法去访问\",\"子类必须调用父类的构造器完成父类的初始化\",\"当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类中用super去指定使用父类哪个构造器完成对父类的初始化工作\",\"同样，如果不想用默认的父类构造器，也可以用super指定一个\",\"super在使用时，需要放在构造器第一行\",\"super（）和this（）不能存在同一个构造器\",\"java所有类都是object的子类\",\"父类构造器的调用不仅仅调用定义的父类，将一直向上调用到object\",\"一个子类只能继承一个父类\",\"继承的本质分析\",\"public class Extend01 { public static void main(String[] args) { Son son = new Son(); // 按照查找关系来返回属性 // 1. 首先看子类是否有该属性 // 2. 如果子类有这个属性，并且可以访问，则返回该信息（private修饰的属性是不能被子类访问的） // 3. 如果子类没有则向上面的父类查找，直到一个父类有该属性 System.out.println(son.name); // 三个类都有name属性，这里返回的是son的name } } class Grandpa { String name = \\\"grandpa\\\"; String hobby = \\\"travel\\\"; } class Father extends Grandpa{ String name = \\\"father\\\"; int age = 48; } class Son extends Father{ String name = \\\"son\\\"; } \"]},\"400\":{\"h\":\"Super关键字\",\"t\":[\"介绍\",\"super代表父类的引用，用于访问父类的属性、方法、构造器\",\"基本语法\",\"访问父类的属性 / 方法，但不能访问父类的private属性 / 方法：super.属性名 / 方法\",\"访问父类的构造器：super（参数列表）\",\"细节\",\"调用父类构造器的好处（分工明确，父类属性由父类初始化，子类属性由子类初始化）\",\"当子类中有和父类重名的属性 / 方法时，要访问父类成员必须用super\",\"super的访问不限于父类，若使用super父类中没有，则会使用父类的父类，super的访问遵循就近原则\",\"super和this的比较\",\"NO.\",\"区别点\",\"this\",\"super\",\"1\",\"访问属性\",\"访问本类中的属性，如果本类中没有则从父类中继续查找\",\"访问父类中的属性，父类中没有则往父类中的父类查找\",\"2\",\"调用方法\",\"访问本类中的方法，如果本类中没有则从父类中继续查找\",\"直接访问父类中的方法\",\"3\",\"调用构造器\",\"调用本类的构造器，必须放在构造器首行\",\"调用父类构造器，必须放在首行\",\"4\",\"特殊\",\"表示当前对象\",\"子类中访问父类对象\"]},\"401\":{\"h\":\"方法重写 / 覆盖（override）\",\"t\":[\"介绍\",\"就是子类有一个和父类相同的方法\",\"细节\",\"子类方法的名称，参数要和父类方法完全相同\",\"子类方法的返回类型需和父类方法返回类型一样，或者是父类方法返回类型的子类，例如父类返回object，子类返回String\",\"子类方法不能缩小父类方法的访问权限，即父类为public时子类不能是protected，默认，private\",\"重载与重写的区别\",\"名称\",\"作用范围\",\"方法名\",\"形参列表\",\"返回类型\",\"修饰符\",\"重载overload\",\"本类\",\"相同\",\"不能完全一样\",\"无要求\",\"无要求\",\"重写override\",\"父子类\",\"相同\",\"相同\",\"相同或父子类关系\",\"子类不能缩小父类访问权限\"]},\"402\":{\"h\":\"面向对象特征 --- 多态\",\"t\":[\"介绍\",\"方法和对象具有多种形态，多态是建立在封装和继承的基础上的\",\"多态的具体体现\",\"方法的多态\",\"重写和重载就体现了方法的多态\",\"对象的多态（核心）\",\"public class Poly01 { public static void main(String[] args) { Animal animal = new Dog(); // 一个对象的编译类型和运行类型可以不一致，等号左边是编译类型，右边是运行类型 animal.cry(); // 输出为Woo，会优先执行运行类型中的方法，若没有则会执行编译类型中的方法 animal = new Cat(); // 运行类型可以改变，但编译类型不能改变 animal.cry(); // 输出为Meow } } class Animal { public void cry() { System.out.println(\\\"谁在叫\\\"); } } class Dog extends Animal{ public void cry() { System.out.println(\\\"Woo!\\\"); } } class Cat extends Animal{ public void cry() { System.out.println(\\\"Meow!\\\"); } } \",\"多态的向上转型\",\"本质：父类引用指向子类对象\",\"语法：父类类型 引用名 = new 子类名（）；\",\"特点：可以调用父类中的所有成员，不能调用子类中的特有成员\",\"多态的向下转型 语法：子类类型 引用名 = （子类类型）父类引用\",\"要求父类引用必须指向当前子类类型\",\"可以调用子类中所有成员\",\"public class Poly01 { public static void main(String[] args) { Animal animal = new Dog(); Dog dog = (Dog)animal; // 强制类型转换 } } \",\"属性重写问题\",\"属性与方法不同，属性没有重写一说\",\"public class Poly01 { public static void main(String[] args) { Base base = new Sub(); System.out.println(base.count); // 输出Base类型的count，属性的输出看其编译类型 } } class Base { int count = 10; } class Sub extends Base { int count = 20; } \"]},\"403\":{\"h\":\"java的动态绑定机制（非常重要）\",\"t\":[\"public class DynamicBind { public static void main(String[] args) { A a = new B(); System.out.println(a.sum()); // 1. 当调用对象方法时，该方法会和对象的运行类型绑定 System.out.println(a.sum1()); // 2. 当调用对象属性时，没有动态绑定机制，哪里声明哪里使用 } } class A { public int i = 10; public int sum() { return geiI() + 10; } public int sum1() { return i + 10; } public int geiI() { return i; } } class B extends A { public int i = 20; // public int sum() { // return i + 20; // } public int sum1() { return i + 10; } public int geiI() { return i; } } \"]},\"404\":{\"h\":\"多态的应用 --- 多态数组\",\"t\":[\"介绍\",\"数组的定义类型为父类类型，里面保存的实际元素为子类类型\",\"示例\",\"// test.java public class test { public static void main(String[] args) { // 多态数组 Person[] persons = new Person[5]; persons[0] = new Person(\\\"jack\\\", 20); persons[1] = new Student(\\\"rose\\\", 18, 100); persons[2] = new Teacher(\\\"smith\\\", 24, 6000); persons[3] = new Student(\\\"nancy\\\", 19, 87); persons[4] = new Teacher(\\\"david\\\", 23, 20000); // 循环调用动态数组 for (Person person : persons) { person.say(); // 动态绑定机制，会按照运行的类型动态地调用方法 } } } // Person.java public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public void say() { System.out.println(\\\"name: \\\" + name); System.out.println(\\\"age: \\\" + age); } } // Student.java public class Student extends Person{ private int score; public Student(String name, int age, int score) { super(name, age); this.score = score; } public int getScore() { return score; } public void setScore(int score) { this.score = score; } @Override public void say() { super.say(); System.out.println(\\\"score: \\\" + score); } } // Teacher.java public class Teacher extends Person{ private int salary; public Teacher(String name, int age, int salary) { super(name, age); this.salary = salary; } public int getSalary() { return salary; } public void setSalary(int salary) { this.salary = salary; } @Override public void say() { super.say(); System.out.println(\\\"salary: \\\" + salary); } } \"]},\"405\":{\"h\":\"多态的应用 --- 多态参数\",\"t\":[\"介绍\",\"方法定义的形参为父类类型，形参可以为子类类型\"]},\"406\":{\"h\":\"Object类详解\",\"t\":[\"equles方法\",\"== 与 equles 对比\",\"== 判断基本类型，表示判断对象的值是否相等\",\"== 判断引用类型，表示判断对象的值是否相等\",\"equles方法只能用来判断引用类型，默认判断对象地址是否相等，子类中往往重写该方法\",\"// 源代码中object类中的equles方法 public boolean equles(Object obj) { return (this == obj) } // Integer中的equles方法 public Boolean equles(Object obj) { if (obj instanceof Integer) { return value == ((Integer)obj).intvalue(); } } \",\"hashcode方法\",\"提高哈希结构容器的效率\",\"两个引用，如果指向同一个对象，那么哈希值肯定是一样的；如果指向不同对象，那么哈希值肯定不一样\",\"哈希值主要是根据地址号来的，但不完全等价于地址\",\"后面集合中，会重写hashcode方法\",\"toString方法\",\"介绍\",\"默认返回：全类名 + @ + 哈希值的十六进制，子类往往重写toString方法，用于返回对象的属性类型\",\"// object类的toString方法 public String toString() { return getClass().getName() + \\\"@\\\" + Integer.toHexString(hashCode()); } \",\"细节\",\"重写toString方法打印该对象和拼接对象时，都会自动调用该对象的toString形式\",\"直接输出一个对象时toString方法会默认调用\",\"finalize方法\",\"当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作。\",\"什么时候被回收：当某个对象没有任何引用时，则jvm就认为该对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象。\",\"垃圾回收机制的调用，是由系统来决定的，也可以由system.gc() 主动触发垃圾回收机制\"]},\"407\":{\"h\":\"八、项目 ：房屋出租系统\"},\"408\":{\"h\":\"项目需求\",\"t\":[\"实现基于文本界面的房屋出租系统，能够实现对房屋信息的添加、修改、删除（用数组实现），并能够打印房屋明细表\",\"主菜单\",\"——————房屋出租系统——————\",\"新增房源\",\"查找房源\",\"删除房源\",\"修改房屋信息\",\"房屋列表\",\"退出\",\"查找房源\",\"请选择（1-6）：2\",\"————————查找房屋————————\",\"请输入你要查找的id：1\",\"1 jack 118 海淀区 3000 未出租\",\"————————查找房屋————————\",\"请输入你要查找的id：10\",\"————————没有该房屋———————\",\"删除房源\",\"————————删除房屋————————\",\"请选择房屋编号（-1退出）：1\",\"确认是否删除（Y/N）：Y\",\"————————删除完成————————\",\"修改房源（如果不希望修改直接回车即可）\",\"————————修改客户————————\",\"请选择修改房屋编号（-1退出）：2\",\"姓名（king）：（None）\",\"电话（112）：（116）\",\"地址（朝阳区）：（昌平区）\",\"租金（2000）：5000\",\"状态（未出租）：已出租\",\"————————修改完成————————\",\"房屋列表\",\"————————房屋列表————————\",\"编号 房主 电话 地址 月租 状态（未出租/已出租）\",\"2 none 116 昌平区 5000 已出租\"]},\"409\":{\"h\":\"程序框架设计\",\"t\":[\"HouseView.java（界面） \",\"显示界面\",\"接收其他用户的输入\",\"调用其他类完成对房屋信息的各种操作\",\"HouseService.java（业务） \",\"响应HouseView的调用\",\"完成对房屋信息的各种操作（增删改查）\",\"House.java（model） \",\"一个House对象表示一个房屋信息\",\"HouseRentApp.java（程序入口）\"]},\"410\":{\"h\":\"九、面向对象编程（高级）\"},\"411\":{\"h\":\"类变量和类方法\",\"t\":[\"类变量\",\"什么是类变量\",\"类变量就叫静态变量，该类所有对象共享的变量\",\"如何定义类变量\",\"加上static\",\"jdk7以上的版本，静态域存储于定义类型的class对象中，class对象如同堆中其他对象一样存在GC堆中\",\"如何访问类变量\",\"推荐使用：类名.类变量名\",\"public class ChildGame { public static void main(String[] args) { Child child1 = new Child(\\\"jack\\\"); Child child2 = new Child(\\\"rose\\\"); child1.join(); System.out.println(child1.count); // 输出都为1 System.out.println(child2.count); child2.join(); System.out.println(child1.count); // 输出都为2 System.out.println(child2.count); } } class Child { private String name; public static int count = 0; // 类静态变量，所有对象共享 public Child() {} public Child(String name) { this.name = name; } public void join() { System.out.println(name + \\\"加入了游戏.\\\"); count ++; } } \",\"类方法\",\"类方法中无this参数\",\"类方法可以通过类名调用，也可以通过对象名调用\",\"细节\",\"静态方法只能访问静态成员\",\"非静态方法可以访问所有成员\",\"在编写代码时，仍要遵守访问权限规则\"]},\"412\":{\"h\":\"理解main方法语法\",\"t\":[\"深入理解main方法：public static void main（String[] args）{}\",\"java虚拟机在调用main方法，所以该方法的访问权限必须是public\",\"static可以使虚拟机在执行main方法时不必创建对象\",\"String[] 数组的参数在执行java命令时传递\",\"main方法与一般static方法相同，可以调用类的静态成员，不能调用非静态成员\"]},\"413\":{\"h\":\"代码块\",\"t\":[\"基本介绍\",\"类成员，类似于方法，但与方法不同没有方法名，没有返回，没有参数，只有方法体，而且不显示调用，只有加载类或创建对象时隐式调用\",\"基本语法\",\"[修饰符] { 代码 }；\",\"注意\",\"修饰符可选，只能写static\",\"有静态代码块和普通代码块\",\"；号可以省略\",\"细节\",\"static代码块作用是对类进行初始化，随着类的加载而执行，只会执行一次\",\"普通代码块，每创建一个对象就会执行一次\",\"类什么时候被加载\",\"创建对象实例时（new）\",\"创建子类对象实例，父类也会被加载\",\"使用类的静态成员时\",\"普通的代码块，在创建对象实例时，会被隐式的调用。每创建一次就会调用一次\",\"如果只是使用类的静态成员，不会调用\",\"public class CodeBlockDetail { public static void main(String[] args) { AA.hi(); // 输出为 // AA的静态代码块1被执行 // hi } } class AA { // 静态代码块 static { System.out.println(\\\"AA的静态代码块1被执行\\\"); } // 普通代码块 { System.out.println(\\\"AA的普通代码块1被执行\\\"); } // 类静态方法 public static void hi() { System.out.println(\\\"hi\\\"); } } \",\"创建一个对象时，在一个类中的调用顺序是：\",\"调用静态代码块和静态属性初始化（初始化顺序取决于定义顺序）\",\"调用普通代码块和普通属性初始化（初始化顺序取决于定义顺序）\",\"调用构造方法\",\"public class CodeBlockDetail { public static void main(String[] args) { AA aa = new AA(); } } class AA { public AA() { System.out.println(\\\"AA的构造器\\\"); } // 静态代码块 static { System.out.println(\\\"AA的静态代码块1被执行\\\"); } static { System.out.println(\\\"AA的静态代码块2被执行\\\"); } // 普通代码块 { System.out.println(\\\"AA的普通代码块1被执行\\\"); } { System.out.println(\\\"AA的普通代码块2被执行\\\"); } // 类静态方法 public static void hi() { System.out.println(\\\"hi\\\"); } } // 输出 // AA的静态代码块1被执行 // AA的静态代码块2被执行 // AA的普通代码块1被执行 // AA的普通代码块2被执行 // AA的构造器 \",\"构造器的最前面隐含了super（）和调用普通代码块\",\"class A { public A() { super(); // 调用普通代码块 System.out.println(\\\"OK\\\"); } } \",\"创建一个子类对象时，初始化顺序如下\",\"父类的静态代码块和静态属性（初始化顺序取决于定义顺序）\",\"子类的静态代码块和静态属性（初始化顺序取决于定义顺序）\",\"父类的普通代码块和普通属性（初始化顺序取决于定义顺序）\",\"父类的构造方法\",\"子类的普通代码块和普通属性（初始化顺序取决于定义顺序）\",\"子类的构造方法\",\"静态代码块只能调用静态成员，普通代码块可以调用任意成员\"]},\"414\":{\"h\":\"单例设计模式\",\"t\":[\"什么是单例模式（单个实例）\",\"采取一定方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且只提供一个取得对象实例的方法\",\"单例模式有两种：1）饿汉式 2）懒汉式\",\"单例模式应用实例\",\"构造器私有化 =》防止直接new对象\",\"类的内部创建对象\",\"向外暴露一个静态的公共方法\",\"代码实现\",\"// 饿汉式 public class SingleTon01 { public static void main(String[] args) { GirlFriend instance = GirlFriend.getInstance(); GirlFriend instance2 = GirlFriend.getInstance(); // 两个instance都指向同一个实例 System.out.println(instance); System.out.println(instance2); } } class GirlFriend { private String name; // 类的内部创建对象 private static GirlFriend only = new GirlFriend(\\\"ztt\\\"); // 构造器私有化 private GirlFriend(String name) { this.name = name; } // 向外暴露一个静态的公共方法 public static GirlFriend getInstance() { return only; } public String getName() { return name; } public void setName(String name) { this.name = name; } } \",\"构造器私有化\",\"定义一个static静态属性对象\",\"提供一个public的static方法，可以返回一个Cat对象（若对象为null则创建一个对象）\",\"public class SingleTon02 { public static void main(String[] args) { Cat instance = Cat.getInstance(); Cat instance2 = Cat.getInstance();// 两次只运行了一次构造器 } } class Cat { private String name; static Cat cat; private Cat(String name) { System.out.println(\\\"运行构造器\\\"); this.name = name; } public static Cat getInstance() { if (cat == null) { cat = new Cat(\\\"ztt\\\"); } return cat; } } \"]},\"415\":{\"h\":\"final关键字\",\"t\":[\"基本介绍\",\"当不希望类被继承时，可以用final修饰\",\"当不希望父类的某个方法被子类重写时，可以用final关键字修饰\",\"当不希望类的某个属性被改时，可以用final修饰\",\"当不希望某个局部变量被修改时，可以用final修饰\",\"final使用细节\",\"final修饰的属性又叫常量，一般用XX_XX_XX来命名\",\"final修饰的属性在定义时，必须赋初值，并且以后不能再修改 赋值可以在定义时，构造器中，或代码块中\",\"如果final修饰的属性是静态的，那么初始化位置只能是定义时或静态代码块中，不能在构造器中赋值\",\"final + static 搭配使用不会导致类加载\",\"public class FinalDetail02 { public static void main(String[] args) { System.out.println(A.num); } } class A { // public static int num = 999; // 输出该属性会导致类加载，静态代码块被执行 public static final int num = 998; // final修饰后就不会导致类加载，只打印998 static { System.out.println(\\\"A的静态代码块被执行\\\"); } } \"]},\"416\":{\"h\":\"抽象类\",\"t\":[\"抽象类的介绍\",\"用abstract关键字来修饰类，这个类就是抽象类\",\"用abstract关键字来修饰方法，这个类就是抽象方法\",\"抽象类使用细节\",\"抽象类不一定包含抽象方法，但是一个类包含抽象方法则一定要声明为抽象类\",\"abstract只能修饰类和方法，不能修饰属性\",\"如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，否则该类也得声明为抽象类\",\"抽象模板 使用抽象模板来计算任意一段代码的运行时间\",\"public class Template01 { public static void main(String[] args) { new TestTemp().calcTimes(); } } // 使用抽象模板来计算任意一段代码的运行时间 abstract class Template { public abstract void code(); //计算一段代码的运行时间 public void calcTimes() { long startTime = System.currentTimeMillis(); code(); long endTime = System.currentTimeMillis(); System.out.println(\\\"耗时：\\\" + (endTime-startTime)); } } class TestTemp extends Template { public void code() { long num = 0; for (long i = 1; i <= 8000000; i++) { num += i; } } } \"]},\"417\":{\"h\":\"接口\",\"t\":[\"基本介绍\",\"给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来\",\"语法\",\"interface 接口名 {\",\"​ // 属性\",\"​ // 方法\",\"}\",\"class 类名 implements 接口 {\",\"​ // 自己的属性\",\"​ // 自己的方法\",\"​ // 必须实现接口的抽象方法\",\"}\",\"// Interface01.java public class Interface01 { public static void main(String[] args) { Computer pc = new Computer(); pc.work(new Camera()); } } // USBInterface.java public interface USBInterface { public void start(); // 接口中abstract可以省略 public void stop(); } // Camera.java public class Camera implements USBInterface{ @Override public void start() { System.out.println(\\\"相机开始工作\\\"); } @Override public void stop() { System.out.println(\\\"相机停止工作\\\"); } } //Computer.java public class Computer { public void work(USBInterface usbInterface) { usbInterface.start(); usbInterface.stop(); } } \",\"细节\",\"接口不能被实例化\",\"接口中的所有方法是public方法，接口中的抽象方法可以不写abstract\",\"一个普通类实现接口就必须将该接口的所有方法都实现；抽象类可以不用\",\"一个类可以同时实现多个接口\",\"接口中的属性是final + static的\",\"接口不能继承类，但可以继承接口\",\"接口的修饰符只能用public或默认\",\"接口VS继承\",\"子类继承父类就自动拥有父类的功能\",\"如果子类需要扩展功能，可以通过接口的方式扩展\",\"接口的多态\",\"public class InterfacePolyPara { public static void main(String[] args) { IF0 if0 = new Cat(); // 像类一样的多态 IF0 if1 = new Dog(); } } interface IF0 {} class Cat implements IF0 {} class Dog implements IF0 {} \",\"接口多态传递\",\"public class InterfacePolyPass { public static void main(String[] args) { IH1 ih1 = new Teacher(); IH0 ih0 = new Teacher(); // 接口的传递性让Teacher类也实现了IH0接口 } } interface IH0 {} interface IH1 extends IH0{} class Teacher implements IH1 {} \",\"练习\",\"interface A { int x = 0; } class B { int x = 1; } class C extends B implements A { public void printX() { // 访问接口的x就用A.x // 访问父类的x就用super.x System.out.println(A.x); System.out.println(super.x); } public static void main(String[] args) { new C().printX(); } } \",\"抽象类与接口的区别\",\"Java核心技术卷补充\",\"default方法冲突 \",\"超类的默认方法优先\",\"如果同时implements的两个接口有同名default方法，需要手动选择方法\",\"如果继承的超类和接口中有同名默认方法，超类的方法优先\"]},\"418\":{\"h\":\"内部类\",\"t\":[\"介绍\",\"一个类的内部嵌套了一个类\",\"语法\",\"class Outer { // 外部类\",\"​ class Inner { } // 内部类\",\"}\",\"class other { } // 其他类\",\"内部类的分类\",\"定义在外部类的局部位置上（比如方法内） \",\"局部内部类（有类名）\",\"匿名内部类（没有类名）\",\"定义在外部类的成员位置上 \",\"成员内部类（没有static）\",\"静态内部类（有static）\",\"局部内部类的使用\",\"可以直接访问外部类的所有成员\",\"不能添加访问修饰符，可以使用final修饰符\",\"作用域仅在定义的局部\",\"局部类访问外部类可以直接访问\",\"外部类访问局部类要先创建局部类对象再访问其成员\",\"class Outer1 { private int n1 = 1; public void f1() { class Inner01 { private void f2() { System.out.println(\\\"外部类n1 = \\\" + Outer1.this.n1); // 可以直接访问外部类的所有成员 System.out.println(\\\"内部类n1 = \\\" + n1); // 成员名重名时采用就近原则，优先本类的n1 f3(); } } final class Inner02 extends Inner01 {} // 不能添加访问修饰符，可以使用final修饰符 Inner01 inner02 = new Inner02(); // 外部类访问局部类要先创建局部类对象再访问其成员 inner02.f2(); } public void f3() { System.out.println(\\\"外部类f3()\\\"); } } \",\"外部其他类不能访问局部内部类（局部内部类是局部变量）\",\"匿名内部类的使用\",\"匿名内部类既是一个类的定义，又是一个类的对象\",\"public class AnonymousInner { public static void main(String[] args) { // 基于接口的匿名内部类，编译类型IA，运行类型是匿名内部类 IA cat = new IA() { // 匿名内部类，相当于下方注释的Cat类 @Override public void cry() { System.out.println(\\\"Meow\\\"); } }; cat.cry(); IA dog = new IA() { @Override public void cry() { System.out.println(\\\"Woo\\\"); } }; dog.cry(); System.out.println(\\\"匿名类名称：\\\" + cat.getClass()); // 输出为：匿名类名称：class ymkedu.oop.Innerclass_.AnonymousInner$1 // 匿名类名称为外部类名称加个$1 System.out.println(\\\"匿名类名称：\\\" + dog.getClass()); // 基于类的匿名内部类 Father father = new Father(\\\"Father匿名内部类\\\") { @Override public void hello() { System.out.println(\\\"hello Father匿名内部类\\\"); super.hello(); } }; father.hello(); // 基于抽象类的匿名内部类与普通类的区别是必须要重写抽象方法 } } interface IA { public void cry(); } class Father { private String name; public Father(String name) { this.name = name; } public void hello() { System.out.println(\\\"hello Father\\\"); } } //class Cat implements IA { // @Override // public void cry() { // System.out.println(\\\"Meow\\\"); // } //} \",\"成员内部类\",\"成员内部类定义在外部类的成员位置，没有static修饰\",\"可以直接访问所有成员\",\"可以添加访问修饰符\",\"作用域在整个类中，外部类需要先创建对象再调用\",\"静态内部类\",\"比成员内部类多个static\",\"可以访问外部类的所有静态成员\",\"可以添加访问修饰符\",\"作用域整个类\"]},\"419\":{\"h\":\"代理（proxy）\",\"t\":[\"介绍\",\"利用代理可以在运行时创建实现一组给定接口的新类。只有在编译时期无法确定需要实现哪个接口时才有必要使用代理\",\"静态代理\",\"通过静态代理来实现功能增强\",\"public interface UserService { public void select(); public void update(); } public class UserServiceImpl implements UserService { public void select() { System.out.println(\\\"查询 selectById\\\"); } public void update() { System.out.println(\\\"更新 update\\\"); } } // 增强的代理 public class UserServiceProxy implements UserService { private UserService target; // 被代理的对象 public UserServiceProxy(UserService target) { this.target = target; } public void select() { before(); target.select(); // 这里才实际调用真实主题角色的方法 after(); } public void update() { before(); target.update(); // 这里才实际调用真实主题角色的方法 after(); } private void before() { // 在执行方法之前执行 System.out.println(String.format(\\\"log start time [%s] \\\", new Date())); } private void after() { // 在执行方法之后执行 System.out.println(String.format(\\\"log end time [%s] \\\", new Date())); } } public class Client1 { public static void main(String[] args) { UserService userServiceImpl = new UserServiceImpl(); UserService proxy = new UserServiceProxy(userServiceImpl); proxy.select(); proxy.update(); } } \",\"静态代理的缺点\",\"当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：\",\"只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大\",\"新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类\",\"当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。\",\"动态代理介绍\",\"Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情：\",\"通过一个类的全限定名来获取定义此类的二进制字节流\",\"将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\",\"在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口\",\"为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：\",\"通过实现接口的方式 -> JDK动态代理\",\"通过继承类的方式 -> CGLIB动态代理\",\"JDK动态代理\",\"利用反射机制，实现 InvocationHandler 接口，重写invoke方法\",\"import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.Date; public interface UserService { public void select(); public void update(); } public class UserServiceImpl implements UserService { public void select() { System.out.println(\\\"查询 selectById\\\"); } public void update() { System.out.println(\\\"更新 update\\\"); } } public class LogHandler implements InvocationHandler { Object target; // 被代理的对象，实际的方法执行者 public LogHandler(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { before(); Object result = method.invoke(target, args); // 调用 target 的 method 方法 after(); return result; // 返回方法的执行结果 } // 调用invoke方法之前执行 private void before() { System.out.println(String.format(\\\"log start time [%s] \\\", new Date())); } // 调用invoke方法之后执行 private void after() { System.out.println(String.format(\\\"log end time [%s] \\\", new Date())); } } // 调用代理类 public class Client2 { public static void main(String[] args) throws IllegalAccessException, InstantiationException { // 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名 // System.getProperties().setProperty(\\\"sun.misc.ProxyGenerator.saveGeneratedFiles\\\", \\\"true\\\"); // 1. 创建被代理的对象，UserService接口的实现类 UserServiceImpl userServiceImpl = new UserServiceImpl(); // 2. 获取对应的 ClassLoader ClassLoader classLoader = userServiceImpl.getClass().getClassLoader(); // 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService， Class[] interfaces = userServiceImpl.getClass().getInterfaces(); // 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用 // 这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl InvocationHandler logHandler = new LogHandler(userServiceImpl); /* 5.根据上面提供的信息，创建代理对象 在这个过程中， a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码 b.然后根据相应的字节码转换成对应的class， c.然后调用newInstance()创建代理实例 */ UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler); // 调用代理的方法 proxy.select(); proxy.update(); // 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy // ProxyUtils.generateClassFile(userServiceImpl.getClass(), \\\"UserServiceProxy\\\"); } } \"]},\"420\":{\"h\":\"枚举和注解\"},\"421\":{\"h\":\"枚举\",\"t\":[\"介绍\",\"public class Enum01 { public static void main(String[] args) { System.out.println(Season.SPRING); } } enum Season { SPRING(\\\"春天\\\", \\\"温暖\\\"), SUMMER(\\\"夏天\\\", \\\"炎热\\\"), AUTUMN(\\\"秋天\\\", \\\"凉爽\\\"), WINTER(\\\"冬天\\\", \\\"寒冷\\\"); private String name; private String desc; // 枚举类型构造器默认是private，防止修改内部属性 Season(String name, String desc) { this.name = name; this.desc = desc; } // 使用枚举类型就不需要 // public static Season Spring = new Season(\\\"春天\\\", \\\"温暖\\\"); // public static Season Summer = new Season(\\\"夏天\\\", \\\"炎热\\\"); // public static Season Autumn = new Season(\\\"秋天\\\", \\\"凉爽\\\"); // public static Season Winter = new Season(\\\"冬天\\\", \\\"寒冷\\\"); public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } } \",\"细节\",\"使用enum关键字的类默认会继承Enum类（包含Enum类的一些属性和方法）\",\"枚举对象必须放在类的第一行\",\"使用enum关键字之后就不能再继承其他类了，因为隐式的继承了Enum类，java是单继承机制\",\"枚举类也可以实现接口\",\"枚举类常用方法\",\"toString：Enum类已经重写过，默认返回对象的属性（可以重写该方法）\",\"name：得到当前枚举对象的名称，不常用，一般用toString\",\"ordinal：得到当前常量的次序\",\"compareTo：可以比较两个枚举常量的大小\",\"clone：枚举类型不能clone\",\"valueOf：传递枚举对象和枚举常量名称给静态方法valueOf，可以得到对应枚举常量\",\"equals\",\"hashCode\",\"getDeclaringClass：得到枚举常量所属类型的Class对象\"]},\"422\":{\"h\":\"注解\",\"t\":[\"注解（Annotation）介绍\",\"使用时要加@符号，并把注解当作一个修饰后面程序的修饰符\",\"三个基本的注解\",\"@Override：修饰一个方法，表示重写父类方法\",\"@Deprecated：表示某个程序元素（类、方法），已过时\",\"@SupressWarnings：抑制编译器警告 ，写入你不希望显示的警告信息\",\"JDK的元注解\",\"基本介绍\",\"元注解用于修饰其他注解\",\"元注解种类\",\"@Retention：指定注解的作用范围（Source，Class，Runtime）\",\"@Target：指定注解可以在哪些地方使用（类，方法）\",\"@Documented：指定该注解是否会在javadoc上体现\",\"@Inherited：子类会继承父类注解\"]},\"423\":{\"h\":\"十、异常\"},\"424\":{\"h\":\"异常介绍\",\"t\":[\"基本概念\",\"Java中，将程序执行中发生的不正常情况称为异常（不是语法错误和逻辑错误）\",\"异常对象都派生于Throwable类\",\"异常分类\",\"Error：java虚拟机无法解决的严重问题（JVM系统内部错误，资源耗尽），不能忽视\",\"Exception：其他因为编程错误或偶然的外在因素导致的一般性问题，派生出RuntimeException和IOException\",\"RuntimeException是非检查型异常是可以预测的，其余Exception是不可预测的异常\",\"常见运行时异常\",\"NullPointerException空指针异常\",\"String name = null; System.out.println(name.length()); \",\"ArithmeticException数学运算异常\",\"int num1 = 10, num2 = 0; int res = num1 / num2; // 整除0 \",\"ArrayIndexOutOfBoundsException数组下标越界异常\",\"int[] array = new int[5]; int m = array[-1]; // 非法索引访问数组 \",\"ClassCastException类型转换异常\",\"class A {}; class B extends A {}; class C extends A {}; A b = new B(); C c = (C)b; // 强制将代码转换为不是实例的子类 \",\"NumberFormatException数字格式不正确异常\",\"String name = \\\"yanmingkui\\\"; int num = Integer.parseInt(name); // 把非数字字符串转换为int \",\"编译异常\",\"编译异常是在编译期间必须处理的异常，否则不能通过编译\",\"异常处理机制\",\"try { // 代码可能有异常 } catch(Exception e) { // 捕获到异常 // 得到异常对象后，程序员自己处理 } finally { // 不管try代码块是否有异常，始终要执行finally // 通常将释放资源的代码放在finally } \",\"try—catch细节\",\"如果异常发生了，则异常后面的代码不会执行，直接进到catch块\",\"如果异常没有发生，则顺序执行try代码块，不会进入catch\",\"要求子类异常写在前面，父类异常写在后面\",\"try { // 代码 } catch (NullPointerException e) { } catch (ArithmeticException e) { } catch (Exception e) { // 父类写前面，后面的子类catch就没意义了 } \"]},\"425\":{\"h\":\"抛出异常\",\"t\":[\"声明检查型异常\",\"public FileInputStream(String name) throws FileNotFoundException // 可以抛出多个异常 \",\"表明这个构造器如果正常运行会产生一个FileInputStream对象，若出错则会抛出一个FileNotFoundException异常\",\"下面两种情况需要使用throws方法来抛出异常\",\"调用了一个抛出检查型异常的方法，例如FileInputStream构造器\",\"检测到一个错误，并利用throw语句抛出一个检查型异常\"]},\"426\":{\"h\":\"十一、常用类\"},\"427\":{\"h\":\"包装类\",\"t\":[\"包装类的分类（Wrapper）\",\"针对八种基本定义相应的引用类型\",\"有了类的特点，就可以调用类中的方法\",\"包装类和基本数据的转化\",\"jdk5前是手动装箱和手动拆箱\",\"public class WrapperType { public static void main(String[] args) { // 手动装箱 int i = 10; Integer i1 = new Integer(i); // 或者 Integer i2 = Integer.valueOf(i); // 手动拆箱 Integer j = new Integer(19); int j1 = j.intValue(); } } \",\"jdk5以后是自动装箱方式（调用valueOf）\",\"public class WrapperType { public static void main(String[] args) { // 自动装箱 int m = 10; Integer m2 = m; // 用的是valueOf // 自动拆箱 Integer n2 = new Integer(18); int n = n2; } } \",\"public class WrapperExercise01 { public static void main(String[] args) { // 三元运算符 默认按两者中精度最高的类型来输出 Object obj = true ? new Integer(1) : new Double(2.0); System.out.println(obj);// 输出1.0 } } \"]},\"428\":{\"h\":\"Integer类\",\"t\":[\"面试题（Integer创建机制）\",\"// 自动装箱用的valueOf函数 public static Integer valueOf(int i) { if (i >= IntegerCache.low && i <= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } // main函数 public class WrapperExercise02 { public static void main(String[] args) { Integer i = new Integer(1); Integer j = new Integer(1); System.out.println(i == j); // false，因为==比对的是是不是同一个类变量 Integer m = 1; Integer n = 1; System.out.println(m == n); // true，根据上面的valueOf函数所示，1在-127和128直接return缓存区的类 Integer x = 128; Integer y = 128; System.out.println(x == y); // false，128在范围外，根据valueOf函数，所以会new一个类变量 } } \"]},\"429\":{\"h\":\"String类\",\"t\":[\"String类的理解和创建对象\",\"String对象用于保存字符串\",\"字符串常量：“你好”， “12.97”\",\"字符串的字符使用Unicode编码，一个字符占两个字节\",\"String类较常用的构造器 \",\"String s1 = new String（）；\",\"String s2 = new String（String original）；\",\"String s3 = new String（char[] a);\",\"String s4 = new String（char[] a, int startIndex, int count）；\",\"String类实现了Serializable接口，串行化，可以在网络传输\",\"String是final类，不能继承\",\"String 有属性 private final char value[] 用于存放字符串类容，final 类型不能再指向其他字符串\",\"例子\",\"public class String01 { public static void main(String[] args) { String a = \\\"hello\\\"; String b = \\\"abc\\\"; String c = a + b; // 常量池中创建了3个变量，hello, abc, helloabc,c指向一个String变量，String变量指向常量池中的helloabc } } \",\"String 类的常见方法\",\"equals：区分大小写，判断内容是否相等\",\"equalsIgnoreCase：忽略大小写的判断\",\"length：获取字符个数\",\"indexOf：获取字符在字符串中第一次出现的索引，找不到则返回-1\",\"lastIndexOf：获取字符在字符串中最后一次出现的索引，找不到则返回-1\",\"substring：截取指定范围的字符串\",\"trim：去前后空格\",\"charAt：获取某索引处的字符\",\"toUpperCase\",\"toLowerCase\",\"concat：拼接字符串\",\"replace：替换字符串中的字符\",\"split：分割字符串，以一个字符为标准分割\",\"compareTo比较两个字符串的大小\",\"format：将所有信息拼接在一个字符串\",\"Java核心技术卷补充\",\"比较两个字符串相等时，不能用 == ，要用equals（），== 只能判断两个字符串是否放在相同的位置上，并不是比较字符串内容\",\"String str1 = \\\"hel\\\"; String str2 = \\\"hello\\\"; // 这里截取hello的前3位与\\\"hel\\\"比较，应当输出true System.out.println(str2.substring(0, 3) == \\\"hel\\\");// false // 因为定义str1时，常量池中已经出现了 hel ，substring产生的字符串并不在常量池中，所以不在同一位置，输出false System.out.println(str2.substring(0, 3).equals(\\\"hel\\\"));// true \"]},\"430\":{\"h\":\"StringBuffer类\",\"t\":[\"介绍\",\"StringBuffer是可变长度的，因为其父类的char[] value不是final类型，不用每次变化字符串都更换地址\",\"String与StringBuffer相互转换\",\"两者都可以使用构造器来相互转化\",\"public class StringAndStringBuffer { public static void main(String[] args) { //看 String——>StringBuffe String str = \\\"hello tom\\\"; //方式 1 使用构造器 //注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响 StringBuffer stringBuffer = new StringBuffer(str); //方式 2 使用的是 append 方法 StringBuffer stringBuffer1 = new StringBuffer(); stringBuffer1 = stringBuffer1.append(str); //看看 StringBuffer ->String StringBuffer stringBuffer3 = new StringBuffer(\\\"韩顺平教育\\\"); //方式 1 使用 StringBuffer 提供的 toString 方法 String s = stringBuffer3.toString(); //方式 2: 使用构造器来搞定 String s1 = new String(stringBuffer3); } } \",\"常见方法\",\"增 append：增加在末尾\",\"删 delete：删除指定索引之内的字符\",\"插 insert：指定索引位置插入\",\"长度 length\",\"练习\",\"public class StringBufferExercise { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(\\\"Input goods name: \\\"); StringBuffer goodsName = new StringBuffer(scanner.next()); System.out.print(\\\"Input goods price: \\\"); StringBuffer goodsPrice = new StringBuffer(scanner.next()); int dotIndex = goodsPrice.lastIndexOf(\\\".\\\"); for (int i = dotIndex-3; i > 0; i-=3) { goodsPrice.insert(i, \\\",\\\"); } // String name = goodsName.toString(); // String price = goodsPrice.toString(); String formatStr = \\\"商品名：%s\\\\t价格：%s\\\"; String info = String.format(formatStr, goodsName, goodsPrice); System.out.println(info); } } \"]},\"431\":{\"h\":\"StringBuilder类\",\"t\":[\"介绍\",\"与StringBuffer类类似，但比StringBuffer类要快，建议优先使用\",\"主要方法是append和insert，可以重载，以接收任意类型数据\",\"StringBuilder的方法没有做互斥处理，即没有synchronized关键字，因此在单线程的情况下使用\",\"三种String类比较\",\"public class Compare { public static void main(String[] args) { long startTime = 0L; long endTime = 0L; StringBuffer buffer = new StringBuffer(\\\"\\\"); startTime = System.currentTimeMillis(); for (int i = 0; i < 80000; i++) {//StringBuffer 拼接 20000 次 buffer.append(String.valueOf(i)); } endTime = System.currentTimeMillis(); System.out.println(\\\"StringBuffer 的执行时间：\\\" + (endTime - startTime)); StringBuilder builder = new StringBuilder(\\\"\\\"); startTime = System.currentTimeMillis(); for (int i = 0; i < 80000; i++) {//StringBuilder 拼接 20000 次 builder.append(String.valueOf(i)); } endTime = System.currentTimeMillis(); System.out.println(\\\"StringBuilder 的执行时间：\\\" + (endTime - startTime)); String text = \\\"\\\"; startTime = System.currentTimeMillis(); for (int i = 0; i < 80000; i++) {//String 拼接 20000 text = text + i; } endTime = System.currentTimeMillis(); System.out.println(\\\"String 的执行时间：\\\" + (endTime - startTime)); } } \",\"可以看出StringBuilder效率最高\",\"String、StringBuffer和StringBuilder类的选择\",\"如果字符串存在大量修改的操作，则使用StringBuffer或StringBuilder\",\"如果存在大量修改操作，并在单线程的情况，使用StringBuilder\",\"如果存在大量修改操作，并在多线程的情况，使用StringBuffer\",\"如果字符串很少修改，被多个对象引用，则使用String\"]},\"432\":{\"h\":\"Math类\",\"t\":[\"介绍\",\"包含基本数学运算的方法\",\"常用方法\",\"abs\",\"正余弦\",\"平方根\",\"随机数random（）：返回0~1之间一个随机小数\",\"最值\"]},\"433\":{\"h\":\"Arrays类\",\"t\":[\"包含了一系列静态方法，用于管理或操作数组\",\"常用方法\",\"toString 返回字符串形式\",\"Arrays.toString(arr); \",\"sort 排序\",\"Arrays.sort(arr); \",\"binarySearch 二分法查找，要求必须排好序\",\"Arrays.binarySearch(arr, 4); \",\"copyOf 数组元素复制\",\"int[] newArr = Arrays.copyOf(arr, arr.length); \",\"fill 数组元素填充\",\"equals 比较两个数组元素是否一致\",\"asList 将一组值，转换成List\",\"sort（）定制排序\",\"import java.util.Arrays; import java.util.Comparator; public class ArraysExercise { public static void main(String[] args) { Book[] books = new Book[4]; books[0] = new Book(\\\"红楼梦\\\", 43); books[1] = new Book(\\\"西游记\\\", 50); books[2] = new Book(\\\"水浒传\\\", 100); books[3] = new Book(\\\"三国演义\\\", 30); // price从大到小排序(定制排序),需要重写compare方法 // Arrays.sort(books, new Comparator<Object>() { // @Override // public int compare(Object o1, Object o2) { // Book b1= (Book)o1; // Book b2= (Book)o2; // return b2.getPrice() - b1.getPrice(); // } // }); // price从小到大排序 // Arrays.sort(books, new Comparator<Object>() { // @Override // public int compare(Object o1, Object o2) { // Book b1= (Book)o1; // Book b2= (Book)o2; // return b1.getPrice() - b2.getPrice(); // } // }); // name从长到短排序 Arrays.sort(books, new Comparator<Object>() { @Override public int compare(Object o1, Object o2) { Book b1= (Book)o1; Book b2= (Book)o2; return b2.getName().length() - b1.getName().length(); } }); for (Book book : books) { System.out.println(book.getName()); System.out.println(book.getPrice()); } } } class Book { private String name; private int price; public Book(String name, int price) { this.name = name; this.price = price; } \"]},\"434\":{\"h\":\"System类\",\"t\":[\"常用方法\",\"exit：退出当前程序\",\"arraycopy：复制数组元素\",\"currentTimeMillens：返回当前时间距离1970-1-1的毫秒数\",\"gc：运行垃圾回收机制\"]},\"435\":{\"h\":\"BigInteger和BigDecimal类\",\"t\":[\"介绍\",\"BigInteger适合保存比较大的整型\",\"BigDecimal适合保存精度更高的浮点型\",\"对这两类进行计算，需要用到下面的类方法\",\"常用方法\",\"add\",\"subtract\",\"multiply\",\"divide\"]},\"436\":{\"h\":\"日期类\",\"t\":[\"第一代日期类\",\"Date：精确到毫秒\",\"SimpleDateFormat：格式化和解析日期的类\",\"public class Date01 { public static void main(String[] args) { Date d1 = new Date(); // 获取当前的系统时间 System.out.println(\\\"当前日期 = \\\" + d1); Date d2 = new Date(9234567); // 根据指定秒数来获得日期 System.out.println(\\\"d2 = \\\" + d2); // 创建SimpleDateFormat对象来指定格式 SimpleDateFormat sdf = new SimpleDateFormat(\\\"yyyy 年 MM 月 dd 日 hh:mm:ss E\\\"); String fmt = sdf.format(d1); // 按format来转换字符串 System.out.println(\\\"当前日期 = \\\" + fmt); } } \",\"第二代日期类\",\"Calendar类\",\"Calendar是一个抽象类，并且构造器是private，要考getInstance（）来获取时间\",\"public class Calendar01 { public static void main(String[] args) { Calendar c = Calendar.getInstance(); //创建日历类对象//比较简单，自由 System.out.println(\\\"c=\\\" + c); //2.获取日历对象的某个日历字段 System.out.println(\\\"年：\\\" + c.get(Calendar.YEAR)); // 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号 System.out.println(\\\"月：\\\" + (c.get(Calendar.MONTH) + 1)); System.out.println(\\\"日：\\\" + c.get(Calendar.DAY_OF_MONTH)); System.out.println(\\\"小时：\\\" + c.get(Calendar.HOUR)); System.out.println(\\\"分钟：\\\" + c.get(Calendar.MINUTE)); System.out.println(\\\"秒：\\\" + c.get(Calendar.SECOND)); //Calender 没有专门的格式化方法，所以需要程序员自己来组合显示 System.out.println(c.get(Calendar.YEAR) + \\\"-\\\" + (c.get(Calendar.MONTH) + 1) + \\\"-\\\" + c.get(Calendar.DAY_OF_MONTH) + \\\" \\\" + c.get(Calendar.HOUR_OF_DAY) + \\\":\\\" + c.get(Calendar.MINUTE) + \\\":\\\" + c.get(Calendar.SECOND)); } } \",\"第三代日期类（JDK8加入）\",\"LocalDate（日期/年月日）、LocalTime（时间/时分秒）、LocalDateTime（日期时间/年月日时分秒）\",\"DateTimeFormatter格式日期类，类似于SimpleDateFormat类\",\"public class ThirdDate{ public static void main(String[] args) { //第三代日期 //1. 使用 now() 返回表示当前日期时间的 对象 LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now() System.out.println(ldt); //2. 使用 DateTimeFormatter 对象来进行格式化 // 创建 DateTimeFormatter 对象 DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\\\"yyyy-MM-dd HH:mm:ss\\\"); String format = dateTimeFormatter.format(ldt); System.out.println(\\\"格式化的日期=\\\" + format); System.out.println(\\\"年=\\\" + ldt.getYear()); System.out.println(\\\"月=\\\" + ldt.getMonth()); System.out.println(\\\"月=\\\" + ldt.getMonthValue()); System.out.println(\\\"日=\\\" + ldt.getDayOfMonth()); System.out.println(\\\"时=\\\" + ldt.getHour()); System.out.println(\\\"分=\\\" + ldt.getMinute()); System.out.println(\\\"秒=\\\" + ldt.getSecond()); LocalDate now = LocalDate.now(); //可以获取年月日 LocalTime now2 = LocalTime.now();//获取到时分秒 //提供 plus 和 minus 方法可以对当前时间进行加或者减 //看看 890 天后，是什么时候 把 年月日-时分秒 LocalDateTime localDateTime = ldt.plusDays(890); System.out.println(\\\"890 天后=\\\" + dateTimeFormatter.format(localDateTime)); //看看在 3456 分钟前是什么时候，把 年月日-时分秒输出 LocalDateTime localDateTime2 = ldt.minusMinutes(3456); System.out.println(\\\"3456 分钟前 日期=\\\" + dateTimeFormatter.format(localDateTime2)); } } \",\"Instant时间戳\",\"类似于Date，可以和Date互相转换\",\"Date date = Date.from(instant); Instant instant = date.toInstant(); \"]},\"437\":{\"h\":\"十二、集合\"},\"438\":{\"h\":\"集合的理解和好处\",\"t\":[\"集合\",\"可以动态保存多个对象\",\"提供了一系列增删改查的方法\"]},\"439\":{\"h\":\"Collection接口和常用方法\",\"t\":[\"常用方法\",\"add：添加单个元素\",\"remove：删除指定元素\",\"contains：查找元素是否存在\",\"size：获取元素个数\",\"isEmpty：判断是否为空\",\"clear：清空\",\"addAll：添加多个元素\",\"containsAll：查找多个元素是否都存在\",\"removeAll：删除多个元素\",\"遍历接口元素方式\",\"Iterator迭代器对象遍历\",\"Iterator接口的方法 \",\"hasNext（）：判断是否还有下个元素，如果有，就将指针指向下一个元素\",\"next（）：返回下一个元素，使用前必须先使用hasNext判断\",\"remove（）\",\"public class CollectionIterator { public static void main(String[] args) { Collection col = new ArrayList(); col.add(new Book(\\\"sanguoyanyi\\\", \\\"luoguanzhong\\\", 10.1)); col.add(new Book(\\\"hongloumeng\\\", \\\"caoxueqin\\\", 5.1)); col.add(new Book(\\\"xiyouji\\\", \\\"wuchengen\\\", 34.6)); // 遍历col // 1.得到col的迭代器，将指针指向col的第一个元素 Iterator iterator = col.iterator(); // 2.使用while循环遍历 while (iterator.hasNext()) { Object obj = iterator.next(); System.out.println(\\\"obj = \\\" + obj); } } } class Book { private String name; private String author; private double price; public Book(String name, String author, double price) { this.name = name; this.author = author; this.price = price; } @Override public String toString() { return \\\"Book{\\\" + \\\"name='\\\" + name + '\\\\'' + \\\", author='\\\" + author + '\\\\'' + \\\", price=\\\" + price + '}'; } } \",\"for循环增强\",\"for-each\",\"// 其实也是调用迭代器方法 for (Object b : col) { System.out.println(\\\"Book: \\\" + b); } \",\"​\"]},\"440\":{\"h\":\"List接口和常用方法\",\"t\":[\"介绍 List接口是Collection接口的子接口\",\"List集合类的接口是有序的，每个元素有对应的索引\",\"常用方法\",\"add\",\"get\",\"indexOf\",\"lastIndexOf\",\"remove\",\"set：替换掉指定位置的元素\",\"public class List01 { public static void main(String[] args) { List list = new ArrayList(); // add list.add(\\\"jack\\\"); list.add(10); list.add(true); list.add(2, \\\"rose\\\"); System.out.println(\\\"list = \\\" + list); // remove list.remove(true); System.out.println(\\\"list = \\\" + list); // contains System.out.println(list.contains(10)); // addAll 传入一个集合 ArrayList arrayList = new ArrayList(); list.addAll(arrayList); System.out.println(list.contains(10)); // set list.set(1, 5); System.out.println(list.contains(10)); // sublist 返回子列 List returnList = list.subList(1,3); System.out.println(list.contains(10)); // size 返回list的大小 System.out.println(list.size()); } } \",\"List的三种遍历方式\",\"使用iterator（参考上面的Collection遍历）\",\"使用for each\",\"使用普通for，通过index来遍历\",\"List练习\",\"public class ListExercise02 { public static void main(String[] args) { List list = new ArrayList(); list.add(new Book(\\\"xiyouji\\\", 12.3, \\\"wuchengen\\\")); list.add(new Book(\\\"anguoyanyi\\\", 22.1, \\\"shinaian\\\")); list.add(new Book(\\\"shuihuzhuan\\\", 12.5, \\\"luoguanzhong\\\")); for (int i = 0; i < list.size(); i++) { for (int j = i; j < list.size() - i; j++) { Book temp1 = (Book) list.get(i); Book temp2 = (Book) list.get(i + 1); if (temp1.getPrice() > temp2.getPrice()) { list.set(j + 1, temp1); list.set(j, temp2); } } } System.out.println(\\\"list:\\\" + list); } } class Book { private String name; private double price; private String author; public Book(String name, double price, String author) { this.name = name; this.price = price; this.author = author; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } @Override public String toString() { return \\\"name=\\\" + name + \\\", price=\\\" + price + \\\", author='\\\" + author; } } \"]},\"441\":{\"h\":\"ArrayList底层结构和源码分析\",\"t\":[\"注意事项\",\"ArrayList可以加入null\",\"ArrayList是由数组来实现数据存储的\",\"ArrayList基本等同于Vector，但是没有synchronized修饰，线程不安全\",\"ArrayList底层操作机制和源码分析\",\"ArrayList中有一个object数组\",\"当创建ArrayList对象时，如果使用无参构造器，则初始elementData容量为0，第一次添加则扩容为10，之后每次扩容为1.5倍\",\"如果使用指定大小的构造器，则初始elementData容量为指定大小，每次扩容变1.5倍\"]},\"442\":{\"h\":\"Vector底层结构和源码剖析\",\"t\":[\"介绍\",\"Vector底层也是一个对象数组，protected Object[] elementData\",\"Vector是线程同步的，线程安全\",\"Vector和ArrayList比较\",\"底层结构\",\"版本\",\"线程安全\",\"扩容倍数\",\"ArrayList\",\"可变数组\",\"jdk1.2\",\"不安全，效率高\",\"有参构造1.5倍如果是无参1.第一次102.从第二次开始1.5倍扩容\",\"Vector\",\"可变数组Object[]\",\"jdk1.0\",\"安全，效率不高\",\"如果是无参，默认10，满后按2倍扩容如果指定大小，每次都按2倍扩容\"]},\"443\":{\"h\":\"LinkedList底层结构\",\"t\":[\"说明\",\"LinkList底层实现了双向链表和双端队列地特点\",\"可以添加任意元素，包括null\",\"线程不安全，没有线程同步\",\"LinkedList底层操作机制\",\"底层双向链表，两个属性first和last分别指向首节点和尾节点\",\"每个节点中prev指向前一个节点，next指向后一个节点\",\"LinkedList的添加和删除，不是通过数组，效率更高\",\"LinkedList增删改查\",\"public class LinkedList01 { public static void main(String[] args) { LinkedList list = new LinkedList(); for (int i = 0; i < 10; i++) { list.add(\\\"hello\\\" + i); } System.out.println(\\\"LinkedList = \\\" + list); // 删除节点 list.remove(); // 不写index默认删除第一个节点 System.out.println(\\\"LinkedList = \\\" + list); list.remove(0); System.out.println(\\\"LinkedList = \\\" + list); // 修改节点 list.set(1, \\\"set1\\\"); System.out.println(\\\"LinkedList = \\\" + list); // 得到节点 Object o = list.get(1); System.out.println(o); // 遍历 System.out.println(\\\"LinkedList遍历\\\"); Iterator iterator = list.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(\\\"next = \\\"+next); } // for each遍历 System.out.println(\\\"for-each遍历\\\"); for (Object o1: list) { System.out.println(\\\"next = \\\"+o1); } } } \",\"ArrayList和LinkedList比较\",\"如果改查操作多用ArrayList\",\"如果增删操作多用LinkedList\",\"LinkedList的添加和删除\",\"List<String> staff = new LinkedList<>(); staff.add(\\\"Amy\\\"); staff.add(\\\"Bob\\\"); staff.add(\\\"Car\\\"); Iterator<String> iter1 = staff.iterator(); // 普通的迭代器只有remove方法 ListIterator<String> iter2 = staff.listIterator(); // 这种迭代器实现了add方法 // 注意 iter1.next(); iter1.remove(); // 删除了迭代器左边的元素 iter1.previous(); iter1.remove(); // 删除了迭代器右边的元素 \"]},\"444\":{\"h\":\"Set接口和常用方法\",\"t\":[\"介绍\",\"无序，没有索引\",\"不允许重复元素，所以最多包含一个null\",\"常用方法\",\"Set接口时Collection子接口，所以常用方法和Collection接口一样\",\"遍历方式\",\"迭代器\",\"for-each\",\"不能使用for加索引的方式来遍历\",\"public class Set01 { public static void main(String[] args) { Set set = new HashSet(); for (int i = 0; i < 10; i++) { set.add(\\\"hello\\\" + i); } Iterator iterator = set.iterator(); while (iterator.hasNext()) { Object next = iterator.next(); System.out.println(\\\"set = \\\" + next); } } } /*输出不是按add顺序来的 set = hello0 set = hello1 set = hello4 set = hello5 set = hello2 set = hello3 set = hello8 set = hello9 set = hello6 set = hello7 */ \"]},\"445\":{\"h\":\"Set接口实现类-HashSet\",\"t\":[\"介绍\",\"HashSet实际上是HashMap，构造器里使用了HashMap的构造器\",\"public HashSet() { map = new HashMap<>(); } \",\"可以存放null，但是只能有一个null\",\"不保证元素有序，hash后再确定索引结果\",\"HashSet底层机制说明\",\"HashSet底层是HashMap，HashMap底层是数组+链表+红黑树\",\"添加一个元素时，先得到Hash值，再将Hash值转换为索引值\",\"找到存储表table，看这个索引位置是否已经存放元素\",\"如果没有，直接存入\",\"如果有，调用equals比较，若相同就不添加，若不同就以链表形式添加到后面\",\"在Java8中，如果一条链表的元素个数达到8，且table大小大于64就会进化成红黑树，否则就用数组扩容\",\"第一次添加时，table数组扩容到16，临界值是16*（loadFactor=0.75）=12，每次到临界值就会扩容2倍，变为32，以此类推\",\"使用HashCode方法\",\"public class HashSetExercise02 { public static void main(String[] args) { Set set = new HashSet(); set.add(new Employ(\\\"ymk\\\", 12000, new MyDate(1998, 3, 31))); set.add(new Employ(\\\"ztt\\\", 12000, new MyDate(1997, 3, 23))); } } class Employ { private String name; private double sal; private MyDate birthday; public Employ(String name, double sal, MyDate birthday) { this.name = name; this.sal = sal; this.birthday = birthday; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employ employ = (Employ) o; return Objects.equals(name, employ.name) && Objects.equals(birthday, employ.birthday); } @Override public int hashCode() { return Objects.hash(name, birthday); } } class MyDate { private int year; private int month; private int day; public MyDate(int year, int month, int day) { this.year = year; this.month = month; this.day = day; } } \"]},\"446\":{\"h\":\"Set接口实现类-LinkedHashSet\",\"t\":[\"介绍\",\"LinkedHashSet是HashSet的子类\",\"底层是一个LinkedHashMap，数组加双向链表\",\"可以看出比HashSet多了before和after分别指向前一个add和后一个add，这样就可以保证遍历的时候按add顺序遍历\"]},\"447\":{\"h\":\"Set接口实现类-TreeSet\",\"t\":[\"对集合进行遍历时，每个值将自动地按照排序后地顺序呈现，排序是用红黑树结构完成的。\",\"要使用TreeSet，则元素必须实现Comparable接口。\"]},\"448\":{\"h\":\"Map接口和常用方法\",\"t\":[\"介绍\",\"Map用于保存有映射关系的数据：Key-Value\",\"Key和Value可以是任何引用类型数据，会封装到HashMap$Node对象中\",\"Map中的Key不能重复\",\"Value可以重复\",\"常用String类来做Key\",\"常用方法\",\"put：添加k-v\",\"remove：根据键删除映射关系\",\"get：根据键获取键值\",\"containsKey：查找键是否存在\",\"遍历方法\",\"public class Map01 { public static void main(String[] args) { Map map = new HashMap(); map.put(\\\"邓超\\\", \\\"孙俪\\\"); map.put(\\\"王宝强\\\", \\\"马蓉\\\"); map.put(\\\"鹿晗\\\", \\\"关晓彤\\\"); map.put(\\\"宋喆\\\", \\\"马蓉\\\"); // 先取出所有Key Set keySet = map.keySet(); // 返回一个key集合 // 1.增强for,用map的方法get根据key得到对应value for (Object key : keySet) { System.out.println(key + \\\"-\\\" + map.get(key)); } // 2.迭代器 Iterator iterator = keySet.iterator(); while (iterator.hasNext()) { Object key = iterator.next(); System.out.println(key + \\\"-\\\" + map.get(key)); } // 3.取出所有value再遍历 Collection values = map.values(); //可以用for-each或迭代器遍历 } } \"]},\"449\":{\"h\":\"Map接口实现类-HashTable\",\"t\":[\"介绍\",\"存放的键和值都不能为null\",\"HashTable是线程安全的，HashMap线程不安全\",\"方法和HashMap类似\"]},\"450\":{\"h\":\"Map接口实现类-Properties\",\"t\":[\"介绍\",\"Properties类继承自HashTable类并且实现了Map接口\",\"使用类似HashTable，key，value不能为null\",\"用于xxx.properties文件（IO流）中，加载数据到Properties类对象\"]},\"451\":{\"h\":\"总结-开发中如何选择集合实现类\",\"t\":[\"先判断存储类型（一组对象【单列】或一组键值对【双列】）\",\"一组对象【单列】：Collection接口\",\"允许重复：List\",\"增删多：LinkedList（双向链表）\",\"改查多：ArrayList（Object[] 数组）\",\"不允许重复：Set\",\"无序：HashSet（底层HashMap）\",\"排序：TreeSet\",\"public class TreeMap01 { public static void main(String[] args) { TreeSet treeSet = new TreeSet(new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String)o1).length() - ((String)o2).length(); } }); treeSet.add(\\\"jack\\\"); treeSet.add(\\\"ymk\\\"); treeSet.add(\\\"qwewe\\\"); System.out.println(\\\"TreeSet = \\\" + treeSet); } } \",\"插入和取出顺序一致：LinkedHashSet（数组加双向链表）\",\"一组键值对【双列】：Map\",\"键无序：HashMap（链表数组）\",\"键排序：TreeMap\",\"键插入和取出顺序一致：LinkedHashMap\",\"读取文件：Properties\"]},\"452\":{\"h\":\"Collections工具类\",\"t\":[\"介绍\",\"Collections是一个操作Set、List和Map等集合的工具类\",\"提供对集合元素进行排序、查询和修改等操作\",\"排序\",\"reverse（List）：反转\",\"shuffle（List）：随机排序\",\"sort（List）：升序\",\"sort（List, Comparator）：指定排序方法\",\"swap（List，int，int）：将指定List集合中的i处元素和j处元素交换\",\"查找\",\"max\",\"min\",\"frequency：元素出现次数\",\"copy\",\"replaceAll（List，oldVal，newVal）：新值替换List中的所有旧值\"]},\"453\":{\"h\":\"十三、泛型\"},\"454\":{\"h\":\"泛型的理解和好处\",\"t\":[\"为什么需要泛型\",\"普通方法\",\"public class ArrayList01 { public static void main(String[] args) { ArrayList arrayList = new ArrayList(); // 如果add了不是Dog类型的对象也不会报错 arrayList.add(new Dog(\\\"旺财\\\", 10)); arrayList.add(new Dog(\\\"大黄\\\", 2)); arrayList.add(new Dog(\\\"柯基\\\", 5)); // 遍历 for (Object o : arrayList) { System.out.println(\\\"Dog: \\\" + o); // 如果想要调用Dog的方法需进行强制类型转换 ((Dog)o).hello(); } } } class Dog { private String name; private int age; public Dog(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \\\"name=\\\" + name + \\\", age=\\\" + age; } public void hello() { System.out.println(\\\"woo\\\"); } } \",\"使用泛型\",\"public class ArrayList02 { public static void main(String[] args) { // 表示存放到ArrayList集合中的元素是Dog类型 // 这样我们取出的元素也是Dog类型而不是Object ArrayList<Dog> arrayList = new ArrayList<Dog>(); arrayList.add(new Dog(\\\"旺财\\\", 10)); arrayList.add(new Dog(\\\"大黄\\\", 2)); arrayList.add(new Dog(\\\"柯基\\\", 5)); // 如果添加了其他类，就会报错 //arrayList.add(new Cat()); } } class Cat {} \",\"泛型好处\",\"编译时会检查添加元素的类型，提高了安全性\",\"减少了类型转换的次数，提高效率\"]},\"455\":{\"h\":\"泛型介绍\",\"t\":[\"可以在类声明时通过一个标识表示类中的某个属性的类型，或者是某个方法的返回值类型，或者是参数类型\"]},\"456\":{\"h\":\"泛型语法\",\"t\":[\"泛型的声明\",\"interface 接口<T> {} 和 class 类<K,V>\",\"其中，T，K，V不带表值，而是代表类型\",\"任意字母都可以，常用T表示，是Type的缩写\",\"泛型的实例化\",\"要在类名后面指定类型参数\",\"List<string> strList = new ArrayList<String>();\",\"Iterator<Customer> iterator = customers.iterator();\",\"泛型的使用细节\",\"<T>只能是引用类型，不能是int\",\"给了泛型具体类型后，可以传入该类型及其子类型\",\"可以简写List<string> strList = new ArrayList<>();\"]},\"457\":{\"h\":\"自定义泛型类\",\"t\":[\"基本语法\",\"class 类名 <T, R...> {\",\"​ 成员 // ... 表示可以有多个泛型成员\",\"}\",\"细节\",\"普通成员（属性，方法）可以使用泛型\",\"使用泛型的数组不能初始化\",\"静态方法中不能使用类的泛型\",\"泛型类的类型，是在创建对象时指定的，若没有指定类型，默认为Object\",\"public class Generic01 { public static void main(String[] args) { Person person = new Person(10); System.out.println(person.f()); person.show(); Person<String> person1 = new Person<String>(\\\"yanmingkui\\\"); System.out.println(person1.f()); person1.show(); } } class Person<E> { E s; public Person(E s) { // 构造器中使用泛型 this.s = s; } public E f() { // 方法中返回值可以为泛型 return s; } public void show() { System.out.println(s.getClass()); } } \"]},\"458\":{\"h\":\"自定义泛型接口\",\"t\":[\"基本语法\",\"interface 接口名 <T, R ...> {\",\"​ 代码\",\"}\",\"注意细节\",\"接口中，静态成员也不能使用泛型，不能直接用泛型定义类\",\"泛型接口的类型，在继承接口或实现接口时确定\",\"没有指定类型，默认Object\",\"interface IUsb<U, R> { // U name; // 无法定义，因为接口中的类默认是静态类型 R get(U u); // 抽象方法中可以使用泛型 default R method(U u) { // jdk8默认方法中可以使用泛型 return null; } } interface IA extends IUsb<String, Double> { // 继承接口时指定泛型接口的类型 } class BB implements IUsb<Integer, Float> { // 实现接口时，直接指定泛型接口的类型 @Override public Float get(Integer integer) { return null; } } \"]},\"459\":{\"h\":\"自定义泛型方法\",\"t\":[\"基本语法\",\"修饰符 <T, R ...> 返回类型 方法名（参数列表）{\",\"​ 代码\",\"}\",\"注意细节\",\"泛型方法，可以定义在普通类中，也可以定义在泛型类中\",\"调用时，确定类型\",\"public void eat(E e) {} // 修饰符后没有<>，不是泛型方法，只是调用了泛型 \",\"class Fish { public<T, R> void fly(T t, R r) { // 普通类中的泛型方法 System.out.println(t.getClass()); System.out.println(r.getClass()); } } class Cat<T, R> { public<K> void hello(R r, K k) { // 泛型类中的泛型方法，也可以使用自己声明的泛型 System.out.println(r.getClass()); System.out.println(k.getClass()); } } \"]},\"460\":{\"h\":\"泛型的继承和通配符\",\"t\":[\"介绍\",\"泛型不具有继承性\",\"List<Object> list = new ArrayList<Object>(); // 正确 //List<Object> list = new ArrayList<String>(); // 错误 \",\"<?>：支持任意泛型类型\",\"<? extends A>：支持A类以及A类的子类\",\"List\\\\<? extends Object\\\\> list1 = new ArrayList\\\\<String\\\\>(); // 正确 \",\"<? super A>：支持A类以及A类的父类，不限于直接父类\",\"List\\\\<? super String\\\\> list2 = new ArrayList\\\\<Object\\\\>(); // 正确 \"]},\"461\":{\"h\":\"java核心技术卷补充\",\"t\":[\"类型变量的限定\",\"public <T extends Comparable & Serializable> T min(T[] a); // 要求T是实现了Comparable接口的类 // 避免了方法中使用了Comparable接口方法，而类中不具有而报错 \",\"java不支持泛型类型的数组，可以使用@SafeVarargs标注来消除限制，但是可能会引发异常\",\"Pair<String>[] table = array(pair1, pair2); Object[] objArrary = table; objArrary[0] = new Pair<Employee>(); // 产生异常 \",\"Class类本身就是一种泛型\",\"泛型类的静态成员和方法无效，故禁止使用\",\"public class A<T> { private static T aInstance; // Error private Static T aMethod() {} // Error } \",\"不能throws或catch泛型类的实例\",\"无论S与T有什么联系，Pair<S>与Pair<T>没有什么联系\"]},\"462\":{\"h\":\"JUnit测试\",\"t\":[\"介绍\",\"JUnit是一个Java语言的单元测试框架\",\"多数Java的开发环境都已经集成了JUnit作为单元测试的工具\",\"语法\",\"在函数上加上@Test可以直接运行\"]},\"463\":{\"h\":\"十四、坦克大战（1）\"},\"464\":{\"h\":\"Java绘图坐标系\"},\"465\":{\"h\":\"十五、多线程基础\"},\"466\":{\"h\":\"线程的基本使用\",\"t\":[\"创建线程的两种方式\",\"继承Thread类，重写run方法\",\"public class Thread01 { public static void main(String[] args) { Cat cat = new Cat(); cat.start(); } } // 当一个类继承了Thread类，它就可以当成线程使用 class Cat extends Thread { private int times; @Override public void run() { times = 0; while (true) { if (times++ == 8) { break; } // 每隔一秒输出一次 System.out.println(\\\"Cat Thread\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } \",\"实现Runnable接口，重写run方法\",\"// java是单继承的，可能一个类已经继承了父类，这时上一个方法就无法使用了 public class Thread02 { public static void main(String[] args) { Tiger tiger = new Tiger(); // tiger.start() 这里不能直接用start Thread thread = new Thread(tiger); thread.start(); } } class Animal { } class Tiger extends Animal implements Runnable { private int times; @Override public void run() { times = 0; while (true) { if (times++ == 4) { break; } // 每隔一秒输出一次 System.out.println(\\\"tiger oww\\\\t\\\" + Thread.currentThread()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } \",\"jconsole监视线程\",\"需要添加以下jvm启动参数\",\"-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8011 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false\",\"多线程执行\",\"public class Thread03 { public static void main(String[] args) { T1 t1 = new T1(); T2 t2 = new T2(); Thread thread1 = new Thread(t1); Thread thread2 = new Thread(t2); thread1.start(); thread2.start(); } } class T1 implements Runnable { int count = 0; @Override public void run() { while (true) { // 每隔一秒输出\\\"hello world\\\" System.out.println(\\\"hello world\\\\t\\\" + Thread.currentThread()+ (++count)); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 60) { break; } } } } class T2 implements Runnable { int count = 0; @Override public void run() { while (true) { // 每隔一秒输出\\\"hello world\\\" System.out.println(\\\"hi\\\\t\\\" + Thread.currentThread() + (++count)); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 50) { break; } } } } \",\"继承Thread vs 实现Runnable的区别\",\"从java设计来看，没有本质上区别\",\"实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制，建议使用Runnable\",\"举例：售票系统（三个窗口售票总共100张）\",\"public class ThreadShop { public static void main(String[] args) { // 三家店同时卖，所以要创建三个线程 Shop1 shop1 = new Shop1(); Shop1 shop2 = new Shop1(); Shop1 shop3 = new Shop1(); new Thread(shop1).start(); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(shop2).start(); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(shop3).start(); } } class Shop1 implements Runnable { private int ticketsNum = 50; @Override public void run() { while (true) { if (ticketsNum <= 0) { System.out.println(\\\"票已售完\\\"); break; } // 每100毫秒卖出去一张票 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"窗口:\\\" + Thread.currentThread() + \\\"售出一张票\\\\t\\\" + \\\"剩余票数\\\" + (--ticketsNum)); } } } \"]},\"467\":{\"h\":\"线程终止\",\"t\":[\"基本说明\",\"当线程完成后，会自动退出\",\"还可通过使用变量来控制run方法退出的方式停止线程（通知方式）\",\"使用案例\",\"public class ThreadStop { public static void main(String[] args) { AThread aThread = new AThread(); new Thread(aThread).start(); // 延迟10秒后结束子线程 try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } aThread.setLoop(false); } } class AThread implements Runnable { boolean loop = true; // 设置一个标记变量 @Override public void run() { while (loop) { // 用loop来控制循环 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"AThread运行......\\\"); } } // 在给以设置loop的方法，即可退出线程 public void setLoop(boolean loop) { this.loop = loop; } } \"]},\"468\":{\"h\":\"线程常用方法\",\"t\":[\"常用方法第一组\",\"setName // 设置线程名称\",\"getName\",\"start\",\"run\",\"setPriority\",\"getPriority\",\"sleep\",\"interrupt\",\"注意事项\",\"start底层会创建一个新线程，run只是调用线程方法\",\"interrupt只是中断线程，但线程并没用真正结束，一般用于中断正在休眠线程\",\"常用方法第二组\",\"yield // 线程的礼让，让出CPU，让其他线程执行\",\"join // 线程插队，插队若成功，则先执行完插队的线程\",\"public class ThreadYield { public static void main(String[] args) { int count = 20; A a = new A(); Thread t = new Thread(a); t.start(); while (true) { if (count-- <= 0) { break; } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"hello\\\" + Thread.currentThread().getName()); if (count == 15) { System.out.println(\\\"让子线程先运行\\\"); // Thread.yield(); // 礼让不一定成功 try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"子线程运行结束，再运行主线程\\\"); } } } } class A implements Runnable{ private int count = 20; @Override public void run() { while (true) { if (count-- <= 0) { break; } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"hello\\\" + Thread.currentThread().getName()); } } } \",\"用户线程和守护线程\",\"用户线程：也叫工作线程当线程的任务执行完或通知方式结束\",\"守护线程：一般是为工作线程服务的，当所有用户线程结束，守护线程自动结束（垃圾回收机制）\",\"设置守护线程\",\"public class ThreadDaemon { public static void main(String[] args) { MyDaemonThread thread = new MyDaemonThread(); thread.setDaemon(true); // 设置为守护线程 thread.start(); for (int i = 0; i < 100; i++) { try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"主线程运行中\\\"); } System.out.println(\\\"主线程运行完毕\\\"); } } class MyDaemonThread extends Thread { @Override public void run() { while (true) { try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"守护线程运行中......\\\"); } } } \"]},\"469\":{\"h\":\"线程的生命周期\",\"t\":[\"JDK中用Thread.State枚举表示了线程的几种状态\",\"New：尚未启动\",\"RUNNABLE：在JVM中执行\",\"BLOCKED：被阻塞等待监视器锁定\",\"WAITING：正在等待另一个线程执行特定动作\",\"TIMED_WAITING：正在等待另一个线程执行动作达到指定时间\",\"TERMINATED：已退出\",\"线程状态转换图\",\"查看线程状态\",\"public class ThreadState { public static void main(String[] args) { T t = new T(); System.out.println(t.getName() + \\\"状态\\\" + t.getState()); t.start(); while (Thread.State.TERMINATED != t.getState()) { System.out.println(t.getName() + \\\"状态\\\" + t.getState()); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(t.getName() + \\\"状态\\\" + t.getState()); // 子线程已经终止 } } class T extends Thread { @Override public void run() { while (true) { for (int i = 0; i < 10; i++) { System.out.println(\\\"hi\\\" + i); try { Thread.sleep(1000); // 线程睡眠时处于TIMED_WAITING } catch (InterruptedException e) { e.printStackTrace(); } } break; } } } \"]},\"470\":{\"h\":\"线程同步\",\"t\":[\"线程同步机制\",\"多线程编程时，一些敏感数据不允许被多个线程同时访问，保证数据完整性\",\"即当一个线程对内存进行操作时，其他线程都不可以对这个内存地址进行操作\",\"同步方法 - Synchronized\",\"同步代码块\",\"synchronized（对象）{ // 得到对象的锁，才能操作同步代码\",\"​ // 需要被同步的代码\",\"}\",\"synchronized还可以放在方法声明中，表示整个方法为同步方法\",\"public synchronized void m（String name）{\",\"​ // 需要被同步代码\",\"}\"]},\"471\":{\"h\":\"互斥锁\",\"t\":[\"介绍\",\"每个对象都有一个互斥锁\",\"关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问\",\"非静态的同步方法的锁可以是this也可以是其他对象\",\"静态的同步方法的锁为当前类本身\",\"public class ThreadShop { public static void main(String[] args) { Shop1 shop1 = new Shop1(); // 三家店同时卖，所以要创建三个线程 new Thread(shop1).start(); new Thread(shop1).start(); new Thread(shop1).start(); } } class Shop1 implements Runnable { private int ticketsNum = 50; // Object o = new Object(); public synchronized static void m1() {} public static void m2() { synchronized (Shop1.class) { // 静态方法互斥锁在类对象 System.out.println(\\\"m2\\\"); } } private void sell() { synchronized (this) { // 代码块互斥锁在this while (true) { if (ticketsNum <= 0) { System.out.println(\\\"票已售完\\\"); break; } // 每100毫秒卖出去一张票 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"窗口:\\\" + Thread.currentThread() + \\\"售出一张票\\\\t\\\" + \\\"剩余票数\\\" + (--ticketsNum)); } } } \",\"@Override public /*synchronized*/ void run() { sell(); } \",\"}\",\"- **注意事项** 1. 实现互斥步骤： - 先分析需要上锁的代码 - 选择同步代码块或同步方法 - 要求多个线程的锁对象为同一个即可，即使用同一个对象来start线程 ### 线程死锁 - **基本介绍** 多个线程都占用了对方的锁资源，但不肯相让，导致死锁 - **模拟线程死锁** ```java public class DeadLock_ { public static void main(String[] args) { //模拟死锁现象 DeadLockDemo A = new DeadLockDemo(true); A.setName(\\\"A 线程\\\"); DeadLockDemo B = new DeadLockDemo(false); B.setName(\\\"B 线程\\\"); A.start(); B.start(); } } class DeadLockDemo extends Thread { static Object o1 = new Object();// 保证多线程，共享一个对象,这里使用 static static Object o2 = new Object(); boolean flag; public DeadLockDemo(boolean flag) {//构造器 this.flag = flag; } @Override public void run() { //1. 如果 flag 为 T, 线程 A 就会先得到/持有 o1 对象锁, 然后尝试去获取 o2 对象锁 //2. 如果线程 A 得不到 o2 对象锁，就会 Blocked //3. 如果 flag 为 F, 线程 B 就会先得到/持有 o2 对象锁, 然后尝试去获取 o1 对象锁 //4. 如果线程 B 得不到 o1 对象锁，就会 Blocked if (flag) { synchronized (o1) {//对象互斥锁, 下面就是同步代码 System.out.println(Thread.currentThread().getName() + \\\" 进入 1\\\"); synchronized (o2) { // 这里获得 li 对象的监视权 System.out.println(Thread.currentThread().getName() + \\\" 进入 2\\\"); } } } else { synchronized (o2) { System.out.println(Thread.currentThread().getName() + \\\" 进入 3\\\"); synchronized (o1) { // 这里获得 li 对象的监视权 System.out.println(Thread.currentThread().getName() + \\\" 进入 4\\\"); } } } } } \"]},\"472\":{\"h\":\"释放锁\",\"t\":[\"如何释放锁\",\"当前线程的同步方法、同步代码块执行结束时释放锁\",\"当前线程在同步代码块、同步方法中遇到break、return\",\"当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束\",\"当前线程在同步代码块、同步方法中执行了线程对象的wait ()方法，当前线程暂停，并释放锁\",\"下面的操作不会释放锁\",\"线程执行同步代码块或同步方法时，程序调用sleep（）、yield（）方法时，不会释放锁\",\"线程执行同步代码块时，其他线程调用了该线程的suspend（）方法将该线程方法挂起，该线程不会释放锁\"]},\"473\":{\"h\":\"十六、IO流\"},\"474\":{\"h\":\"文件流\",\"t\":[\"文件在程序中是以流的形式来操作的\"]},\"475\":{\"h\":\"常用文件操作\",\"t\":[\"创建文件对象相关构造器和方法\",\"new File（String pathname） // 根据路径构建一个File对象\",\"new File（File parent， String child） // 根据父目录文件+子路径构建\",\"new File（String parent， String child） // 根据父目录+子路径构建\",\"createNewFile（） // 创建新文件\",\"public class File01 { // method 1 new File(String pathname) @Test public void create01() { // File对象在java程序中只是一个对象 File file = new File(\\\"e:\\\\\\\\news1.txt\\\"); try { file.createNewFile(); // File对象在java程序中只是一个对象，只有执行了createNewFile才会创建文件 } catch (IOException e) { e.printStackTrace(); } } // method 2 new File(File parent, String child) // 根据父目录文件+子路径构建 @Test public void create02() { File parentFile = new File(\\\"e:\\\\\\\\\\\"); File file = new File(parentFile, \\\"news2.txt\\\"); try { file.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } // method 3 new File(String parent, String child) @Test public void create03() { File file = new File(\\\"e:\\\\\\\\\\\", \\\"news3.txt\\\"); try { file.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } } \",\"获取文件的相关信息\",\"getName\",\"getAbsolutePath\",\"getParent\",\"length\",\"exists\",\"isFile\",\"isDirectory\",\"public class File02 { //获取文件的信息 @Test public void info() { //先创建文件对象 File file = new File(\\\"e:\\\\\\\\news1.txt\\\"); //调用相应的方法，得到对应信息 System.out.println(\\\"文件名字=\\\" + file.getName()); //getName、getAbsolutePath、getParent、length、exists、isFile、isDirectory System.out.println(\\\"文件绝对路径=\\\" + file.getAbsolutePath()); System.out.println(\\\"文件父级目录=\\\" + file.getParent()); System.out.println(\\\"文件大小(字节)=\\\" + file.length()); System.out.println(\\\"文件是否存在=\\\" + file.exists());//T System.out.println(\\\"是不是一个文件=\\\" + file.isFile());//T System.out.println(\\\"是不是一个目录=\\\" + file.isDirectory());//F } } \",\"目录的操作和文件的删除\",\"mkdir // 创建一级目录\",\"mkdirs // 创建多级目录\",\"delete // 删除目录或文件\",\"public class File03 { @Test public void makeDir() { File file = new File(\\\"e:\\\\\\\\demo\\\\\\\\a\\\\\\\\b\\\\\\\\c\\\"); // 判断目录是否存在，否则创建多级目录 if (!file.exists()) { file.mkdirs(); } } } \"]},\"476\":{\"h\":\"IO流原理及流的分类\",\"t\":[\"Java IO流原理\",\"I/O用于处理数据传输（读写、网络通讯）\",\"Java.io包下提供了各种“流”类和接口\",\"输入input：读取外部数据到程序中\",\"输出output：将程序数据输出到存储设备\",\"流的分类\",\"按操作数据单位不同分为：字节流（8bit）二进制文件，字符流（按字符）文本文件\",\"按数据流的流向不同分为：输入流、输出流\",\"按流的角色不同分为：节点流、处理流/包装流\",\"抽象基类\",\"字节流\",\"字符流\",\"输入流\",\"InputStream\",\"Reader\",\"输出流\",\"OutputStream\",\"Writer\"]},\"477\":{\"h\":\"IO流体系图 - 常用的类\",\"t\":[\"IO流 体系图\",\"FileInputStream介绍\",\"public class FileInputStream01 { // 单字节读取 @Test public void readFile01() { int readData = 0; FileInputStream fileInputStream = null; try { fileInputStream = new FileInputStream(\\\"e:\\\\\\\\hello.txt\\\"); // 从输入流读取一个字节的数据 // 返回-1表示读取完毕 while ((readData = fileInputStream.read()) != -1) { System.out.println((char) readData); } } catch (IOException e) { e.printStackTrace(); } finally { // 关闭文件流 try { fileInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } @Test public void readFile02() { // 多字节读取 byte[] readBuff = new byte[8]; int readLen = 0; FileInputStream fileInputStream = null; try { fileInputStream = new FileInputStream(\\\"e:\\\\\\\\hello.txt\\\"); // 从输入流读取最多readBuff.length个数据 // 返回-1表示读取完毕 // 如果读取正常，返回实际读取的字节数 while ((readLen = fileInputStream.read(readBuff)) != -1) { System.out.print(new String(readBuff, 0, readLen)); } } catch (IOException e) { e.printStackTrace(); } finally { // 关闭文件流 try { fileInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } } \",\"FileOutputStream介绍\",\"public class FileOutputStream01 { @Test public void writeFile01() { FileOutputStream fileOutputStream = null; // 1. new FileOutputStream(filePath) 创建方式，会覆盖原来的内容 // 2. new FileOutputStream(filePath, true) 创建方式，追加到文件后面 try { fileOutputStream = new FileOutputStream(\\\"e:\\\\\\\\a.txt\\\"); // 写入一个字节 fileOutputStream.write('H'); // 写入一个字符串 String str = \\\"hello world\\\"; fileOutputStream.write(str.getBytes(StandardCharsets.UTF_8), 0, 4); } catch (IOException e) { e.printStackTrace(); } finally { try { fileOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } } \",\"FileOutputStream拷贝\",\"public class FileCpy { @Test public void FileCopy() { FileInputStream fileInputStream = null; FileOutputStream fileOutputStream = null; byte[] readBuff = new byte[8]; int readLen = 0; try { fileInputStream = new FileInputStream(\\\"e:\\\\\\\\hello.txt\\\"); fileOutputStream = new FileOutputStream(\\\"e:\\\\\\\\a.txt\\\"); // 一边读一边写 while ((readLen = fileInputStream.read(readBuff)) != -1) { fileOutputStream.write(readBuff, 0 ,readLen); } System.out.println(\\\"拷贝完成\\\"); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileInputStream != null) { fileInputStream.close(); } if (fileOutputStream != null) { fileOutputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } } \",\"FileReader相关方法\",\"new FileReader（File/String）\",\"read：每次读取单个字符，返回该字符值，文件末尾返回-1\",\"read（char[]）：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1\",\"new String（char[]）：将char[]转换成String\",\"new String（char[]，off，len）：将char[]的指定部分转换成String\",\"public class FileReader01 { @Test public void readFile01() { String filePath = \\\"e:\\\\\\\\hello.txt\\\"; FileReader fileReader = null; int data = 0; try { fileReader = new FileReader(filePath); // 循环读取 read 单字符 while ((data = fileReader.read()) != -1) { System.out.print((char) data); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileReader != null) { fileReader.close(); } } catch (IOException e) { e.printStackTrace(); } } } @Test public void readFile02() { String filePath = \\\"e:\\\\\\\\hello.txt\\\"; FileReader fileReader = null; char[] buff = new char[8]; int readLen = 0; try { fileReader = new FileReader(filePath); // 循环读取 read 多字符 while ((readLen = fileReader.read(buff)) != -1) { System.out.print(new String(buff, 0, readLen)); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileReader != null) { fileReader.close(); } } catch (IOException e) { e.printStackTrace(); } } } } \",\"FileWriter常用方法\",\"new FileWriter（File/String）：覆盖模式，相当于流的指针在首端\",\"new FileWriter（File/String，true）：追加模式，相当于流的指针在尾端\",\"write（int）：写入单个字符\",\"write（char[]）：写入指定数组\",\"write（char[]，off，len）：写入指定数组的指定部分\",\"write（String）：写入整个字符串\",\"write（String，off，len）：写入字符串的指定部分\",\"String.toCharArray（）\",\"注意：FileWriter使用后，必须要关闭（close）或刷新（flush），否则写入不到指定文件\",\"public class FileWriter01 { public static void main(String[] args) { String filePath = \\\"e:\\\\\\\\note.txt\\\"; //创建 FileWriter 对象 FileWriter fileWriter = null; char[] chars = {'a', 'b', 'c'}; try { fileWriter = new FileWriter(filePath);//默认是覆盖写入 // 3) write(int):写入单个字符 fileWriter.write('H'); // 4) write(char[]):写入指定数组 fileWriter.write(chars); // 5) write(char[],off,len):写入指定数组的指定部分 fileWriter.write(\\\"韩顺平教育\\\".toCharArray(), 0, 3); // 6) write（string）：写入整个字符串 fileWriter.write(\\\" 你好北京~\\\"); fileWriter.write(\\\"风雨之后，定见彩虹\\\"); // 7) write(string,off,len):写入字符串的指定部分 fileWriter.write(\\\"上海天津\\\", 0, 2); //在数据量大的情况下，可以使用循环操作. } catch (IOException e) { e.printStackTrace(); } finally { //对应 FileWriter , 一定要关闭流，或者 flush 才能真正的把数据写入到文件 //老韩看源码就知道原因. /* private void writeBytes() throws IOException { this.bb.flip(); int var1 = this.bb.limit(); int var2 = this.bb.position(); assert var2 <= var1; int var3 = var2 <= var1 ? var1 - var2 : 0; if (var3 > 0) { if (this.ch != null) { assert this.ch.write(this.bb) == var3 : var3; } else { this.out.write(this.bb.array(), this.bb.arrayOffset() + var2, var3); } } this.bb.clear(); } */ try { //fileWriter.flush(); //关闭文件流，等价 flush() + 关闭 fileWriter.close(); } catch (IOException e) { e.printStackTrace(); } } System.out.println(\\\"程序结束...\\\"); } } \"]},\"478\":{\"h\":\"节点流和处理流\",\"t\":[\"介绍\",\"节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter\",\"处理流是连接已存在的流之上，为程序提供更为强大的读写功能，如BufferedReader、BufferedWriter\",\"节点流和处理流的区别和联系\",\"节点流是底层流/低级流，直接跟数据源相接\",\"处理流（包装流）包装节点流，既可以消除不同节点流的的实现差异，也可以提供更方便的方法来完成输入输出\",\"处理流对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连\",\"处理流 - BufferedReader 和 BufferedWriter\",\"public class BufferedReaderANDWriter { @Test public void bufferedRead() { String filePath = \\\"e:\\\\\\\\hello.txt\\\"; String line; BufferedReader bufferedReader = null; try { // 创建bufferedReader bufferedReader = new BufferedReader(new FileReader(filePath)); // 读取 //1. bufferedReader.readLine() 是按行读取文件 //2. 当返回 null 时，表示文件读取完毕 while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } finally { try { bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } } } @Test public void bufferedWrite() { String filePath = \\\"e:\\\\\\\\ok.txt\\\"; //创建 BufferedWriter //说明: //1. new FileWriter(filePath, true) 表示以追加的方式写入 //2. new FileWriter(filePath) , 表示以覆盖的方式写入 BufferedWriter bufferedWriter = null; try { bufferedWriter = new BufferedWriter(new FileWriter(filePath)); bufferedWriter.write(\\\"hello, 韩顺平教育!\\\"); bufferedWriter.newLine();//插入一个和系统相关的换行 bufferedWriter.write(\\\"hello2, 韩顺平教育!\\\"); bufferedWriter.newLine(); bufferedWriter.write(\\\"hello3, 韩顺平教育!\\\"); bufferedWriter.newLine(); } catch (IOException e) { e.printStackTrace(); } finally { try { //说明：关闭外层流即可 ， 传入的 new FileWriter(filePath) ,会在底层关闭 bufferedWriter.close(); } catch (IOException e) { e.printStackTrace(); } } } } \",\"处理流 - BufferedInputStream 和 BufferedOutputStream\",\"// 拷贝文件 public class BufferedOutputStream_ { public static void main(String[] args) { // String srcFilePath = \\\"e:\\\\\\\\Koala.jpg\\\"; // String destFilePath = \\\"e:\\\\\\\\hsp.jpg\\\"; // String srcFilePath = \\\"e:\\\\\\\\0245_韩顺平零基础学 Java_引出 this.avi\\\"; // String destFilePath = \\\"e:\\\\\\\\hsp.avi\\\"; String srcFilePath = \\\"e:\\\\\\\\a.java\\\"; String destFilePath = \\\"e:\\\\\\\\a3.java\\\"; //创建 BufferedOutputStream 对象 BufferedInputStream 对象 BufferedInputStream bis = null; BufferedOutputStream bos = null; try { //因为 FileInputStream 是 InputStream 子类 bis = new BufferedInputStream(new FileInputStream(srcFilePath)); bos = new BufferedOutputStream(new FileOutputStream(destFilePath)); //循环的读取文件，并写入到 destFilePath byte[] buff = new byte[1024]; int readLen = 0; //当返回 -1 时，就表示文件读取完毕 while ((readLen = bis.read(buff)) != -1) { bos.write(buff, 0, readLen); } System.out.println(\\\"文件拷贝完毕~~~\\\"); } catch (IOException e) { e.printStackTrace(); } finally { //关闭流 , 关闭外层的处理流即可，底层会去关闭节点流 try { if(bis != null) { bis.close(); } if(bos != null) { bos.close(); } } catch (IOException e) { e.printStackTrace(); } } } } \",\"对象流 - ObjectInputStream 和 ObjectOutputStream\",\"序列化与反序列化\",\"序列化就是在保存数据时，保存数据的值和数据类型\",\"反序列化就是在恢复数据时，恢复数据的值和数据类型\",\"为了让某个类时可序列化的，该类必须实现如下两个接口之一： \",\"Serializable // 标记接口，没有方法\",\"Externalizable // 该接口有方法需要实现\",\"对象流介绍\",\"ObjecInpuStream提供反序列化功能\",\"ObjectOutputStream提供序列化功能\",\"public class ObjectOutStream_ { @Test public void out() { // 要注意序列化文件的保存格式 String filePath = \\\"e:\\\\\\\\data.dat\\\"; ObjectOutputStream objectOutputStream = null; try { objectOutputStream = new ObjectOutputStream(new FileOutputStream(filePath)); objectOutputStream.writeInt(100); objectOutputStream.writeBoolean(true); objectOutputStream.writeChar('a'); objectOutputStream.writeDouble(12.1); objectOutputStream.writeUTF(\\\"严明奎\\\"); objectOutputStream.writeObject(new Dog(\\\"puppy\\\")); } catch (IOException e) { e.printStackTrace(); } finally { if (objectOutputStream != null) { try { objectOutputStream.close(); System.out.println(\\\"保存完毕\\\"); } catch (IOException e) { e.printStackTrace(); } } } } @Test public void in() { String filePath = \\\"e:\\\\\\\\data.dat\\\"; ObjectInputStream objectInputStream = null; try { objectInputStream = new ObjectInputStream(new FileInputStream(filePath)); System.out.println(objectInputStream.readInt()); System.out.println(objectInputStream.readBoolean()); System.out.println(objectInputStream.readChar()); System.out.println(objectInputStream.readDouble()); System.out.println(objectInputStream.readUTF()); System.out.println(objectInputStream.readObject()); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { if (objectInputStream != null) { try { objectInputStream.close(); System.out.println(\\\"读取完成\\\"); } catch (IOException e) { e.printStackTrace(); } } } } } class Dog implements Serializable { private String name; public Dog(String name) { this.name = name; } public String getName() { return name; } @Override public String toString() { return \\\"name=\\\" + name; } } \",\"注意事项\",\"读写顺序要一致\",\"序列化对象需实现Serializable\",\"序列化的类中建议添加SerialVersionUID，为了提高版本兼容性\",\"序列化对象时，默认将里面所有属性都序列化，除了static和transient成员\",\"序列化对象时，里面的属性也要实现序列化接口\",\"序列化具备可继承性\",\"标准输入输出流\",\"类型\",\"默认设备\",\"System.in\",\"InputStream\",\"键盘\",\"System.out\",\"PrintStream\",\"显示器\",\"转换流 - InputStreamReader 和 OutputStreamWriter\",\"InputStreamReader可以将InputStream（字节流）转换成Reader（字符流）\",\"OutputStreamWriter可以将OutputStream转换成Writer\",\"处理纯文本数据时转换为字符流效率更高，还可以指定编码格式\",\"public class InputStreamReader_ { @Test public void input() { String filePath = \\\"e:\\\\\\\\a.txt\\\"; String line; BufferedReader bufferedReader = null; try { // 创建bufferedReader 读取转换的FileInputStream bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(filePath), \\\"utf-8\\\")); // 读取 //1. bufferedReader.readLine() 是按行读取文件 //2. 当返回 null 时，表示文件读取完毕 while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } finally { try { bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } } } } \"]},\"479\":{\"h\":\"打印流 - PrintStream 和 PrintWriter\",\"t\":[\"public class PrintStream_ { @Test public void PrintWriter_() { PrintWriter printWriter = null; try { printWriter = new PrintWriter(new FileWriter(\\\"e:\\\\\\\\f2.txt\\\")); printWriter.print(\\\"PrintWriter Test\\\"); } catch (IOException e) { e.printStackTrace(); } finally { try { // 关闭流，才会写入数据到文件 printWriter.close(); } catch (Exception e) { e.printStackTrace(); } } } @Test public void PrintStream_() { PrintStream out = System.out; //在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器 /* public void print(String s) { if (s == null) { s = \\\"null\\\"; } write(s); } */ try { //因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印/输出 out.write(\\\"PrintStream Test\\\".getBytes()); out.close(); //我们可以去修改打印流输出的位置/设备 //1. 输出修改成到 \\\"e:\\\\\\\\f1.txt\\\" //2. \\\"hello, 韩顺平教育~\\\" 就会输出到 e:\\\\f1.txt //3. public static void setOut(PrintStream out) { // checkIO(); // setOut0(out); // native 方法，修改了 out // } System.setOut(new PrintStream(\\\"e:\\\\\\\\f1.txt\\\")); System.out.println(\\\"PrintStream Test\\\"); } catch (IOException e) { e.printStackTrace(); } } } \"]},\"480\":{\"h\":\"Properties类\",\"t\":[\"介绍\",\"专门用于读写配置文件的集合类\",\"配置文件格式：\",\"键1 = 值1\",\"键2 = 值2\",\"键值对不需要空格，值不需要引号，默认类型为String\",\"常见方法\",\"load：加载配置文件的键值对到Properties对象\",\"list：将数据显示到指定设备\",\"getProperty（key）：根据键获取值\",\"setProperty（key，value）：设置键值对\",\"store：将Properties对象的键值对储存到配置文件中（idea中的中文默认编码为unicode）\",\"properties案例\",\"public class Properties01 { public static void main(String[] args) { // 使用Properties类来读取 // 1. 创建对象 Properties properties = new Properties(); // 2. 加载指定配置文件 try { properties.load(new FileReader(\\\"e:\\\\\\\\mysql.properties\\\")); } catch (IOException e) { e.printStackTrace(); } //3. 把 k-v 显示到控制台 properties.list(System.out); //4. 根据 key 获取对应的值 String user = properties.getProperty(\\\"user\\\"); String pwd = properties.getProperty(\\\"pwd\\\"); System.out.println(\\\"用户名=\\\" + user); System.out.println(\\\"密码是=\\\" + pwd); // 修改 Properties父类时Hashtable，操作与其相同 properties.setProperty(\\\"charset\\\", \\\"utf8\\\"); properties.setProperty(\\\"user\\\", \\\"汤姆\\\");//注意保存时，是中文的 unicode 码值 properties.setProperty(\\\"pwd\\\", \\\"888888\\\"); //将 k-v 存储文件中即可 try { properties.store(new FileOutputStream(\\\"src\\\\\\\\mysql2.properties\\\"), null); } catch (IOException e) { e.printStackTrace(); } System.out.println(\\\"保存配置文件成功~\\\"); } } \"]},\"481\":{\"h\":\"十七、网络编程\"},\"482\":{\"h\":\"网络通信相关概念\",\"t\":[\"网络通信\",\"java.net包下提供了一系列的类或接口\",\"ipv4地址分类\",\"域名\",\"www.baidu.com将ip地址映射成域名（HTTP协议）\",\"端口号\",\"概念：用于标识计算机上某个特定的网络程序\",\"表示形式：整数形式，端口范围0~65535【占两个字节】\",\"0~1024已经被占用，比如ssh占用22，ftp占用21，http占用80\",\"网络通信协议\",\"tcp/ip协议\",\"中文名，传输控制协议/因特网互联协议，由网络层的ip协议和传输层的tcp协议组成\",\"tcp和udp\",\"tcp\",\"使用tcp协议前，须先建立TCP连接，形成数据传输通道\",\"传输前，采用三次握手方式\",\"客户端和服务端\",\"连接中可进行大数据量传输\",\"传输完毕，需释放已简历的连接，效率低\",\"udp\",\"将数据、源、目的封装成数据包，不需要建立连接\",\"每个数据包的大小限制在64k内，不适合传输大量数据\",\"不需要握手连接\",\"发送数据结束时无需断开连接（释放资源），速度快\"]},\"483\":{\"h\":\"InetAddress类\",\"t\":[\"相关方法\",\"getLocalHost：获取本机InetAddress对象\",\"getByName：根据指定主机名/域名获取IP地址对象\",\"getHostName：获取InetAddress对象的主机名\",\"getHostAddress：获取InetAddress对象的地址\",\"案例\",\"public class InetAddress01 { public static void main(String[] args) { // 获取本机InetAddress对象getLocalHost try { InetAddress localHost = InetAddress.getLocalHost(); System.out.println(localHost); } catch (UnknownHostException e) { e.printStackTrace(); } //根据指定主机名/域名获取 ip 地址对象 getByName try { InetAddress host2 = InetAddress.getByName(\\\"BF-201911032247\\\"); System.out.println(host2); } catch (UnknownHostException e) { e.printStackTrace(); } //获取 InetAddress 对象的主机名 getHostName //获取 InetAddress 对象的地址 getHostAddress try { InetAddress host3 = InetAddress.getByName(\\\"www.hsp.com\\\"); System.out.println(host3); String host3Name = host3.getHostName(); System.out.println(host3Name); String host3Address = host3.getHostAddress(); System.out.println(host3Address); } catch (UnknownHostException e) { e.printStackTrace(); } } } \"]},\"484\":{\"h\":\"Socket 网络套接字\",\"t\":[\"介绍\",\"通信的两端都要有Socket\",\"网络通信其实就是Socket间的通信\",\"Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输\"]},\"485\":{\"h\":\"TCP网络通信编程\",\"t\":[\"基本介绍\",\"案例\",\"// 服务端 public class SocketTCP02Server { public static void main(String[] args) { try { // 在本机的9999端口监听，等待连接 ServerSocket serverSocket = new ServerSocket(9999); System.out.println(\\\"服务端在9999端口监听，等待连接。。。\\\"); // 没有客户端连接9999端口时，程序会阻塞 // 有客户端连接则会返回Socket对象 Socket socket = serverSocket.accept(); System.out.println(\\\"服务端 socket = \\\" + socket.getClass()); // 通过socket.getInputStream 读取客户端写入到数据通道的数据 InputStream inputStream = socket.getInputStream(); // IO读取 byte[] buf = new byte[1024]; int readLen = 0; while ((readLen = inputStream.read(buf)) != -1) { System.out.println(new String(buf, 0, readLen)); } // 关闭流和socket inputStream.close(); socket.close(); serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } \",\"// 客户端 public class SocketTCP01Client { public static void main(String[] args) { // 连接服务端(IP, 端口) try { Socket socket = new Socket(InetAddress.getLocalHost(), 9999); System.out.println(\\\"客户端 socket 返回=\\\" + socket.getClass()); // 连接上后，生成Socket OutputStream outputStream = socket.getOutputStream(); // 通过输出流，写入数据到数据通道 outputStream.write(\\\"hello, server\\\".getBytes(StandardCharsets.UTF_8)); // 关闭流对象和socket outputStream.close(); socket.close(); System.out.println(\\\"客户端退出\\\"); } catch (IOException e) { e.printStackTrace(); } } } \",\"netstat指令\",\"netstat -an可以查看当前主机网络情况，包括端口监听和网络连接情况\",\"Listening表示某个端口在监听\",\"如果有一个外部程序（客户端）连接到该端口，就会显示一条连接信息\"]},\"486\":{\"h\":\"十八、反射\",\"t\":[\"介绍\",\"在运行时分析类的能力\",\"在运行时检查对象\",\"实现泛型数组操作代码\",\"利用Method对象（类似C++中的函数指针）\",\"Class类\",\"运行期间每个对象都有一个运行时类型标识，保存这些信息的类名为Class getName（）方法可以返回类的名字 Class.forName（）方法可以获得类名对应的Class对象\",\"Constructor对象\",\"对一个Class对象使用getConstrouctor（）可以获得Constructor对象 可以通过Constructor类的newInstance（）方法来构造一个实例\",\"利用反射分析类的能力\",\"查看任意对象的内容\",\"getFields（）：返回类中的public成员变量\",\"getDeclaredFields（）：返回类中的所有成员变量\",\"getMethods（）：返回类中的public方法\",\"getDeclaredMethods（）：返回类中的所有方法\",\"getConstrouctors（）：返回类中的public构造器\",\"getDeclaredConstrouctors（）：返回类中的所有构造器\",\"操作对象内容\",\"Employee harry = new Employee(\\\"harry hacker\\\", 50000, 10 ,1, 1989); Class cl = harry.getClass(); // 获得Class对象 Field f = cl.getDeclaredField(\\\"name\\\"); // 获得private String name成员 f.setAccessible(true); // 获得访问权限 Object obj = f.get(harry); // 获取对应的String对象 f.set(harry, \\\"david\\\"); // 改变name值 \",\"使用反射机制调用任意方法\",\"Method类的invoke方法允许你调用包装在当前Method对象中的方法\",\"public class Method01 { public static void main(String[] args) { Employee harry = new Employee(\\\"harry chou\\\", 6000); try { Class cl = harry.getClass();// 获得Class对象 Method m1 = cl.getMethod(\\\"getName\\\");// 获得对应的方法 Method m2 = cl.getMethod(\\\"getSalary\\\"); String n = (String)m1.invoke(harry);// 调用Class对应的方法 double s = (Double)m2.invoke(harry); System.out.println(n); System.out.println(s); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } class Employee { private String name; private double salary; public Employee(String name, double salary) { this.name = name; this.salary = salary; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } } \"]},\"487\":{\"h\":\"十九、Lambda表达式\"},\"488\":{\"h\":\"语法\",\"t\":[\"(parameters) -> expression 或 (parameters) ->{ statements; } \",\"以下是lambda表达式的重要特征:\",\"**可选类型声明：**不需要声明参数类型，编译器可以统一识别参数值。\",\"**可选的参数圆括号：**一个参数无需定义圆括号，但多个参数需要定义圆括号。\",\"**可选的大括号：**如果主体包含了一个语句，就不需要使用大括号。\",\"**可选的返回关键字：**如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。\"]},\"489\":{\"h\":\"表达式实例\",\"t\":[\"// 1. 不需要参数,返回值为 5 () -> 5 // 2. 接收一个参数(数字类型),返回其2倍的值 x -> 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -> x – y // 4. 接收2个int型整数,返回他们的和 (int x, int y) -> x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -> System.out.print(s) \"]},\"490\":{\"h\":\"函数式接口\",\"t\":[\"对于只有一个抽象方法得接口，需要这种接口得对象时，可以提供一个lambda表达式，这种接口称为函数式接口\",\"public void testLambda() { GreetingService gs = message -> System.out.println(\\\"hello\\\" + message); gs.sayMessage(\\\" lambda\\\"); } interface GreetingService { void sayMessage(String message); } \"]},\"491\":{\"h\":\"变量作用域\",\"t\":[\"lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。\",\"public class Java8Tester { final static String salutation = \\\"Hello! \\\"; public static void main(String args[]){ GreetingService greetService1 = message -> System.out.println(salutation + message); greetService1.sayMessage(\\\"Runoob\\\"); } interface GreetingService { void sayMessage(String message); } } \",\"lambda 表达式的局部变量可以不用声明为 final，但是不可被后面的代码修改（即隐性的具有 final 的语义）\",\"int num = 1; Converter<Integer, String> s = (param) -> System.out.println(String.valueOf(param + num)); s.convert(2); num = 5; // 修改num，引起报错 //报错信息：Local variable num defined in an enclosing scope must be final or effectively \"]},\"492\":{\"h\":\"二十、面试题\",\"t\":[\"为什么重写 equals 还要重写 hashcode？\",\"因为equals是通过hashcode来比较的，通过hash计算可以直接定位某个值存储的位置，这样比如比较两集合时不通过hashcode来比较只能遍历依次比较，通过hashcode可以直接确定位置，效率高\",\"== 和 equals 比较的区别\",\"==：对于8种基本数据类型，是比较他们的值是否相等；对于引用数据类型，比较他们在堆内存的地址是否相等\",\"equals：默认返回结果是两个对象使用 == 的判断结果；可以重写对象的equals方法\",\"为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？\",\"因为浮点类型采用二进制系统表示，二进制系统种无法精确的表示分数1/10，所以会出现舍入误差\",\"0.1无法精确表示，因为它不能表示成为1/(2^n)的和的形式\",\"如果在数值计算中不允许有任何舍入误差， 就应该使用 BigDecimal类\",\"final 关键字的作用\",\"可以修饰引用、方法和类\",\"修饰基本数据类型：该数据为常量，值无法修改\",\"修饰引用数据类型：该对象本身可以修改，但指向该对象的地址不能修改\",\"修饰方法：方法无法被子类重写\",\"修饰类：无法被继承\",\"介绍 Java 的集合类\",\"2大接口：Collection、Map\",\"Collection下有3个子接口：Set、List、Queue\",\"ArrayList 和 LinkedList 的区别\",\"描述动态代理的几种实现方式？分别说出相应的优缺点\",\"代理可以分为 \\\"静态代理\\\" 和 \\\"动态代理\\\"，动态代理又分为 \\\"JDK动态代理\\\" 和 \\\"CGLIB动态代理\\\" 实现。静态代理：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object\",\"优点：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。\",\"缺点：不同的接口要有不同的代理类实现，会很冗余\",\"JDK 动态代理：\",\"为了解决静态代理中，生成大量的代理类造成的冗余；JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象 jdk动态代理之所以只能代理接口是因为代理类本身已经extends了Proxy，而java是不允许多重继承的，但是允许实现多个接口。\",\"优点：解决了静态代理中冗余的代理实现类问题。\",\"缺点：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。\",\"CGLIB 代理：\",\"由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。 同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。\",\"优点：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。\",\"缺点：技术实现相对难理解些。\"]},\"493\":{\"h\":\"MyBatis笔记\"},\"494\":{\"h\":\"1 MyBatis 简介\"},\"495\":{\"h\":\"1.1 MyBatis 特性\",\"t\":[\"1）MyBatis 支持定制化 SQL、存储过程及高级映射的持久层框架\",\"2）封装了 Jdbc，但避免了写 Jdbc 代码\",\"3）使用简单的 xml 或注解用于配置和原始映射\",\"4）半自动的 ORM 对象\"]},\"496\":{\"h\":\"1.2 与其他持久层技术对比\",\"t\":[\"JDBC \",\"SQL 夹杂在 java 代码中，耦合度高\",\"维护不易，若修改 SQL 语句，则需重新编译\",\"Hibernate 和 JPA \",\"操作简便\",\"实现常难 SQL 语句需要绕开框架，自己编写\",\"全映射的全自动框架，实现部分映射比较困难\",\"反射操作多，数据库性能下降\",\"MyBatis \",\"轻量级\",\"SQL 与 Java 代码分开，修改 SQL 语句只需修改映射文件\",\"开发效率稍逊 Hibernate\"]},\"497\":{\"h\":\"2 搭建 MyBatis\"},\"498\":{\"h\":\"2.1 配置 Maven 依赖\",\"t\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>ymk.learnssm</groupId> <artifactId>mybatis_helloworld</artifactId> <version>1.0-SNAPSHOT</version> <packaging>jar</packaging> <properties> <maven.compiler.source>8</maven.compiler.source> <maven.compiler.target>8</maven.compiler.target> </properties> <dependencies> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.7</version> </dependency> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> <scope>test</scope> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.30</version> </dependency> <!-- <dependency>--> <!-- <groupId>org.projectlombok</groupId>--> <!-- <artifactId>lombok</artifactId>--> <!-- <optional>true</optional>--> <!-- </dependency>--> </dependencies> <!-- 配置阿里云仓库 --> <repositories> <repository> <id>aliyun-repos</id> <url>https://maven.aliyun.com/repository/public</url> <releases> <enabled>true</enabled> </releases> <snapshots> <enabled>false</enabled> </snapshots> </repository> </repositories> <pluginRepositories> <pluginRepository> <id>aliyun-repos</id> <url>https://maven.aliyun.com/repository/public</url> <releases> <enabled>true</enabled> </releases> <snapshots> <enabled>false</enabled> </snapshots> </pluginRepository> </pluginRepositories> </project> \"]},\"499\":{\"h\":\"2.2 创建 MyBatis 核心配置文件\",\"t\":[\"mybatis-config.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <configuration> <typeAliases> <typeAlias alias=\\\"User\\\" type=\\\"ymk.learnssm.entity.User\\\" /> </typeAliases> <environments default=\\\"development\\\"> <environment id=\\\"development\\\"> <transactionManager type=\\\"JDBC\\\" /> <dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"com.mysql.cj.jdbc.Driver\\\" /> <property name=\\\"url\\\" value=\\\"jdbc:mysql://localhost:3306/test1?serverTimezone=GMT%2b8\\\" /> <property name=\\\"username\\\" value=\\\"root\\\" /> <property name=\\\"password\\\" value=\\\"Yo*tja>AF96;\\\" /> </dataSource> </environment> </environments> <!-- 引入 mybatis 映射文件 --> <mappers> <mapper resource=\\\"mappers/UserMapper.xml\\\" /> </mappers> </configuration> \"]},\"500\":{\"h\":\"2.3 创建 mapper 接口\",\"t\":[\"UserMapper.java\",\"public interface UserMapper { int insertUser(); } \"]},\"501\":{\"h\":\"2.4 配置 mapper 映射\",\"t\":[\"UserMapper.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org/DTD Mapper 3.0\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"ymk.learnssm.mapper.UserMapper\\\"> <!-- 两个一致 1. mapper 接口的全类名和 namespace 保持一致 2. mapper 接口中的方法方法名和映射文件中的 sql 的 id 保持一致 --> <!-- int insertUser();--> <insert id=\\\"insertUser\\\"> insert into user(id, username, password, nickname, email, phone, address) values (20, 'admin', '123456', '管理员', '1252480844@qq.com', '13905142704', '江苏南京') </insert> <!-- id：返回的是所有对象的Map集合，type：每个对象是User类 --> <!-- <resultMap id=\\\"userMap\\\" type=\\\"User\\\">--> <!--id表示主键字段，property：User类中的属性，column：数据表中的字段，javaType：Use类中属性的类型 --> <!--result表示对象的任何一个属性字段--> <!-- <id property=\\\"id\\\" column=\\\"id\\\" javaType=\\\"java.lang.Integer\\\"></id>--> <!-- <result property=\\\"username\\\" column=\\\"username\\\" javaType=\\\"java.lang.String\\\">--> <!-- </result>--> <!-- </resultMap>--> <!-- useGeneratedKeys：（仅对insert有用），作用：取出由数据库表内部生成的主键值。默认值： false。 比如：数据库管理系统的自动递增字段）--> <!-- keyProperty： （仅对insert有用）作用：用来标记一个属性，MyBatis 会设置它的值。默认：不设置。 配合useGeneratedKeys使用，单独使用一个取的值为null --> <!-- <insert id=\\\"insertUser\\\" useGeneratedKeys=\\\"true\\\" keyProperty=\\\"id\\\">--> <!-- insert into user (username, password, account)--> <!-- values (#{username}, #{password}, #{account})--> <!-- </insert>--> <!-- 1、在各种标签中的id属性必须和接口中的方法名相同 ， id属性值必须是唯一的，不能够重复使用。--> <!-- 2、 parameterType属性指明查询时使用的参数类型，resultType属性指明查询返回的结果集类型--> <!-- 3、#{ }中的内容，为占位符，当参数为某个JavaBean时，表示放置该Bean对象的属性值--> <!-- <update id=\\\"updateUser\\\" >--> <!-- update user set username=#{username},password=#{password},account=#{account} where id=#{id}--> <!-- </update>--> <!-- <delete id=\\\"deleteUser\\\" parameterType=\\\"int\\\">--> <!-- delete from user where id=#{id}--> <!-- </delete>--> <!-- <select id=\\\"selectUserById\\\" parameterType=\\\"int\\\" resultMap=\\\"userMap\\\">--> <!-- select * from user where id=#{id}--> <!-- </select>--> <!-- <select id=\\\"selectAllUser\\\" resultMap=\\\"userMap\\\">--> <!-- select * from user--> <!-- </select>--> </mapper> \"]},\"502\":{\"h\":\"2.5 获取 sql 会话对象 测试功能\",\"t\":[\"Test.java\",\"public class MyBatisTest { @Test public void testInsertUser() throws IOException { // 获取核心配置文件的输入流 InputStream inputStream = Resources.getResourceAsStream(\\\"mybatis-config.xml\\\"); // 获取SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 获取SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); // 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); // 获取 UserMapper 的代理实现类对象 UserMapper userMapperImpl = sqlSession.getMapper(UserMapper.class); // 测试插入功能 System.out.println(userMapperImpl.insertUser()); } } \"]},\"503\":{\"h\":\"3 完善 MyBatis\"},\"504\":{\"h\":\"3.1 添加查询功能\",\"t\":[\"BookMapper.java\",\"带参数的查询语句，根据id查询\",\"public interface BookMapper { Book getUserById(@Param(\\\"id\\\") int id); } \",\"BookMapper.xml\",\"xml中获取参数 #\",\"resultType 把返回的数据转换成 Book 类型\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org/DTD Mapper 3.0\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"ymk.learnssm.mapper.BookMapper\\\"> <!-- Book getUserById(@Param(\\\"id\\\") int id) --> <select id=\\\"getUserById\\\" resultType=\\\"ymk.learnssm.entity.Book\\\"> select * from book where userid = #{id}; </select> </mapper> \"]},\"505\":{\"h\":\"4 MyBatis 核心配置文件（mybatis-config.xml）\"},\"506\":{\"h\":\"4.1 核心配置文件之 environment\",\"t\":[\"<!-- environments: 配置连接数据库的环境 属性: default: 设置默认使用的环境的 id --> <environments default=\\\"development\\\"> <!-- environment: 设置一个具体的数据库的环境 属性: id: 设置环境的唯一标识（不能重复） --> <environment id=\\\"development\\\"> <!-- transactionManager: 设置事务管理器 属性: type: 设置事务管理的方式 type=\\\"JDBC | MANAGED\\\" JDBC: 表示使用原生的事务管理方式 MANAGED: 被管理，例如 Spring --> <transactionManager type=\\\"JDBC\\\"/> <!-- dataSource: 设置事数据源 属性: type: 设置数据源的类型 type=\\\"POOLED | UNPOOLED | JNDI\\\" POOLED: 表示使用数据库连接池 UNPOOLED: 表示不使用数据库连接池 JNDI: 表示使用上下文中的数据源 --> <dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"com.mysql.cj.jdbc.Driver\\\"/> <property name=\\\"url\\\" value=\\\"jdbc:mysql://localhost:3306/test1?serverTimezone=GMT%2b8\\\"/> <property name=\\\"username\\\" value=\\\"root\\\"/> <property name=\\\"password\\\" value=\\\"Yo*tja>AF96;\\\"/> </dataSource> </environment> </environments> \"]},\"507\":{\"h\":\"4.2 核心配置文件之 properties\",\"t\":[\"<!-- 引入 jdbc 配置文件，此后就可以使用 ${key} 的方式来访问 value --> <properties resource=\\\"jdbc.properties\\\"/> \",\"把 jdbc 的配置文件写在一个单独的文件中\",\"jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/test1?serverTimezone=GMT%2b8 jdbc.username=root jdbc.password=Yo*tja>AF96; \"]},\"508\":{\"h\":\"4.3 核心配置文件之 typeAliases\",\"t\":[\"<!-- 类型别名用别名来代替一个复杂的名字 --> <typeAliases> <typeAlias alias=\\\"User\\\" type=\\\"ymk.learnssm.entity.User\\\"/> <typeAlias alias=\\\"Book\\\" type=\\\"ymk.learnssm.entity.Book\\\"/> <!-- 通过包设置别名，指定包下的所有类型都有默认的别名，即类名不区分大小写 --> <package name=\\\"ymk.learnssm.entity\\\"/> </typeAliases> \"]},\"509\":{\"h\":\"4.4 核心配置文件之 mappers\",\"t\":[\"<!-- 引入 mybatis 映射文件 --> <mappers> <!-- 以包的方式引入映射文件，但是必须满足两个条件: 1. mapper 接口和映射文件所在的包必须一致 2. mapper 接口的名字和映射文件必须一致 --> <!-- <mapper resource=\\\"mappers/UserMapper.xml\\\"/>--> <!-- <mapper resource=\\\"mappers/BookMapper.xml\\\"/>--> <package name=\\\"ymk.learnssm.mapper\\\"/> </mappers> \"]},\"510\":{\"h\":\"5 MyBatis 获取参数值的两种方式\",\"t\":[\"MyBatis 获取参数值的两种方式：\",\"${}：字符串拼接\",\"#{}：占位符复制\"]},\"511\":{\"h\":\"5.1 获取单个参数情况\",\"t\":[\"UserMapper.java\",\"public interface UserMapper { List<User> getUserByUsername(String username); } \",\"UserMapper.xml\",\"<!-- 使用 #{} --> <select id=\\\"getUserByUsername\\\" resultType=\\\"User\\\"> select * from user where username = #{username单个参数里面输什么无所谓}; </select> <!-- 使用 ${} --> <select id=\\\"getUserByUsername\\\" resultType=\\\"User\\\"> select * from user where username = '${username}'; </select> \"]},\"512\":{\"h\":\"5.2 获取多个参数情况\",\"t\":[\"以 arg0、arg1... 存储传入的多个参数\",\"<!-- User checkLogin(String username, String password); --> <select id=\\\"checkLogin\\\" resultType=\\\"User\\\"> select * from user where username = #{arg0} and password = #{arg1}; </select> \",\"以 param1、param2... 存储传入的多个参数\",\"<!-- User checkLogin(String username, String password); --> <select id=\\\"checkLogin\\\" resultType=\\\"User\\\"> select * from user where username = #{param1}; and password = #{param2}; </select> \",\"用 @Param()注解 为传入的参数起名\",\"User checkLogin(@Param(\\\"username\\\") String username, @Param(\\\"password\\\") String password); \",\"<!-- User checkLogin(String username, String password); --> <select id=\\\"checkLogin\\\" resultType=\\\"User\\\"> select * from user where username = #{username} and password = #{password}; </select> \",\"直接传入参数的键值对，可以直接通过键名获取\",\"@Test public void testCheckLoginByMap() throws IOException { // 获取SqlSession对象 SqlSession sqlSession = SqlSessionUtil.getSqlSession(); // 获取 UserMapper 的代理实现类对象 UserMapper userMapperImpl = sqlSession.getMapper(UserMapper.class); // 测试插入功能 Map map = new HashMap<>(); map.put(\\\"username\\\", \\\"admin\\\"); map.put(\\\"password\\\", \\\"admin\\\"); User user = userMapperImpl.checkLoginByMap(map); System.out.println(user); } \",\"<select id=\\\"checkLoginByMap\\\" resultType=\\\"User\\\"> select * from user where username = #{username} and password = #{password}; </select> \",\"可以通过实体类直接获取相对应的属性值\"]},\"513\":{\"h\":\"6 MyBatis 查询\"},\"514\":{\"h\":\"6.1 查询返回多条数据 @MapKey()\",\"t\":[\"将某个字段的值作为大 Map 的 key\",\"@MapKey(\\\"id\\\") Map<String, Object> getUserByIdToMap(@Param(\\\"id\\\") Integer id); \"]},\"515\":{\"h\":\"6.2 查询返回多条数据 List<map>\",\"t\":[\"用一个存有多个 Map 的 List 集合\",\"List<Map<String, Object>> getUserByIdToMap(@Param(\\\"id\\\") Integer id); \"]},\"516\":{\"h\":\"7 Mybatis 特殊功能\"},\"517\":{\"h\":\"7.1 模糊查询\",\"t\":[\"单引号内使用 #{} 会导致 ？ 被识别为字符串，无法替换\",\"<select id=\\\"getUserByLike\\\" resultType=\\\"User\\\"> select * from user where username like '%${mohoName}%'; </select> \",\"使用 concat 拼接\",\"<select id=\\\"getUserByLike\\\" resultType=\\\"User\\\"> select * from user where username like concat('%',#{mohoName},'%'); </select> \",\"使用双引号 “”\",\"<select id=\\\"getUserByLike\\\" resultType=\\\"User\\\"> select * from user where username like \\\"%\\\"#{mohoName}\\\"%\\\"; </select> \"]},\"518\":{\"h\":\"7.2 批量删除\",\"t\":[\"使用 ${} 字符串替换\",\"<delete id=\\\"batchDelete\\\"> delete from user where id in (${ids}); </delete> \",\"userMapperImpl.batchDelete(\\\"3,4\\\"); \"]},\"519\":{\"h\":\"7.3 动态设置表名\",\"t\":[\"<!-- List<User> getUserFromTable(@Param(\\\"tableName\\\") String tableName); --> <select id=\\\"getUserFromTable\\\" resultType=\\\"User\\\"> select * from ${tableName}; </select> \",\"List list = userMapperImpl.getUserFromTable(\\\"user\\\"); \"]},\"520\":{\"h\":\"7.4 获取自增的主键\",\"t\":[\"<insert id=\\\"insertUser\\\" useGeneratedKeys=\\\"true\\\" keyProperty=\\\"id\\\"> insert into user values (null, #{username}, #{password}, #{nickname}, #{email}, #{phone}, #{address}) </insert> \"]},\"521\":{\"h\":\"8 搭建 MyBatis 框架\"},\"522\":{\"h\":\"8.1 处理字段名和属性名不一致的情况\",\"t\":[\"更改 sql 语句，起字段别名\",\"数据库的数据名\",\"image-20221104140010926\",\"实体类字段名\",\"private Integer empId; private String empName; private Integer age; private String gender; \",\"sql 语句使用别名\",\"<select id=\\\"getEmpById\\\" resultType=\\\"Emp\\\"> select emp_id empId,emp_name empName,emp_age age,emp_gender gender from emp where emp_id = #{empId} </select> \",\"使用 mybatis 核心配置文件，下划线驼峰替换\",\"<settings> <setting name=\\\"mapUnderscoreToCamelCase\\\" value=\\\"true\\\"/> </settings> \",\"配置 resultmap 映射\",\"<mapper namespace=\\\"ymk.learnssm.mapper.EmpMapper\\\"> <!-- column对应 sql 字段，property 对应 --> <resultMap id=\\\"empResultMap\\\" type=\\\"Emp\\\"> <id column=\\\"emp_id\\\" property=\\\"empId\\\"></id> <result column=\\\"emp_name\\\" property=\\\"empName\\\"></result> <result column=\\\"emp_age\\\" property=\\\"empAge\\\"></result> <result column=\\\"emp_gender\\\" property=\\\"empGender\\\"></result> </resultMap> <!-- Emp getEmpById(@Param(\\\"empId\\\") Integer empId); --> <select id=\\\"getEmpById\\\" resultMap=\\\"empResultMap\\\"> select * from emp where emp_id = #{empId}; </select> </mapper> \"]},\"523\":{\"h\":\"8.2 多对一映射处理\",\"t\":[\"使用级联处理多对一映射\",\"联表查询语句如下\",\"<select id=\\\"getEmpAndDeptById\\\" resultMap=\\\"empDeptResultMap\\\"> select emp.*, dept.* from emp left join dept on emp.dept_id = dept.dept_id where emp.emp_id = #{empId}; </select> \",\"设置resultmap\",\"<resultMap id=\\\"empDeptResultMap\\\" type=\\\"Emp\\\"> <id column=\\\"emp_id\\\" property=\\\"empId\\\"></id> <result column=\\\"emp_name\\\" property=\\\"empName\\\"></result> <result column=\\\"emp_age\\\" property=\\\"empAge\\\"></result> <result column=\\\"emp_gender\\\" property=\\\"empGender\\\"></result> <result column=\\\"dept_id\\\" property=\\\"dept.deptId\\\"></result> <result column=\\\"dept_name\\\" property=\\\"dept.deptName\\\"></result> </resultMap> \",\"查询结果\",\"Emp{empId=1, empName='张三', empAge=20, empGender='男', dept=Dept{deptId=1, deptName='A'}} \",\"使用 association 处理多对一映射关系\",\"在 resultmap 中加入 association 属性\",\"<resultMap id=\\\"empDeptAssResultMap\\\" type=\\\"Emp\\\"> <id column=\\\"emp_id\\\" property=\\\"empId\\\"></id> <result column=\\\"emp_name\\\" property=\\\"empName\\\"></result> <result column=\\\"emp_age\\\" property=\\\"empAge\\\"></result> <result column=\\\"emp_gender\\\" property=\\\"empGender\\\"></result> <!-- association：处理多对一的映射关系 property：设置需要处理映射关系的属性和属性名 javaType：设置要处理的属性类型 --> <association property=\\\"dept\\\" javaType=\\\"Dept\\\"> <id column=\\\"dept_id\\\" property=\\\"deptId\\\"></id> <result column=\\\"dept_name\\\" property=\\\"deptName\\\"></result> </association> </resultMap> \",\"使用分步查询处理多对一映射关系（执行两条查询语句）\",\"DeptMapper.xml\",\"<mapper namespace=\\\"ymk.learnssm.mapper.DeptMapper\\\"> <resultMap id=\\\"deptMap\\\" type=\\\"Dept\\\"> <id column=\\\"dept_id\\\" property=\\\"deptId\\\"></id> <result column=\\\"dept_name\\\" property=\\\"deptName\\\"></result> </resultMap> <select id=\\\"getDeptById\\\" resultMap=\\\"deptMap\\\"> select * from dept where dept_id = #{id}; </select> </mapper> \",\"EmpMapper.xml\",\"<resultMap id=\\\"empDeptByStepResultMap\\\" type=\\\"Emp\\\"> <id column=\\\"emp_id\\\" property=\\\"empId\\\"></id> <result column=\\\"emp_name\\\" property=\\\"empName\\\"></result> <result column=\\\"emp_age\\\" property=\\\"empAge\\\"></result> <result column=\\\"emp_gender\\\" property=\\\"empGender\\\"></result> <!-- association：处理多对一的映射关系 property：设置需要处理映射关系的属性和属性名 select：设置写一步的查询语句的唯一标识 column：将查询的字段作为下一步查询语句的的 sql 输入 --> <association property=\\\"dept\\\" select=\\\"ymk.learnssm.mapper.DeptMapper.getDeptById\\\" column=\\\"dept_id\\\"></association> </resultMap> <select id=\\\"getEmpAndDeptByStep\\\" resultMap=\\\"empDeptByStepResultMap\\\"> select emp.*, dept.* from emp left join dept on emp.dept_id = dept.dept_id where emp.emp_id = #{empId}; </select> \"]},\"524\":{\"h\":\"8.3 延迟加载\",\"t\":[\"分步查询可以实现延迟加载\",\"mybatis 设置中开启延迟加载\",\"<settings> <!-- 开启延迟加载 --> <setting name=\\\"lazyLoadingEnabled\\\" value=\\\"true\\\"/> <setting name=\\\"aggressiveLazyLoading\\\" value=\\\"false\\\"/> </settings> \",\"测试语句\",\"@Test public void testGetEmpAndDeptByStep() { SqlSession sqlSession = SqlSessionUtil.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp emp = mapper.getEmpAndDeptByStep(1); System.out.println(emp.getempName()); } \",\"得到结果，当不需要 dept 信息时，就没有执行下一个查询语句\",\"[DEBUG][2022-11-06 17:18:56 816][ymk.learnssm.mapper.EmpMapper.getEmpAndDeptByStep]-[==> Preparing: select emp.*, dept.* from emp left join dept on emp.dept_id = dept.dept_id where emp.emp_id = ?;] [DEBUG][2022-11-06 17:18:56 834][ymk.learnssm.mapper.EmpMapper.getEmpAndDeptByStep]-[==> Parameters: 1(Integer)] [DEBUG][2022-11-06 17:18:56 882][ymk.learnssm.mapper.EmpMapper.getEmpAndDeptByStep]-[<== Total: 1] \",\"还可以设置 association 的 fetchType 属性来实现延迟加载还是立即加载\",\"<resultMap id=\\\"empDeptByStepResultMap\\\" type=\\\"Emp\\\"> <id column=\\\"emp_id\\\" property=\\\"empId\\\"></id> <result column=\\\"emp_name\\\" property=\\\"empName\\\"></result> <result column=\\\"emp_age\\\" property=\\\"empAge\\\"></result> <result column=\\\"emp_gender\\\" property=\\\"empGender\\\"></result> <!-- association：处理多对一的映射关系 property：设置需要处理映射关系的属性和属性名 select：设置写一步的查询语句的唯一标识 column：将查询的字段作为下一步查询语句的的 sql 输入 --> <association property=\\\"dept\\\" fetchType=\\\"lazy\\\" select=\\\"ymk.learnssm.mapper.DeptMapper.getDeptById\\\" column=\\\"dept_id\\\"></association> </resultMap> \"]},\"525\":{\"h\":\"8.4 一对多映射\",\"t\":[\"通过 collection 处理一对多映射\",\"<resultMap id=\\\"deptAssMap\\\" type=\\\"Dept\\\"> <id column=\\\"dept_id\\\" property=\\\"deptId\\\"></id> <result column=\\\"dept_name\\\" property=\\\"deptName\\\"></result> <collection property=\\\"empList\\\" ofType=\\\"Emp\\\"> <id column=\\\"emp_id\\\" property=\\\"empId\\\"></id> <result column=\\\"emp_name\\\" property=\\\"empName\\\"></result> <result column=\\\"emp_age\\\" property=\\\"empAge\\\"></result> <result column=\\\"emp_gender\\\" property=\\\"empGender\\\"></result> </collection> </resultMap> <select id=\\\"getDeptAndEmpById\\\" resultMap=\\\"deptAssMap\\\"> select * from dept left join emp on dept.dept_id = emp.emp_id where dept.dept_id = #{id}; </select> \",\"通过分步查询处理一对多映射\",\"sql 语句\",\"<resultMap id=\\\"deptAssMap\\\" type=\\\"Dept\\\"> <id column=\\\"dept_id\\\" property=\\\"deptId\\\"></id> <result column=\\\"dept_name\\\" property=\\\"deptName\\\"></result> <collection property=\\\"empList\\\" ofType=\\\"Emp\\\"> <id column=\\\"emp_id\\\" property=\\\"empId\\\"></id> <result column=\\\"emp_name\\\" property=\\\"empName\\\"></result> <result column=\\\"emp_age\\\" property=\\\"empAge\\\"></result> <result column=\\\"emp_gender\\\" property=\\\"empGender\\\"></result> </collection> </resultMap> <select id=\\\"getDeptAndEmpByStep\\\" resultMap=\\\"deptStepMap\\\"> select * from dept left join emp on dept.dept_id = emp.emp_id where dept.dept_id = #{id}; </select> \",\"step one\",\"/** * 通过分步查询门以及部门中的员工信息 * * @param id * @return */ Dept getDeptAndEmpByStep(@Param(\\\"id\\\") Integer id); \",\"step two\",\"/** * 查询员工信息合集 用于分步查询 * * @param empId * @return */ List<Emp> getEmpListById(@Param(\\\"deptId\\\") Integer deptId); \"]},\"526\":{\"h\":\"9 动态 SQL\",\"t\":[\"根据条件动态拼接 sql 语句，解决字符串拼接痛点\"]},\"527\":{\"h\":\"9.1 if\",\"t\":[\"/** * 根据条件查询员工信息 * @param emp * @return */ List<Emp> getEmpListByCondition(Emp emp); \",\"条件查询，使用 if 进行拼接\",\"<resultMap id=\\\"empDeptAssResultMap\\\" type=\\\"Emp\\\"> <id column=\\\"emp_id\\\" property=\\\"empId\\\"></id> <result column=\\\"emp_name\\\" property=\\\"empName\\\"></result> <result column=\\\"emp_age\\\" property=\\\"empAge\\\"></result> <result column=\\\"emp_gender\\\" property=\\\"empGender\\\"></result> <!-- association：处理多对一的映射关系 property：设置需要处理映射关系的属性和属性名 javaType：设置要处理的属性类型 --> <association property=\\\"dept\\\" javaType=\\\"Dept\\\"> <id column=\\\"dept_id\\\" property=\\\"deptId\\\"></id> <result column=\\\"dept_name\\\" property=\\\"deptName\\\"></result> </association> </resultMap> <select id=\\\"getEmpListByCondition\\\" resultMap=\\\"empDeptAssResultMap\\\"> select * from emp left join dept on emp.dept_id = dept.dept_id where <if test=\\\"empName != null and empName != ''\\\"> emp_name = #{empName} </if> <if test=\\\"empAge != null and empAge != ''\\\"> and emp_age = #{empAge} </if> <if test=\\\"empGender != null and empGender != ''\\\"> and emp_gender = #{empGender} </if> </select> \"]},\"528\":{\"h\":\"9.2 where\",\"t\":[\"where 标签会自动判断条件标签是否成立 不成立则不拼接 where 并且where 标签还会自动删除前面多余的 and\",\"<select id=\\\"getEmpListByCondition\\\" resultMap=\\\"empDeptAssResultMap\\\"> select * from emp left join dept on emp.dept_id = dept.dept_id <where> <if test=\\\"empName != null and empName != ''\\\"> emp_name = #{empName} </if> <if test=\\\"empAge != null and empAge != ''\\\"> and emp_age = #{empAge} </if> <if test=\\\"empGender != null and empGender != ''\\\"> and emp_gender = #{empGender} </if> </where> </select> \"]},\"529\":{\"h\":\"9.3 trim\",\"t\":[\"trim 可以自动删除后面多余的 and\",\"prefix，suffix：在标签内容前或后添加指定内容\",\"prefixOverrides，suffixOverrides：在标签内容的前或后去除指定内容\",\"<select id=\\\"getEmpListByCondition\\\" resultMap=\\\"empDeptAssResultMap\\\"> select * from emp left join dept on emp.dept_id = dept.dept_id <trim prefix=\\\"where\\\" suffixOverrides=\\\"and\\\"> <if test=\\\"empName != null and empName != ''\\\"> emp_name = #{empName} and </if> <if test=\\\"empAge != null and empAge != ''\\\"> emp_age = #{empAge} and </if> <if test=\\\"empGender != null and empGender != ''\\\"> emp_gender = #{empGender} </if> </trim> </select> \"]},\"530\":{\"h\":\"9.4 choose、when、otherwise\",\"t\":[\"choose when 只要符合第一个就只会加上第一个条件，下面的条件都不会判断\",\"相当于 if。。。else if 。。。else\",\"<select id=\\\"getEmpListByChoose\\\" resultType=\\\"Emp\\\"> select * from emp <where> <choose> <when test=\\\"empName != null and empName != ''\\\"> emp_name = #{empName} </when> <when test=\\\"\\\"> emp_age = #{empAge} </when> <when test=\\\"\\\"> emp_gender = #{empGender} </when> </choose> </where> </select> \",\"@Test public void testGetEmpByChoose() { SqlSession sqlSession = SqlSessionUtil.getSqlSession(); DynamicSqlMapper mapper = sqlSession.getMapper(DynamicSqlMapper.class); Emp emp = new Emp(null, \\\"张三\\\", 20, \\\"\\\"); System.out.println(mapper.getEmpListByChoose(emp)); } \",\"结果为\",\"[Emp{empId=1, empName='张三', empAge=20, empGender='男', dept=null}, Emp{empId=5, empName='张三', empAge=21, empGender='女', dept=null}] \"]},\"531\":{\"h\":\"9.5 foreach\",\"t\":[\"批量添加功能\",\"/** * 批量添加用户 * @param empList * @return */ int insertMoreEmp(@Param(\\\"empList\\\") List<Emp> empList); \",\"foreach 的 separator 设置多个赋值之间的分隔符\",\"<insert id=\\\"insertMoreEmp\\\"> insert into emp values <foreach collection=\\\"empList\\\" item=\\\"emp\\\" separator=\\\",\\\"> (#{emp.empId},#{emp.empName},#{emp.empAge},#{emp.empGender},null) </foreach> </insert> \",\"批量删除功能\",\"/** * 批量删除功能 * @param empIds * @return */ int deleteMoreEmp(@Param(\\\"empIds\\\") Integer[] empIds); \",\"open 表示循环的内容以什么开始\",\"close 表示循环的内容以什么结束\",\"<delete id=\\\"deleteMoreEmp\\\"> delete from emp where emp_id in <foreach collection=\\\"empIds\\\" item=\\\"empId\\\" separator=\\\",\\\" open=\\\"(\\\" close=\\\")\\\"> #{empId} </foreach> </delete> \",\"或者\",\"<delete id=\\\"deleteMoreEmp\\\"> delete from emp where <foreach collection=\\\"empIds\\\" item=\\\"empId\\\" separator=\\\"or\\\"> emp_id = #{empId} </foreach> </delete> \",\"使用 or 当作分隔符\"]},\"532\":{\"h\":\"9.6 sql\",\"t\":[\"sql 标签表示代码片段\",\"可以用 include 标签来引用\",\"<sql id=\\\"empColumns\\\"> emp_id,emp_name,emp_age,emp_gender,dept_id </sql> <select id=\\\"getEmpListByCondition\\\" resultMap=\\\"empDeptAssResultMap\\\"> select <include refid=\\\"empColumns\\\"></include> from emp left join dept on emp.dept_id = dept.dept_id <trim prefix=\\\"where\\\" suffixOverrides=\\\"and\\\"> <if test=\\\"empName != null and empName != ''\\\"> emp_name = #{empName} and </if> <if test=\\\"empAge != null and empAge != ''\\\"> emp_age = #{empAge} and </if> <if test=\\\"empGender != null and empGender != ''\\\"> emp_gender = #{empGender} </if> </trim> </select> \"]},\"533\":{\"h\":\"10 MyBatis 缓存\"},\"534\":{\"h\":\"10.1 一级缓存\",\"t\":[\"介绍\",\"MyBatis 的一级缓存是 sqlSession 级别的，通过同一个 SqlSession 查询的数据会被缓存，再次使用同一个 SqlSession 查询同一条数据，会从缓存中获取\",\"一级缓存失效的情况\",\"不同的 SqlSession 对应不同的一级缓存\",\"同一个 SqlSession 但是查询条件不同\",\"同一个 SqlSession 两次查询期间执行了任意一次增删查改操作\",\"同一个 SqlSession 两次查询期间手动清空了缓存\"]},\"535\":{\"h\":\"10.2 二级缓存\",\"t\":[\"介绍\",\"二级缓存是 SqlSessionFactory 级别，通过同一个 SqlSessionFactory 创建的 SqlSession 查询的结果会被缓存，此后若再次执行相同的查询语句，结果会从缓存中获取\",\"二级缓存开启条件：\",\"在核心配置文件中全局属性 cacheEnabled=\\\"true\\\" （默认为true）\",\"在映射文件配置文件中设置标签<cache/>\",\"<mapper namespace=\\\"ymk.learnssm.mapper.CacheMapper\\\"> <cache/> </mapper> \",\"二级缓存必须在 SqlSession 关闭或提交之后有效\",\"sqlSession.close(); \",\"查询的数据所转换的实体类型必须实现序列化的接口\",\"public class Emp implements Serializable { } \",\"二级缓存失效的情况\",\"两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效\"]},\"536\":{\"h\":\"10.3 二级缓存相关配置文件\",\"t\":[\"<cache eviction=\\\"\\\" flushInterval=\\\"\\\" size=\\\"\\\" readOnly=\\\"\\\" blocking=\\\"\\\" type=\\\"\\\"/> \",\"eviction 缓存回收策略 默认 LRU\",\"LRU：最近最少使用的，一处最长时间不配使用的对象\",\"FIFO：先进先出，按对象进入缓存的顺序来移出他们\",\"SOFT：软引用，移出基于垃圾回收器状态和软引用规则的对象\",\"WEAK：弱引用，更积极地移出基于垃圾收集器状态和弱引用规则的对象\",\"flushInterval 刷新间隔，单位毫秒\",\"默认情况是不设置，调用语句时刷新\",\"size 引用数目\",\"代表缓存可以存储多少个对象，太大容易导致内存溢出\",\"readOnly 只读 默认 false\",\"true：只读缓存 会给所有调用者返回缓存对象的相同实例\",\"false：独写缓存，会返回缓存对象的拷贝（通过序列化）。慢但是安全\"]},\"537\":{\"h\":\"10.4 MyBatis 缓存查询顺序\",\"t\":[\"先查询二级缓存，因为二级缓存中可能会有其他 SqlSession 查出来的数据\",\"二级缓存没有再查一级缓存\",\"一级缓存也没有，则查询数据库\",\"注：SqlSession 关闭后，一级缓存的数据会写入二级缓存\"]},\"538\":{\"h\":\"10.5 整合第三方缓存 EHcache\",\"t\":[\"二级缓存可以使用第三方的缓存\"]},\"539\":{\"h\":\"11 MyBatis 逆向工程\"},\"540\":{\"h\":\"11.1 简洁版\",\"t\":[\"正向工程：先创建 java 实体类，由框架负责根据实体类生成数据库表。Hibernate 是支持正向工程的\",\"逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成资源\",\"配置 maven,添加 mybatis 逆向插件及其依赖\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>ymk.learnssm</groupId> <artifactId>mybatis_helloworld</artifactId> <version>1.0-SNAPSHOT</version> <packaging>jar</packaging> <properties> <maven.compiler.source>8</maven.compiler.source> <maven.compiler.target>8</maven.compiler.target> </properties> <dependencies> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.7</version> </dependency> <!-- mybatis-generator --> <dependency> <groupId>org.mybatis.generator</groupId> <artifactId>mybatis-generator-core</artifactId> <version>1.3.7</version> </dependency> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> <scope>test</scope> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.30</version> </dependency> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter</artifactId> <version>RELEASE</version> <scope>compile</scope> </dependency> <dependency> <groupId>log4j</groupId> <artifactId>log4j</artifactId> <version>1.2.17</version> </dependency> <!-- <dependency>--> <!-- <groupId>org.projectlombok</groupId>--> <!-- <artifactId>lombok</artifactId>--> <!-- <optional>true</optional>--> <!-- </dependency>--> </dependencies> <build> <plugins> <plugin> <groupId>org.mybatis.generator</groupId> <artifactId>mybatis-generator-maven-plugin</artifactId> <version>1.4.0</version> <!-- 插件的依赖 --> <dependencies> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.30</version> </dependency> <dependency> <groupId>org.mybatis.generator</groupId> <artifactId>mybatis-generator-core</artifactId> <version>1.4.0</version> </dependency> </dependencies> </plugin> </plugins> </build> <!-- 配置阿里云仓库 --> <repositories> <repository> <id>aliyun-repos</id> <url>https://maven.aliyun.com/repository/public</url> <releases> <enabled>true</enabled> </releases> <snapshots> <enabled>false</enabled> </snapshots> </repository> </repositories> <pluginRepositories> <pluginRepository> <id>aliyun-repos</id> <url>https://maven.aliyun.com/repository/public</url> <releases> <enabled>true</enabled> </releases> <snapshots> <enabled>false</enabled> </snapshots> </pluginRepository> </pluginRepositories> </project> \",\"添加 generatorConfig.xml 配置文件\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <!DOCTYPE generatorConfiguration PUBLIC \\\"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\\\"> <generatorConfiguration> <context id=\\\"DB2Tables\\\" targetRuntime=\\\"MyBatis3Simple\\\"> <!-- 数据库连接驱动类,URL，用户名、密码 --> <jdbcConnection driverClass=\\\"com.mysql.cj.jdbc.Driver\\\" connectionURL=\\\"jdbc:mysql://localhost:3306/test1?serverTimezone=GMT%2b8\\\" userId=\\\"root\\\" password=\\\"Yo*tja>AF96;\\\"> </jdbcConnection> <javaModelGenerator targetPackage=\\\"ymk.learnssm.entity\\\" targetProject=\\\".\\\\src\\\\main\\\\java\\\"> <!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --> <property name=\\\"enableSubPackages\\\" value=\\\"true\\\"/> <!-- 设置是否在getter方法中，对String类型字段调用trim()方法--> <property name=\\\"trimStrings\\\" value=\\\"true\\\"/> </javaModelGenerator> <!-- 生成xml映射文件：包名(targetPackage)、位置(targetProject) --> <sqlMapGenerator targetPackage=\\\"ymk.learnssm.mapper\\\" targetProject=\\\".\\\\src\\\\main\\\\resources\\\"> <property name=\\\"enableSubPackages\\\" value=\\\"true\\\"/> </sqlMapGenerator> <!-- 生成DAO接口：包名(targetPackage)、位置(targetProject) --> <javaClientGenerator type=\\\"XMLMAPPER\\\" targetPackage=\\\"ymk.learnssm.mapper\\\" targetProject=\\\".\\\\src\\\\main\\\\java\\\"> <property name=\\\"enableSubPackages\\\" value=\\\"true\\\"/> </javaClientGenerator> <!-- 要生成的表：tableName - 数据库中的表名或视图名，domainObjectName - 实体类名 --> <table tableName=\\\"emp\\\" domainObjectName=\\\"Emp\\\"> </table> <table tableName=\\\"dept\\\" domainObjectName=\\\"Dept\\\"> </table> </context> </generatorConfiguration> \"]},\"541\":{\"h\":\"11.2 奢华版\",\"t\":[\"<context id=\\\"DB2Tables\\\" targetRuntime=\\\"MyBatis3\\\"> \"]},\"542\":{\"h\":\"12 分页功能\",\"t\":[\"**参数：**limit index pageSize\",\"pageSize：每页显示的条数\",\"pageNum：当前页的页码\",\"index：当前页的起始索引，index=（pageNum-1）*pageSize\",\"count：总数据\",\"totalPage：总页数\",\"page\",\"Page{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=20, pages=5, reasonable=false, pageSizeZero=false} [Emp{empId=1, empName='a', empAge=null, empGender='null', deptId=null}, Emp{empId=2, empName='b', empAge=null, empGender='null', deptId=null}, Emp{empId=3, empName='c', empAge=null, empGender='null', deptId=null}, Emp{empId=4, empName='d', empAge=null, empGender='null', deptId=null}] \",\"PageInfo{pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=20, pages=5, list=Page{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=20, pages=5, reasonable=false, pageSizeZero=false} [Emp{empId=1, empName='a', empAge=null, empGender='null', deptId=null}, Emp{empId=2, empName='b', empAge=null, empGender='null', deptId=null}, Emp{empId=3, empName='c', empAge=null, empGender='null', deptId=null}, Emp{empId=4, empName='d', empAge=null, empGender='null', deptId=null}], prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=5, navigatepageNums=[1, 2, 3, 4, 5]} \"]},\"543\":{\"h\":\"Spring实战\"},\"544\":{\"h\":\"1 Spring 概念\"},\"545\":{\"h\":\"1.1 Spring 介绍\",\"t\":[\"Spring 的核心是一个 容器，通常称为 Spring 应用程序上下文，用于创建和管理应用程序组件。这些组件（或 bean）在 Spring 应用程序上下文中连接在一起以构成一个完整的应用程序\",\"将 bean 连接在一起的行为是基于一种称为 依赖注入（DI）的模式。依赖项注入的应用程序不是由组件自身创建和维护它们依赖的其他 bean 的生命周期，而是依赖于单独的实体（容器）来创建和维护所有组件，并将这些组件注入需要它们的 bean。通常通过构造函数参数或属性访问器方法完成此操作。\",\"除了其核心容器之外，Spring 和完整的相关库产品组合还提供 Web 框架、各种数据持久性选项、安全框架与其他系统的集成、运行时监视、微服务支持、响应式编程模型以及许多其他功能，应用于现代应用程序开发。\"]},\"546\":{\"h\":\"1.2 Spring 框架概述\",\"t\":[\"Spring 是轻量级开源的JavaEE框架\",\"Spring 可以解决企业开发的复杂性问题\",\"Spring 有两个核心部分：IOC、AOP\"]},\"547\":{\"h\":\"1.2.1 IOC 介绍\",\"t\":[\"控制反转，把创建对象的过程交给 Spring 管理，不用 new 的方式\"]},\"548\":{\"h\":\"1.2.2 AOP 介绍\",\"t\":[\"面向切面，在不修改源代码的情况下，进行功能增强\"]},\"549\":{\"h\":\"1.3 Spring 特点\",\"t\":[\"方便解耦，简化开发\",\"AOP 编程的支持\",\"方便程序测试\",\"方便和其他框架进行整合\",\"方便进行事务的管理\",\"降低 API 的开发难度\"]},\"550\":{\"h\":\"2 入门案例\"},\"551\":{\"h\":\"2.1 Spring 源码下载地址\",\"t\":[\"Spring源码下载：https://repo.spring.io/ui/native/release/org/springframework/spring/\",\"commons-logging_1.1.1.jar下载：https://nowjava.com/jar/detail/m02262204/commons-logging-1.1.1.jar.html\"]},\"552\":{\"h\":\"2.2 配置基本功能\",\"t\":[\"导入依赖库\",\"建立一个 User 类，并配置 Spring xml 配置文件\",\"image-20220905151848479\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <!--配置 User 对象创建--> <bean id=\\\"user\\\" class=\\\"com.ymk.learnSpring.User\\\"></bean> </beans> \",\"新建一个测试类\",\"public class TestSpring5 { @Test public void testAdd() { // 1. 加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(\\\"bean1.xml\\\"); // 2. 获取配置创建的变量 User user = context.getBean(\\\"user\\\", User.class); // 3. 测试输出 System.out.println(user); user.add(); } } \"]},\"553\":{\"h\":\"3 IOC 容器\"},\"554\":{\"h\":\"3.1 IOC 概念\",\"t\":[\"把对象创建和对象之间调用的过程，交给Spring管理\",\"降低代码耦合\",\"入门案例就是 IOC 的一种实现\"]},\"555\":{\"h\":\"3.2 IOC 底层原理\",\"t\":[\"**使用技术：**XML解析、工厂模式、反射\",\"**工厂模式：**解耦\",\"// UserService.java class UserService { execute() { UserAdd add = UserFactory.getAdd(); } } \",\"// UserAdd.java class UserAdd { add() { // todo } } \",\"// UserFactory.java class UserFactory { public static UserAdd getAdd() { return new UserAdd(); } } \",\"IOC 的过程\",\"配置 XML 文件\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <!--配置 User 对象创建--> <bean id=\\\"user\\\" class=\\\"com.ymk.learnSpring.User\\\"></bean> </beans> \",\"创建工厂类\",\"// UserFactory.java class UserFactory { public static UserAdd getAdd() { String classValue = class属性值; // xml解析得到对象名 Class clazz = Class.forName(classValue); // 通过反射创建对象 return (UserAdd)clazz.newInstance(); } } \",\"IOC 思想\",\"IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂\",\"Spring 提供 IOC 容器实现的两种方式\",\"BeanFactory：IOC 容器实现，是 Spring 内部的使用接口，不提供开发人员进行使用（加载配置文件时不会加载里面的对象，在获取对象时才会创建对象）\",\"ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员使用（加载配置文件时就会把对象创建）\",\"ApplicationContext 接口实现类\",\"image-20220906170932519\"]},\"556\":{\"h\":\"4 Bean 管理\"},\"557\":{\"h\":\"4.1 什么是 Bean 管理\",\"t\":[\"Bean 管理指用 Spring 创建对象，注入属性\",\"基于 XML 方式\",\"基于 XML 方式创建对象\",\"<bean id=\\\"user\\\" class=\\\"com.ymk.learnSpring.User\\\"></bean> \",\"在 Spring 文件中添加 bean 标签，添加对应属性，即可实现对象创建（创建对象时默认使用的无参构造）\",\"bean 属性\",\"id 属性：唯一标识\",\"class 属性：创建对象的类路径\",\"name 属性：与 id 类似，区别是 id 中不能加特殊符号，name 中可以加\",\"基于 XML 方式注入属性\",\"(1) DI: 依赖注入，就是注入属性\",\"第一种注入方式：使用 set 方法注入\",\" <bean id=\\\"book\\\" class=\\\"com.ymk.learnSpring.Book\\\"> <!--注入属性--> <property name=\\\"name\\\" value=\\\"斗罗大陆\\\"></property> </bean> \",\"@Test public void testBook1() { // 1. 加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(\\\"bean1.xml\\\"); // 2. 获取配置创建的变量 Book book = context.getBean(\\\"book\\\", Book.class); // 3. 测试输出 book.printName(); } \",\"第二种注入方式：使用有参构造器注入\",\" <bean id=\\\"book\\\" class=\\\"com.ymk.learnSpring.Book\\\"> <!--注入属性--> <constructor-arg name=\\\"name\\\" value=\\\"天蚕变\\\"></constructor-arg> <!-- <constructor-arg index=\\\"0\\\" value=\\\"天蚕变\\\"></constructor-arg>--> </bean> \",\"(2) P 名称空间注入\",\"可以简化基于 XML 配置方式\",\"基于 XML 注入其他类型属性\",\"设置属性为空\",\"<property name=\\\"name\\\"><null></null></property> \",\"属性值包含特殊符号\",\"<!--转义特殊字符--> <property name=\\\"name\\\" value=\\\"&lt;斗罗大陆&lt;\\\"></property> <property name=\\\"name\\\"> <value><![CDATA[《斗罗大陆》]]></value> </property> \",\"基于 XML 注入外部 bean\",\"(1)配置 xml 文件\",\" <bean id=\\\"userService\\\" class=\\\"com.ymk.learnSpring.service.UserService\\\"> <!--注入外部bean userImpl--> <property name=\\\"userDao\\\" ref=\\\"userDaoImpl\\\"></property> </bean> <bean id=\\\"userDaoImpl\\\" class=\\\"com.ymk.learnSpring.dao.UserDaoImpl\\\"></bean> \",\"(2)实现接口和实现类\",\"// UserService public class UserService { // 创建UserDao属性 private UserDao userDao; public void setUserDao(UserDaoImpl userDao) { this.userDao = userDao; } public void add() { System.out.println(\\\"Service Add.............\\\"); this.userDao.update(); } } \",\"// UserDao接口 public interface UserDao { public void update(); } \",\"// UserDaoImpl实现类 public class UserDaoImpl implements UserDao{ @Override public void update() { System.out.println(\\\"Update..........\\\"); } } \",\"注入属性-内部 bean\",\"(1)一对多关系：部门和员工\",\"​ 一个部门里有多个员工\",\"(2)在实体类之间表示一对多的关系\",\"// 部门类 public class Dept { private String name; public void setName(String name) { this.name = name; } } // 员工类 public class Emp { private String name; private String gender; // 员工属于某一个部门，使用对象形式表示 private Dept dept; public void setDept(Dept dept) { this.dept = dept; } public void setName(String name) { this.name = name; } public void setGender(String gender) { this.gender = gender; } } \",\"<!--内部bean--> <bean id=\\\"emp\\\" class=\\\"com.ymk.learnSpring.bean.Emp\\\"> <!--先设置两个普通属性--> <property name=\\\"name\\\" value=\\\"ymk\\\"></property> <property name=\\\"gender\\\" value=\\\"female\\\"></property> <!--设置对象类型属性--> <property name=\\\"dept\\\"> <bean id=\\\"dept\\\" class=\\\"com.ymk.learnSpring.bean.Dept\\\"> <property name=\\\"name\\\" value=\\\"开发部\\\"></property> </bean> </property> </bean> \",\"注入属性-级联赋值\",\"<bean id=\\\"emp\\\" class=\\\"com.ymk.learnSpring.bean.Emp\\\"> <!--先设置两个普通属性--> <property name=\\\"name\\\" value=\\\"ymk\\\"></property> <property name=\\\"gender\\\" value=\\\"female\\\"></property> <!--设置对象类型属性--> <!--级联赋值--> <!--第一种写法--> <property name=\\\"dept\\\" ref=\\\"dept\\\"></property> <!--第二种写法--> <property name=\\\"dept.name\\\" value=\\\"技术部\\\"></property> </bean> <bean id=\\\"dept\\\" class=\\\"com.ymk.learnSpring.bean.Dept\\\"> <property name=\\\"name\\\" value=\\\"营销部\\\"></property> </bean> \",\"注入集合类型属性-数组属性\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"stu\\\" class=\\\"com.ymk.learnSpring.collectiontype.Student\\\"> <!--数组类型注入--> <property name=\\\"coursesArray\\\"> <array> <value>Math</value> <value>English</value> <value>PE</value> </array> </property> <!--list类型注入--> <property name=\\\"coursesList\\\"> <list> <value>Math</value> <value>English</value> <value>PE</value> </list> </property> <!--map类型注入--> <property name=\\\"coursesMap\\\"> <map> <entry key=\\\"ymk\\\" value=\\\"math\\\"></entry> <entry key=\\\"ztt\\\" value=\\\"english\\\"></entry> </map> </property> <!--set类型注入--> <property name=\\\"coursesSet\\\"> <set> <value>Math</value> <value>English</value> <value>PE</value> </set> </property> </bean> </beans> \",\"对象类型数组的注入\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"stu\\\" class=\\\"com.ymk.learnSpring.collectiontype.Student\\\"> <property name=\\\"coursesList\\\"> <list> <ref bean=\\\"course1\\\"></ref> <ref bean=\\\"course2\\\"></ref> </list> </property> <!--注入Course对象--> <property name=\\\"course\\\"> <bean id=\\\"course\\\" class=\\\"com.ymk.learnSpring.collectiontype.Course\\\"> <property name=\\\"courseName\\\" value=\\\"面向对象\\\"></property> </bean> </property> <property name=\\\"course\\\" ref=\\\"course1\\\"></property> <property name=\\\"course.courseName\\\" value=\\\"面向对象2\\\"></property> </bean> <bean id=\\\"course1\\\" class=\\\"com.ymk.learnSpring.collectiontype.Course\\\"> <property name=\\\"courseName\\\" value=\\\"面向对象1\\\"></property> </bean> <bean id=\\\"course2\\\" class=\\\"com.ymk.learnSpring.collectiontype.Course\\\"> <property name=\\\"courseName\\\" value=\\\"注入对象\\\"></property> </bean> </beans> \",\"使用 util 把集合注入部分提取出来\",\"在 Spring 配置文件中引入名称空间\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:util=\\\"http://www.springframework.org/schema/util\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\\\"> <!--提取list集合类型--> <util:list id=\\\"bookList\\\"> <value>三国</value> <value>天龙八部</value> <value>水浒</value> <value>红楼梦</value> </util:list> <!--list集合属性注入使用--> <bean id=\\\"book\\\" class=\\\"com.ymk.learnSpring.collectiontype.Book\\\"> <property name=\\\"bookList\\\" ref=\\\"bookList\\\"></property> </bean> </beans> \"]},\"558\":{\"h\":\"4.2 工厂 Bean (FactoryBean)\",\"t\":[\"Spring 有两种类型 bean，一种普通 bean，一种 FactoryBean\",\"普通 bean\",\"xml 里定义的 bean 类型就是你的返回类型\",\"FactoryBean\",\"xml 里定义的 bean 类型可以和返回的类型不一样\",\"使用方法\",\"创建类，让这个类作为工厂 bean 实现接口 FactoryBean\",\"实现接口里方法，在实现的方法中定义返回的 bean 类型\"]},\"559\":{\"h\":\"4.3 Bean 作用域\",\"t\":[\"在 Spring 里，设置创建 bean 实例是单实例还是多实例\",\"在 Spring 里，默认情况下，bean 是单实例对象\",\"试一试默认情况下，是单实例还是多实例，测试下两个实例是否是同一地址\",\"public class TestSpring5 { @Test public void testBean5() { // 1. 加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(\\\"bean5.xml\\\"); // 2. 获取配置创建的变量 Book book1 = context.getBean(\\\"book\\\", Book.class); Book book2 = context.getBean(\\\"book\\\", Book.class); // 3. 测试输出 System.out.println(book1); System.out.println(book2); } } // 结果 com.ymk.learnSpring.collectiontype.Book@55183b20 com.ymk.learnSpring.collectiontype.Book@55183b20 \",\"如何设置 bean 多实例对象\",\"bean 标签里的属性 scope 用于设置单实例还是多实例\",\"scope 属性\",\"不写属性有个默认值，singleton，表示单实例\",\"可选 prototype，表示多实例，每次创建变量时会创建不同的变量\",\"// 结果 com.ymk.learnSpring.collectiontype.Book@55183b20 com.ymk.learnSpring.collectiontype.Book@4f83df68 \",\"**注意：**设置 scope 的值为 singleton 时，加载 Spring 配置时就会自动创建单实例对象。 设置 scope 的值为 prototype 时，不是在加载 Spring 配置文件时去创建对象，而是在获取对象时创建，每次都是一个新的对象\"]},\"560\":{\"h\":\"4.4 Bean 生命周期\",\"t\":[\"bean 的生命周期（bean 创建到销毁的过程）\",\"通过构造器创建 bean 实例（无参数构造）\",\"为 bean 的属性设置值和对其他 bean 的引用（调用 set 方法）\",\"（可选）bean 前置处理器\",\"调用 bean 的初始化方法（需要自己配置初始化方法）\",\"（可选）bean 后置处理器\",\"bean 可以使用了（对象已经获取到了）\",\"当容器关闭时，调用 bean 销毁的方法（需要自己配置销毁的方法）\",\"演示 bean 生命周期\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:util=\\\"http://www.springframework.org/schema/util\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\\\"> <bean id=\\\"orders\\\" class=\\\"com.ymk.learnSpring.bean.Orders\\\" init-method=\\\"init\\\" destroy-method=\\\"destory\\\"> <property name=\\\"oname\\\" value=\\\"phone\\\"></property> </bean> </beans> \",\"public class Orders { private String oname; public Orders() { System.out.println(\\\"---------- 1.执行无参构造----------\\\"); } public String getOname() { return oname; } public void setOname(String oname) { System.out.println(\\\"----------2.执行 set 方法----------\\\"); this.oname = oname; } // 创建一个 bean 初始化方法 public void init() { System.out.println(\\\"----------3.执行 bean 初始化方法----------\\\"); } // 创建一个 bean 销毁方法 public void destory() { System.out.println(\\\"----------5.执行 bean 销毁方法----------\\\"); } @Test public void testBean7() { // 1. 加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(\\\"bean7.xml\\\"); // 2. 获取配置创建的变量 Orders orders = context.getBean(\\\"orders\\\", Orders.class); // 3. 测试输出 System.out.println(orders.getOname()); // 4. 销毁 bean ((ClassPathXmlApplicationContext) context).close(); } } \",\"把 bean 实例传递给 bean 的后置处理器\",\"先配置xml中的后置处理器\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:util=\\\"http://www.springframework.org/schema/util\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\\\"> <bean id=\\\"orders\\\" class=\\\"com.ymk.learnSpring.bean.Orders\\\" init-method=\\\"init\\\" destroy-method=\\\"destory\\\"> <property name=\\\"oname\\\" value=\\\"phone\\\"></property> </bean> <!--配置后置处理器--> <!--为当前配置文件中的所有 bean 都添加后置处理器--> <bean id=\\\"myBeanPost\\\" class=\\\"com.ymk.learnSpring.bean.MyBeanPost\\\"></bean> </beans> \",\"初始化之前会执行\",\"@Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName); } \",\"初始化之后会执行\",\"@Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName); } \",\"运行结果\",\"---------- 1.执行无参构造---------- ----------2.执行 set 方法---------- ----------初始化之前会执行---------- ----------3.执行 bean 初始化方法---------- ----------初始化之后会执行---------- phone ----------5.执行 bean 销毁方法---------- \"]},\"561\":{\"h\":\"4.5 Bean 管理 (xml自动装配)\",\"t\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:util=\\\"http://www.springframework.org/schema/util\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\\\"> <!-- 实现自动装配 byName: 根据属性名注入，注入bean的id值和类属性名称一样 byType: 根据属性类型注入，注入bean的类型与类属性类型相同--> <bean id=\\\"emp\\\" class=\\\"com.ymk.learnSpring.autowire.Employee\\\" autowire=\\\"byName\\\"> <!-- <property name=\\\"dept\\\" ref=\\\"dept\\\"></property>--> </bean> <bean id=\\\"dept\\\" class=\\\"com.ymk.learnSpring.autowire.Department\\\"> </bean> </beans> \"]},\"562\":{\"h\":\"4.6 Bean管理xml 外部属性文件（数据库 配置文件）\",\"t\":[\"直接配置数据库信息\",\"配置德鲁伊连接池\",\"引入德鲁伊连接池依赖\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:util=\\\"http://www.springframework.org/schema/util\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\\\"> <!--配置连接池--> <bean id=\\\"dataSource\\\" class=\\\"com.alibaba.druid.pool.DruidDataSource\\\"> <property name=\\\"driverClassName\\\" value=\\\"com.mysql.jdbc.Driver\\\"></property> <property name=\\\"url\\\" value=\\\"jdbc:mysql://localhost:3306/test1\\\"></property> <property name=\\\"username\\\" value=\\\"root\\\"></property> <property name=\\\"password\\\" value=\\\"Yo*tja>AF96;\\\"></property> </bean> </beans> \",\"引入外部属性文件配置数据库连接池\",\"添加外部配置文件\",\"image-20220914215416375\",\"把外部文件引入spring配置\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:util=\\\"http://www.springframework.org/schema/util\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\\\"> <!-- 引入外部属性文件 --> <context:property-placeholder location=\\\"jdbc.properties\\\"></context:property-placeholder> <!--配置连接池--> <bean id=\\\"dataSource\\\" class=\\\"com.alibaba.druid.pool.DruidDataSource\\\"> <property name=\\\"driverClassName\\\" value=\\\"${prop.driverClass}\\\"></property> <property name=\\\"url\\\" value=\\\"${prop.url}\\\"></property> <property name=\\\"username\\\" value=\\\"${prop.username}\\\"></property> <property name=\\\"password\\\" value=\\\"${prop.password}\\\"></property> </bean> <!-- 引入外部属性文件 --> </beans> \"]},\"563\":{\"h\":\"4.7 基于注解方式操作 Bean\",\"t\":[\"为了简化 xml 配置\",\"注解类型\",\"@Component\",\"@Service\",\"@Controller\",\"@Repository\",\"基于注解方式实现对象的创建\",\"引入 aop 依赖\",\"开启组件扫描（扫描上层目录，或用逗号隔开多个包\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:util=\\\"http://www.springframework.org/schema/util\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\\\"> <!--开启组件扫描--> <context:component-scan base-package=\\\"com.ymk.learnSpring\\\"></context:component-scan> </beans> \",\"在需要注入的类上打上注释\",\"// 等价于 <bean id=\\\"userService\\\" class=\\\"\\\"/> // 默认值是类名首字母小写 @Component(value = \\\"userService\\\") public class UserService { public void add() { System.out.println(\\\"Service add----------------\\\"); } } \",\"组件扫描配置过滤器\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:util=\\\"http://www.springframework.org/schema/util\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\\\"> <!--对扫描加上过滤 根据expression 设置包含Service注解的类--> <context:component-scan base-package=\\\"com.ymk.learnSpring\\\" use-default-filters=\\\"false\\\"> <context:include-filter type=\\\"annotation\\\" expression=\\\"org.springframework.stereotype.Service\\\"/> </context:component-scan> <!--对扫描加上过滤 根据expression 设置不包含Service注解的类--> <context:component-scan base-package=\\\"com.ymk.learnSpring\\\" use-default-filters=\\\"false\\\"> <context:exclude-filter type=\\\"annotation\\\" expression=\\\"org.springframework.stereotype.Service\\\"/> </context:component-scan> </beans> \"]},\"564\":{\"h\":\"4.8 基于注解方式实现属性的注入\",\"t\":[\"注解类型\",\"@AutoWired: 根据属性类型进行自动装配\",\"@Qualifier: 根据属性名称进行注入\",\"@Resource: 根据属性类型注入，也可根据名称\",\"@Value: 注入基本类型属性（int...)\",\"注入方法\",\"@AutoWired\",\"把 service 和 dao 对象创建，在 service 和 dao 类添加对象注解\",\"在 service 中定义 dao 类型属性\",\"@Service(value = \\\"userService\\\") public class UserService { // 不需要set方法, 通过注解给这个属性赋了一个值 @Autowired private UserDao userDao; public void add() { System.out.println(\\\"Service add----------------\\\"); userDao.add(); } public UserDao getUserDao() { return userDao; } } \",\"@Repository(value = \\\"userDaoImpl1\\\") public class UserDaoImpl implements UserDao{ @Override public void add() { System.out.println(\\\"UserDaoImpl1 Add----------\\\"); } } \",\"@Qualifier\",\"可以根据不同的实现类来注入\",\"@Service(value = \\\"userService\\\") public class UserService { // 不需要set方法, 通过注解给这个属性赋了一个值 // 选用 userDaoImpl2 而不是 UserDaoImpl1 @Autowired @Qualifier(value = \\\"userDaoImpl2\\\") private UserDao userDao; public void add() { System.out.println(\\\"Service add----------------\\\"); userDao.add(); } public UserDao getUserDao() { return userDao; } } \",\"@Resource\",\"@Resource // 不加参数 默认按类型注入 注意如果有多个实现类会报错 @Resource(name = \\\"userDaoImpl2\\\") // name参数 按照类名来注入 private UserDao userDao; \",\"@Value\",\"@Value(value = \\\"Annotation value 注解\\\") private String name; \"]},\"565\":{\"h\":\"4.9 完全注解开发\",\"t\":[\"创建配置类，替代 xml 配置文件\",\"@Configuration @ComponentScan(basePackages = \\\"com.ymk.learnSpring\\\") public class SpringConfig { } \",\"测试函数中加载配置类\",\"public class TestSpringDemo { @Test public void testService03() { // 加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); // 获取对应 bean UserService userService = context.getBean(\\\"userService\\\", UserService.class); // 测试功能 System.out.println(userService); System.out.println(userService.getUserDao()); System.out.println(userService.getName()); userService.add(); } } \"]},\"566\":{\"h\":\"5 AOP 面向切面\"},\"567\":{\"h\":\"5.1 AOP 概念\",\"t\":[\"什么是 AOP\",\"面向切面编程，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性\",\"通俗描述：不修改源代码，在程序主干里添加新功能\"]},\"568\":{\"h\":\"5.2 AOP 底层原理\",\"t\":[\"AOP 底层使用代理\",\"动态代理\",\"有接口情况，使用 JDK 动态代理\",\"创建一个接口实现类代理对象\",\"没有接口情况，使用 CGLIB 动态代理\",\"创建当前类子类的代理对象\"]},\"569\":{\"h\":\"5.3 JDK 动态代理\",\"t\":[\"使用 Proxy 里的方法\",\"调用 newProxyInstance 方法\",\"方法有三个参数：\",\"类加载器、增强方法所在的类（这个类实现的接口，支持多个接口）、实现这个接口 InvocationHandler（创建代理对象，写增强的方法）\",\"编写 JDK 动态代理代码\",\"// UserDao 接口 public interface UserDao { public int add(int x, int y); public String update(String id); } \",\"// UserDao 实现类 public interface UserDao { public int add(int x, int y); public String update(String id); } \",\"// 动态代理 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.util.Arrays; public class JDKProxy { public static void main(String[] args) { // 创建接口实现类的代理对象 Class[] interfaces = {UserDao.class}; UserDaoImpl1 userDao = new UserDaoImpl1(); UserDao user = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao)); user.add(10, 20); user.update(\\\"ymk\\\"); } } class UserDaoProxy implements InvocationHandler { private Object obj; public UserDaoProxy(Object obj) { this.obj = obj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 方法之前 System.out.println(\\\"正在执行方法: \\\" + method.getName() + \\\", 传递的参数: \\\" + Arrays.toString(args)); // 方法执行 Object res = method.invoke(obj, args); // 方法之后 System.out.println(\\\"方法执行结果为: \\\" + res); return res; } } \"]},\"570\":{\"h\":\"5.4 AOP 操作术语\",\"t\":[\"**连接点：**类里的哪些方法可以被增强，这些方法称为连接点\",\"**切入点：**被增强的方法称为切入点\",\"**通知（增强）：**实际增强的逻辑部分称为通知（前置通知、后置通知、环绕通知、异常通知、最终通知）\",\"**切面：**把通知应用到切入点的过程\"]},\"571\":{\"h\":\"5.5 AOP 操作准备\",\"t\":[\"Spring 框架一般基于 AspectJ 实现 AOP 操作（AspectJ 是一个独立的 AOP 框架）\",\"基于 AspectJ 实现 AOP 操作\",\"基于 XML 配置文件实现\",\"基于注解方式实现\",\"在项目工程文件中引入 AOP 依赖\",\"image-20220929205623323\",\"切入点表达式\",\"切入点表达式的作用：知道哪个类里的哪个方法需要增强\",\"语法结构：\",\"execution([权限修饰符][返回类型][类全路径][方法名称])([参数列表])\",\"举例：对 com.ymk.learnSpring.UserDao 类里的 add 方法进行增强\",\"execution(*com.ymk.learnSpring.UserDao.add(..))\"]},\"572\":{\"h\":\"5.6 AOP 操作 - AspectJ注解\",\"t\":[\"创建类，在类里定义方法\",\"public class User { public void add() { System.out.println(\\\"Add----------\\\"); } } \",\"创建增强类\",\"在增强类里创建方法\",\"public class UserProxy { public void before() { System.out.println(\\\"前置方法增强----------\\\"); } } \",\"进行通知的配置\",\"在 Spring 配置文件中，开启注解扫描\",\"<context:component-scan base-package=\\\"com.ymk.learnSpring.aopAno\\\"></context:component-scan> \",\"使用注解创建 User 和 UserProxy 对象\",\"@Component \",\"在增强类上面添加注解 @Aspect\",\"在 Spring 配置文件中开启生成代理对象\",\"<aop:aspectj-autoproxy></aop:aspectj-autoproxy> \",\"配置不同类型通知\",\"在增强类里面，在作为通知方法上面配置通知注解（切入点表达式）\",\"@Component @Aspect // 生成代理对象 public class UserProxy { // @Before 注解作为前置通知 @Before(value = \\\"execution(* com.ymk.learnSpring.aopAno.User.add(..))\\\") public void before() { System.out.println(\\\"前置方法增强----------\\\"); } @After(value = \\\"execution(* com.ymk.learnSpring.aopAno.User.add(..))\\\") public void after() { System.out.println(\\\"后置方法增强----------\\\"); } @AfterReturning(value = \\\"execution(* com.ymk.learnSpring.aopAno.User.add(..))\\\") public void afterReturn() { System.out.println(\\\"返回后方法增强----------\\\"); } @Around(value = \\\"execution(* com.ymk.learnSpring.aopAno.User.add(..))\\\") public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{ System.out.println(\\\"环绕前置方法增强----------\\\"); proceedingJoinPoint.proceed(); System.out.println(\\\"环绕后置方法增强----------\\\"); } @AfterThrowing(value = \\\"execution(* com.ymk.learnSpring.aopAno.User.add(..))\\\") public void afterThrow() { System.out.println(\\\"返回异常后方法增强----------\\\"); } } \"]},\"573\":{\"h\":\"6 JdbcTemplate\"},\"574\":{\"h\":\"6.1 JdbcTemplate 概念\",\"t\":[\"Spiring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现数据库的增删改查\"]},\"575\":{\"h\":\"6.2 准备工作\",\"t\":[\"引入 Jar 包\",\"在 Spring 配置文件中配置连接池\",\"<!--配置连接池--> <bean id=\\\"dataSource\\\" class=\\\"com.alibaba.druid.pool.DruidDataSource\\\"> <property name=\\\"driverClassName\\\" value=\\\"com.mysql.jdbc.Driver\\\"></property> <property name=\\\"url\\\" value=\\\"jdbc:mysql://localhost:3306/test1\\\"></property> <property name=\\\"username\\\" value=\\\"root\\\"></property> <property name=\\\"password\\\" value=\\\"Yo*tja>AF96;\\\"></property> </bean> \",\"配置 JDBCTemplate 对象，注入 Datasource\",\"<!--JdbcTemplate对象--> <bean id=\\\"jdbcTemplate\\\" class=\\\"org.springframework.jdbc.core.JdbcTemplate\\\"> <!--注入dataSource--> <property name=\\\"dataSource\\\" ref=\\\"dataSource\\\"></property> </bean> \",\"创建 service 类，创建 Dao 类，在 Dao 注入 jdbcTemplate 对象\",\"@Service public class BookService { // 注入 Dao @Autowired private BookDao bookDao; } \",\"@Repository public class BookDaoImpl implements BookDao{ // 注入 JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; } \"]},\"576\":{\"h\":\"6.3 添加数据库功能\",\"t\":[\"对应数据库表，创建一个实体类 User\",\"public class User { private String userId; private String username; private String userStatus; public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getUserStatus() { return userStatus; } public void setUserStatus(String userStatus) { this.userStatus = userStatus; } } \",\"编写 Service 和 Dao\",\"@Service public class BookService { // 注入 Dao @Autowired private BookDao bookDao; // 添加方法 public void addUser(User user) { bookDao.add(user); } } \",\"public interface BookDao { public void add(User user); } @Repository public class BookDaoImpl implements BookDao{ // 注入 JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; @Override public void add(User user) { System.out.println(\\\"----------BookDaoImpl Add方法----------\\\"); System.out.println(\\\"添加\\\" + user.getUsername()); int update = jdbcTemplate.update(\\\"insert into book values(?,?,?)\\\", user.getUserId(), user.getUsername(), user.getUserStatus()); System.out.println(\\\"更新了 \\\" + update + \\\" 行\\\"); } } \",\"测试\",\"public class TestBook { @Test public void testJdbc() { ApplicationContext context = new ClassPathXmlApplicationContext(\\\"bean1.xml\\\"); BookService bookService = context.getBean(\\\"bookService\\\", BookService.class); User user = new User(); user.setUserId(\\\"1\\\"); user.setUsername(\\\"ymk\\\"); user.setUserStatus(\\\"working\\\"); bookService.addUser(user); } } \"]},\"577\":{\"h\":\"6.4 添加数据库修改、删除\",\"t\":[\"public interface BookDao { public void add(User user); public void update(User user); public void delete(String id); } \",\"@Repository public class BookDaoImpl implements BookDao{ // 注入 JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; @Override public void add(User user) { System.out.println(\\\"----------BookDaoImpl Add方法----------\\\"); System.out.println(\\\"添加\\\" + user.getUsername()); int update = jdbcTemplate.update(\\\"insert into book values(?,?,?)\\\", user.getUserId(), user.getUsername(), user.getUserStatus()); System.out.println(\\\"更新了 \\\" + update + \\\" 行\\\"); } @Override public void update(User user) { System.out.println(\\\"----------BookDaoImpl update方法----------\\\"); System.out.println(\\\"修改\\\" + user.getUserId()); String sql = \\\"update book set username=?,userstatus=? where userid=?\\\"; int update = jdbcTemplate.update(sql, user.getUsername(), user.getUserStatus(), user.getUserId()); System.out.println(\\\"修改了 \\\" + update + \\\" 行\\\"); } @Override public void delete(String id) { System.out.println(\\\"----------BookDaoImpl delete方法----------\\\"); System.out.println(\\\"删除\\\" + id); String sql = \\\"delete from book where userid=?\\\"; int update = jdbcTemplate.update(sql, id); System.out.println(\\\"删除了 \\\" + update + \\\" 行\\\"); } } \"]},\"578\":{\"h\":\"6.5 Jdbc 数据库批量操作\",\"t\":[\"JdbcTemplate 实现批量操作\",\"batchUpdate(String sql, List<Object[]> bachArgs)\"]},\"579\":{\"h\":\"7 事务\"},\"580\":{\"h\":\"7.1 事务概念\",\"t\":[\"事务是数据库操作的基本单元，逻辑上的一组操作，要么这些操作都成功，要么都失败\",\"**例子：**银行转账，转账分成两步，一个人少100，一个人多100，若多100这个操作失败，则少100的操作也会失败\",\"事务的四个特性 ACID\",\"原子性\",\"一致性\",\"隔离性：多事务操作不会互相影响\",\"持久性\"]},\"581\":{\"h\":\"7.2 事务操作（搭建事务操作环境）\",\"t\":[\"建表\",\"创建 service，搭建 dao，完成对象创建和注入关系\"]},\"582\":{\"h\":\"7.3 事务的参数\",\"t\":[\"propagation 事务传播行为\",\"多事务方法直接调用，这个过程中事务时如何进行管理的\",\"isolation 事务隔离级别\",\"多事务操作之间不会产生影响，不考虑隔离性产生很多问题\",\"有三个读问题：脏读、不可重复读、虚读 \",\"脏读：一个未提交事务读取到另一个未提交事务的数据\",\"不可重复读：一个未提交事务读取到另一提交事务修改数据\",\"虚读：一个未提交事务读取到另一个提交事务添加数据\",\"image-20221016160326239\"]},\"583\":{\"h\":\"7.4 例子：转账事务（xml 方式）\",\"t\":[\"配置 xml 文件\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xmlns:aop=\\\"http://www.springframework.org/schema/aop\\\" xmlns:tx=\\\"http://www.springframework.org/schema/tx\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\\\"> <!--组件扫描--> <context:component-scan base-package=\\\"com.ymk.learnSpring\\\"></context:component-scan> <!--配置连接池--> <bean id=\\\"dataSource\\\" class=\\\"com.alibaba.druid.pool.DruidDataSource\\\"> <property name=\\\"driverClassName\\\" value=\\\"com.mysql.jdbc.Driver\\\"></property> <property name=\\\"url\\\" value=\\\"jdbc:mysql://localhost:3306/test1\\\"></property> <property name=\\\"username\\\" value=\\\"root\\\"></property> <property name=\\\"password\\\" value=\\\"Yo*tja>AF96;\\\"></property> </bean> <!--JdbcTemplate对象--> <bean id=\\\"jdbcTemplate\\\" class=\\\"org.springframework.jdbc.core.JdbcTemplate\\\"> <!--注入dataSource--> <property name=\\\"dataSource\\\" ref=\\\"dataSource\\\"></property> </bean> <!--1 创建事务管理器--> <bean id=\\\"transactionManager\\\" class=\\\"org.springframework.jdbc.datasource.DataSourceTransactionManager\\\"> <!--注入数据源--> <property name=\\\"dataSource\\\" ref=\\\"dataSource\\\"></property> </bean> <!--2 配置通知--> <tx:advice id=\\\"txadvice\\\"> <!--配置事务参数--> <tx:attributes> <!--指定哪种规则的方法上添加事务--> <tx:method name=\\\"transfer\\\" propagation=\\\"REQUIRED\\\"/> </tx:attributes> </tx:advice> <!--3 配置切入点和切面--> <aop:config> <!--配置切入点--> <aop:pointcut id=\\\"pt\\\" expression=\\\"execution(* com.ymk.learnSpring.service.BankService.*(..))\\\"/> <!--配置切面--> <aop:advisor advice-ref=\\\"txadvice\\\" pointcut-ref=\\\"pt\\\"></aop:advisor> </aop:config> </beans> \",\"创建 service 和 dao 并在 service 中注入 dao\",\"@Service(value = \\\"bankService\\\") public class BankService { // 注入 Dao @Autowired BankDao bankDao; // 修改 public void updateBankUser(BankUser user) { bankDao.update(user); } // 转账 public void transfer(String formUser, String toUser, double amount) { bankDao.subRemain(formUser, amount); // 模拟异常 int i = 10/0; bankDao.addRemain(toUser, amount); } } \",\"public interface BankDao { public void update(BankUser user); public void batchUpdate(List<Object[]> Args); public void addRemain(String user, double amount); public void subRemain(String user, double amount); } \",\"@Repository public class BankDaoImpl implements BankDao{ // 注入 Jdbc @Autowired private JdbcTemplate jdbcTemplate; @Override public void update(BankUser user) { System.out.println(\\\"----------BankDaoImpl update方法----------\\\"); System.out.println(\\\"修改\\\" + user.getId()); String sql = \\\"update bank set username=?,userbalance=? where userid=?\\\"; int update = jdbcTemplate.update(sql, user.getName(), user.getBalance(), user.getId()); System.out.println(\\\"修改了 \\\" + update + \\\" 行\\\"); } @Override public void batchUpdate(List<Object[]> Args) { } @Override public void addRemain(String user, double amount) { System.out.println(\\\"----------BankDaoImpl addRemain方法----------\\\"); System.out.println(\\\"增加\\\" + user + \\\": \\\" + amount + \\\"块钱\\\"); String sql = \\\"update bank set userbalance=userbalance+? where username=?\\\"; int update = jdbcTemplate.update(sql, amount, user); System.out.println(\\\"修改了 \\\" + update + \\\" 行\\\"); } @Override public void subRemain(String user, double amount) { System.out.println(\\\"----------BankDaoImpl subRemain方法----------\\\"); System.out.println(\\\"减少\\\" + user + \\\": \\\" + amount + \\\"块钱\\\"); String sql = \\\"update bank set userbalance=userbalance-? where username=?\\\"; int update = jdbcTemplate.update(sql, amount, user); System.out.println(\\\"修改了 \\\" + update + \\\" 行\\\"); } } \",\"测试\",\"public class TestBook { /** * 测试转账功能(异常) * */ @Test public void testTransfer() { ApplicationContext context = new ClassPathXmlApplicationContext(\\\"bean1.xml\\\"); BankService service = context.getBean(\\\"bankService\\\", BankService.class); service.transfer(\\\"ymk\\\", \\\"ztt\\\", 100); } } \"]},\"584\":{\"h\":\"7.5 事务开发（完全注解方式）\",\"t\":[\"写配置类替代 xml 文件\",\"/** * 代替 xml 文件 * */ @Configuration // 配置类 @ComponentScan(basePackages = \\\"com.ymk.learnSpring\\\") // 开启组件扫描 @EnableTransactionManagement // 开启事务功能 public class TxConfig { // 创建数据库连接池 @Bean public DruidDataSource getDruidDataSource() { DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(\\\"com.mysql.jdbc.Driver\\\"); dataSource.setUrl(\\\"jdbc:mysql://localhost:3306/test1\\\"); dataSource.setUsername(\\\"root\\\"); dataSource.setPassword(\\\"Yo*tja>AF96;\\\"); return dataSource; } // 创建Jdbc对象 @Bean public JdbcTemplate getJdbcTemplate(DataSource dataSource) { JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; } @Bean // 创建事务管理器 public DataSourceTransactionManager getDataSourceTransactionManager (DataSource dataSource) { DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } } \",\"测试\",\"public class TestBook { /** * 测试完全注解方式 * */ @Test public void testTransfer2() { ApplicationContext context = new AnnotationConfigApplicationContext(TxConfig.class); BankService service = context.getBean(\\\"bankService\\\", BankService.class); service.transfer(\\\"ymk\\\", \\\"ztt\\\", 100); } } \"]},\"585\":{\"h\":\"8 Spring5 新功能\"},\"586\":{\"h\":\"8.1 通用日志封装\",\"t\":[\"Spring5 已经移除了 Log4jConfigListener，官方建议使用 Log4j2\",\"Spring5 整合了 Log4j2\",\"配置简单的 log4j2\",\"引入 jar 包\",\"image-20221018105613706\",\"配置 log4j2.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <Configuration status=\\\"INFO\\\"> <Appenders> <Console name=\\\"Console\\\" target=\\\"SYSTEM_OUT\\\"> <PatternLayout pattern=\\\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\\\"/> </Console> </Appenders> <Loggers> <Root level=\\\"info\\\"> <AppenderRef ref=\\\"Console\\\"/> </Root> </Loggers> </Configuration> \",\"自定义输出日志\",\"import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class UserLog { private static final Logger log = LoggerFactory.getLogger(UserLog.class); public static void main(String[] args) { log.info(\\\"hello log4j2 info\\\"); log.warn(\\\"hello log4j2 warn\\\"); } } \"]},\"587\":{\"h\":\"8.2 SpringWebFlux\"},\"588\":{\"h\":\"8.2.1 基本概念\",\"t\":[\"需要掌握\",\"SpringMVC\",\"SpringBoot\",\"Maven\",\"Java8新特性\",\"SpringWebFlux 介绍 \",\"是 Spring5 添加的新模块，用于 Web 开发，功能与 SpringMVC 类似，使用响应式编程\",\"SpringMVC，基于 Servlet 容器，WebFlux 是一种异步非阻塞框架，核心是基于 Reactor 的相关 API 实现的\",\"与 SpringMVC 关系 \",\"两个框架都可以使用注解方式，都运行在 Tomcat 等容器中\",\"SpringMVC 采用命令式编程，WebFlux 采用异步响应式编程\"]},\"589\":{\"h\":\"微服务SpringCloud\"},\"590\":{\"h\":\"0 微服务架构理论\"},\"591\":{\"h\":\"介绍\",\"t\":[\"微服务架构提倡将单一的应用程序划分成一组小的服务，服务之间互相协调，为用户提供最终价值。每个服务运行在独立的进程中，服务与服务间采用轻量级的通信机制互相协作。\"]},\"592\":{\"h\":\"微服务的组成\",\"t\":[\"服务注册与开发 eureka springboot\",\"服务调用 feign\",\"服务熔断 hystrix\",\"负载均衡 ribbon\",\"服务降级 hystrix\",\"服务消息队列 RabbitMQ、Kafka\",\"配置管理中心 spring cloud config\",\"服务网关 zuul\",\"服务监控\",\"全链路追踪\",\"自动化构建部署\",\"服务定时任务、调度操作\"]},\"593\":{\"h\":\"SpringCloud 简介\",\"t\":[\"分布式微服务架构的一站式解决方案 \",\"路由网关 Spring Cloud Zuul\",\"Zuul 是作为微服务系统的网关组件，致力于动态路由、过滤、监控、弹性伸缩和安全。\",\"服务注册和发现 Eureka\",\"Eureka 是作为微服务系统的服务注册与发现组件，提供服务注册和发现功能。\",\"网络请求 RestTemplate\",\"RestTemplate 是一个访问 RESTful API 接口的网络请求框架。\",\"负载均衡 Ribbon\",\"Ribbon 是一个负载均衡组件，Ribbon作为服务消费者的负载均衡器，一种是和 RestTemplae结合，一种是和 Feign 相结合，Feign 默认集成了 Ribbon 。\",\"声明式调用 Feign\",\"简单方便的调用 Spring Cloud 服务的工具，让 Java Http 客户端调用过程变的简单。\",\"配置中心 Config\",\"将配置文件进行统一管理，可以从 Config Server 服务或 Git 仓库读取。\",\"熔断器 Hystrix\",\"Hystrix 提供了熔断器的功能，能够阻止分布式系统中出现联动故障。\",\"服务链路追踪 Sleuth\",\"Sleuth 是 Spring Cloud 中的一个组件，主要功能是在分布式系统中提供服务链路追踪的解决方案。\",\"服务监控 Spring Boot Admin\",\"Spring Boot Admin 用于管理和监控一个或多个 Spring Boot 程序，使用 Spring Boot Admin 监控 Spring Cloud 微服务。\",\"消息总线 Bus\",\"Spring Cloud Bus 将 Spring 的事件处理机制和消息中间件消息的发送和接收整合起来，可以轻松的将分布式应用中连接有消息中间件的多个服务节点连接起来，实现消息互通。\",\"系统保护\",\"为保证服务的安全，微服务系统需要增加安全验证，常用的方式是增加 Spring Security 或Spring OAuth2 框架来保护微服务系统。\"]},\"594\":{\"h\":\"1 微服务治理\"},\"595\":{\"h\":\"1.1 认识微服务\",\"t\":[\"微服务架构的演变\",\"单体架构：耦合度高，不适合多人开发。\",\"分布式架构：对业务功能对系统进行拆分，每个业务模块独立开发，称为服务，降低耦合度。服务拆分会导致部署困难。\",\"分布式需要考虑的问题:1.服务拆分颗粒度如何 2.服务集群地址如何维护 3.服务之间如何远程调用 4.服务健康如何感知\",\"微服务\",\"单一职责：拆分粒度更小，每个服务对应唯一业务能力，避免重复业务开发\",\"面向服务：微服务对外暴露业务接口\",\"自治：团队独立，技术独立，数据独立，部署独立\",\"隔离性强：服务做好隔离，容错，降级，避免出现级联问题\",\"微服务结构\",\"微服务架构图\",\"微服务技术对比\",\"Dubbo\",\"SpringCloud\",\"SpringCloudAlibaba\",\"注册中心\",\"zookeeper、redis\",\"Eureka、Consul\",\"Nacos、Eureka\",\"服务远程调用\",\"Dubbo协议\",\"Feign（Http协议）\",\"Dubbo、Feign\",\"配置中心\",\"无\",\"SpringCloudConfig\",\"SpringCloudConfig、Nacos\",\"服务网关\",\"无\",\"SpringCloudGateway、Zuul\",\"SpringCloudGateway、Zuul\",\"服务监控和保护\",\"dubbo-admin功能弱\",\"Hystrix\",\"Sentinel\",\"SpringCloudAlibaba兼容前两种架构\",\"SpringCloud\",\"SpringCloud集成了各种微服务组件，基于SpingBoot实现自动装配\",\"与SpringBoot有对应版本\"]},\"596\":{\"h\":\"1.2 分布式服务架构案例\",\"t\":[\"服务拆分和远程调用\",\"不同微服务，不要开发重复业务\",\"微服务数据独立，不要访问其他微服务数据库\",\"可以把自己得业务暴露为接口，供其他微服务调用\",\"案例 调用其他服务的接口\",\"要求 查询订单并且查询其中用户对应的信息\",\"在order-service的OrderApplication中注册RestTemplate\",\"服务远程调用RestTemplate实现调用其他服务的接口（发送HTTP请求）\",\"提供者与消费者\",\"服务提供者：一次业务中，被其他微服务调用的\",\"消费者：调用其他服务的\"]},\"597\":{\"h\":\"1.3 eureka 注册中心\",\"t\":[\"远程调用的问题\",\"服务消费者该如何获取服务提供者的地址信息\",\"如果有多个服务提供者，消费者该如何选择\",\"消费者如何得知服务提供者的健康状态\",\"Eureka的作用\",\"在这里插入图片描述\",\"Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。Eureka说白了就是一个注册服务中心。\",\"同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。\",\"这就实现了服务的自动注册、发现、状态监控。\",\"服务注册到Eureka\",\"服务注册\",\"引入Eureka-client依赖\",\"<!--eureka客户端依赖--> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId> </dependency> \",\"在application中配置eureka地址\",\"eureka: client: service-url: # eureka的地址信息 defaultZone: http://127.0.0.1:10086/eureka \",\"无论是消费者还是提供者，引入Eureka-client依赖都可以完成注册\",\"在order-service完成拉取服务\",\"修改OrderService的代码，修改访问的url路径（IP改为服务名称）\",\"public Order queryOrderById(Long orderId) { // 1.查询订单 Order order = orderMapper.findById(orderId); // 2.利用RestTemplate发起http请求，查询用户 // 2.1.url路径 String url = \\\"http://userservice/user/\\\" + order.getUserId(); // 2.2.发送http请求，实现远程调用 User user = restTemplate.getForObject(url, User.class); // 3.封装user到Order order.setUser(user); // 4.返回 return order; \",\"在order-service项目启动类OrderApplication中的RestTemplate添加负载均衡注解\",\"@Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); } \"]},\"598\":{\"h\":\"1.4 Ribbon 负载均衡原理\",\"t\":[\"负载均衡原理\",\"String url = \\\"http://userservice/user/\\\" + order.getUserId(); \",\"这条url被Ribbon实现的请求拦截器拦截，获取服务名称，请求拦截器中根据服务名称从Eureka中拉取服务列表，再通过负载均衡算法获得服务\",\"// 负载均衡流程 public ClientHttpResponse intercept(final HttpRequest request, final byte[] body, final ClientHttpRequestExecution execution) throws IOException { final URI originalUri = request.getURI(); String serviceName = originalUri.getHost(); Assert.state(serviceName != null, \\\"Request URI does not contain a valid hostname: \\\" + originalUri); return this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution)); } \",\"负载均衡策略\",\"Ribbon的负载均衡策略是一个叫做IRule的接口来定义的，每一种子接口都是一种规则\",\"[(img-LneKI92V-1623824544221)(https://s3-us-west-2.amazonaws.com/secure.notion-static.com/092b6cbe-bdee-4762-8286-86c37ced48c5/Untitled.png)]\",\"调用负载均衡策略\",\"代码方式\",\"在order-service中OrderApplication类中，定义一个新的IRule\",\"@Bean public IRule randomRule() { return new RandomRule(); } \",\"配置文件方式\",\"在application.yml中，添加新的配置\",\"userservice: ribbon: NFLoadBalanceRuleClassName: com.netflix.loadbalancer.RandomRule \",\"有哪些负载均衡策略\",\"1.轮询策略：RoundRobinRule，按照一定的顺序依次调用服务实例。比如一共有 3 个服务，第一次调用服务 1，第二次调用服务 2，第三次调用服务3，依次类推。 此策略的配置设置如下：\",\"springcloud-nacos-provider: # nacos中的服务id ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #设置负载均衡 复制代码 \",\"2.权重策略\",\"权重策略：WeightedResponseTimeRule，根据每个服务提供者的响应时间分配一个权重，响应时间越长，权重越小，被选中的可能性也就越低。 它的实现原理是，刚开始使用轮询策略并开启一个计时器，每一段时间收集一次所有服务提供者的平均响应时间，然后再给每个服务提供者附上一个权重，权重越高被选中的概率也越大。 此策略的配置设置如下：\",\"springcloud-nacos-provider: # nacos中的服务id ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule 复制代码 \",\"3.随机策略\",\"随机策略：RandomRule，从服务提供者的列表中随机选择一个服务实例。 此策略的配置设置如下：\",\"springcloud-nacos-provider: # nacos中的服务id ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #设置负载均衡 复制代码 \",\"4.最小连接数策略\",\"最小连接数策略：BestAvailableRule，也叫最小并发数策略，它是遍历服务提供者列表，选取连接数最小的⼀个服务实例。如果有相同的最小连接数，那么会调用轮询策略进行选取。 此策略的配置设置如下：\",\"springcloud-nacos-provider: # nacos中的服务id ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.BestAvailableRule #设置负载均衡 复制代码 \",\"5.重试策略\",\"重试策略：RetryRule，按照轮询策略来获取服务，如果获取的服务实例为 null 或已经失效，则在指定的时间之内不断地进行重试来获取服务，如果超过指定时间依然没获取到服务实例则返回 null。 此策略的配置设置如下：\",\"ribbon: ConnectTimeout: 2000 # 请求连接的超时时间 ReadTimeout: 5000 # 请求处理的超时时间 springcloud-nacos-provider: # nacos 中的服务 id ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #设置负载均衡 复制代码 \",\"6.可用性敏感策略\",\"可用敏感性策略：AvailabilityFilteringRule，先过滤掉非健康的服务实例，然后再选择连接数较小的服务实例。 此策略的配置设置如下：\",\"springcloud-nacos-provider: # nacos中的服务id ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.AvailabilityFilteringRule 复制代码 \",\"7.区域敏感策略\",\"区域敏感策略：ZoneAvoidanceRule，根据服务所在区域（zone）的性能和服务的可用性来选择服务实例，在没有区域的环境下，该策略和轮询策略类似。 此策略的配置设置如下：\",\"springcloud-nacos-provider: # nacos中的服务id ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.ZoneAvoidanceRule \",\"懒加载\",\"Ribbon默认采用懒加载，第一次访问才会创建LoadBalancer，所以第一次加载会耗费较长时间。\",\"如何修改加载策略\",\"ribbon: eager-load: enabled: true # 开启饥饿加载 clients: userservice # 指定对userservice这个服务饥饿加载 \"]},\"599\":{\"h\":\"1.5 nacos 注册中心\",\"t\":[\"认使安装Nacos\",\"比Eureka功能更加丰富\",\"下载Nacos发行版本，配置好端口号并运行 GitHub的Release下载页：https://github.com/alibaba/nacos/releases\",\"startup.cmd -m standalone # 单体非集群 \",\"项目中配置Nacos依赖\",\"父工程：\",\"<dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-alibaba-dependencies</artifactId> <version>2.2.5.RELEASE</version> <type>pom</type> <scope>import</scope> </dependency> \",\"客户端：\",\"<!-- nacos客户端依赖包 --> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId> </dependency> \",\"Nacos服务分级存储模型\",\"把同在一个机房的多个实例称为一个集群\",\" 服务 / \\\\ 集群1 集群2 ... / \\\\ / \\\\ 实例1.1 实例1.2 实例2.1 实例2.2 \",\"服务跨集群调用问题\",\"cloud: nacos: server-addr: localhost:8848 # nacos地址 discovery: cluster-name: SH # 集群名称 config: file-extension: yaml # 文件后缀名 \",\"添加discovery属性，设置集群名称\",\"yml文件中添加规则\",\"userservice: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 优先本地集群负载均衡规则 \",\"集群负载均衡\",\"不同服务设备性能有差异，性能好的机器权重设置大一点\",\"Nacos控制台可以设置权重，0~1之间，权重设置为0不会被访问\",\"Nacos环境隔离-namespace\",\"Nacos中服务存储和数据存储的最外层是一个名为namespace的东西，用来做外层隔离\",\"img\",\"配置namespace\",\"在Nacos控制台中添加命名空间，会自动生成命名空间id\",\"在项目配置中添加命名空间id\",\"cloud: nacos: server-addr: localhost:8848 # nacos服务地址 discovery: cluster-name: HZ # 集群名称 namespace: 6185f2c8-23df-409b-a58b-76000989482f # dev环境 \",\"不同命名空间内的服务，无法访问\",\"No instances available for userservice \"]},\"600\":{\"h\":\"1.6 Eureka和Nacos比较\",\"t\":[\"Nacos和Eureka的共同点\",\"都支持服务注册和服务拉取\",\"都支持服务提供者心跳方式做健康监测\",\"Nacos和Eureka的区别\",\"Nacos支持服务端主动监测提供者的状态；临时实例会通过心跳监测告诉注册中心，自己还活着；非临时实例，Nacos会主动询问是否健康\",\"临时实例心跳不正常回被剔除，非临时实例不会\",\"Nacos支持服务列表变更的消息推送模式，服务列表更新更及时\",\"Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式，Eureka采用AP方式\"]},\"601\":{\"h\":\"2 Nacos配置管理\"},\"602\":{\"h\":\"2.1 统一配置管理\",\"t\":[\"配置更改热更新\",\"方法：提供一个管理配置的配置管理服务，当配置更新时，配置管理服务会通知对应的服务\",\"Nacos提供的方法：在nacos终端新增配置，按照服务名来对应配置名\",\"获取配置的步骤\",\"项目启动\",\"读取Nacos中的配置文件\",\"读取本地配置文件application.yml\",\"创建Spring容器\",\"加载bean\",\"以上步骤就会产生一个问题，那就是我们的Nacos服务地址是写在application.yml中的，但是读取Nacos中的配置文件是在读取application.yml之前，所以我们需要在读取Nacos之前配置好Nacos地址\",\"项目启动\",\"读取bootstrap.yml中的Nacos地址\",\"读取Nacos中的配置文件\",\"读取本地配置文件application.yml\",\"创建Spring容器\",\"加载bean\",\"Nacos配置管理客户端的配置\",\"pom.xml中添加依赖\",\"<!--nacos的配置管理依赖--> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId> </dependency> \",\"添加bootstrap文件\",\"spring: application: name: userservice profiles: active: dev # 环境 cloud: nacos: server-addr: localhost:8848 # nacos地址 discovery: cluster-name: SH # 集群名称 config: file-extension: yaml # 文件后缀名 \"]},\"603\":{\"h\":\"2.2 配置热更新\",\"t\":[\"第一种方法：添加服务的刷新注解\",\"@RefreshScope public class UserController \",\"第二种方法：手动获取属性\",\"// 配置类 自动装配对应值 @Data @Component @ConfigurationProperties(prefix = \\\"pattern\\\") public class PatternProperties { private String dateformat; private String envSharedValue; private String name; } \",\"// Controller类 public class UserController { @Autowired private UserService userService; // 注入配置类 @Autowired private PatternProperties properties; @GetMapping(\\\"now\\\") public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(properties.getDateformat())); } } \"]},\"604\":{\"h\":\"2.4 配置共享\",\"t\":[\"多环境配置共享\",\"微服务在启动时会在Nacos读取多个配置文件：\",\"(spring.application.name)-(spring.profiles.active).yaml 例如 userservice-dev.yaml\",\"(spring.application.name).yaml,例如: userservice.yaml\",\"(spring.application.name).yaml可以做到多环境共享\",\"当本地和远端共享配置同时配置了一个属性时，以多环境共享文件为准\",\"当本地和远端单环境配置和多环境配置同时配置了一个属性时，以远端单环境配置为准\"]},\"605\":{\"h\":\"2.5 搭建Nacos集群\",\"t\":[\"包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx\",\"搭建集群的基本步骤：\",\"搭建数据库，初始化数据库表结构\",\"CREATE TABLE `config_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(255) DEFAULT NULL, `content` longtext NOT NULL COMMENT 'content', `md5` varchar(32) DEFAULT NULL COMMENT 'md5', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', `src_user` text COMMENT 'source user', `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip', `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', `c_desc` varchar(256) DEFAULT NULL, `c_use` varchar(64) DEFAULT NULL, `effect` varchar(64) DEFAULT NULL, `type` varchar(64) DEFAULT NULL, `c_schema` text, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info'; /******************************************/ /* 数据库全名 = nacos_config */ /* 表名称 = config_info_aggr */ /******************************************/ CREATE TABLE `config_info_aggr` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(255) NOT NULL COMMENT 'group_id', `datum_id` varchar(255) NOT NULL COMMENT 'datum_id', `content` longtext NOT NULL COMMENT '内容', `gmt_modified` datetime NOT NULL COMMENT '修改时间', `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='增加租户字段'; /******************************************/ /* 数据库全名 = nacos_config */ /* 表名称 = config_info_beta */ /******************************************/ CREATE TABLE `config_info_beta` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(128) NOT NULL COMMENT 'group_id', `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name', `content` longtext NOT NULL COMMENT 'content', `beta_ips` varchar(1024) DEFAULT NULL COMMENT 'betaIps', `md5` varchar(32) DEFAULT NULL COMMENT 'md5', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', `src_user` text COMMENT 'source user', `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip', `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_beta'; /******************************************/ /* 数据库全名 = nacos_config */ /* 表名称 = config_info_tag */ /******************************************/ CREATE TABLE `config_info_tag` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(128) NOT NULL COMMENT 'group_id', `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id', `tag_id` varchar(128) NOT NULL COMMENT 'tag_id', `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name', `content` longtext NOT NULL COMMENT 'content', `md5` varchar(32) DEFAULT NULL COMMENT 'md5', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', `src_user` text COMMENT 'source user', `src_ip` varchar(50) DEFAULT NULL COMMENT 'source ip', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_tag'; /******************************************/ /* 数据库全名 = nacos_config */ /* 表名称 = config_tags_relation */ /******************************************/ CREATE TABLE `config_tags_relation` ( `id` bigint(20) NOT NULL COMMENT 'id', `tag_name` varchar(128) NOT NULL COMMENT 'tag_name', `tag_type` varchar(64) DEFAULT NULL COMMENT 'tag_type', `data_id` varchar(255) NOT NULL COMMENT 'data_id', `group_id` varchar(128) NOT NULL COMMENT 'group_id', `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id', `nid` bigint(20) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`nid`), UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`), KEY `idx_tenant_id` (`tenant_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_tag_relation'; /******************************************/ /* 数据库全名 = nacos_config */ /* 表名称 = group_capacity */ /******************************************/ CREATE TABLE `group_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID', `group_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Group ID，空字符表示整个集群', `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值', `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量', `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值', `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数，，0表示使用默认值', `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值', `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `uk_group_id` (`group_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='集群、各Group容量信息表'; /******************************************/ /* 数据库全名 = nacos_config */ /* 表名称 = his_config_info */ /******************************************/ CREATE TABLE `his_config_info` ( `id` bigint(64) unsigned NOT NULL, `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `data_id` varchar(255) NOT NULL, `group_id` varchar(128) NOT NULL, `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name', `content` longtext NOT NULL, `md5` varchar(32) DEFAULT NULL, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `src_user` text, `src_ip` varchar(50) DEFAULT NULL, `op_type` char(10) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`nid`), KEY `idx_gmt_create` (`gmt_create`), KEY `idx_gmt_modified` (`gmt_modified`), KEY `idx_did` (`data_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='多租户改造'; /******************************************/ /* 数据库全名 = nacos_config */ /* 表名称 = tenant_capacity */ /******************************************/ CREATE TABLE `tenant_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID', `tenant_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Tenant ID', `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值', `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量', `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值', `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数', `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值', `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量', `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_id` (`tenant_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='租户容量信息表'; CREATE TABLE `tenant_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `kp` varchar(128) NOT NULL COMMENT 'kp', `tenant_id` varchar(128) default '' COMMENT 'tenant_id', `tenant_name` varchar(128) default '' COMMENT 'tenant_name', `tenant_desc` varchar(256) DEFAULT NULL COMMENT 'tenant_desc', `create_source` varchar(32) DEFAULT NULL COMMENT 'create_source', `gmt_create` bigint(20) NOT NULL COMMENT '创建时间', `gmt_modified` bigint(20) NOT NULL COMMENT '修改时间', PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`), KEY `idx_tenant_id` (`tenant_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='tenant_info'; CREATE TABLE `users` ( `username` varchar(50) NOT NULL PRIMARY KEY, `password` varchar(500) NOT NULL, `enabled` boolean NOT NULL ); CREATE TABLE `roles` ( `username` varchar(50) NOT NULL, `role` varchar(50) NOT NULL, UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE ); CREATE TABLE `permissions` ( `role` varchar(50) NOT NULL, `resource` varchar(255) NOT NULL, `action` varchar(8) NOT NULL, UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE ); INSERT INTO users (username, password, enabled) VALUES ('nacos', '$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu', TRUE); INSERT INTO roles (username, role) VALUES ('nacos', 'ROLE_ADMIN'); \",\"下载nacos安装包\",\"配置nacos\",\"进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：然后添加内容：\",\"127.0.0.1:8845 127.0.0.1.8846 127.0.0.1.8847 \",\"然后修改application.properties文件，添加数据库配置\",\"spring.datasource.platform=mysql db.num=1 db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC db.user.0={用户名} db.password.0={密码} \",\"启动nacos集群\",\"将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3\",\"然后分别修改三个文件夹中的application.properties，\",\"nacos1:\",\"server.port=8845 \",\"nacos2:\",\"server.port=8846 \",\"nacos3:\",\"server.port=8847 \",\"然后分别启动三个nacos节点：\",\"startup.cmd \",\"nginx反向代理\",\"解压nginx安装包\",\"修改conf/nginx.conf文件，配置如下：\",\"upstream nacos-cluster { server 127.0.0.1:8845; server 127.0.0.1:8846; server 127.0.0.1:8847; } server { listen 80; server_name localhost; location /nacos { proxy_pass http://nacos-cluster; } } \",\"而后在浏览器访问：http://localhost/nacos即可。\",\"代码中application.yml文件配置如下：\",\"spring: cloud: nacos: server-addr: localhost:80 # Nacos地址 \"]},\"606\":{\"h\":\"2.6 Http客户端Feign\",\"t\":[\"Feign 的核心原理是基于接口注解和动态代理实现远程调用，可以将应用程序需要的远程 HTTP API 伪装成本地的接口进行调用，降低了使用者开发和维护服务的成本。\",\"简单来说就是Http请求动态代理\",\"使用Feign客户端\",\"引入依赖\",\"<!--feign客户端依赖--> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-openfeign</artifactId> </dependency> \",\"orderservice启动类添加注解开启Feign功能\",\"@EnableFeignClients \",\"定义远程接口：创建一个接口，并通过@FeignClient注解来指定远程服务地址和协议。\",\"@FeignClient(\\\"userservice\\\") public interface UserClient { @GetMapping(\\\"/user/{id}\\\") User findById(@PathVariable(\\\"id\\\") Long id); } \",\"原来远程调用userservice的请求为\",\"// 2.1.url路径 String url = \\\"http://userservice/user/\\\" + order.getUserId(); // 2.2.发送http请求，实现远程调用 User user = restTemplate.getForObject(url, User.class); \",\"创建接口代理：根据定义的接口信息，通过动态代理创建一个代理实例。\",\"发送请求：当代理实例方法被调用时，根据注解中的地址、请求方式等信息，发送 HTTP 请求到远程服务并获取响应结果。\",\"解析响应：将返回的 HTTP 响应转换成需要的响应对象，并返回给调用方。\",\"Feign自定义配置\",\"java代码配置\",\"先声明一个Bean\",\"public class FeignClientConfig { @Bean public Logger.Level feignLogLevel() { return Logger.Level.BASIC; } } \",\"如果是局部配置\",\"@FeignClient(value = \\\"userservice\\\", configuration = FeignClientConfig.class) \",\"如果是全局配置\",\"@EnableFeignClients(clients = UserClient.class,defaultConfiguration = DefaultFeignConfiguration.class) \",\"Feign性能优化\",\"底层实现：Feign的作用是把我们的请求转换为HTTP请求，发送HTTP请求的客户端还是通过调用其他包来实现的，以下几种\",\"URLConnection：默认，不支持连接池\",\"Apache HttpClient：支持连接池\",\"OKHttp：支持连接池\",\"因此优化Feign性能的步骤主要包括\",\"使用连接池代替默认的URLConnection\",\"日志级别，最好用basic或none（打印日志越多越影响性能）\",\"连接池配置\",\"引入依赖\",\"<!--引入HttpClient依赖--> dependency> <groupId>io.github.openfeign</groupId> <artifactId>feign-httpclient</artifactId> </dependency> \",\"配置连接池\",\"feign: httpclient: enabled: true # 支持HttpClient的开关 max-connections: 200 # 最大连接数 max-connections-per-route: 50 # 单个路径的最大连接数 \"]},\"607\":{\"h\":\"2.7 统一网关Gateway\",\"t\":[\"为什么需要网关\",\"网关功能\",\"身份认证和权限校验\",\"服务路由、负载均衡\",\"请求限流\",\"网关技术实现\",\"网关的实现包括两种\",\"gateway\",\"zuul\",\"zuul是基于Servlet实现，属于阻塞式编程，而SpringCloudGateway是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能\",\"配置网关\",\"server: port: 10010 logging: level: cn.itcast: debug pattern: dateformat: MM-dd HH:mm:ss:SSS spring: application: name: gateway cloud: nacos: server-addr: nacos:8848 # nacos地址 gateway: routes: - id: user-service # 路由标示，必须唯一 uri: lb://userservice # 路由的目标地址 predicates: # 路由断言，判断请求是否符合规则 - Path=/user/** # 路径断言，判断路径是否是以/user开头，如果是则符合 - id: order-service uri: lb://orderservice predicates: - Path=/order/** default-filters: - AddRequestHeader=Truth,Itcast is freaking awesome! \",\"路由断言工厂\",\"我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件\",\"例如Path=/user/**是按照路径匹配，这个规则是由org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来处理的\",\"这种断言工厂有10多个\",\"springcloud gateway有11种断言工厂。下面是它们的简要说明:\",\"after: 确认请求是否在某个时间之后。\",\"before: 确认请求是否在某个时间之前。\",\"between: 确认请求是否在两个指定的时间之间。\",\"cookie: 确认请求中是否包含指定cookie或cookie值。\",\"header: 确认请求中是否包含指定header或header值。\",\"host: 确认请求的host匹配指定的模式。\",\"method: 确认请求的http方法与指定的方法匹配。\",\"path: 确认请求的路径符合指定的模式。\",\"query: 确认请求的查询参数中是否包含指定的参数或参数值。\",\"remoteaddr: 确认请求的远程地址匹配指定的模式。\",\"weight: 在多个路由规则中指定给定的路由权重。\",\"路由过滤器\",\"可以对进入网关的请求和微服务返回的响应做处理\",\"Filter 通常被用来对接入的HTTP请求/响应中的各个属性进行处理，比如添加头信息、请求参数转换等，从而实现对请求的过滤和改造\",\"全局过滤器\",\"与上面的过滤器的区别在于，GatewayFilter通过配置文件定义，功能都是固定的。而GlobalFilter的逻辑需要自己写代码实现\",\"下面是一个鉴权的全局过滤器功能实现\",\"@Component public class AuthorizeFilter implements GlobalFilter, Ordered { @Override public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) { // 1.获取请求参数 ServerHttpRequest request = exchange.getRequest(); MultiValueMap<String, String> params = request.getQueryParams(); // 2.获取参数中的 authorization 参数 String auth = params.getFirst(\\\"authorization\\\"); // 3.判断参数值是否等于 admin if (\\\"admin\\\".equals(auth)) { // 4.是，放行 return chain.filter(exchange); } // 5.否，拦截 // 5.1.设置状态码 exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); // 5.2.拦截请求 return exchange.getResponse().setComplete(); } @Override public int getOrder() { return -1; } } \",\"过滤器链执行顺序\",\"默认过滤器 -> 路由过滤器 -> 全局过滤器\",\"每一个过滤器都必须指定一 个int类型的order值，order值越小，优先级越高，执行顺序越靠前。\",\"GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定\",\"路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。\",\"当过滤器的order值一样时，会按照defaultFilter >路由过滤器> GlobalFilter的顺序执行。\",\"跨域Cros设置\",\"跨域:域名不-致就是跨域,主要包括:\",\"域名不同: www.taobao.com和www.taobao.org和www.jd.com和miaosha.jd.com\",\"域名相同，端口不同: localhost:8080和localhost8081\",\"跨域问题:浏览器禁止请求的发起者与服务端发生跨域ajax请求,请求被浏览器拦截的问题\",\"spring: cloud: gateway: globalcors: corsConfigurations: '[/**]': allowedOrigins: \\\"*\\\" # 允许哪些网站的跨域请求 allowedMethods: # 允许的跨域请求方式 - GET allowedHeaders: # 允许在请求中携带的头信息 - Authorization - Content-Type - X-Requested-With allowCredentials: true # 是否允许携带cookie exposeHeaders: - X-Total-Count maxAge: 1800 # 跨域检测有效期 \"]},\"608\":{\"h\":\"3 Docker 入门\"},\"609\":{\"h\":\"3.1 什么是Docker\",\"t\":[\"项目部署问题\",\"大型项目运行环境要配置很多软件、依赖，node、sql、redis、消息队列等，产生了不同组件依赖的兼容性问题\",\"开发、测试、生产的环境有差异问题，比如开发用的ubuntu，生产环境是CentOS\",\"Docker如何解决上述问题\",\"Docker 镜像中包含完整运行环境，包含操作系统函数库，仅系统的内核，因此程序可以在任何Linux 操作系统中运行\",\"并且将每个程序放入一个隔离的容器去运行，避免互相干扰\"]},\"610\":{\"h\":\"3.2 Docker 和虚拟机的区别\",\"t\":[\"Docker 是将程序完整的运行环境打包，这样在任意系统中就可以运行这个程序\",\"虚拟机是在操作系统中模拟硬件设备，然后运行另一个操作系统。\"]},\"611\":{\"h\":\"3.3 Docker 架构\",\"t\":[\"镜像和容器\",\"镜像（Image）：Docker 将程序运行的完整环境打包在一起，成为镜像\",\"容器（Container）：镜像中的程序运行后形成的进程就是容器\",\"Docker 和DockerHub\",\"DockerHub：是Docker 镜像的托管平台像Github\",\"Docker 架构\",\"Docker 是一个CS 架构的程序，由两部分组成\",\"服务端（server）：Docker 守护进程，负责处理Docker 指令，管理镜像/容器等\",\"客户端（client）：通过RestAPI 向Docker 服务端发送指令\",\"image-20230721135022502\"]},\"612\":{\"h\":\"3.4 安装Docker\"},\"613\":{\"h\":\"3.5 Docker 基本操作\",\"t\":[\"Docker 操作命令\",\"本地根据Dockerfile 文件，使用docker build构建镜像\",\"远程使用docker pull从服务拉取镜像\",\"docker images 查看本地的镜像\",\"docker rmi 删除镜像\",\"docker save保存镜像为一个压缩包\",\"docker load加载压缩包\",\"[命令] --help可以查看命令的帮助\",\"容器相关命令\",\"docker run创建容器，并进入运行状态\",\"docker pause容器进入暂停状态\",\"docker unpause 容器从暂停恢复运行状态\",\"docker stop容器停止\",\"docker start容器从停止恢复到运行状态\"]},\"614\":{\"h\":\"3.6 容器操作\",\"t\":[\"创建运行一个Nginx容器\",\"docker run --name containerName -p 80:80 -d nginx\",\"--name：给容器起一个名字\",\"-p：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口\",\"-d：后台运行容器\",\"查看容器日志\",\"docker logs\",\"添加-f 参数可以持续查看日志\",\"查看容器状态\",\"docker ps\",\"进入Nginx容器，修改HTML文件内容\",\"进入容器 docker exec -it mn bash\",\"docker exec：进入容器内部，执行一个命令\",\"-it：给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互\",\"mn：要进入的容器名称\",\"bash：进入容器后执行的命令\",\"进入Nginx的HTML所在目录 cd usr/share/nginx/html\",\"修改index.html 的内容\",\"sed -i 's#Welcome to nginx#docker 中的nginx#g' index.html\",\"sed -i 's#<head>#<head><meta charset=\\\"utf-8\\\">#g' index.html\"]},\"615\":{\"h\":\"3.7 数据卷操作\",\"t\":[\"数据卷\",\"数据卷(volume)是一个虚拟目录，指向宿主机文件系统中的某个目录\",\"操作数据卷\",\"docker volume [COMMAND]\",\"create：创建一个volume\",\"inspect：显示一个或多个volume 信息\",\"ls：列出所有的volume\",\"rm：删除volume\",\"prune：清楚未使用的数据卷\",\"挂载数据卷\",\"docker run --name mn -p 80:80 -v html:/usr/share/nginx/html -d nginx\",\"-v html:/usr/share/nginx/html：挂载目录到宿主机的数据卷html上（不存在数据卷会自动创建）\"]},\"616\":{\"h\":\"3.8 Dockerfile 自定义镜像\",\"t\":[\"镜像结构\",\"从低到高\",\"基础镜像（BaseImage）：系统函数库、环境、配置、文件（装系统）\",\"层（Layer）：在Baseimage 的基础上添加安装包、程序依赖、配置，每一步的操作都是一层（装程序）\",\"入口（Entrypoint）：镜像运行的入口，一般是启动的脚本和参数（快捷方式）\",\"Dockerfile\",\"文本文件，包含构建镜像的指令\",\"FROM：指定基础镜像 FROM centos:6 也可From 一个别人制作好的镜像\",\"ENV：设置环境变量 ENV key value\",\"COPY：拷贝本地文件到指定目录 COPY ./mysql-5.7.rpm /tmp\",\"RUN：执行Linux 的shell 命令 Run yum install gcc\",\"EXPOSE：指定容器运行时的监听端口\",\"ENTRYPOINT：镜像中应用的启动命令，运行时使用 ENTRYPOINT java -jar xx.jar\",\"案例：docker 部署一个java应用\",\"# 配置基础镜像 FROM ubuntu:16.04 # 配置环境变量 ENV JAVA_DIR=/usr/local # 拷贝jdk和java项目的包 COPY ./jdk8.tar.gz ${JAVA_DIR} COPY ./docker-demo.jar /tmp/app.jar # 安装jdk RUN cd ${JAVA_DIR} \\\\ && tar -xf ./jdk8.tar.gz \\\\ && mv ./jdk1.8.0_144 ./java8 # 配置环境变量 ENV JAVA_HOME=${JAVA_DIR}/java8 ENV PATH=$PATH:${JAVA_HOME}/bin # 暴露端口 EXPOSE 8080 #入口 java应用启动命令 ENTRYPOINT [ \\\"java\\\", \\\"-jar\\\" ] CMD [ \\\"/tmp/app.jar\\\" ] \",\"优化部署，可以将上面的dockerfile 中的jdk 安装部分单独打包，避免重复工作 java:8-alpine\",\"# 配置基础镜像 FROM java:8-alpine # 拷贝java项目的包 COPY ./docker-demo.jar /tmp/app.jar # 暴露端口 EXPOSE 8080 #入口 java应用启动命令 ENTRYPOINT [ \\\"java\\\", \\\"-jar\\\" ] CMD [ \\\"/tmp/app.jar\\\" ] \"]},\"617\":{\"h\":\"3.9 DockerCompose\",\"t\":[\"什么是DockerCompose\",\"基于Compose 文件帮助快速部署分布式应用，无需手动创建运行容器\",\"Compose 文件是一个文本文件，指令定义集群中的每个容器如何运行\",\"使用DockerCompose 部署微服务\",\"编写docker-compose文件\",\"version: \\\"3.2\\\" services: nacos: image: nacos/nacos-server environment: MODE: standalone ports: - \\\"8848:8848\\\" mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - \\\"$PWD/mysql/data:/var/lib/mysql\\\" - \\\"$PWD/mysql/conf:/etc/mysql/conf.d/\\\" userservice: build: ./user-service orderservice: build: ./order-service gateway: build: ./gateway ports: - \\\"10010:10010\\\" \",\"确保docker-compose 中的服务名和项目中的地址一致（localhost改成服务名称）\",\"使用Maven 打包时，把项目中每个微服务都打包成app.jar\",\"将app.jar 拷贝到服务集群项目的对应子目录中\",\"将服务集群项目上传虚拟机，使用docker-compose up -d部署\"]},\"618\":{\"h\":\"LeetCode刷题\",\"t\":[\"参考代码随想录学习\"]},\"619\":{\"h\":\"1 数组\"},\"620\":{\"h\":\"704 二分查找（左右指针法）\",\"t\":[\"二分查找使用前提：这道题目的前提是数组为有序数组，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的\",\"找好区间 [left, right]\",\"class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length-1; while (left <= right) { int mid = left + ((right - left) / 2); if (nums[mid] > target) { right = mid - 1; } else if (nums[mid] < target) { left = mid + 1; } else { return mid; } } return -1; } } \"]},\"621\":{\"h\":\"33 旋转数组的二分查找\",\"t\":[\"class Solution { public int search(int[] nums, int target) { if (nums == null || nums.length < 1) return -1; return binarySearch(nums, target, 0, nums.length - 1); } int binarySearch(int[] arr, int target, int l, int r) { int left = l; int right = r; while (left <= right) { int mid = left + (right - left) / 2; if (arr[mid] == target) { return mid; } // 判断mid的左右哪边是升序数组 if (arr[l] <= arr[mid]) { if (arr[l] <= target && target < arr[mid]) { right = mid - 1; } else { left = mid + 1; } } else { if (arr[mid] < target && target <= arr[r]) { left = mid + 1; } else { right = mid - 1; } } } return -1; } } \"]},\"622\":{\"h\":\"739 每日温度\",\"t\":[\"给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。\",\"示例 1:\",\"输入: temperatures = [73,74,75,71,69,72,76,73] 输出: [1,1,4,2,1,1,0,0] \",\"方法：暴力法 但是不太暴力\",\"双层for循环，每个都向后查找一个比该天温度高的那天，两指针相减得到res\",\"但是在每次的向后判断过程中有很多重复的判断，优化暴力法，选择从后向前遍历\",\"class Solution { public int[] dailyTemperatures(int[] temperatures) { int[] res = new int[temperatures.length]; for (int i = temperatures.length - 2; i >= 0; i--) { for (int j = i + 1; j < temperatures.length; j+=res[j]) { if (temperatures[j] > temperatures[i]) { res[i] = j - i; break; } if (res[j] == 0) { res[i] = 0; break; } } } return res; } } \"]},\"623\":{\"h\":\"27 移除元素（前后指针法）\",\"t\":[\"方法一：单指针暴力法\",\"指针从头到尾遍历数组，发现需要删除的数后整个数组从该位置整体前移一位，记录删除的个数\",\"class Solution { public int removeElement(int[] nums, int val) { int size = nums.length; // 从头到尾遍历数组 for (int i = 0; i < size; i++) { // 发现删除的数后整体向前移一位 if (nums[i] == val) { for (int j = i; j < size - 1; j++) { nums[j] = nums[j + 1]; } // 指针指向前移的数 i--; // 删除了一个数 新数组大小减减 size--; } } return size; } } \",\"方法二：双指针 快慢指针法 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作\",\"快指针：寻找新数组的元素，新数组就是不含有目标元素的数组\",\"慢指针：指向更新 新数组下标的位置\",\"class Solution { public int removeElement(int[] nums, int val) { int slowIndex = 0; for (int fastIndex = 0; fastIndex < nums.length; fastIndex++) { // 判断是否为新数组的元素（不需要删除即为新数组元素） if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } } \"]},\"624\":{\"h\":\"42 接雨水（动态规划 前后指针）\",\"t\":[\"给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\",\"示例 1：\",\"img\",\"输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\",\"方法1：暴力解法\",\"water[i] = min( # 左边最高的柱子 max(height[0..i]), # 右边最高的柱子 max(height[i..end]) ) - height[i] \",\"class Solution { public int trap(int[] height) { // 先找极小值 // 再向极小值的两边找极大值 // 用最小的极大值减去中间区域的值 相加 得到该区域接的雨水 int n = height.length; int res = 0; for (int i = 1; i < n - 1; i++) { int l_max = 0, r_max = 0; // 找右边最高的柱子 for (int j = i; j < n; j++) r_max = Math.max(r_max, height[j]); // 找左边最高的柱子 for (int j = i; j >= 0; j--) l_max = Math.max(l_max, height[j]); // 如果自己就是最高的话， // l_max == r_max == height[i] res += Math.min(l_max, r_max) - height[i]; } return res; } } \",\"方法2：备忘录 先提前计算好每个位置的左右最大柱子高度 避免计算雨水时的重复计算\",\"class Solution { // 备忘录优化 public int trap(int[] height) { if (height.length == 0) { return 0; } int n = height.length; int res = 0; // 数组充当备忘录 int[] l_max = new int[n]; int[] r_max = new int[n]; // 初始化 base case l_max[0] = height[0]; r_max[n - 1] = height[n - 1]; // 从左向右计算 l_max for (int i = 1; i < n; i++) l_max[i] = Math.max(height[i], l_max[i - 1]); // 从右向左计算 r_max for (int i = n - 2; i >= 0; i--) r_max[i] = Math.max(height[i], r_max[i + 1]); // 计算答案 for (int i = 1; i < n - 1; i++) res += Math.min(l_max[i], r_max[i]) - height[i]; return res; } } \",\"方法3：继续优化dp数组的空间 很明显可以优化到1\",\"class Solution { public int trap(int[] height) { if (height.length == 0) { return 0; } // 动态规划 双dp数组 分别记录每个i对应位置的左边最大值和右边最大值 // 1. 初始化dp数组(dp数组空间优化 仅记录左最大和右最大) int l_max = 0; int r_max = 0; int left = 0, right = height.length - 1; int res = 0; while (left < right) { // 更新dp l_max = Math.max(l_max, height[left]); r_max = Math.max(r_max, height[right]); // 计算结果 // res += min(l_max, r_max) - height[i] if (l_max < r_max) { res += l_max - height[left]; left++; } else { res += r_max - height[right]; right--; } } return res; } } \"]},\"625\":{\"h\":\"11 盛水最多的容器\",\"t\":[\"给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\",\"找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\",\"返回容器可以储存的最大水量。\",\"示例 1：\",\"img\",\"输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\",\"方法1：暴力 遍历所有情况\",\"class Solution { public int maxArea(int[] height) { if (height.length == 0) { return 0; } int n = height.length; int res = 0; for (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { res = Math.max(res, Math.min(height[i], height[j]) * (j - i)); } } return res; } } \",\"方法2：左右指针 只向内移动短板 容量只会不变或者上升\",\"class Solution { public int maxArea(int[] height) { if (height.length == 0) { return 0; } int n = height.length; int res = 0; // 左右指针 // 移动短板 int left = 0, right = n - 1; while (left < right) { res = Math.max(res, Math.min(height[left], height[right]) * (right - left)); if (height[left] < height[right]) { left++; } else { right--; } } return res; } } \"]},\"626\":{\"h\":\"1 两数之和\",\"t\":[\"这题要返回下标 所以先排序再左右指针的方法不适用\",\"class Solution { public int[] twoSum(int[] nums, int target) { // 优化时间 // 遍历一遍过程中记录后面是否有满足与前面和=target的数 Map<Integer, Integer> need = new HashMap(); for (int left = 0; left < nums.length; left++) { if (need.containsKey(target - nums[left])) { return new int[] { need.get(target - nums[left]), left }; } need.put(nums[left], left); } return null; } } \"]},\"627\":{\"h\":\"18 四数之和(排序后的左右指针)\",\"t\":[\"给出一个求N数之和的框架\",\"class Solution { /** * @apiNote N个数的和问题通用解法 使用递归分解问题 * @param nums 数组 * @param n 计算n个数和 * @param start 开始位置 * @param target 目标和 使用long类型以防超出int类型范围 * @return 返回满足情况的所有解 */ List<List<Integer>> backtrackNSum(int[] nums, int n, int start, long target) { List<List<Integer>> res = new ArrayList<>(); if (n < 2 || nums.length < n) { return res; } if (n == 2) { // 两数之和 int lo = start, hi = nums.length - 1; while (lo < hi) { int sum = nums[lo] + nums[hi]; int left = nums[lo], right = nums[hi]; if (sum < target) { // 跳过相同的数 while (lo < hi && nums[lo] == left) lo++; } else if (sum > target) { while (lo < hi && nums[hi] == right) hi--; } else { res.add(new ArrayList<>(Arrays.asList(left, right))); // 跳过所有重复的元素 while (lo < hi && nums[lo] == left) lo++; while (lo < hi && nums[hi] == right) hi--; } } } else { // 超过两数之和 递归计算 for (int i = start;i < nums.length; i++) { List<List<Integer>> sub = backtrackNSum(nums, n - 1, i + 1, (long)(target - nums[i])); for (List<Integer> list : sub) { list.add(nums[i]); res.add(list); } // 跳过重复数 while (i < nums.length - 1 && nums[i] == nums[i + 1]) i++; } } return res; } } \"]},\"628\":{\"h\":\"31 下一个排列\",\"t\":[\"整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。\",\"例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\",\"例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。\",\"必须 原地 修改，只允许使用额外常数空间。\",\"思路：\",\"我们希望下一个数 比当前数大，这样才满足 “下一个排列” 的定义。因此只需要 将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。\",\"我们还希望下一个数 增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要： \",\"在 尽可能靠右的低位 进行交换，需要 从后向前 查找\",\"将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换\",\"将「大数」换到前面后，需要将「大数」后面的所有数 重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列\",\"class Solution { public void nextPermutation(int[] nums) { if (nums.length == 0 && nums.length == 1) return; // 双指针 // 从后往前找第一个升序的数对 for (int i = nums.length - 1; i >= 1; i--) { if (nums[i - 1] < nums[i]) { // i 到 nums.length之间找到一个比nums[i - 1]大的最小的数 int right = i; for (int j = i; j < nums.length; j++) { if (nums[j] > nums[i - 1] && nums[j] < nums[right]) { right = j; } } // 交换left 和 right 位置的数 int temp = nums[i - 1]; nums[i - 1] = nums[right]; nums[right] = temp; // 调转right后面的数 Arrays.sort(nums, i, nums.length); return; } } // 没找到升序对 Arrays.sort(nums); } } \"]},\"629\":{\"h\":\"977 有序数组的平方\",\"t\":[\"给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\",\"示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]\",\"示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]\",\"方法一：暴力法 先平方再排序\",\"class Solution { public int[] sortedSquares(int[] nums) { int[] res = new int[nums.length]; int sqrt = 0; for (int i = 0; i < nums.length; i++) { nums[i]*=nums[i]; } // 快速排序 QuickSort(res); return res; } } \",\"方法二：双指针法 因为最大平方值肯定是出现再最两边数的平方，所以用两个指针指向数组两边 进行平方的比较，大者存入结果数组的末端（结果数组从大到小存），并且将两个指针向内收缩继续比较。\",\"class Solution { public int[] sortedSquares(int[] nums) { int[] res = new int[nums.length]; // k指针指向结果数组的最后一位，即最大位 int k = nums.length - 1; // 双指针法 for (int i = 0, j = nums.length - 1; i <= j;) { if (nums[i]*nums[i] < nums[j]*nums[j]) { res[k--] = nums[j]*nums[j]; j--; } else { res[k--] = nums[i]*nums[i]; i++; } } return res; } } \"]},\"630\":{\"h\":\"209 长度最小的子数组（滑动窗口法）\",\"t\":[\"给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\",\"示例：\",\"输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。\",\"提示：\",\"1 <= target <= 10^9\",\"1 <= nums.length <= 10^5\",\"1 <= nums[i] <= 10^5\",\"方法一： 暴力解法\",\"class Solution { public int minSubArrayLen(int target, int[] nums) { int res = Integer.MAX_VALUE; int sum = 0; for (int i = 0; i < nums.length; i++) { sum = 0; for (int j = i; j < nums.length; j++) { sum += nums[j]; if (sum >= target) { res = res > j - i + 1 ? j - i + 1 : res; break; } } } return res == Integer.MAX_VALUE ? 0 : res; } } \",\"方法二：滑动窗口法\",\"初始化Left = right = 0，把索引左闭右开[left, right]称为一个窗口\",\"我们先不断增加right指针扩大窗口，直到窗口中的值符合要求\",\"此时，停止增加right，不断增加left指针缩小窗口范围，直到窗口不再满足\",\"class Solution { public int minSubArrayLen(int target, int[] nums) { int res = Integer.MAX_VALUE; int sum = 0; // 滑动窗口法 int width = 0; // 窗口宽度 for (int left = 0, right = 0; right < nums.length; right++) { sum += nums[right]; // 当窗口之和大于目标时，左边界右移，窗口值减小 while (sum >= target) { // 输出处理 width = right - left + 1; res = res < width ? res : width; // 左边界右移 sum -= nums[left++]; } } return res == Integer.MAX_VALUE ? 0 : res; } } \"]},\"631\":{\"h\":\"练习 904 水果成篮\",\"t\":[\"你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。\",\"你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\",\"你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。\",\"示例 1：\",\"输入：fruits = [1,2,1] 输出：3 解释：可以采摘全部 3 棵树。 示例 2：\",\"输入：fruits = [0,1,2,2] 输出：3 解释：可以采摘 [1,2,2] 这三棵树。 如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3：\",\"输入：fruits = [1,2,3,2,2] 输出：4 解释：可以采摘 [2,3,2,2] 这四棵树。 如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4：\",\"输入：fruits = [3,3,3,1,2,1,1,2,3,3,4] 输出：5 解释：可以采摘 [1,2,1,1,2] 这五棵树。\",\"方法：滑动窗口法\",\"选用何种数据类型来存储窗口：纯数量问题选用int类型就行 涉及到多类型（比如本题的水果有多种类，需要分别记录数量）则使用Map来存储窗内数据\",\"left right 其中right递增\",\"何时减小窗口：窗口中的水果种类大于两种时\",\"class Solution { public int totalFruit(int[] fruits) { int res = 0; int width = 0; Map<Integer, Integer> cnt = new HashMap<Integer, Integer>(); for (int left = 0, right = 0; right < fruits.length; ++right) { cnt.put(fruits[right], cnt.getOrDefault(fruits[right], 0) + 1); while (cnt.size() > 2) { cnt.put(fruits[left], cnt.get(fruits[left]) - 1); if (cnt.get(fruits[left]) == 0) { cnt.remove(fruits[left]); } left++; } width = right - left + 1; res = res > width ? res : width; } return res; } } \"]},\"632\":{\"h\":\"59 螺旋矩阵\",\"t\":[\"给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\",\"示例:\",\"输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]\",\"方法：把螺旋的运动分成多次的for循环 注意每次螺旋的变化\",\"class Solution { public int[][] generateMatrix(int n) { int[][] resMatrix = new int[n][n]; int startX = 0, startY = 0; // 每个循环的起始位置 int loop = n / 2; // 循环几圈 int cnt = 1; // 每次移动的计数 int offset = 1; // 每循环一次 边界收缩一次 int i, j; // 行列指针 while (loop-- > 0) { i = startX; j = startY; // 左到右 for (; j < n - offset; j++) { resMatrix[i][j] = cnt++; } // 上到下 for (; i < n - offset; i++) { resMatrix[i][j] = cnt++; } // 右到左 for (; j > startX; j--) { resMatrix[i][j] = cnt++; } // 下到上 for (; i > startY; i--) { resMatrix[i][j] = cnt++; } // 进入下一圈 收缩一格 offset++; startX++; startY++; } // 判断n为奇数情况 中间会有一个单独的数 if (n % 2 != 0) { resMatrix[n/2][n/2] = n*n; } return resMatrix; } } \"]},\"633\":{\"h\":\"2 链表\"},\"634\":{\"h\":\"203 移除链表元素（虚拟头指针dummy）\",\"t\":[\"题意：删除链表中等于给定值 val 的所有节点。\",\"示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]\",\"示例 2： 输入：head = [], val = 1 输出：[]\",\"示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]\",\"方法：考虑到头指针可能为删除节点的情况，使用虚拟头指针next指向原head，再通过一个pre指针来连接新链表（遍历的过程还需要一个指针来遍历原链表）\",\"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) { return head; } ListNode dummy = new ListNode(-1, head); ListNode pre = dummy; // 生成新链表的指针 ListNode temp = head; // 遍历原链表的指针 // 使用temp遍历原链表 while (temp != null) { // 发现需要删除节点则pre跳过 if (temp.val == val) { pre.next = temp.next; } else { // 无需删除的节点连接上pre pre = temp; } temp = temp.next; } return dummy.next; } } \"]},\"635\":{\"h\":\"707 设计链表\",\"t\":[\"方法一：单链表\",\"//单链表 class ListNode { int val; ListNode next; ListNode(){} ListNode(int val) { this.val=val; } } class MyLinkedList { //size存储链表元素的个数 int size; //虚拟头结点 ListNode head; //初始化链表 public MyLinkedList() { size = 0; head = new ListNode(0); } //获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点 public int get(int index) { //如果index非法，返回-1 if (index < 0 || index >= size) { return -1; } ListNode currentNode = head; //包含一个虚拟头节点，所以查找第 index+1 个节点 for (int i = 0; i <= index; i++) { currentNode = currentNode.next; } return currentNode.val; } //在链表最前面插入一个节点，等价于在第0个元素前添加 public void addAtHead(int val) { addAtIndex(0, val); } //在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加 public void addAtTail(int val) { addAtIndex(size, val); } // 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。 // 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点 // 如果 index 大于链表的长度，则返回空 public void addAtIndex(int index, int val) { if (index > size) { return; } if (index < 0) { index = 0; } size++; //找到要插入节点的前驱 ListNode pred = head; for (int i = 0; i < index; i++) { pred = pred.next; } ListNode toAdd = new ListNode(val); toAdd.next = pred.next; pred.next = toAdd; } //删除第index个节点 public void deleteAtIndex(int index) { if (index < 0 || index >= size) { return; } size--; if (index == 0) { head = head.next; return; } ListNode pred = head; for (int i = 0; i < index ; i++) { pred = pred.next; } pred.next = pred.next.next; } } \",\"方法二：双向链表\",\"//双链表 class ListNode{ int val; ListNode next,prev; ListNode() {}; ListNode(int val){ this.val = val; } } class MyLinkedList { //记录链表中元素的数量 int size; //记录链表的虚拟头结点和尾结点 ListNode head,tail; public MyLinkedList() { //初始化操作 this.size = 0; this.head = new ListNode(0); this.tail = new ListNode(0); //这一步非常关键，否则在加入头结点的操作中会出现null.next的错误！！！ head.next=tail; tail.prev=head; } public int get(int index) { //判断index是否有效 if(index<0 || index>=size){ return -1; } ListNode cur = this.head; //判断是哪一边遍历时间更短 if(index >= size / 2){ //tail开始 cur = tail; for(int i=0; i< size-index; i++){ cur = cur.prev; } }else{ for(int i=0; i<= index; i++){ cur = cur.next; } } return cur.val; } public void addAtHead(int val) { //等价于在第0个元素前添加 addAtIndex(0,val); } public void addAtTail(int val) { //等价于在最后一个元素(null)前添加 addAtIndex(size,val); } public void addAtIndex(int index, int val) { //index大于链表长度 if(index>size){ return; } //index小于0 if(index<0){ index = 0; } size++; //找到前驱 ListNode pre = this.head; for(int i=0; i<index; i++){ pre = pre.next; } //新建结点 ListNode newNode = new ListNode(val); newNode.next = pre.next; pre.next.prev = newNode; newNode.prev = pre; pre.next = newNode; } public void deleteAtIndex(int index) { //判断索引是否有效 if(index<0 || index>=size){ return; } //删除操作 size--; ListNode pre = this.head; for(int i=0; i<index; i++){ pre = pre.next; } pre.next.next.prev = pre; pre.next = pre.next.next; } } \"]},\"636\":{\"h\":\"206 反转链表\",\"t\":[\"题意：反转一个单链表。\",\"示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL\",\"方法：前后双指针法\",\"双指针不断向后移动，反转两个指针指向节点的next（注意在反转之前应当保存之后的节点，否则反转后会丢失连接）\",\"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode temp = head; // 遍历原链表的指针 ListNode cur = temp; // 前指针 ListNode pre = null; // 后指针 while (temp != null) { // 先保存反转的两个节点之后的节点 temp = cur.next; // cur 指向后一个节点，pre 指向前一个节点，两节点反转 cur.next = pre; // pre 和 cur 向后移动一位 pre = cur; cur = temp; } return pre; } } \"]},\"637\":{\"h\":\"24 两两交换链表中的节点\",\"t\":[\"给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\",\"你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\",\"方法：虚拟链表头 （链表操作注意顺序）\",\"24.两两交换链表中的节点1\",\"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { // 判断链表是否为空 if (head == null) { return head; } ListNode virtulHead = new ListNode(0); virtulHead.next = head; ListNode cur =virtulHead; while (cur.next != null && cur.next.next != null) { ListNode temp = cur.next; ListNode temp1 = cur.next.next.next; // 交换 对应上方三步 cur.next = cur.next.next; cur.next.next = temp; cur.next.next.next = temp1; // cur后移两位 下一轮交换 cur = cur.next.next; } return virtulHead.next; } } \"]},\"638\":{\"h\":\"19 删除链表的的倒数第N个节点\",\"t\":[\"给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点\",\"方法：快慢指针 快慢指针之间间距为 n+1 保证在快指针遍历到头时，慢指针指向要删除的节点前一位\",\"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { // 虚拟头 ListNode virtulHead = new ListNode(0, head); // 前后双指针 ListNode cur = virtulHead; ListNode pre = virtulHead; // 前指针后移n位 while (n-- != 0) { cur = cur.next; // 删除的节点大于链表长度 if (cur == null) { return null; } } // 双指针后移 pre的后一位即为倒数第n位 cur = cur.next; while (cur != null) { cur = cur.next; pre = pre.next; } // 删除pre后的节点 pre.next = pre.next.next; return virtulHead.next; } } \"]},\"639\":{\"h\":\"160 链表相交\",\"t\":[\"给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\",\"方法：简单来说，就是求两个链表交点节点的指针。 这里同学们要注意，交点不是数值相等，而是指针相等。\",\"为了方便举例，假设节点元素数值相等，则节点指针相等。\",\"看如下两个链表，目前curA指向链表A的头结点，curB指向链表B的头结点：\",\"面试题02.07.链表相交_1\",\"我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置，如图：\",\"面试题02.07.链表相交_2\",\"此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。\",\"否则循环退出返回空指针。\",\"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode curA = headA; ListNode curB = headB; int lenA = 0, lenB = 0; while (curA != null) { // 求链表A的长度 lenA++; curA = curA.next; } while (curB != null) { // 求链表B的长度 lenB++; curB = curB.next; } curA = headA; curB = headB; // 让curA为最长链表的头，lenA为其长度 if (lenB > lenA) { //1. swap (lenA, lenB); int tmpLen = lenA; lenA = lenB; lenB = tmpLen; //2. swap (curA, curB); ListNode tmpNode = curA; curA = curB; curB = tmpNode; } // 求长度差 int gap = lenA - lenB; // 让curA和curB在同一起点上（末尾位置对齐） while (gap-- > 0) { curA = curA.next; } // 遍历curA 和 curB，遇到相同则直接返回 while (curA != null) { if (curA == curB) { return curA; } curA = curA.next; curB = curB.next; } return null; } } \"]},\"640\":{\"h\":\"142 环形链表（快慢指针）\",\"t\":[\"给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\",\"为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\",\"方法：\",\"判断链表是否有环\",\"可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。\",\"如果有环，如何找到这个环的入口\",\"这就意味着，从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。\",\"/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode detectCycle(ListNode head) { // 快慢指针法 // 1. 判断是否有环 快指针一次走两步 慢指针一次走一步 ListNode fast = head; ListNode slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; // 快慢指针相遇 说明有环 if (fast == slow) { // 在头节点处定义一个新指针 与相遇处的指针同时运动 两指针相遇节点为环入口 ListNode index = head; while (index != slow) { index = index.next; slow = slow.next; } return index; } } return null; } } \"]},\"641\":{\"h\":\"3 字符串\"},\"642\":{\"h\":\"344 反转字符串\",\"t\":[\"编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\",\"方法：双指针法 两指针分别指向头和尾 交换指向的数\",\"class Solution { public void reverseString(char[] s) { if (s.length == 0 || s.length == 1) { return; } // 双指针法 头尾指针指向的char交换 int fast = s.length - 1; int slow = 0; char temp; while (slow < fast) { // 交换 temp = s[slow]; s[slow] = s[fast]; s[fast] = temp; // slow++; fast--; } return; } } \"]},\"643\":{\"h\":\"541 反转字符串2\",\"t\":[\"给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。\",\"如果剩余字符少于 k 个，则将剩余字符全部反转。\",\"如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\",\"示例:\",\"输入: s = \\\"abcdefg\\\", k = 2 输出: \\\"bacdfeg\\\"\",\"方法：其实在遍历字符串的过程中，只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。\",\"因为要找的也就是每2 * k 区间的起点，这样写，程序会高效很多。\",\"class Solution { public String reverseStr(String s, int k) { char[] ch = s.toCharArray(); for(int i = 0; i < ch.length; i += 2 * k){ int start = i; // 判断尾数够不够k个来取决end指针的位置 int end = Math.min(ch.length - 1,start + k - 1); reverseString(ch, start, end); } return new String(ch); } public void reverseString(char[] s, int start, int end) { // 双指针法 头尾指针指向的char交换 int fast = end; int slow = start; char temp; while (slow < fast) { // 交换 temp = s[slow]; s[slow] = s[fast]; s[fast] = temp; // slow++; fast--; } return; } } \"]},\"644\":{\"h\":\"剑指Offer 05 替换空格\",\"t\":[\"请实现一个函数，把字符串 s 中的每个空格替换成\\\"%20\\\"。\",\"方法：将空格换成多个字符 改变了字符串的长度 所以使用StringBuilder\",\"遍历字符串数组，遇到非空格就append 遇到空格就append\\\"%20\\\"\",\"class Solution { public String replaceSpace(String s) { StringBuilder stringBuilder = new StringBuilder(); for (char c: s.toCharArray()) { if (c != ' ') { stringBuilder.append(c); } else { stringBuilder.append(\\\"%20\\\"); } } return stringBuilder.toString(); } } \"]},\"645\":{\"h\":\"151 翻转字符串里的单词\",\"t\":[\"给定一个字符串，逐个翻转字符串中的每个单词。\",\"示例 1： 输入: \\\"the sky is blue\\\" 输出: \\\"blue is sky the\\\"\",\"示例 2： 输入: \\\" hello world! \\\" 输出: \\\"world! hello\\\" 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\",\"示例 3： 输入: \\\"a good example\\\" 输出: \\\"example good a\\\" 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\",\"方法：/** * 1.去除首尾以及中间多余空格 * 2.反转整个字符串 * 3.反转各个单词 */\",\"class Solution { public String reverseWords(String s) { // 1.去除首尾以及中间多余空格 StringBuilder sb = removeSpace(s); // 2.反转整个字符串 reverseString(sb, 0, sb.length() - 1); // 3.反转各个单词 reverseEachWord(sb); return sb.toString(); } private StringBuilder removeSpace(String s) { // System.out.println(\\\"ReverseWords.removeSpace() called with: s = [\\\" + s + \\\"]\\\"); int start = 0; int end = s.length() - 1; while (s.charAt(start) == ' ') start++; while (s.charAt(end) == ' ') end--; StringBuilder sb = new StringBuilder(); while (start <= end) { char c = s.charAt(start); if (c != ' ' || sb.charAt(sb.length() - 1) != ' ') { sb.append(c); } start++; } // System.out.println(\\\"ReverseWords.removeSpace returned: sb = [\\\" + sb + \\\"]\\\"); return sb; } /** * 反转字符串指定区间[start, end]的字符 */ public void reverseString(StringBuilder sb, int start, int end) { // System.out.println(\\\"ReverseWords.reverseString() called with: sb = [\\\" + sb + \\\"], start = [\\\" + start + \\\"], end = [\\\" + end + \\\"]\\\"); while (start < end) { char temp = sb.charAt(start); sb.setCharAt(start, sb.charAt(end)); sb.setCharAt(end, temp); start++; end--; } // System.out.println(\\\"ReverseWords.reverseString returned: sb = [\\\" + sb + \\\"]\\\"); } private void reverseEachWord(StringBuilder sb) { int start = 0; int end = 1; int n = sb.length(); while (start < n) { while (end < n && sb.charAt(end) != ' ') { end++; } reverseString(sb, start, end - 1); start = end + 1; end = start + 1; } } } \"]},\"646\":{\"h\":\"剑指Offer58-II 左旋转字符串\",\"t\":[\"字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\\\"abcdefg\\\"和数字2，该函数将返回左旋转两位得到的结果\\\"cdefgab\\\"\",\"方法：\",\"反转区间为前n的子串\",\"反转区间为n到末尾的子串\",\"反转整个字符串\",\"class Solution { public String reverseLeftWords(String s, int n) { char[] ch = s.toCharArray(); StringBuilder stringBuilder = new StringBuilder(); for (int i = n; i < ch.length; i++) { stringBuilder.append(ch[i]); } for (int i = 0; i < n; i++) { stringBuilder.append(ch[i]); } return stringBuilder.toString(); } } \"]},\"647\":{\"h\":\"3 无重复字符的最长子串（滑动窗口）\",\"t\":[\"给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\",\"示例 1:\",\"输入: s = \\\"abcabcbb\\\" 输出: 3 解释: 因为无重复字符的最长子串是 \\\"abc\\\"，所以其长度为 3。 \",\"方法：滑动窗口法 s由英文字母、数字、符号和空格组成 所以用一个128位的数组来记录s中每个字符的出现次数\",\"class Solution { public int lengthOfLongestSubstring(String s) { int[] abc = new int[128]; // 记录128个字符出现的个数 int res = 0; for (int left = 0, right = 0; right < s.length(); right++) { abc[s.charAt(right) - ' ']++; // 左移窗口 while (abc[s.charAt(right) - ' '] > 1) { abc[s.charAt(left) - ' '] -= 1; left++; }; // 记录当前的最大长度 res = Math.max(res, right - left + 1); } return res; } } \"]},\"648\":{\"h\":\"76 最小覆盖子串（滑动窗口）\",\"t\":[\"给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \\\"\\\" 。\",\"注意：\",\"对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。\",\"示例 1：\",\"输入：s = \\\"ADOBECODEBANC\\\", t = \\\"ABC\\\" 输出：\\\"BANC\\\" 解释：最小覆盖子串 \\\"BANC\\\" 包含来自字符串 t 的 'A'、'B' 和 'C'。\",\"方法：滑动窗口法 这里需要使用Map来当作窗口\",\"public class Solution { public static String minWindow(String s, String t) { // t比s长的情况 if (t.length() > s.length()) { return \\\"\\\"; } // 初始化 Map<Character, Integer> need = new HashMap(); // 用来判断是否已经出现过该字符 Map<Character, Integer> window = new HashMap(); int valid = 0; for (int i = 0; i < t.length(); i++) { add(need, t.charAt(i)); } int head = 0; // 记录最短覆盖串的起始位置 int minLen = Integer.MAX_VALUE; // 记录最短的覆盖串长度 // 滑动窗口 for (int right = 0, left = 0; right < s.length(); right++) { // 扩大窗口 if (need.containsKey(s.charAt(right))) { add(window, s.charAt(right)); if (window.get(s.charAt(right)) == need.get(s.charAt(right))) { valid++; } } // 判断是否收缩窗口 while (valid == need.size()) { // 是否更新数据 if (right - left + 1 < minLen) { head = left; minLen = right - left + 1; } // 移出窗口 收缩 if (need.containsKey(s.charAt(left))) { if (window.get(s.charAt(left)) == need.get(s.charAt(left))) { // 一个字符不满足个数 valid--; } } minus(window, s.charAt(left)); left++; } } // 输出 return minLen == Integer.MAX_VALUE ? \\\"\\\" : s.substring(head, head + minLen); } static void add(Map<Character, Integer> map, char key) { if (!map.containsKey(key)) { map.put(key, 1); } else { map.put(key, map.get(key) + 1); } } static void minus(Map<Character, Integer> map, char key) { if (map.containsKey(key)) { map.put(key, map.get(key) - 1); } } public static void main(String[] args) { System.out.println(minWindow(\\\"ADOBECODEBANC\\\", \\\"ABC\\\")); } } \"]},\"649\":{\"h\":\"438 找到字符串中所有字母异位词\",\"t\":[\"给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\",\"异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。\",\"示例 1:\",\"输入: s = \\\"cbaebabacd\\\", p = \\\"abc\\\" 输出: [0,6] 解释: 起始索引等于 0 的子串是 \\\"cba\\\", 它是 \\\"abc\\\" 的异位词。 起始索引等于 6 的子串是 \\\"bac\\\", 它是 \\\"abc\\\" 的异位词。\",\"class Solution { public List<Integer> findAnagrams(String s, String p) { // 用于返回字母异位词的起始索引 List<Integer> res = new ArrayList<>(); // 用 map 存储目标值中各个单词出现的次数 HashMap<Character, Integer> map = new HashMap<>(); for (Character c : p.toCharArray()) map.put(c, map.getOrDefault(c, 0) + 1); // 用另外一个 map 存储滑动窗口中有效字符出现的次数 HashMap<Character, Integer> window = new HashMap<>(); int left = 0; // 左指针 int right = 0; // 右指针 int valid = p.length(); // 只有当 valid == 0 时，才说明 window 中包含了目标子串 while (right < s.length()) { // 如果目标子串中包含了该字符，才存入 window 中 if (map.containsKey(s.charAt(right))) { window.put(s.charAt(right), window.getOrDefault(s.charAt(right), 0) + 1); // 只有当 window 中该有效字符数量不大于map中该字符数量，才能算一次有效包含 if (window.get(s.charAt(right)) <= map.get(s.charAt(right))) { valid--; } } // 如果 window 符合要求，即两个 map 存储的有效字符相同，就可以移动左指针了 // 但是只有二个map存储的数据完全相同，才可以记录当前的起始索引，也就是left指针所在位置 while (valid == 0) { if (right - left + 1 == p.length()) res.add(left); // 如果左指针指的是有效字符,需要更改 window 中的 key 对应的 value // 如果 有效字符对应的数量比目标子串少，说明无法匹配了 if (map.containsKey(s.charAt(left))) { window.put(s.charAt(left), window.get(s.charAt(left)) - 1); if (window.get(s.charAt(left)) < map.get(s.charAt(left))) { valid++; } } left++; } right++; } return res; } } \"]},\"650\":{\"h\":\"5 最长回文子串\",\"t\":[\"给你一个字符串 s，找到 s 中最长的回文子串。\",\"如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\",\"示例 1：\",\"输入：s = \\\"babad\\\" 输出：\\\"bab\\\" 解释：\\\"aba\\\" 同样是符合题意的答案。 \",\"方法：动态规划\",\"P(i,i)=true\",\"P(i,i+1)=(Si==Si+1)\",\"public class Solution { public String longestPalindrome(String s) { int len = s.length(); // 排除长度为1的情况 if (len < 2) { return s; } int maxLen = 1; int begin = 0; // dp[i][j] 表示 s[i..j] 是否是回文串 boolean[][] dp = new boolean[len][len]; // 初始化：所有长度为 1 的子串都是回文串 for (int i = 0; i < len; i++) { dp[i][i] = true; } char[] charArray = s.toCharArray(); // 递推开始 // 先枚举子串长度 for (int L = 2; L <= len; L++) { // 枚举左边界，左边界的上限设置可以宽松一些 for (int i = 0; i < len; i++) { // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得 int j = L + i - 1; // 如果右边界越界，就可以退出当前循环 if (j >= len) { break; } if (charArray[i] != charArray[j]) { dp[i][j] = false; } else { if (j - i < 3) { dp[i][j] = true; } else { dp[i][j] = dp[i + 1][j - 1]; } } // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置 if (dp[i][j] && j - i + 1 > maxLen) { maxLen = j - i + 1; begin = i; } } } return s.substring(begin, begin + maxLen); } } \"]},\"651\":{\"h\":\"28 实现 strStr()\",\"t\":[\"实现 strStr() 函数。\",\"给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。\",\"示例 1: 输入: haystack = \\\"hello\\\", needle = \\\"ll\\\" 输出: 2\",\"示例 2: 输入: haystack = \\\"aaaaa\\\", needle = \\\"bba\\\" 输出: -1\",\"说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。\"]},\"652\":{\"h\":\"方法1 ：暴力遍历\",\"t\":[\"/**暴力法 */ class Solution { public int strStr(String haystack, String needle) { char[] haystackArr = haystack.toCharArray(); char[] needleArr = needle.toCharArray(); // 以haystack中的每一个字符为起点判断一次 for (int i = 0; i < haystackArr.length; i++) { if (haystackArr.length - i + 1 < needleArr.length) { break; } for (int j = i, k = 0; j < haystackArr.length; j++, k++) { if (haystackArr[j] != needleArr[k]) { break; } if (j - i + 1 == needleArr.length) { return i; } } } return -1; } } \"]},\"653\":{\"h\":\"方法2 ：KMP\",\"t\":[\"KMP的主要思想\",\"当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。\",\"什么是前缀表\",\"前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配，要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。\",\"KMP详解1\",\"可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。\",\"那么什么是前缀表：记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\",\" \",\"怎么计算前缀表（next数组）\",\"接下来就要说一说怎么计算前缀表。\",\"如图：\",\"KMP精讲5\",\"长度为前1个字符的子串a，最长相同前后缀的长度为0。（注意字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。）\",\"KMP精讲6\",\"长度为前2个字符的子串aa，最长相同前后缀的长度为1。\",\"KMP精讲7\",\"长度为前3个字符的子串aab，最长相同前后缀的长度为0。\",\"以此类推： 长度为前4个字符的子串aaba，最长相同前后缀的长度为1。 长度为前5个字符的子串aabaa，最长相同前后缀的长度为2。 长度为前6个字符的子串aabaaf，最长相同前后缀的长度为0。\",\"那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图：\",\"KMP精讲8\",\"可以看出模式串与前缀表对应位置的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\",\"class Solution { //前缀表（不减一）Java实现 public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; int[] next = new int[needle.length()]; getNext(next, needle); int j = 0; for (int i = 0; i < haystack.length(); i++) { while (j > 0 && needle.charAt(j) != haystack.charAt(i)) j = next[j - 1]; if (needle.charAt(j) == haystack.charAt(i)) j++; if (j == needle.length()) return i - needle.length() + 1; } return -1; } private void getNext(int[] next, String s) { int j = 0; next[0] = 0; for (int i = 1; i < s.length(); i++) { while (j > 0 && s.charAt(j) != s.charAt(i)) j = next[j - 1]; if (s.charAt(j) == s.charAt(i)) j++; next[i] = j; } } } \"]},\"654\":{\"h\":\"4 栈与队列\"},\"655\":{\"h\":\"232 用栈实现队列\",\"t\":[\"使用栈实现队列的下列操作：\",\"push(x) -- 将一个元素放入队列的尾部。 pop() -- 从队列首部移除元素。 peek() -- 返回队列首部的元素。 empty() -- 返回队列是否为空。\",\"方法：双栈 一个栈存数据，另一个栈用来在取数据时反转数据\",\"class MyQueue { private Stack<Integer> stack; private Stack<Integer> reverseStack; public MyQueue() { stack = new Stack(); reverseStack = new Stack(); } public void push(int x) { stack.push(x); } public int pop() { // 反转到另一个栈 while (!stack.empty()) { reverseStack.push(stack.pop()); } // pop 出末尾的数 int res = reverseStack.pop(); // 剩余的数回到原来的栈 while (!reverseStack.empty()) { stack.push(reverseStack.pop()); } return res; } public int peek() { // 反转到另一个栈 while (!stack.empty()) { reverseStack.push(stack.pop()); } // pop 出末尾的数 int res = reverseStack.peek(); // 剩余的数回到原来的栈 while (!reverseStack.empty()) { stack.push(reverseStack.pop()); } return res; } public boolean empty() { return stack.empty(); } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ \",\"改进：输入栈和输出栈 pop时，只有当输出栈中没有数据时再从输出栈中读取数据\",\"class MyQueue { private Stack<Integer> stack; private Stack<Integer> reverseStack; public MyQueue() { stack = new Stack(); reverseStack = new Stack(); } public void push(int x) { stack.push(x); } public int pop() { if (reverseStack.empty()) { // 反转到另一个栈 while (!stack.empty()) { reverseStack.push(stack.pop()); } } // pop 出末尾的数 return reverseStack.pop(); } public int peek() { // 复用一下pop() int res = this.pop(); // 再添加回去 reverseStack.push(res); return res; } public boolean empty() { // 两个栈都空时为empty return stack.empty() && reverseStack.empty(); } } \"]},\"656\":{\"h\":\"225 用队列实现栈\",\"t\":[\"使用队列实现栈的下列操作：\",\"push(x) -- 元素 x 入栈\",\"pop() -- 移除栈顶元素\",\"top() -- 获取栈顶元素\",\"empty() -- 返回栈是否为空\",\"队列的操作方法：offer(), poll(), peek(), size(), isEmpty()\"]},\"657\":{\"h\":\"方法1：双队列实现\",\"t\":[\"先存在辅助队列中 在把原队列中的数poll到辅助队列中，这样辅助队列中的数就模拟了栈中的出栈顺序\",\"class MyStack { Queue<Integer> queue1; // 和栈中保持一样元素的队列 Queue<Integer> queue2; // 辅助队列 /** Initialize your data structure here. */ public MyStack() { queue1 = new LinkedList<>(); queue2 = new LinkedList<>(); } /** Push element x onto stack. */ public void push(int x) { queue2.offer(x); // 先放在辅助队列中 while (!queue1.isEmpty()){ queue2.offer(queue1.poll()); } Queue<Integer> queueTemp; queueTemp = queue1; queue1 = queue2; queue2 = queueTemp; // 最后交换queue1和queue2，将元素都放到queue1中 } /** Removes the element on top of the stack and returns that element. */ public int pop() { return queue1.poll(); // 因为queue1中的元素和栈中的保持一致，所以这个和下面两个的操作只看queue1即可 } /** Get the top element. */ public int top() { return queue1.peek(); } /** Returns whether the stack is empty. */ public boolean empty() { return queue1.isEmpty(); } } \"]},\"658\":{\"h\":\"方法2：单队列实现\",\"t\":[\"一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了\",\"class MyStack { Queue<Integer> queue; /** Initialize your data structure here. */ public MyStack() { queue = new LinkedList<>(); } /** Push element x onto stack. */ public void push(int x) { // 每offer一个数进来都重新排序 queue.offer(x); int size = queue.size(); while (size-- > 1) { queue.offer(queue.poll()); } } /** Removes the element on top of the stack and returns that element. */ public int pop() { return queue.poll(); } /** Get the top element. */ public int top() { return queue.peek(); } /** Returns whether the stack is empty. */ public boolean empty() { return queue.isEmpty(); } } \"]},\"659\":{\"h\":\"20 有效的括号\",\"t\":[\"给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\",\"有效字符串需满足：\",\"左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。\",\"示例 1：\",\"输入：s = \\\"()\\\" 输出：true \",\"示例 2：\",\"输入：s = \\\"()[]{}\\\" 输出：true \",\"方法：遇到左括号就⼊栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配\",\"class Solution { public boolean isValid(String s) { // 括号不是成双成对出现 肯定错的 if (s.length() % 2 != 0) { return false; } Set<Character> left = new HashSet<>(); left.add('('); left.add('{'); left.add('['); Stack<Character> flags = new Stack<>(); // 存储左括号 for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (left.contains(c)) { // 入栈 flags.push(c); } else { // 排除掉括号闭合顺序错误的情况 if (flags.isEmpty()) { return false; } // 判断左括号是否与相同类型的右括号闭合 char lc = flags.pop(); if ((c == ')' && lc != '(') || (c == '}' && lc != '{') || (c == ']' && lc != '[')) { return false; } } } // 排除掉缺少与左括号对应的右括号的情况 if (!flags.isEmpty()) { return false; } return true; } } \"]},\"660\":{\"h\":\"921 使括号有效的最少添加\",\"t\":[\"只有满足下面几点之一，括号字符串才是有效的：\",\"它是一个空字符串，或者\",\"它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者\",\"它可以被写作 (A)，其中 A 是有效字符串。\",\"给定一个括号字符串 s ，在每一次操作中，你都可以在字符串的任何位置插入一个括号\",\"例如，如果 s = \\\"()))\\\" ，你可以插入一个开始括号为 \\\"(()))\\\" 或结束括号为 \\\"())))\\\" 。\",\"返回 为使结果字符串 s 有效而必须添加的最少括号数。\",\"示例 1：\",\"输入：s = \\\"())\\\" 输出：1 \",\"示例 2：\",\"输入：s = \\\"(((\\\" 输出：3 \",\"方法：// 遍历完后need中存储需要的右括号数量 // res中存储需要的左括号数量\",\"class Solution { public int minAddToMakeValid(String s) { int need = 0; int res = 0; for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c == '(') { need++; // 需要一个右括号 } else { need--; // 消耗一个左括号 if (need == -1) { // 说明前面缺少对应的左括号 需要补一个左括号 res++; need = 0; } } } // 遍历完后need中存储需要的右括号数量 // res中存储需要的左括号数量 return res + need; } } \"]},\"661\":{\"h\":\"239 滑动窗口的最大值（单调队列）\",\"t\":[\"给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\",\"返回 滑动窗口中的最大值 。\",\"示例 1\",\"输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释： 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 \",\"方法：需要判断窗口中的数的大小，使用单调队列作为窗口\",\"class Solution { public int[] maxSlidingWindow(int[] nums, int k) { MonotonicQueue window = new MonotonicQueue(); List<Integer> res = new ArrayList<>(); for (int i = 0; i < nums.length; i++) { // 先填满窗口 if (i < k - 1) { window.push(nums[i]); } else { window.push(nums[i]); // 记录当前窗口最大值 res.add(window.max()); // 缩小窗口 window.pop(nums[i - k + 1]); } } int[] arr = new int[res.size()]; for (int i = 0; i < res.size(); i++) { arr[i] = res.get(i); } return arr; } } // 单调队列 class MonotonicQueue { LinkedList<Integer> q = new LinkedList<>(); public void push(int n) { // 将队列中小于n的元素全部删除 while (!q.isEmpty() && q.getLast() < n) { q.pollLast(); } // 将n加入尾部 q.addLast(n); } public int max() { return q.getFirst(); } // 删除窗口左侧元素时 如果他在队列中 就把他删除 // 如果不在队列中 说明它在push()中就已经被删除 public void pop(int n) { if (n == q.getFirst()) { q.pollFirst(); } } } \"]},\"662\":{\"h\":\"84 柱状图中最大的矩形（单调栈）\",\"t\":[\"class Solution { public int largestRectangleArea(int[] heights) { int length = heights.length; if (length == 0) return 0; if (length == 1) return heights[0]; int maxSize = 0; // 哨兵 int[] newHeights = new int[length + 2]; System.arraycopy(heights, 0, newHeights, 1, length); newHeights[0] = 0; newHeights[length + 1] = 0; length += 2; heights = newHeights; Deque<Integer> stack = new ArrayDeque<>(length); stack.addLast(0); for (int i = 1; i < length; i++) { // 如果需要入栈的数大于栈中最后一个数 先把栈中的数从后往前依次出栈 // 直到小于该数 while (heights[i] < heights[stack.peekLast()]) { // 此时可以确定出栈柱形对应的最大矩形 int curHeight = heights[stack.pollLast()]; int curWidth = i - stack.peekLast() - 1; maxSize = Math.max(curWidth * curHeight, maxSize); } stack.addLast(i); } return maxSize; } } \"]},\"663\":{\"h\":\"5 二叉树\"},\"664\":{\"h\":\"二叉树的遍历\",\"t\":[\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { private List<Integer> res = new ArrayList(); public List<Integer> traversal(TreeNode root) { if (root != null) { preorderTraversal(root); } return res; } // 前序遍历 private void preorderTraversal(TreeNode node) { res.add(node.val); if (node.left != null) { preorderTraversal(node.left); } if (node.right != null) { preorderTraversal(node.right); } } // 中序遍历 private void inorderTraversal(TreeNode node) { if (node.left != null) { inorderTraversal(node.left); } res.add(node.val); if (node.right != null) { inorderTraversal(node.right); } } // 后序遍历 private void postorderTraversal(TreeNode node) { if (node.left != null) { postorderTraversal(node.left); } res.add(node.val); if (node.right != null) { postorderTraversal(node.right); } } } \"]},\"665\":{\"h\":\"二叉树迭代遍历（栈）\",\"t\":[\"前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。\",\"为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。\",\"二叉树前序遍历（迭代法）\"]},\"666\":{\"h\":\"二叉树层序遍历（队列）\",\"t\":[\"给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\",\"img\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<List<Integer>> levelOrder(TreeNode root) { // 存储最终结果 List<List<Integer>> res = new ArrayList(); // 队列存储node节点 Queue<TreeNode> queue= new LinkedList<>(); // 遍历指针指向根节点 TreeNode cur = root; // 临时节点 TreeNode temp; // 当前队列的大小，每一次的重新赋值获得的都是一层的大小 int size = 0; // 先把头节点加入队列 if (cur != null) { queue.offer(cur); } // 从第一层开始遍历 // size 表示本层元素的大小 while (!queue.isEmpty()) { size = queue.size(); // 存储当前层的节点值 List<Integer> list = new ArrayList(); // size遍历完即一层的节点已经遍历完，此时的队列中已经包含下一层的节点 while (size-- > 0) { // 取出节点 temp = queue.poll(); list.add(temp.val); // 把节点的左右都存入队列 if (temp.left != null) { queue.offer(temp.left); } if (temp.right != null) { queue.offer(temp.right); } } // 一层遍历完，存入结果列表 res.add(list); } return res; } } \"]},\"667\":{\"h\":\"226 反转二叉树\",\"t\":[\"给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\",\"示例 1：\",\"img\",\"输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 示例 2：\",\"img\",\"输入：root = [2,1,3] 输出：[2,3,1] 示例 3：\",\"输入：root = [] 输出：[]\",\"**方法：**就是遍历二叉树 然后把节点的左右子节点对调\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode invertTree(TreeNode root) { if (root != null) { preorderTraversal(root); } return root; } // 前序遍历 private void preorderTraversal(TreeNode node) { // 操作(把节点的左子节点和右子节点对调) // 左右子节点都不存在则不操作 if (node.left == null && node.right == null) { return; } else { TreeNode temp; temp = node.left; node.left = node.right; node.right = temp; } // 遍历 if (node.left != null) { preorderTraversal(node.left); } if (node.right != null) { preorderTraversal(node.right); } } } \"]},\"668\":{\"h\":\"101 对称二叉树\",\"t\":[\"给你一个二叉树的根节点 root ， 检查它是否轴对称。\",\"示例 1：\",\"输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2：\",\"输入：root = [1,2,2,null,3,null,3] 输出：false\",\"**方法：**左子树和右子树分别从左和右前序遍历\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSymmetric(TreeNode root) { if (root != null) { return preorderTraversal(root.left, root.right); } return true; } // 前序遍历 private boolean preorderTraversal(TreeNode left, TreeNode right) { if (left == null && right != null) { return false; } else if (left != null && right == null) { return false; } else if (left == null && right == null) { return true; } else if (left.val != right.val) { return false; } // 遍历 boolean outside = preorderTraversal(left.left, right.right); boolean inside = preorderTraversal(left.right, right.left); return inside && outside; } } \"]},\"669\":{\"h\":\"104 二叉树的最大深度\",\"t\":[\"给定一个二叉树，找出其最大深度。\",\"二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\",\"说明: 叶子节点是指没有子节点的节点。\",\"示例： 给定二叉树 [3,9,20,null,null,15,7]，\",\" 3 / \\\\ 9 20 / \\\\ 15 7 返回它的最大深度 3 。 \",\"**方法1：**使用深度优先遍历\",\"class Solution { public int maxDepth(TreeNode root) { return getDepth(root); } int getDepth(TreeNode node) { if (node == null) { return 0; } int leftDepth = getDepth(node.left); int rightDepth = getDepth(node.right); int depth = 1 + (leftDepth > rightDepth ? leftDepth : rightDepth); return depth; } } \",\"**方法2：**层序遍历 层数即深度\",\"class Solution { public List<List<Integer>> levelOrder(TreeNode root) { // 队列存储node节点 Queue<TreeNode> queue= new LinkedList<>(); // 遍历指针指向根节点 TreeNode cur = root; // 临时节点 TreeNode temp; // 当前队列的大小，每一次的重新赋值获得的都是一层的大小 int size = 0; // 深度 int depth = 0; // 先把头节点加入队列 if (cur != null) { queue.offer(cur); } // 从第一层开始遍历 // size 表示本层元素的大小 while (!queue.isEmpty()) { size = queue.size(); // 存储当前层的节点值 List<Integer> list = new ArrayList(); // size遍历完即一层的节点已经遍历完，此时的队列中已经包含下一层的节点 while (size-- > 0) { // 取出节点 temp = queue.poll(); list.add(temp.val); // 把节点的左右都存入队列 if (temp.left != null) { queue.offer(temp.left); } if (temp.right != null) { queue.offer(temp.right); } } // 一层遍历完，深度+1 depth++; } return depth; } } \"]},\"670\":{\"h\":\"技巧 前缀和\"},\"671\":{\"h\":\"560 和为 K 的子数组\",\"t\":[\"class Solution { public int subarraySum(int[] nums, int k) { Map<Integer, Integer> mp = new HashMap<Integer, Integer>(); // Map记录前缀和出现的次数 mp.put(0, 1); int prefix = 0; int res = 0; // for (int i = 0; i < nums.length; i++) { prefix += nums[i]; // 当前前缀和与前面的某一个前缀和之差 = k // 说明存在连续的数和为k if (mp.containsKey(prefix - k)) res += mp.get(prefix - k); mp.put(prefix, mp.getOrDefault(prefix, 0) + 1); } return res; } } \"]},\"672\":{\"h\":\"437 路径总和（二叉树中的前缀和）\",\"t\":[\"（DFS+ 前缀和Map）\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { Map<Long, Integer> mp = new HashMap<Long, Integer>(); public int pathSum(TreeNode root, int targetSum) { mp.put(0L, 1); return dfs(root, targetSum, 0); } int dfs(TreeNode node, int k, long pre) { if (node == null) return 0; int ret = 0; pre += node.val; if (mp.containsKey(pre - k)) ret = mp.get(pre - k); mp.put(pre, mp.getOrDefault(pre, 0) + 1); ret += dfs(node.left, k, pre); ret += dfs(node.right, k, pre); // 需要回溯 mp.put(pre, mp.getOrDefault(pre, 0) - 1); return ret; } } \"]},\"673\":{\"h\":\"技巧 前缀树\"},\"674\":{\"h\":\"基本字典树\",\"t\":[\"class Trie { class Node { char val; boolean hasWord; Node[] children = new Node[26]; // 对应26个字母 Node() {}; Node(char val) { this.val = val; }; } Node root; public Trie() { root = new Node(); } public void insert(String word) { if (word == null || word == \\\"\\\") return; Node cur = root; for (int i = 0; i < word.length(); i++) { char c = word.charAt(i); if (cur.children[c - 'a'] == null) cur.children[c - 'a'] = new Node(c); cur = cur.children[c - 'a']; } cur.hasWord = true; } public boolean search(String word) { Node cur = searchPrefix(word); // 判断是否遍历到叶子节点 if (!cur.hasWord) return false; return true; } public boolean startsWith(String prefix) { return searchPrefix(prefix) != null; } private Node searchPrefix(String prefix) { if (prefix == null || prefix == \\\"\\\") return true; Node cur = root; for (int i = 0; i < prefix.length(); i++) { char c = prefix.charAt(i); if (cur.children[c - 'a'] == null) return null; cur = cur.children[c - 'a']; } return cur; } } /** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */ \"]},\"675\":{\"h\":\"820 单词的压缩编码\",\"t\":[\"倒着插入单词到前缀树即可以判断后缀\",\"class Solution { public int minimumLengthEncoding(String[] words) { int len = 0; Trie trie = new Trie(); // 先对单词列表根据单词长度由长到短排序 Arrays.sort(words, (s1, s2) -> s2.length() - s1.length()); // 单词插入trie，返回该单词增加的编码长度 for (String word: words) { len += trie.insert(word); } return len; } } // 定义tire class Trie { TrieNode root; public Trie() { root = new TrieNode(); } public int insert(String word) { TrieNode cur = root; boolean isNew = false; // 倒着插入单词 for (int i = word.length() - 1; i >= 0; i--) { int c = word.charAt(i) - 'a'; if (cur.children[c] == null) { isNew = true; // 是新单词 cur.children[c] = new TrieNode(); } cur = cur.children[c]; } // 如果是新单词的话编码长度增加新单词的长度+1，否则不变。 return isNew? word.length() + 1: 0; } } class TrieNode { char val; TrieNode[] children = new TrieNode[26]; public TrieNode() {} } \"]},\"676\":{\"h\":\"技巧 差分数组\",\"t\":[\"假设你有⼀个⻓度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k 个更新的操作。 其中，每个操作会被表示为⼀个三元组：[startIndex, endIndex, inc]，你需要将⼦数组 A[startIndex ... endIndex]（包括 startIndex 和 endIndex）增加 inc。 请你返回 k 次操作后的数组。注意：数组的索引可能跟题目给的序号不一致 要减一\"]},\"677\":{\"h\":\"1094 拼车\",\"t\":[\"车上最初有 capacity 个空座位。车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向）\",\"给定整数 capacity 和一个数组 trips , trip[i] = [numPassengersi, fromi, toi] 表示第 i 次旅行有 numPassengersi 乘客，接他们和放他们的位置分别是 fromi 和 toi 。这些位置是从汽车的初始位置向东的公里数。\",\"当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。\",\"示例 1：\",\"输入：trips = [[2,1,5],[3,3,7]], capacity = 4 输出：false\",\"**方法：**差分数组法 把问题等效于每个时间段的总乘客数相加（这样就把问题转换为了数组操作） 而后判断是否有某个时间段的人数超过座位数\",\"class Solution { public boolean carPooling(int[][] trips, int capacity) { // 最多有1000个车站 int[] nums = new int[1001]; // 构造差分解法 Difference df = new Difference(nums); for (int[] trip : trips) { // 乘客数量 int val = trip[0]; // 第 trip[1] 站上车 int i = trip[1]; // 第 trip[2] 站下车 int j = trip[2] - 1; // 呆在车上的区间为[trip[1], trip[2] - 1] // 区间化操作 df.increment(i, j, val); } int[] res = df.result(); // 判断是否超载 for (int i = 0; i < res.length; i++) { if (capacity < res[i]) { return false; } } return true; } // 差分数组⼯具类 class Difference { // 差分数组 private int[] diff; /* 输⼊⼀个初始数组，区间操作将在这个数组上进⾏ */ public Difference(int[] nums) { assert nums.length > 0; diff = new int[nums.length]; // 根据初始数组构造差分数组 diff[0] = nums[0]; for (int i = 1; i < nums.length; i++) { diff[i] = nums[i] - nums[i - 1]; } } /* 给闭区间 [i,j] 增加 val（可以是负数）*/ public void increment(int i, int j, int val) { diff[i] += val; if (j + 1 < diff.length) { diff[j + 1] -= val; } } /* 返回结果数组 */ public int[] result() { int[] res = new int[diff.length]; // 根据差分数组构造结果数组 res[0] = diff[0]; for (int i = 1; i < diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } public static void main(String[] args) { } } \"]},\"678\":{\"h\":\"1109 航班预定统计\",\"t\":[\"这里有 n 个航班，它们分别从 1 到 n 进行编号。\",\"有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。\",\"请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。\",\"示例 1：\",\"输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 输出：[10,55,45,25,25] 解释： 航班编号 1 2 3 4 5 预订记录 1 ： 10 10 预订记录 2 ： 20 20 预订记录 3 ： 25 25 25 25 总座位数： 10 55 45 25 25 因此，answer = [10,55,45,25,25]\",\"**方法：**完美满足差分数组法 返回计算后的result就行\",\"class Solution { public int[] corpFlightBookings(int[][] bookings, int n) { // 存结果 int[] answer = new int[n]; // 初始化差分数组 Difference df = new Difference(answer); // 计算 for (int i = 0; i < bookings.length; i++) { df.increment(bookings[i][0] - 1, bookings[i][1] - 1, bookings[i][2]); } return df.result(); } // 差分数组⼯具类 class Difference { // 差分数组 private int[] diff; /* 输⼊⼀个初始数组，区间操作将在这个数组上进⾏ */ public Difference(int[] nums) { assert nums.length > 0; diff = new int[nums.length]; // 根据初始数组构造差分数组 diff[0] = nums[0]; for (int i = 1; i < nums.length; i++) { diff[i] = nums[i] - nums[i - 1]; } } /* 给闭区间 [i,j] 增加 val（可以是负数）*/ public void increment(int i, int j, int val) { diff[i] += val; if (j + 1 < diff.length) { diff[j + 1] -= val; } } /* 返回结果数组 */ public int[] result() { int[] res = new int[diff.length]; // 根据差分数组构造结果数组 res[0] = diff[0]; for (int i = 1; i < diff.length; i++) { res[i] = res[i - 1] + diff[i]; } return res; } } } \"]},\"679\":{\"h\":\"技巧 并查集（集合 连通问题）\"},\"680\":{\"h\":\"6 回溯算法\"},\"681\":{\"h\":\"理论\",\"t\":[\"回溯法，一般可以解决如下几种问题：\",\"组合问题：N个数里面按一定规则找出k个数的集合\",\"切割问题：一个字符串按一定规则有几种切割方式\",\"子集问题：一个N个数的集合里有多少符合条件的子集\",\"排列问题：N个数按一定规则全排列，有几种排列方式\",\"棋盘问题：N皇后，解数独等等\"]},\"682\":{\"h\":\"模板\",\"t\":[\"void backtracking(参数) { if (终止条件) { result.add(路径) return } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } \"]},\"683\":{\"h\":\"77 组合问题\",\"t\":[\"给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\",\"你可以按 任何顺序 返回答案。\",\"class Solution { private List<List<Integer>> result = new ArrayList<>(); private LinkedList<Integer> path = new LinkedList<>(); public List<List<Integer>> combine(int n, int k) { backTrack(n, k, 1); return result; } // n 表示宽度 // k 表示递归的深度 // startIndex来记录下一层递归，搜索的起始位置 void backTrack(int n, int k, int startIndex) { if (path.size() == k) { result.add(new ArrayList(path)); return; } // 【剪枝优化】 当列表中剩余的元素数小于列表需要的元素数时 说明已经不需要向后递归了 // k - path.size() 表示剩余需要的元素数 // n - i + 1 表示表中剩余元素数 for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) { // 做选择 path.add(i); // 递归下一层 backTrack(n, k, i + 1); // 撤销选择 path.removeLast(); } } } \"]},\"684\":{\"h\":\"17 电话号码的字母组合\",\"t\":[\"给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\",\"给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\",\"示例 1：\",\"输入：digits = \\\"23\\\" 输出：[\\\"ad\\\",\\\"ae\\\",\\\"af\\\",\\\"bd\\\",\\\"be\\\",\\\"bf\\\",\\\"cd\\\",\\\"ce\\\",\\\"cf\\\"] 示例 2：\",\"输入：digits = \\\"\\\" 输出：[] 示例 3：\",\"输入：digits = \\\"2\\\" 输出：[\\\"a\\\",\\\"b\\\",\\\"c\\\"]\",\"**方法：**回溯算法框架 这题的宽度为两层需要两层for 深度为输入字符串的长度\",\"class Solution { String[] ABC = new String[] {\\\"\\\", \\\"\\\", \\\"abc\\\", \\\"def\\\", \\\"ghi\\\", \\\"jkl\\\", \\\"mno\\\", \\\"pqrs\\\", \\\"tuv\\\",\\\"wxyz\\\"}; List<String> res = new ArrayList(); public List<String> letterCombinations(String digits) { if (digits.isEmpty()) { return res; } backtrack(digits, 0, new StringBuilder()); return res; } void backtrack(String digits,int start, StringBuilder sb) { // 判断是否到达底部 if (sb.length() == digits.length()) { res.add(sb.toString()); return; } // for (int i = start; i < digits.length(); i++) { int digit = digits.charAt(i) - '0'; for (char c : ABC[digit].toCharArray()) { // 做选择 sb.append(c); // 递归 backtrack(digits, i + 1, sb); // 撤销选择 sb.deleteCharAt(sb.length() - 1); } } } } \"]},\"685\":{\"h\":\"46 全排列\",\"t\":[\"给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案\",\"**方法：**全排列问题因为有顺序的原因所以for循环遍历都是从0开始 判断path中是否已经有当前数来判断是否已经排列过这个数\",\"class Solution { List<List<Integer>> result = new ArrayList<>(); LinkedList<Integer> path = new LinkedList<>(); public List<List<Integer>> permute(int[] nums) { if (nums.length == 0) return result; backtrack(nums); return result; } public void backtrack(int[] nums) { if (path.size() == nums.length) { result.add(new ArrayList<>(path)); } for (int i =0; i < nums.length; i++) { // 如果path中已有，则跳过 if (path.contains(nums[i])) { continue; } path.add(nums[i]); backtrack(nums); path.removeLast(); } } } \"]},\"686\":{\"h\":\"78 子集\",\"t\":[\"给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\",\"解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\",\"示例 1：\",\"输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] \",\"**方法：**子集问题看成深度在变化的组合问题\",\"多个组合问题 深度在变化 = [0, nums.length]\",\"class Solution { List<List<Integer>> res = new ArrayList(); LinkedList<Integer> path = new LinkedList(); public List<List<Integer>> subsets(int[] nums) { // 多个组合问题 深度在变化 = [0, nums.length] for (int i = 0; i <= nums.length; i++) { backtrack(nums, i, 0); } return res; } void backtrack(int[] nums, int depth, int startIndex) { // 终止条件 if (path.size() == depth) { res.add(new ArrayList(path)); return; } for (int i = startIndex; i < nums.length - (depth - path.size()) + 1; i++) { // 选择 path.add(nums[i]); // 递归 backtrack(nums, depth, i + 1); // 撤销选择 path.removeLast(); } } } \",\"**方法2：**遍历一颗回溯树，但是不设终止条件 保存全部的路径\",\"class Solution { List<List<Integer>> res = new ArrayList(); LinkedList<Integer> path = new LinkedList(); public List<List<Integer>> subsets(int[] nums) { backtrack(nums, 3, 0); return res; } void backtrack(int[] nums, int depth, int startIndex) { res.add(new ArrayList(path)); for (int i = startIndex; i < nums.length; i++) { // 选择 path.add(nums[i]); // 递归 backtrack(nums, depth, i + 1); // 撤销选择 path.removeLast(); } } } \"]},\"687\":{\"h\":\"494 目标和\",\"t\":[\"给你一个整数数组 nums 和一个整数 target 。\",\"向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：\",\"例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 \\\"+2-1\\\" 。\",\"返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\",\"示例 1：\",\"输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3\",\"方法：回溯树中每次可选择+nums[i]或者-nums[i]，画出回溯树\",\"class Solution { private int res = 0; // 记录和满足目标的表达式个数 public int findTargetSumWays(int[] nums, int target) { backtrack(nums, target, 0); return res; } private void backtrack(int[] nums, int target, int start) { // 终止条件 if (start == nums.length) { // 判断是否和为target if (target == 0) { res++; } return; } // 回溯 // + backtrack(nums, target - nums[start], start+1); // - backtrack(nums, target + nums[start], start+1); } } \",\"剪枝优化\",\"利用备忘录当在同一位置，且剩余的值相同时，直接返回备忘录中的值\",\"方法2：使用动态规划\",\"class Solution { public int findTargetSumWays(int[] nums, int target) { // 排除 nums 中所有数的和都小于target的情况 if (Arrays.stream(nums).sum() < target || - Arrays.stream(nums).sum() > target) { return 0; } // 转换为0-1背包问题 // 如果我们把 nums 划分成两个子集 A 和 B，分别代表分配 + 的数和分配 - 的数，那么他们和 target 存在如下关系 // 可以推出 sum(A) = (target + sum(nums)) / 2，也就是把原问题转化成：nums 中存在几个子集 A，使得 A 中元素的和为 (target + sum(nums)) / 2 if ((target + Arrays.stream(nums).sum()) % 2 != 0) { return 0; } int sum = (target + Arrays.stream(nums).sum()) / 2; // 初始化DP数组 // 优化一维dp 因为新的一行只与上一行的数相关 所以计算过程中保留一行的计算结果就行 int[] dp = new int[sum + 1]; dp[0] = 1; // 状态转移 for (int i = 0; i < nums.length; i++) { for (int j = sum; j >= nums[i]; j--) { // 优化一维dp必须倒着更新行 因为顺序更新 会直接影响这一行之后的结果 dp[j] = dp[j] + dp[j - nums[i]]; // 优化一维dp } } return dp[sum]; } } \"]},\"688\":{\"h\":\"131 分割回文串\",\"t\":[\"给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。\",\"回文串 是正着读和反着读都一样的字符串。\",\"示例 1：\",\"输入：s = \\\"aab\\\" 输出：[[\\\"a\\\",\\\"a\\\",\\\"b\\\"],[\\\"aa\\\",\\\"b\\\"]] \",\"方法：\",\"class Solution { List<List<String>> res = new ArrayList(); LinkedList<String> path = new LinkedList(); public List<List<String>> partition(String s) { if (s == null) { return res; } backtrack(s, 0); return res; } // 深度为字符串长度 void backtrack(String str, int startIndex) { // 终止条件 startIndex 表示截取的记号 if (startIndex >= str.length()) { res.add(new ArrayList(path)); return; } for (int i = startIndex; i < str.length(); i++) { // 选择 if (isPalindrome(str, startIndex, i)) { String temp = str.substring(startIndex, i + 1); path.add(temp); } else { continue; } // 递归 backtrack(str, i + 1); path.removeLast(); } } // 判断是否为回文字符串 // 字符串反转与原字符串相等即为回文 boolean isPalindrome(String str, int start, int end) { for (int i = start, j = end; i < j; i++, j--) { if (str.charAt(i) != str.charAt(j)) { return false; } } return true; } } \"]},\"689\":{\"h\":\"698 划分相等子集（分割等和子集问题通用解法）\",\"t\":[\"给定⼀个整数数组 nums 和⼀个正整数 k，找出是否有可能把这个数组分成 k 个⾮空⼦集，其总和都相等。\",\"示例 1：\",\"输⼊：nums = [4, 3, 2, 3, 5, 2, 1], k = 4\",\"输出：True 说明：有可能将其分成 4 个⼦集 {5}, {1,4}, {2,3}, {2,3} 等于总和。\",\"class Solution { public boolean canPartition(int[] nums) { if (nums.length < 2) { return false; } // 先判断能否整除2 即能否等分为两个子集 int sum = 0; for (int num : nums) { sum += num; } if (sum % 2 != 0) { return false; } // int target = sum / 2; // 每个子集的和 int used = 0; // 使⽤位图技巧 // k 号桶初始什么都没装，从 nums[0] 开始做选择 return backtrack(2, 0, nums, 0, used, target); } // 下面为分割等和子集通用回溯法 HashMap<Integer, Boolean> memo = new HashMap<>(); boolean backtrack(int k, int bucket, int[] nums, int start, int used, int target) { // base case if (k == 0) { // 所有桶都被装满了，⽽且 nums ⼀定全部⽤完了 return true; } if (bucket == target) { // 装满了当前桶，递归穷举下⼀个桶的选择 // 让下⼀个桶从 nums[0] 开始选数字 boolean res = backtrack(k - 1, 0, nums, 0, used, target); // 缓存结果 memo.put(used, res); return res; } if (memo.containsKey(used)) { // 避免冗余计算 return memo.get(used); } for (int i = start; i < nums.length; i++) { // 剪枝 if (((used >> i) & 1) == 1) { // 判断第 i 位是否是 1 // nums[i] 已经被装⼊别的桶中 continue; } if (nums[i] + bucket > target) { continue; } // 做选择 used |= 1 << i; // 将第 i 位置为 1 bucket += nums[i]; // 递归穷举下⼀个数字是否装⼊当前桶 if (backtrack(k, bucket, nums, i + 1, used, target)) { return true; } // 撤销选择 used ^= 1 << i; // 将第 i 位置为 0 bucket -= nums[i]; } return false; } } \"]},\"690\":{\"h\":\"22 括号生成\",\"t\":[\"数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\",\"示例 1：\",\"输入：n = 3 输出：[\\\"((()))\\\",\\\"(()())\\\",\\\"(())()\\\",\\\"()(())\\\",\\\"()()()\\\"] \",\"示例 2：\",\"输入：n = 1 输出：[\\\"()\\\"] \",\"方法：回溯算法 回溯的index为左括号和右括号的剩余个数\",\"class Solution { public List<String> generateParenthesis(int n) { // 左右括号数量应该相同 // 从左往右添加括号 保证每个右括号都有一个左括号对应 即左括号的数量一定要大于右括号 List<String> res = new ArrayList<>(); StringBuilder path = new StringBuilder(); int left = n, right = n; backtrack(left, right, res, path); return res; } /** * * @param l 左括号剩余 * @param r 右括号剩余 * @param res * @param path */ void backtrack(int l, int r, List<String> res, StringBuilder path) { // 判断结束 if (l == 0 && r == 0) { // 左右括号都用完时结束回溯 res.add(path.toString()); return; } // 剪枝 if (l > r) { return; } // 递归 // 1. 添加左括号 if (l > 0) { path.append('('); backtrack(l - 1, r, res, path); // 回溯撤销 path.deleteCharAt(path.length() - 1); } // 2. 添加右括号 if (r > 0) { path.append(')'); backtrack(l, r - 1, res, path); // 回溯撤销 path.deleteCharAt(path.length() - 1); } } } \"]},\"691\":{\"h\":\"7 动态规划\"},\"692\":{\"h\":\"模板\",\"t\":[\"动态规划问题五步曲\",\"确定dp数组（dp table）以及下标的含义\",\"确定递推公式\",\"dp数组如何初始化\",\"确定遍历顺序\",\"举例推导dp数组\"]},\"693\":{\"h\":\"剑指 Offer 42. 连续子数组的最大和\",\"t\":[\"输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。\",\"要求时间复杂度为O(n)。\",\"输入: nums = [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 \",\"class Solution { public int maxSubArray(int[] nums) { // dp[i] 表示以第i个数结尾的最大连续数组和 int[] dp = new int[nums.length]; dp[0] = nums[0]; int max = dp[0]; // max 记录最大的连续子数组和 // dp 数组初始状态 for (int i = 1; i < nums.length; i++) { if (dp[i - 1] <= 0) { dp[i] = nums[i]; } else { dp[i] = dp[i - 1] + nums[i]; } max = Math.max(max, dp[i]); } return max; } } \",\"优化dp 数组内存占用 只用O(1)的空间存储前一个dp 值就行\",\"class Solution { public int maxSubArray(int[] nums) { int dp = nums[0]; int max = nums[0]; // max 记录最大的连续子数组和 // dp 数组初始状态 for (int i = 1; i < nums.length; i++) { if (dp <= 0) { dp = nums[i]; } else { dp += nums[i]; } max = Math.max(max, dp); } return max; } } \"]},\"694\":{\"h\":\"509 斐波那契数\",\"t\":[\"斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\",\"F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给定 n ，请计算 F(n) 。\",\"**方法：**优化dp数组，只保留F(n - 1) + F(n - 2)的值，不需要保存for循环计算的所有值，省空间O(1)\",\"状态转移式如上所示\",\"class Solution { public int fib(int n) { if (n < 1) { return n; } // 初始化DP int[] dpTable = new int[2]; dpTable[0] = 0; dpTable[1] = 1; int sum = 0; // 状态转移 if (n > 1) { for (int i = 2; i <= n; i++) { sum = dpTable[0] + dpTable[1]; dpTable[0] = dpTable[1]; dpTable[1] = sum; } } return dpTable[1]; } } \"]},\"695\":{\"h\":\"62 不同路径\",\"t\":[\"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\",\"机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\",\"问总共有多少条不同的路径？\",\"img\",\"class Solution { public int uniquePaths(int m, int n) { // dp数组 int[][] dpTable = new int[m][n]; int temp1 = 0; int temp2 = 0; // 按行遍历 for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { // 边上的格子缺少 会数组越界 if (i == 0 && j == 0) { temp1 = 0; temp2 = 1; } else if (i == 0 && j != 0) { temp1 = 0; temp2 = dpTable[i][j - 1]; } else if (i != 0 && j == 0) { temp1 = dpTable[i - 1][j]; temp2 = 0; } else { temp1 = dpTable[i][j - 1]; temp2 = dpTable[i - 1][j]; } dpTable[i][j] = temp1 + temp2; } } return dpTable[m - 1][n - 1]; } } \"]},\"696\":{\"h\":\"63 不同路径2\",\"t\":[\"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\",\"机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。\",\"现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\",\"网格中的障碍物和空位置分别用 1 和 0 来表示。\",\"示例 1：\",\"img\",\"输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2 解释：3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径：\",\"向右 -> 向右 -> 向下 -> 向下\",\"向下 -> 向下 -> 向右 -> 向右\",\"**方法：**动态规划二维DP问题\",\"class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; // 行数 int n = obstacleGrid[0].length; // 列数 // dp数组 数组中每个数代表从起点到对应位置的路径数 int[][] dpTable = new int[m][n]; // 如果在起点和终点遇到了障碍 直接返回0 if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) { return 0; } // 本题特点 因为是从左上往右下移动，所以最左一列和最上一行的dp数组值都为1 for (int i = 0; i < m; i++) { // 当出现了一个障碍时 后面的都到达不了 直接结束赋值 if (obstacleGrid[i][0] == 1) { break; } dpTable[i][0] = 1; } for (int i = 1; i < n; i++) { if (obstacleGrid[0][i] == 1) { break; } dpTable[0][i] = 1; } // 按行遍历 从[1, 1]开始 for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { // 障碍物处理 if (obstacleGrid[i][j] == 1) { dpTable[i][j] = 0; } else { dpTable[i][j] = dpTable[i - 1][j] + dpTable[i][j - 1]; } } } return dpTable[m - 1][n - 1]; } } \"]},\"697\":{\"h\":\"198 打家劫舍\",\"t\":[\"如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\",\"给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\",\"示例 1：\",\"输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。\",\"**方法：**这是一道一维动态规划题 主要需要确定dp数组的含义 以及递推公式\",\"class Solution { public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } // 递推公式 // 每次偷当前人家 偷或不偷对应两种情况 da取最大值 // max(dp[i - 2] + nums[i], dp[i - 1]) // 初始化dp数组 // 优化空间 dp数组只用2格空间 只记录与当前计算相关的前两个结果 int[] dpTable = new int[2]; dpTable[0] = nums[0]; dpTable[1] = nums[0] > nums[1] ? nums[0] : nums[1]; int res = 0; // 遍历 for (int i = 2; i < nums.length; i++) { res = (dpTable[0] + nums[i]) > dpTable[1] ? (dpTable[0] + nums[i]) : dpTable[1]; dpTable[0] = dpTable[1]; dpTable[1] = res; } // 输出结果 return dpTable[1]; } } \"]},\"698\":{\"h\":\"213 打家劫舍2\",\"t\":[\"你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。\",\"给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。\",\"示例 1：\",\"输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\",\"**方法：**打家劫舍1的区别是首尾是相连的 状态转移方程有变化 初始状态也有变化\",\"我们把首尾被抢的情况分为3种\",\"首尾都不抢 此时等效于对[1, n-2]的房屋进行打家劫舍1问题\",\"首抢尾不抢 此时等效于对[0, n-2]的房屋进行打家劫舍1问题\",\"首不抢尾抢 此时等效于对[1, n-1]的房屋进行打家劫舍1问题\",\"class Solution { public int rob(int[] nums) { if (nums.length == 1) { return nums[0]; } // 分成3次基本打家劫舍问题 又由于后两次的范围对于第一次是包含关系 所以可以不考虑第一次 int result1 = rob1(nums, 0, nums.length - 2); int result2 = rob1(nums, 1, nums.length - 1); return result1 > result2 ? result1 : result2; } // 基本打家劫舍问题算法 int rob1(int[] nums, int start, int end) { if (end - start < 0) { return 0; } else if (end - start == 0) { return nums[start]; } int[] dpTable = new int[2]; dpTable[0] = nums[start]; dpTable[1] = nums[start] > nums[start + 1] ? nums[start] : nums[start + 1]; int res = 0; // 遍历 for (int i = start + 2; i <= end; i++) { res = (dpTable[0] + nums[i]) > dpTable[1] ? (dpTable[0] + nums[i]) : dpTable[1]; dpTable[0] = dpTable[1]; dpTable[1] = res; } // 输出结果 return dpTable[1]; } } \"]},\"699\":{\"h\":\"337 打家劫舍3（数组结构的动态规划）\",\"t\":[\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { Map<TreeNode, Integer> f = new HashMap<>(); // 存储选中当前节点的最高金额 Map<TreeNode, Integer> g = new HashMap<>(); // 存储不选中当前节点的最高金额 public int rob(TreeNode root) { dfs(root); return Math.max(f.getOrDefault(root, 0), g.getOrDefault(root, 0)); } void dfs(TreeNode node) { if (node == null) return; dfs(node.left); dfs(node.right); f.put(node, node.val + g.getOrDefault(node.left, 0) + g.getOrDefault(node.right, 0)); g.put(node, Math.max(f.getOrDefault(node.left, 0), g.getOrDefault(node.left, 0)) + Math.max(f.getOrDefault(node.right, 0), g.getOrDefault(node.right, 0))); } } \"]},\"700\":{\"h\":\"背包问题模板\",\"t\":[\"// dp[][]数组的意义 // dp[i][w]表示对于前i个物品，当前背包承重为w时，可以装下的最大价值 // 状态转移方程 dp[i][w] = // 如果没有把第i个物品装入背包 = dp[i - 1][w] 即继承之前的结果 // 如果把第i个物品装入背包 = dp[i-1][w - wt[i - 1]] + val[i - 1] (wt和val数组存的是第i个物品的重量和价值) int bagSolution(int w, int n, int[] wt, int[] val) { // 初始化dp数组 // 注意：要根据不同题的逻辑来对数组进行初始化 int[][] dp = new int[n+1][w+1]; for (int i = 0; i < n + 1; i++) { dp[i][0] = 0; } for (int i = 0; i < w + 1; i++) { dp[0][i] = 0; } // 状态转移 for (int i = 1; i <= n; i++) { for (int j = 1; j <= w; j++) { // 背包容量不够 if (w - wt[i - 1] < 0) { dp[i][j] = dp[i - 1][j]; } else { // 装入或不装入背包 取最大价值 dp[i][j] = Math.max(dp[i - 1][j], dp[i-1][j - wt[i - 1]] + val[i - 1]); } } } // 输出 return dp[n][w]; } \"]},\"701\":{\"h\":\"416 分割等和子集\",\"t\":[\"给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\",\"示例 1：\",\"输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 \",\"**方法1：**回溯法暴力搜索 会超时 直接套回溯算法分割等和子集模板\",\"class Solution { public boolean canPartition(int[] nums) { if (nums.length < 2) { return false; } // 先判断能否整除2 即能否等分为两个子集 int sum = 0; for (int num : nums) { sum += num; } if (sum % 2 != 0) { return false; } // int target = sum / 2; // 每个子集的和 int used = 0; // 使⽤位图技巧 // k 号桶初始什么都没装，从 nums[0] 开始做选择 return backtrack(2, 0, nums, 0, used, target); } HashMap<Integer, Boolean> memo = new HashMap<>(); boolean backtrack(int k, int bucket, int[] nums, int start, int used, int target) { // base case if (k == 0) { // 所有桶都被装满了，⽽且 nums ⼀定全部⽤完了 return true; } if (bucket == target) { // 装满了当前桶，递归穷举下⼀个桶的选择 // 让下⼀个桶从 nums[0] 开始选数字 boolean res = backtrack(k - 1, 0, nums, 0, used, target); // 缓存结果 memo.put(used, res); return res; } if (memo.containsKey(used)) { // 避免冗余计算 return memo.get(used); } for (int i = start; i < nums.length; i++) { // 剪枝 if (((used >> i) & 1) == 1) { // 判断第 i 位是否是 1 // nums[i] 已经被装⼊别的桶中 continue; } if (nums[i] + bucket > target) { continue; } // 做选择 used |= 1 << i; // 将第 i 位置为 1 bucket += nums[i]; // 递归穷举下⼀个数字是否装⼊当前桶 if (backtrack(k, bucket, nums, i + 1, used, target)) { return true; } // 撤销选择 used ^= 1 << i; // 将第 i 位置为 0 bucket -= nums[i]; } return false; } } \",\"**方法2：**动态规划 背包问题模板\",\"分成两个子集，把子集看成背包，就相当于双背包问题，装满背包意思就是，每个子集里的数字和正好等于sum/2\",\"关键是如何套用0-1背包的模板\",\"先判断能否整除2，即能否等分\",\"再使用0-1背包模板 判断能不能恰好装满一个背包 当一个背包能够装满时 说明剩余的数恰好也能装满另一个背包\",\"所以本题依然可以使用0-1背包问题的模板\",\"class Solution { public boolean canPartition(int[] nums) { if (nums.length < 2) { return false; } // 先判断能否整除2 即能否等分为两个子集 int sum = 0; for (int num : nums) { sum += num; } if (sum % 2 != 0) { return false; } // 背包问题参数 int n = nums.length; int target = sum / 2; // 每个子集的和 即每个背包的承重 boolean[][] dp = new boolean[n + 1][target + 1]; // 初始化dp // 背包没有空间时 相当于装满了 所以赋true // 没有物品可以选择时 无法装满背包 所以赋false for (int i = 0; i <= n; i++) { dp[i][0] = true; } for (int i = 0; i <= target; i++) { dp[0][i] = false; } // 状态转移 for (int i = 1; i <= n; i++) { for (int j = 1; j <= target; j++) { // 判断背包容量不足时 不装这个数 if (j - nums[i - 1] < 0) { dp[i][j] = dp[i - 1][j]; } else { // 选择装入或不装入背包 dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]; } } } return dp[n][target]; } } \"]},\"702\":{\"h\":\"10 正则表达式匹配\",\"t\":[\"给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。\",\"'.' 匹配任意单个字符\",\"'*' 匹配零个或多个前面的那一个元素\",\"示例 3：\",\"输入：s = \\\"ab\\\", p = \\\".*\\\" 输出：true 解释：\\\".*\\\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 \",\"class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); // dp数组初始化 boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i <= m; ++i) { for (int j = 1; j <= n; ++j) { if (p.charAt(j - 1) == '*') { f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) { f[i][j] = f[i][j] || f[i - 1][j]; } } else { if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == '.') { return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } \"]},\"703\":{\"h\":\"8 DFS深度优先搜索\"},\"704\":{\"h\":\"dfs搜索框架(图论)\",\"t\":[\"递归参数 \",\"如果是在矩阵中递归 参数为行列索引 i，j\",\"终止条件\",\"递推 \",\"已经遍历过的区域是否需要打上标记防止重复访问\",\"朝各个方向开始递归\",\"如果打过标记 是否需要还原\",\"返回值\",\"void dfs(int[][] grid, int r, int c) { // 1. 在遍历二维列表的过程中，从一个点向四周遍历 // 会碰到超出数组边界的情况 需要在每次递归调用之前判断是否超出数组边界 if (!inArea(grid, r, c)) { return; } // 2. 如果这个格子不是岛屿，直接返回 if (grid[r][c] != 1) { return; } // 3. 防止重复访问同一片区域 遍历过的区域可以打上标记 grid[r][c] = 2; // 将格子标记为「已遍历过」 // 4. 向该区域的相邻区域发散 访问上、下、左、右四个相邻结点 dfs(grid, r - 1, c); dfs(grid, r + 1, c); dfs(grid, r, c - 1); dfs(grid, r, c + 1); } // 判断坐标 (r, c) 是否在网格中 boolean inArea(int[][] grid, int r, int c) { return 0 <= r && r < grid.length && 0 <= c && c < grid[0].length; } \"]},\"705\":{\"h\":\"剑指 Offer 12. 矩阵中的路径\",\"t\":[\"给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\",\"单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\",\"例如，在下面的 3×4 的矩阵中包含单词 \\\"ABCCED\\\"（单词中的字母已标出）。\",\"img\",\"class Solution { public boolean exist(char[][] board, String word) { char[] words = word.toCharArray(); for(int i = 0; i < board.length; i++) { for(int j = 0; j < board[0].length; j++) { if(dfs(board, words, i, j, 0)) return true; } } return false; } boolean dfs(char[][] board, char[] word, int i, int j, int k) { // 如果超出数组边界 或不满足word中的单词则返回false if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]) return false; // word 中的所有字母都匹配完 说明包含该字母 if(k == word.length - 1) return true; // 防止访问同一片区域 遍历过的区域打上标记 board[i][j] = '\\\\0'; boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1); // 撤销标记 board[i][j] = word[k]; return res; } } \"]},\"706\":{\"h\":\"200 岛屿数量\",\"t\":[\"给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。\",\"岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\",\"此外，你可以假设该网格的四条边均被水包围。\",\"示例 1：\",\"输入：grid = [ [\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"1\\\",\\\"0\\\"], [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"1\\\",\\\"0\\\"], [\\\"1\\\",\\\"1\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"], [\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\",\\\"0\\\"] ] 输出：1\",\"方法：使用图的DFS框架，遍历整张图，遇到一块陆地就res++，并且淹没整块岛屿防止重复遍历\",\"class Solution { public int numIslands(char[][] grid) { int res = 0; // 遍历整张图 每发现一块陆地就淹没该片的岛屿 for (int i = 0; i < grid.length; i++) { for (int j = 0; j < grid[0].length; j++) { if (grid[i][j] == '1') { res++; dfs(grid, i, j); } } } return res; } /** * 把与之相邻的陆地都淹掉 * @param grid 图 * @param i 行 * @param j 列 */ void dfs(char[][] grid, int i, int j) { // 数组的边界判断 int m = grid.length, n = grid[0].length; if (i < 0 || j < 0 || i >= m || j >= n) { // 超出索引边界 return; } if (grid[i][j] == '0') { // 当前区域是海水 return; } // 遍历过的陆地直接淹没 防止之后重复遍历 grid[i][j] = '0'; // 淹没相邻的陆地 dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i - 1, j); dfs(grid, i, j - 1); } } \"]},\"707\":{\"h\":\"695 岛屿的最大面积\",\"t\":[\"简单题 图的遍历稍作修改\",\"class Solution { public int maxAreaOfIsland(int[][] grid) { int res = 0; for (int i = 0; i < grid.length; i++) { for (int j = 0; j < grid[0].length; j++) { if (grid[i][j] == 1) { // 遍历到陆地 // 计算当前岛屿的面积 res = Math.max(dfs(grid, i, j), res); } } } return res; } /** * 每发现一个岛屿 就把与之相邻的陆地都淹掉 * * @param grid 图 * @param i 行 * @param j 列 */ int dfs(int[][] grid, int i, int j) { // 数组的边界判断 int m = grid.length, n = grid[0].length; if (i < 0 || j < 0 || i >= m || j >= n) { // 超出索引边界 return 0; } if (grid[i][j] == 0) { // 当前区域是海水 return 0; } // 遍历过的区域 淹掉 grid[i][j] = 0; // 淹没相邻的陆地 return 1 + dfs(grid, i + 1, j) + dfs(grid, i, j + 1) + dfs(grid, i - 1, j) + dfs(grid, i, j - 1); } } \"]},\"708\":{\"h\":\"1254 统计封闭岛屿的数目\",\"t\":[\"二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封闭岛是一个 完全 由1包围（左、上、右、下）的岛。\",\"请返回 封闭岛屿 的数目。\",\"示例 1：\",\"img\",\"输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] 输出：2 解释： 灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。\",\"方法：参考200题 在计算岛屿数量的基础上 先排除掉靠边的岛屿\",\"class Solution { public int closedIsland(int[][] grid) { int res = 0; // 排除掉靠边岛屿 for (int i = 0; i < grid.length; i++) { dfs(grid, i, 0); dfs(grid, i, grid[0].length - 1); } for (int i = 0; i < grid[0].length; i++) { dfs(grid, 0, i); dfs(grid, grid.length - 1, i); } // 计算封闭岛屿数量 for (int i = 1; i < grid.length; i++) { for (int j = 1; j < grid[0].length; j++) { if (grid[i][j] == 0) { res++; dfs(grid, i, j); } } } return res; } /** * 每发现一个岛屿 就把与之相邻的陆地都淹掉 * * @param grid 图 * @param i 行 * @param j 列 */ void dfs(int[][] grid, int i, int j) { // 数组的边界判断 int m = grid.length, n = grid[0].length; if (i < 0 || j < 0 || i >= m || j >= n) { // 超出索引边界 return; } if (grid[i][j] == 1) { // 当前区域是海水 return; } // 遍历过的区域 淹掉 grid[i][j] = 1; // 淹没相邻的陆地 dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i - 1, j); dfs(grid, i, j - 1); } } \"]},\"709\":{\"h\":\"130 被围绕的区域（并查集）\",\"t\":[\"给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。\",\"示例 1：\",\"img\",\"输入：board = [[\\\"X\\\",\\\"X\\\",\\\"X\\\",\\\"X\\\"],[\\\"X\\\",\\\"O\\\",\\\"O\\\",\\\"X\\\"],[\\\"X\\\",\\\"X\\\",\\\"O\\\",\\\"X\\\"],[\\\"X\\\",\\\"O\\\",\\\"X\\\",\\\"X\\\"]] 输出：[[\\\"X\\\",\\\"X\\\",\\\"X\\\",\\\"X\\\"],[\\\"X\\\",\\\"X\\\",\\\"X\\\",\\\"X\\\"],[\\\"X\\\",\\\"X\\\",\\\"X\\\",\\\"X\\\"],[\\\"X\\\",\\\"O\\\",\\\"X\\\",\\\"X\\\"]] 解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 \",\"方法1：参考统计封闭岛屿数目的方法，先给边缘的陆地打上标记，再把被围绕的区域淹没，最后再把边缘区域还原\",\"class Solution { public void solve(char[][] board) { // 排除掉靠边岛屿 for (int i = 0; i < board.length; i++) { notIsland(board, i, 0); notIsland(board, i, board[0].length - 1); } for (int i = 0; i < board[0].length; i++) { notIsland(board, 0, i); notIsland(board, board.length - 1, i); } // 遍历图 for (int i = 1; i < board.length; i++) { for (int j = 1; j < board[0].length; j++) { if (board[i][j] == 'O') { dfs(board, i, j); } } } for (int i = 0; i < board.length; i++) { for (int j = 0; j < board[0].length; j++) { if (board[i][j] == 'E') { board[i][j] = 'O'; } } } } /** * 每发现一个岛屿 就把与之相邻的陆地都淹掉 * * @param grid 图 * @param i 行 * @param j 列 */ void dfs(char[][] grid, int i, int j) { // 数组的边界判断 int m = grid.length, n = grid[0].length; if (i < 0 || j < 0 || i >= m || j >= n) { // 超出索引边界 return; } if (grid[i][j] == 'X' || grid[i][j] == 'E') { // 当前区域是海水 return; } // 遍历过的区域 淹掉 grid[i][j] = 'X'; // 淹没相邻的陆地 dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i - 1, j); dfs(grid, i, j - 1); } void notIsland(char[][] grid, int i, int j) { // 数组的边界判断 int m = grid.length, n = grid[0].length; if (i < 0 || j < 0 || i >= m || j >= n) { // 超出索引边界 return; } if (grid[i][j] == 'X' || grid[i][j] == 'E') { // 当前区域是海水 return; } // 遍历过的区域 淹掉 grid[i][j] = 'E'; // 淹没相邻的陆地 notIsland(grid, i + 1, j); notIsland(grid, i, j + 1); notIsland(grid, i - 1, j); notIsland(grid, i, j - 1); } } \",\"方法2：并查集\",\"并查集常用来解决连通性的问题，即将一个图中连通的部分划分出来\",\"并查集的思想就是，同一个连通区域内的所有点的根节点是同一个，使用数组来存储每个节点的根节点\",\"本题把所有的边缘区域看做是一整块联通区域（因为实际上这些区域在图上不是真正的连在一起所以我们需要一个虚拟的根节点）。先预处理，把边界上的O都与一个虚拟根节点相连，接着遍历整张图当发现O时让它与它上下左右四个节点相连（即让它们指向同一个根节点），最后再次遍历整张图，把根节点不为虚拟节点的节点替换为X\",\"并查集模板类\",\"/** * 并查集 */ class UF{ private int[] ID; private int[] treeSize; public UF(int N){ ID = new int[N]; treeSize = new int[N]; for(int i = 0; i < N; i++){ ID[i] = i; treeSize[i] = 1; } } public int find(int i){ //查找当前树的根节点 int root = i; while(root != ID[root]) root = ID[root]; //路径压缩 所有子节点直接指向根节点 int next; while(i != ID[i]){ next = ID[i]; ID[i] = root; i = next; } return root; } public boolean connected(int p, int q){ return find(p) == find(q); } public void union(int p, int q){ if(find(p) == find(q)) return; if(treeSize[p] < treeSize[q]) //小树链接到大树上 ID[ID[p]] = ID[q]; //在调用find后， 路径被压缩， 因此ID[p]即为根节点, 同理ID[q]也为根节点 else ID[ID[q]] = ID[p]; } //将二维坐标转化为一维坐标, 便于并查集使用 //ｘ为二维数组的一维索引， ｙ为二维数组的二维索引 public static int flatternTowDim(int x, int y, int width){ return x * width + y; } } \",\"实现代码\",\"class Solution { //并查集类 class UF{ private int[] ID; private int[] treeSize; public UF(int N){ ID = new int[N]; treeSize = new int[N]; for(int i = 0; i < N; i++){ ID[i] = i; treeSize[i] = 1; } } public int find(int i){ //查找当前树的根节点 int root = i; while(root != ID[root]) root = ID[root]; //路径压缩 所有子节点直接指向根节点 int next; while(i != ID[i]){ next = ID[i]; ID[i] = root; i = next; } return root; } public boolean connected(int p, int q){ return find(p) == find(q); } public void union(int p, int q){ if(find(p) == find(q)) return; if(treeSize[p] < treeSize[q]) //小树链接到大树上 ID[ID[p]] = ID[q]; //在调用find后， 路径被压缩， 因此ID[p]即为根节点, 同理ID[q]也为根节点 else ID[ID[q]] = ID[p]; } } //将二维坐标转化为一维坐标, 便于并查集使用 //ｘ为二维数组的一维索引， ｙ为二维数组的二维索引 private int flatternTowDim(int x, int y, int width){ return x * width + y; } public void solve(char[][] board) { if(board.length == 0) return; int len = board.length; int width = board[0].length; int boardSize = len * width; UF uf = new UF(boardSize+1); //添加一个虚拟节点，所有位于边界的Ｏ节点均与该虚拟节点相连接 int i, j; for(i = 0; i < board.length; i++){ for(j = 0; j < board[0].length; j++){ if((i == 0 || i == board.length-1 || j == 0 || j == board[0].length-1) && board[i][j]=='O') uf.union(flatternTowDim(i, j, width), boardSize); } } //遍历搜索相邻的Ｏ，添加到并查集中 for(i = 0; i < board.length; i++){ for(j = 0;j < board[0].length; j++){ if(board[i][j] == 'O'){ //将当前Ｏ点与其下右两个方向的Ｏ点相连接(只需要连接你遍历数组的两个方向就可以全部连接了) if(i+1 < board.length && board[i+1][j] == 'O') uf.union(flatternTowDim(i+1, j, width), flatternTowDim(i, j, width)); if(j+1 <= board[0].length && board[i][j] == 'O') uf.union(flatternTowDim(i, j+1, width), flatternTowDim(i, j, width)); } } } //将所有与边界节点不相连的＇Ｏ＇点替换为＇Ｘ＇ for(i = 0; i < board.length; i++){ for(j = 0; j < board[0].length; j++){ if(board[i][j] == 'O' && !uf.connected(flatternTowDim(i, j, width), boardSize)) board[i][j] = 'X'; } } } } \"]},\"710\":{\"h\":\"9 BFS广度优先搜索\"},\"711\":{\"h\":\"模板\",\"t\":[\"能解决的问题\",\"在一幅图中找从起点到终点最近的距离\",\"int BFS(Node start, Node end) { Queue<Node> q; // 核心数据结构 Set<Node> visited; // 避免走回头路 q.offer(start); // 讲起点加入队列 visited.add(start); int step = 0; // 记录扩散的步数 while(q not empty) { int sz = q.size(); /* 将当前队列中的所有节点向四周扩散 */ for (int i = 0; i < sz.size(); i++) { Node cur = q.poll(); /* 重点：这里判断是否达到终点 */ if (cur is target) { return step; } /* 将cur的相邻节点加入队列 */ for (Node x : cur.adj()) { if (x not in visited) { q.offer(x); visited.add(x); } } /* 重点：在这里更新步数 */ step++; } } } \"]},\"712\":{\"h\":\"111 二叉树的最小深度\",\"t\":[\"给定一个二叉树，找出其最小深度。\",\"最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\",\"**说明：**叶子节点是指没有子节点的节点。\",\"img\",\"**方法：**start为root节点，end为遍历完所有的节点 遍历过程中当判断到叶子节点时 记录此时的深度 判断是否为最小深度\",\"class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } Queue<TreeNode> queue = new LinkedList(); int curDepth = 0; // 起点加入队列 queue.offer(root); curDepth++; // 遍历当前队列中的一层节点 while (!queue.isEmpty()) { int size = queue.size(); // 判断该层节点是否有叶子节点 for (int i = 0; i < size; i++) { TreeNode cur = queue.poll(); // 判断是否为叶子节点 if (cur.left == null && cur.right == null) { return curDepth; } // 将与cur节点相邻的节点都加入队列 if (cur.left != null) { queue.offer(cur.left); } if (cur.right != null) { queue.offer(cur.right); } } // 遍历完一层节点 增加步数 curDepth++; } return curDepth; } } \"]},\"713\":{\"h\":\"752 打开转盘锁\",\"t\":[\"你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。\",\"锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。\",\"列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。\",\"字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。\",\"class Solution { public int openLock(String[] deadends, String target) { int step = 0; Queue<String> queue = new LinkedList(); // 用set记录deadend 方便用contains方法判断 Set<String> deads = new HashSet(); for (String s : deadends) deads.add(s); // 用visited记录已经使用过的密码 Set<String> visited = new HashSet(); // 起点 queue.offer(\\\"0000\\\"); visited.add(\\\"0000\\\"); // while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i < size; i++) { String cur = queue.poll(); // 判断是否为deadend if (deads.contains(cur)) { continue; } // 判断是否结束 if (target.equals(cur)) { return step; } // 未遍历且不在deadend中的相邻节点加入队列 for (int j = 0; j < 4; j++) { String up = plusOne(cur, j); if (!visited.contains(up)) { queue.offer(up); visited.add(up); } String down = minusOne(cur, j); if (!visited.contains(down)) { queue.offer(down); visited.add(down); } } } step++; } return -1; } String plusOne(String s, int j) { char[] ch = s.toCharArray(); if (ch[j] == '9') { ch[j] = '0'; } else { ch[j] += 1; } return new String(ch); } String minusOne(String s, int j) { char[] ch = s.toCharArray(); if (ch[j] == '0') { ch[j] = '9'; } else { ch[j] -= 1; } return new String(ch); } } \"]},\"714\":{\"h\":\"10 图论算法\"},\"715\":{\"h\":\"797 所有可能路径\",\"t\":[\"给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）\",\"graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。\",\"img\",\"方法：解法很简单，以 0 为起点遍历图，同时记录遍历过的路径，当遍历到终点时将路径记录下来即可。 既然输⼊的图是无环的，我们就不需要 visited 数组辅助了，可以直接套用图的遍历框架。\",\"/* 图的遍历框架 */ // 回溯 void backtrack(int[][] graph, int outIndex) { // 递归结束的判断 if (outIndex == graph.length - 1) { res.add(new ArrayList(path)); return; } // 跟着图的顺序递归 for (int i = 0; i < graph[outIndex].length; i++) { // 处理 path.add(graph[outIndex][i]); // 递归 backtrack(graph, graph[outIndex][i]); // 撤销 path.removeLast(); } } \",\"class Solution { List<List<Integer>> res = new ArrayList(); LinkedList<Integer> path = new LinkedList(); public List<List<Integer>> allPathsSourceTarget(int[][] graph) { path.add(0); backtrack(graph, 0); return res; } // 回溯 void backtrack(int[][] graph, int outIndex) { // 遍历到底结束 if (outIndex == graph.length - 1) { res.add(new ArrayList(path)); return; } // for (int i = 0; i < graph[outIndex].length; i++) { // 处理 path.add(graph[outIndex][i]); // 递归 backtrack(graph, graph[outIndex][i]); // 撤销 path.removeLast(); } } } \"]},\"716\":{\"h\":\"785 判断二分图（双色问题）\",\"t\":[\"存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给你一个二维数组 graph ，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性： 不存在自环（graph[u] 不包含 u）。 不存在平行边（graph[u] 不包含重复值）。 如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图） 这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。 二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。\",\"如果图是二分图，返回 true ；否则，返回 false 。\",\"示例 1：\",\"输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]] 输出：false 解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。\",\"方法：双色问题的方法 二分图即每条边的两个节点属于分别属于两个独立的节点集合，那么我们可以用两种颜色来代表这两种集合，在遍历图的所有节点时，分别赋上不同的颜色，判断是否出现两个相邻节点颜色相同的情况。如若遍历中没有出现这种情况则代表此图为二分图。\",\"class Solution { // 记录图是否符合⼆分图性质 private boolean ok = true; // 记录图中节点的颜⾊，false 和 true 代表两种不同颜⾊ private boolean[] color; // 记录图中节点是否被访问过 private boolean[] visited; public boolean isBipartite(int[][] graph) { color = new boolean[graph.length]; visited = new boolean[graph.length]; // 图的遍历 遍历所有的节点下的路径 遇到已经访问过的则不遍历 for (int i = 0; i < graph.length; i++) { if (!visited[i]) { backtrack(graph, i); } } return ok; } // 图的单条路径遍历 使用回溯框架 即DFS private void backtrack(int[][] graph, int outIndex) { // 判断 if (!ok) return; visited[outIndex] = true; // 代表已经访问过该节点 // 递归遍历 for (int dot : graph[outIndex]) { if (!visited[dot]) { // 相邻的节点没有访问过 // 给这个节点涂上与上个节点不同的颜色 color[dot] = !color[outIndex]; // 回溯遍历 backtrack(graph, dot); } else { // 如果已经访问过 // 判断是否与上个节点颜色不同 if (color[dot] == color[outIndex]) { // 相同则不是二分图 ok = false; } } } } } \"]},\"717\":{\"h\":\"207 课程表\",\"t\":[\"你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。\",\"在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。\",\"例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。\",\"示例 1：\",\"输入：numCourses = 2, prerequisites = [[1,0]] 输出：true 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。\",\"方法：转换为图论问题中的查找是否有闭环问题 生成图结构\",\"利⽤布尔数组 path，如果遍历过程中发现下⼀个即将遍历的节点已经被标记为 true，说明遇到了环\",\"class Solution { private boolean ok = true; private boolean[] visited; private boolean[] path; public boolean canFinish(int numCourses, int[][] prerequisites) { List<Integer>[] graph = buildGraph(numCourses, prerequisites); visited = new boolean[numCourses]; path = new boolean[numCourses]; for (int i = 0; i < numCourses; i++) { if (!visited[i]) { backtrack(graph, i); } } return ok; } void backtrack(List<Integer>[] graph, int outIndex) { if (path[outIndex]) { // 出现了闭环 ok = false; return; } // 遍历到没有要求的课程 结束 if (graph[outIndex].isEmpty()) { return; } // visited[outIndex] = true; path[outIndex] = true; for (int dot : graph[outIndex]) { // 加入路径 backtrack(graph, dot); } path[outIndex] = false; } // 生成图结构 List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) { // 图中共有 numCourses 个节点 List<Integer>[] graph = new LinkedList[numCourses]; for (int i = 0; i < numCourses; i++) { graph[i] = new LinkedList<>(); } for (int[] edge : prerequisites) { int from = edge[0]; int to = edge[1]; // 修完课程 from 才能修课程 to // 在图中添加⼀条从 from 指向 to 的有向边 graph[from].add(to); } return graph; } } \"]},\"718\":{\"h\":\"4.26 华为笔试 批量初始化次数\",\"t\":[\"某部门在开发一个代码分析工具，需要分析代码模块之间的赖关系，用来确定模块的初始化顺序、是否有循环依赖等问题，\\\"就量初给化 是指-次可以初始化一个或多个块，例如提块1依赖模块2,模块3也依模块2，但模块1和3没有依赖关系。则必须先\\\"批量初始化”模块2，再“批量初始化“模块1和3。现给定一组模块间的依赖关系，请计算需要“批量初始化\\\"的次数。\",\"输入 (1)第1行只有一个数字,表示模块总数N。\",\"(2)随后的N行依次表示模块1到N的依赖数据。每行的第1个数据表示赖的模块数量不会超过N，之后的数字表示当前模块依赖的块1序列,该序列不会重复出现相同的数字,模块D的取值一定在1.N之内\",\"(3)模块总数N取值范围1<=N<=1000。\",\"(4)每一行里面的数字按1个空格分隔。\",\"输出 输出“批量初始化次数”,若有循环依赖无法完成初始化，则输出-1\",\"样例1\",\"输入: 5 3 2 3 4 1 5 1 5 1 5 输出:3 解释: 共5个模块。模块1依赖模块2、3、4;模块2依赖模块5;模块3依赖模块5;模块4依赖模块5;模块5没有依赖任何模块.批量初始化顺序为 {5)->(2,3,4]->(1]，共需\\\"批量初始化\\\"3次。 \",\"样例2\",\"输入: 3 1 2 1 3 1 1 输出:-1 解释:存在循环依赖，无法完成初始化，返回-1 \",\"方法：图的遍历 先构造图的数据结构List<LinkedList<Integer>> 里面的LinkedList记录了该Index模块的依赖模块列表，外面的List记录的是按顺序的模块列表（图也可表示成LinkedList<Integer>[]）\",\"再使用回溯算法遍历\",\"循环依赖通过判断 回溯path中是否有相同的节点 有则代表有循环依赖\",\"public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); // 输入处理 int n = sc.nextInt(); // 图结构 List<LinkedList<Integer>> dependency = new ArrayList<>(); for (int i = 0; i < n; i++) { LinkedList<Integer> list = new LinkedList<>(); int modNum = sc.nextInt(); for (int j = 0; j < modNum; j++) { list.add(sc.nextInt()); } dependency.add(list); } // 回溯算法 for (int i = 0; i < dependency.size(); i++) { backtrack(dependency, i); } // 输出结果 System.out.println(maxDepth); } static int maxDepth = 0; static LinkedList<Integer> path = new LinkedList<>(); static ArrayList<Integer> memo = new ArrayList<>(); // 备忘录 记录每一个模块的依赖深度 // 什么时候结束 当没有依赖时结束 // nums 表示待遍历的图 outIndex 表示模块的序号 static void backtrack(List<LinkedList<Integer>> nums, int outIndex) { // 出现循环依赖 直接终止后面的递归 if (-1 == maxDepth) { return; } // 遍历到没有依赖的模块 代表结束 if (nums.get(outIndex).isEmpty()) { maxDepth = Math.max(maxDepth, path.size() + 1); return; } for (int i = 0; i < nums.get(outIndex).size(); i++) { // 处理 int nextMod = nums.get(outIndex).get(i) - 1; if (path.contains(nextMod)) { // path中出现重复的模块说明存在循环依赖 返回值为-1 maxDepth = -1; return; } else { path.add(nextMod); } // 递归 backtrack(nums, nextMod); // 撤销选择 path.removeLast(); } } } \"]},\"719\":{\"h\":\"11 数据结构设计\"},\"720\":{\"h\":\"146 LRU缓存\",\"t\":[\"请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。 实现 LRUCache 类：\",\"LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存\",\"int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\",\"void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。\",\"函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。\",\"输入 [\\\"LRUCache\\\", \\\"put\\\", \\\"put\\\", \\\"get\\\", \\\"put\\\", \\\"get\\\", \\\"put\\\", \\\"get\\\", \\\"get\\\", \\\"get\\\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] 输出 [null, null, null, 1, null, -1, null, -1, 3, 4] 解释 LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // 缓存是 {1=1} lRUCache.put(2, 2); // 缓存是 {1=1, 2=2} lRUCache.get(1); // 返回 1 lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3} lRUCache.get(2); // 返回 -1 (未找到) lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3} lRUCache.get(1); // 返回 -1 (未找到) lRUCache.get(3); // 返回 3 lRUCache.get(4); // 返回 4 \",\"方法：该题的关键是找一个能满足函数 get 和 put 必须以 O(1) 的平均时间复杂度运行的数据结构\",\"哈希表查找快，但是数据⽆固定顺序；链表有顺序之分，插⼊删除快，但是查找慢，所以结合⼆者的⻓处， 可以形成⼀种新的数据结构：哈希链表 LinkedHashMap\",\"class LRUCache { int cap; // 缓存容量 LinkedHashMap<Integer, Integer> cache = new LinkedHashMap(); public LRUCache(int capacity) { this.cap = capacity; } // 删除key 重新插入到队尾 表示它最近使用过 private void makeRecently(int key) { int val = cache.get(key); // 删除key 重新插入到队尾 表示它最近使用过 cache.remove(key); cache.put(key, val); } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 将key变为最近使用 makeRecently(key); return cache.get(key); } public void put(int key, int value) { if (cache.containsKey(key)) { // 修改原key值 cache.put(key, value); // 最近使用 makeRecently(key); return; } // 缓存中不存在该key 且缓存已满 if (cache.size() >= this.cap) { // 删除头部的key 即最久未用的key int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); } // 将新的key添加到链表尾部 cache.put(key, value); } } \"]},\"721\":{\"h\":\"380 O(1)时间插入、删除和获取随机元素\",\"t\":[\"实现RandomizedSet 类：\",\"RandomizedSet() 初始化 RandomizedSet 对象 bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。 bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。 int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。 你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。\",\"方法：HashSet做不到随机在O(1)时间获取元素，必须使用紧凑数组\",\"数组可以快速的获取对应元素 所以使用数组来存储数据 但是使用数组 插入和删除的时间复杂度又不可能是O(1)\",\"所以我们需要用一个Map来记录元素对应的索引，这样插入和删除查找下标时可以直接通过Map来查找\",\"class RandomizedSet { // 存储元素的值 List<Integer> nums; // 记录每个元素对应在 nums 中的索引 Map<Integer, Integer> indices; // 随机数 Random random; public RandomizedSet() { nums = new ArrayList<Integer>(); indices = new HashMap<Integer, Integer>(); random = new Random(); } public boolean insert(int val) { if (indices.containsKey(val)) { return false; } int index = nums.size(); nums.add(val); indices.put(val, index); return true; } public boolean remove(int val) { if (!indices.containsKey(val)) { return false; } // 待删除数的索引 int index = indices.get(val); int last = nums.get(nums.size() - 1); // 末尾数替换到删除数的位置 nums.set(index, last); // 末尾数的索引更改为删除数的索引 indices.put(last, index); // 删除nums末尾的多余数 nums.remove(nums.size() - 1); // 删除val对应的索引 indices.remove(val); return true; } public int getRandom() { int randomIndex = random.nextInt(nums.size()); return nums.get(randomIndex); } } \"]},\"722\":{\"h\":\"ACM输入输出\"},\"723\":{\"h\":\"1 多行输入\"},\"724\":{\"h\":\"示例\",\"t\":[\"输入： 5 10 9 0 5 9 1 8 1 0 1 9 100 \",\"import java.util.Arrays; import java.util.Scanner; public class MultilineInput { public static void main(String[] args) { //Scanner类默认的分隔符就是空格 Scanner sc=new Scanner(System.in); while(sc.hasNext()){ int n=sc.nextInt(); int full=sc.nextInt(); int avg=sc.nextInt(); int[][] nums=new int[n][2]; for(int i=0;i<n;i++){ nums[i][0]=sc.nextInt(); nums[i][1]=sc.nextInt(); } // 输出描述: // 一行输出答案。 // 输出 // 43 System.out.println(time); } } } \"]},\"725\":{\"h\":\"2 数组输入\"},\"726\":{\"h\":\"示例\",\"t\":[\"输入例子: 7 15 15 5 3 7 9 14 0 \"]},\"727\":{\"h\":\"2.1 读取一维数组\",\"t\":[\"Scanner cin = new Scanner(System.in); while(cin.hasNext()) { int r = cin.nextInt(); // 行数 int[] matrix = new int[r]; cin.nextLine(); // 跳过行数后的换行符 for(int i=0;i<r;i++) { for (int j = 0; j < c; j++) { matrix[i] = cin.nextInt(); } } } \"]},\"728\":{\"h\":\"2.2 读取二维数组\",\"t\":[\"如果要求的测试用例需要读取二维数组，我们应该先读取二维数组的长度和宽度存在两个整数中。在下一行将一串整型数字存入二维数组中。 注意：为了换行读取可以使用nextLine()跳过换行;\",\"Scanner cin = new Scanner(System.in); while(cin.hasNext()) { int r = cin.nextInt(); int c = cin.nextInt(); int[][] matrix = new int[r][c]; cin.nextLine(); // 跳过行数和列数后的换行符 for(int i=0;i<r;i++) { for (int j = 0; j < c; j++) { matrix[i][j] = cin.nextInt(); } } } \"]},\"729\":{\"h\":\"3 链表输入\",\"t\":[\"以反转链表为例\",\"import java.util.Scanner; import java.util.Stack; public class LinkListInput { //题目描述 //对于一个链表 L: L0→L1→…→Ln-1→Ln, //将其翻转成 L0→Ln→L1→Ln-1→L2→Ln-2→… //先构建一个节点类，用于链表构建 static class LinkNode { int val; LinkNode next; public LinkNode(int val){ this.val = val; } } public static void main(String[] args){ //输入是一串数字，请将其转换成单链表格式之后，再进行操作 //输入描述: //一串数字，用逗号分隔 //输入 //1,2,3,4,5 Scanner scanner = new Scanner(System.in); //以字符串形式作为输入 String str = scanner.next().toString(); //通过分隔符将其转为字符串数组 String[] arr = str.split(\\\",\\\"); //初始化一个整数数组 int[] ints = new int[arr.length]; //给整数数组赋值 for(int j = 0; j<ints.length;j++) { ints[j] = Integer.parseInt(arr[j]); } Stack<LinkNode> stack = new Stack<>(); LinkNode head = new LinkNode(0); LinkNode p = head; //链表初始化并放入stack中 for(int i = 0; i < ints.length; i++){ p.next = new LinkNode(ints[i]); p = p.next; stack.add(p); } head = head.next; //开始链表转换 p = head; LinkNode q = stack.peek(); while ((!p.equals(q)) && (!p.next.equals(q))) { q = stack.pop(); q.next = p.next; p.next = q; p = p.next.next; q = stack.peek(); } q.next = null; //输出 //1,5,2,4,3 //打印 while (head != null) { if(head.next == null){ System.out.print(head.val); }else{ System.out.print(head.val + \\\",\\\"); } head = head.next; } } } \"]},\"730\":{\"h\":\"4 树的输入\",\"t\":[\"以判断是否是二叉搜索树为例\",\"把node.val存入数组，把对应的左右节点的值也存入数组\",\"import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Stack; //题目描述 //给定一个二叉树，判断其是否是一个有效的二叉搜索树。 //假设一个二叉搜索树具有如下特征： //节点的左子树只包含小于当前节点的数。 //节点的右子树只包含大于当前节点的数。 //所有左子树和右子树自身必须也是二叉搜索树。 //例如： //输入： // 5 // / \\\\ // 1 3 // / \\\\ // 4 6 //输出: false //构造树需要的结点类 class TreeNode { TreeNode left, right; int val; public TreeNode(int val) { this.val = val; } } public class TreeInput { public static void main(String[] args) throws IOException { //输入描述: //第一行两个数n,root，分别表示二叉树有n个节点，第root个节点时二叉树的根 //接下来共n行，第i行三个数val_i,left_i,right_i， //分别表示第i个节点的值val是val_i,左儿子left是第left_i个节点，右儿子right是第right_i个节点。 //节点0表示空。 //1<=n<=100000,保证是合法的二叉树 //输入 //5 1 //5 2 3 //1 0 0 //3 4 5 //4 0 0 //6 0 0 BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); String[] s = reader.readLine().split(\\\" \\\"); int n = Integer.parseInt(s[0]); int root = Integer.parseInt(s[1]); TreeNode[] tree = new TreeNode[n + 1]; int[][] leaf = new int[n + 1][2]; for (int i = 1; i <= n; i++) { String[] ss = reader.readLine().split(\\\" \\\"); int val_i = Integer.parseInt(ss[0]); int left_i = Integer.parseInt(ss[1]); int right_i = Integer.parseInt(ss[2]); TreeNode node = new TreeNode(val_i); leaf[i][0] = left_i; leaf[i][1] = right_i; tree[i] = node; } for (int i = 1; i <= n; i++) { int left = leaf[i][0]; if (left != 0) { tree[i].left = tree[left]; } else { tree[i].left = null; } int right = leaf[i][1]; if (right != 0) { tree[i].right = tree[right]; } else { tree[i].right = null; } } TreeNode head = tree[root]; boolean flag = isBinarySearchTree(head); System.out.println(flag); } private static boolean isBinarySearchTree(TreeNode node) { if(node == null){ return true; } int pre = Integer.MIN_VALUE; Stack<TreeNode> s = new Stack<>(); while(!s.isEmpty() || node != null){ while(node != null){ s.push(node); node = node.left; } node = s.pop(); if(node == null){ break; } if(pre > node.val){ return false; } pre = node.val; node = node.right; } return true; } } \",\"作者：小雨Coding\\n链接：https://www.jianshu.com/p/4be070789f7a\"]},\"731\":{\"h\":\"剑指Offer\"},\"732\":{\"h\":\"剑指 Offer 13. 机器人的运动范围\"},\"733\":{\"h\":\"思路\",\"t\":[\"有约束的dfs题\",\"输入给了二维数组信息和约束条件\",\"返回值为int\"]},\"734\":{\"h\":\"题解\",\"t\":[\"class Solution { public int movingCount(int m, int n, int k) { // 生成二维方格数组 int[][] board = new int[m][n]; return dfs(board, 0, 0, k); } int dfs(int[][] board, int i, int j, int k) { // 如果超出数组边界，数位和大于k，走到遍历过的区域返回0 if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || calcSum(i) + calcSum(j) > k || board[i][j] == -1) return 0; // 防止访问同一片区域 遍历过的区域打上标记 board[i][j] = -1; return 1 + dfs(board, i + 1, j, k) + dfs(board, i - 1, j, k) + dfs(board, i, j + 1, k) + dfs(board, i , j - 1, k); } // 计算一个数的数位之和 static int calcSum(int x) { int sum = 0; while (x != 0) { sum += x % 10; x /= 10; } return sum; } } \"]},\"735\":{\"h\":\"剑指 Offer 14- I. 剪绳子\"},\"736\":{\"h\":\"思路\",\"t\":[\"动态规划题\",\"重复子问题为不同长度的绳子 剪完子段的最大乘积\",\"状态转移：dp[i] 与前面的状态有什么关系 长度i 剪一段j ，分为长度j 和长度i-j 两段，这时最大乘积就有两种选择，一种是最大乘积为这两段的乘积j×(1-j) ，两一种是将其中一段继续剪，那样最大乘积就为j×dp[i-j]。 这样就确定了状态转移方程\"]},\"737\":{\"h\":\"题解\",\"t\":[\"class Solution { public int cuttingRope(int n) { int[] dp = new int[n + 1]; dp[2] = 1; for (int i = 3; i < n + 1; i++) { int curMax = 0; // 遍历所有剪法 找到一个当前长度的乘积最大剪法 for (int j = 2; i - j > 0; j++) { curMax = Math.max(dp[i - j] * j, (i - j) * j); dp[i] = Math.max(dp[i], curMax); } } return dp[n]; } } \"]},\"738\":{\"h\":\"剑指 Offer 14- II. 剪绳子 II\"},\"739\":{\"h\":\"思路\",\"t\":[\"该题与上题逻辑相同，多了一步大数取模\",\"在每一步的操作上都要取模，取模后的结果无法用Math.max()来比较，所以本体无法使用动态规划\",\"使用贪心算法，每3剪一次绳，此时的乘积最大\"]},\"740\":{\"h\":\"题解\",\"t\":[\"class Solution { public int cuttingRope(int n) { if(n == 2) return 1; if(n == 3) return 2; long res = 1; while(n > 4){ res *= 3; res = res % 1000000007; n -= 3; } return (int)(res * n % 1000000007); } } \"]},\"741\":{\"h\":\"剑指 Offer 16. 数值的整数次方\"},\"742\":{\"h\":\"思路\",\"t\":[\"常规的循环相乘x 的方法会超时\",\"使用快速幂法，二分法的思路，把幂指数二分，这样时间复杂度就变成了log2N\",\"class Solution { public double myPow(double x, int n) { if(x == 0) return 0; long b = n; double res = 1.0; if(b < 0) { x = 1 / x; b = -b; } while(b > 0) { if((b % 2) == 1) res *= x; x *= x; b /= 2; } return res; } } \"]},\"743\":{\"h\":\"HTTP笔记\"},\"744\":{\"h\":\"第一章 了解Web及网络基础\"},\"745\":{\"h\":\"1.2 HTTP的诞生\"},\"746\":{\"h\":\"3项WWW构建技术\",\"t\":[\"SGML（标准通用标记语言）\",\"HTML（超文本标记语言）：作为页面的文本标记语言\",\"HTTP：文档传递协议\",\"URL（统一资源定位符）：指定文档所在地址\"]},\"747\":{\"h\":\"1.3 网络基础 TCP/IP\",\"t\":[\"通常使用的网络是在TCP/IP协议族的基础上运作的，HTTP属于它的子集\"]},\"748\":{\"h\":\"TCP/IP协议族\",\"t\":[\"image-20220424153500110\"]},\"749\":{\"h\":\"TCP/IP的分层管理\",\"t\":[\"TCP/IP分为4层：应用层、传输层、网络层、数据链路层\",\"应用层决定了向用户提供应用服务时通信的活动（HTTP、FTP）\",\"传输层提供处于网络连接中的两台计算机的数据传输（TCP、UDP）\",\"网络层用来处理网络上流动的数据包（IP）\",\"链路层用来处理连接网络的硬件部分（设备驱动、网络适配器）\"]},\"750\":{\"h\":\"TCP/IP通信传输\",\"t\":[\"image-20220424161324998\",\"数据每通过一层都会加上该层的首部\",\"image-20220424161516323\"]},\"751\":{\"h\":\"1.4 与HTTP关系密切的协议\"},\"752\":{\"h\":\"负责传输的IP协议\",\"t\":[\"IP地址指明了节点被分配到的地址\",\"MAC地址是网卡所属的固定地址\",\"中转时使用ARP协议 根据MAC地址发送\"]},\"753\":{\"h\":\"确保可靠性的TCP协议\",\"t\":[\"字节流传输：把大块数据分割成报文段为单位的数据包进行管理\",\"确保数据能准确发送：发送后会进行三次握手，确保数据发送成功\",\"image-20220424163837296\"]},\"754\":{\"h\":\"1.5 负责域名解析的DNS服务\",\"t\":[\"DNS是HTTP一样位于应用层的协议，提供域名到IP地址之间的解析服务，或逆向从IP地址反查域名的服务\",\"xxx.com就是域名，DNS把它转成IP地址\",\"​ \"]},\"755\":{\"h\":\"1.6 HTTP通信的流程\",\"t\":[\"image-20220424164647288\"]},\"756\":{\"h\":\"1.7 URI和URL\"},\"757\":{\"h\":\"统一资源标识符（URI）\",\"t\":[\"URI的格式\",\"image-20220424164952584\",\"登录信息：指定用户名和密码作为从服务器获得资源时的登录信息（可选）\",\"服务器地址：可以是xxx.com的DNS可解析域名也可以是IP地址\",\"端口号：指定服务器连接的网络端口号（可选）\",\"带层次的文件路径：指定服务器上的文件路径来定位资源\",\"查询字符串：针对指定的资源可以使用查询字符串传入任意参数（可选）\",\"片段标识符：标记出已经获得资源中的子资源（比如文档的某个位置）（可选）\"]},\"758\":{\"h\":\"第二章 简单的HTTP协议\"},\"759\":{\"h\":\"2.1 HTTP用于客户端和服务器端之间的通信\",\"t\":[\"客户端发送请求，服务器应答，通过HTTP协议能够明确区分两端\"]},\"760\":{\"h\":\"2.2 通过请求和响应的交换达成通信\",\"t\":[\"下面是一个客户端的请求报文\",\"GET /index.htm HTTP/1.1 Host: hackr.jp Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: 16 name=ueno&age=37 \",\"GET 表示方法，/index.htm 指明了访问的资源对象，最后的HTTP/1.1 表示HTTP协议的版本号\",\"中间的是请求首部字段、\",\"最下面是内容实体\",\"下面是一个服务器的响应报文\",\"HTTP/1.1 200 OK Date: Tue, 10 Jul 2012 06:50:15 GMT Content-Length: 362 Content-Type: text/html <html> ... \",\"HTTP/1.1 表示HTTP协议的版本号，200 表示请求处理结果的状态码，OK 是原因短语\",\"中间是首部字段，显示时间和一些内容属性\",\"空行之后是内容的实体\"]},\"761\":{\"h\":\"2.3 HTTP不保存之前状态\",\"t\":[\"HTTP协议自身不对请求和响应做持久化处理，为了保存状态引入了Cookie技术\"]},\"762\":{\"h\":\"2.4 URI定位资源\",\"t\":[\"多种URI请求方式\",\"完整URI\",\"GET http://hackr.jp/index.htm HTTP/1.1 \",\"再首部字段Host中写明域名或IP地址\",\"GET /index.htm HTTP/1.1 Host: hackr.jp \",\"对服务器自身发送请求\",\"OPTIONS * HTTP/1.1 \",\"上面表示查询HTTP服务器端支持的HTTP方法种类\"]},\"763\":{\"h\":\"2.5 告知服务器意图的 HTTP方法\",\"t\":[\"image-20220530215006775\",\"GET：获取资源\",\"image-20220530214309518\",\"POST：传输实体\",\"image-20220530214320409\",\"image-20220530214336582\",\"PUT：传输文件\",\"image-20220530214406072\",\"HEAD：获取报文首部\",\"HEAD方法和GET方法的区别在于不返回报文的主体部分，用于确认URI的有效性及资源的更新日期时间\",\"DELETE：删除文件\",\"OPTIONS：询问支持\",\"image-20220530214737632\",\"TRACE：追踪路径\",\"image-20220530214816605\",\"CONNECT：要求用隧道协议链接代理\",\"通过代理服务器把通信内容加密后经网络隧道传输\",\"image-20220530214941450\"]},\"764\":{\"h\":\"2.7 持久连接节省通信量\",\"t\":[\"旧版的HTTP协议每次发送HTTP请求时都要断开TCP连接\",\"新版只要任意一端没有明确提出断开连接，则保持TCP连接状态\",\"管线化使得不用等待前一个请求的响应即可发送下一个请求，并行发送\"]},\"765\":{\"h\":\"2.8 使用Cookie的状态管理\",\"t\":[\"Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态\",\"在报文内加入一个叫Set-Cookie的首部字段信息，通知客户端保存Cookie，下次客户端再发送请求时会自动在请求报文中加入Cookie值后发送\",\"服务器发现客户端发送的Cookie后会对比服务器上的记录，得到之前的状态信息\",\"image-20220530220550805\",\"image-20220530220602402\",\"image-20220530220734131\"]},\"766\":{\"h\":\"第三章 HTTP报文内的HTTP信息\"},\"767\":{\"h\":\"3.1 HTTP报文\",\"t\":[\"HTTP报文结构如下\",\"image-20220601083458070\",\"请求报文和响应报文的结构如下\",\"image-20220601083542688\"]},\"768\":{\"h\":\"3.3 编码 提升传输速率\",\"t\":[\"介绍\",\"HTTP在传输时可以按照原数据直接传输，也可以通过编码来提升传输速率\",\"一个报文分为报文首部和报文主体，报文主体是用来传输主体（entity）\",\"HTTP的内容编码是用在实体上的编码格式\",\"常见的编码格式有\",\"gzip（GNU zip）\",\"compress（UNIX 系统的标准压缩）\",\"deflate（zlib）\",\"identity（不进行编码）\",\"分割发送的分块传输编码\",\"在HTTP通信中，请求的编码实体资源在尚未传输完成时，页面是无法显示的，所以在传输大容量数据时，一般将编码实体资源进行分块，这样传输过程中可以让浏览器逐步显示页面，这种技术叫分块传输编码（Chunked Transfer Coding）\",\"image-20220601090527855\",\"其中每一块都会由一个16进制数来标记块的大小，最后一块会使用“0（CR+LF）”来标记\"]},\"769\":{\"h\":\"3.4 发送多种数据的 多部分对象集合\",\"t\":[\"HTTP 协议采用了类似MIME机制（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）发送的一份报文可以含有多类型实体\",\"多部分对象集合包含\",\"form-data：上传Web表单时使用\",\"byteranges：\",\"在HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type\"]},\"770\":{\"h\":\"3.5 获取部分内容的 范围请求\",\"t\":[\"为了解决下载过程中的网络中断问题，需要一种可恢复的机制，即从中断处恢复下载\",\"从中断处继续下载，就要像服务器请求从中断处开始的范围内容，即范围请求（Range Request），对一份10 000字节大小的资源可以只请求 5001~10 000字节内的资源\",\"image-20220601151244206\",\"byte范围的指定形式如下\",\"image-20220601151351231\",\"针对范围请求，响应会返回状态码 206 Partial Content，如果是多重范围请求则会在 Content-Type 标明 multipart/byteranges\"]},\"771\":{\"h\":\"3.6 内容协商 返回最合适的内容\",\"t\":[\"同一个网站可能存在多份相同内容的页面，比如可能存在一份英文版和中文版的页面，根据浏览器的默认语言来切换，这就是内容协商机制\",\"包含在请求报文中的某些首部字段就是判断基准\",\"Accept\",\"Accept-Charset\",\"Accept-Encoding\",\"Accept-Language\",\"Content-Language\",\"内容协商技术有以下3种类型\",\"服务器驱动协商\",\"由服务器端进行协商，以请求报文的首部字段为参考，在服务器端处理\",\"客户端驱动协商\",\"用户从浏览器显示的可选项列表中手动选择，还可以利用JS脚本在Web页面上自动进行选择。比如按OS类型自动切换成PC版或手机版页面\",\"透明协商\",\"服务器驱动协商和客户端驱动协商的结合体，服务器端和客户端各自进行内容协商\"]},\"772\":{\"h\":\"第四章 返回结果的HTTP状态码\"},\"773\":{\"h\":\"4.1 状态码 告知从服务器端返回得请求结果\",\"t\":[\"状态码是服务器端响应时得请求结果\",\"image-20220606104624138\",\"状态码类别\",\"image-20220606104655840\",\"遵守以上定义，可以自定义状态码\"]},\"774\":{\"h\":\"4.2 2XX 成功状态码\",\"t\":[\"200 OK：表示客户端发来得请求在服务器端被正常处理了\",\"204 No Content：表示请求已正确处理，但响应报文中不包含实体得主体部分\",\"206 Partial Content：表示对范围请求的正确处理\",\"image-20220606105213896\"]},\"775\":{\"h\":\"4.3 3XX 重定向状态码\",\"t\":[\"301 Moved Permanently：永久重定向，表示请求的资源已被分配了新的URI\",\"image-20220606105546497\",\"302 Found：临时性重定向，表示请求的资源已被分配了新的URI，希望用户能够使用新的URI访问\",\"image-20220606105657052\",\"303 See Other：表示由于请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源，与302的区别在于指明采用 GET 方法\",\"image-20220606105946593\",\"304 Not Modified：表示当客户端发送附带条件的请求时，服务器允许访问资源，但未满足条件\",\"image-20220606153105058\",\"307 Temporary Redirect：临时重定向\"]},\"776\":{\"h\":\"4.4 4XX 客户端错误状态码\",\"t\":[\"400 Bad Request：报文中存在语法错误\",\"401 Unauthorized：请求 HTTP 验证\",\"image-20220606153504993\",\"403 Forbidden：请求资源的访问被服务器拒绝\",\"404 Not Found：服务器上没有请求的资源\"]},\"777\":{\"h\":\"4.5 5XX 服务器错误状态码\",\"t\":[\"500 Internet Server Error：服务器端在执行请求时发生错误\",\"503 Service Unavailable：服务器超载或正在停机维护\"]},\"778\":{\"h\":\"第五章 与 HTTP 协作的 Web 服务器\",\"t\":[\"一台 Web 服务器可搭建多个独立域名的 Web 网站，也可做为中转服务器提升传输效率\"]},\"779\":{\"h\":\"5.1 用单台虚拟主机实现多个域名\",\"t\":[\"HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点，只要使用虚拟主机的功能\",\"image-20220607101723849\",\"如果一台服务器内托管了多个域名，当收到请求时就需要弄清究竟要访问那个域名，发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI\",\"image-20220607102537456\"]},\"780\":{\"h\":\"5.2 通信数据转发程序：代理、网关、隧道\",\"t\":[\"这些应用程序可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端\",\"代理\",\"代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端之间的“中间人”角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端\",\"image-20220607150540596\",\"在 HTTP 通信过程中，可级联多台代理服务器，转发时需要附加 Via 首部字段以标记出经过的代理服务器信息\",\"缓存代理：将资源副本缓存在代理服务器上\",\"透明代理：不对报文做任何处理加工\",\"网关\",\"网关是转发其他服务器通信数据的服务器，接收到客户端的请求时，它就像自己拥有资源的源服务器一样对请求进行处理\",\"网关的机制和代理相似，而网关能使通信线路上的服务器提供非 HTTP 服务\",\"image-20220607153136712\",\"利用网关可以提高通信的安全性\",\"隧道\",\"隧道是在相隔甚远的客户端和服务器之间进行中转，并保持双方通信连接的应用程序\",\"隧道的目的是确保客户端与服务器，使用 SSL 等加密手段进行通信，隧道本身不会去解析 HTTP 请求\",\"image-20220607154559474\"]},\"781\":{\"h\":\"5.3 保存资源的缓存\",\"t\":[\"缓存指代理服务器保存的资源副本\",\"image-20220607161416653\",\"缓存的有效期限\",\"image-20220607162623180\",\"客户端的缓存\",\"客户端也可以有缓存，称为临时网络文件，一样会过期\",\"image-20220607162710737\"]},\"782\":{\"h\":\"第六章 HTTP 首部\"},\"783\":{\"h\":\"6.1 HTTP 报文首部\",\"t\":[\"HTTP 报文得结构为\",\"image-20220613160632816\",\"报文首部又分为\",\"image-20220613161119615\"]},\"784\":{\"h\":\"6.2 HTTP 首部字段\",\"t\":[\"使用首部字段是为了给浏览器和服务器提供报文主体大小，所使用得语言、认证信息等内容。\",\"HTTP 首部字段格式\",\"image-20220613161217832\",\"4 种 HTTP 首部字段类型\",\"首部字段根据实际用途被分为4类\",\"通用首部字段\",\"请求首部字段\",\"响应首部字段\",\"实体首部字段\",\"首部字段一览\"]},\"785\":{\"h\":\"6.7 为 Cookie 服务的首部字段\",\"t\":[\"Set-Cookie\",\"格式为：\",\"各字段值：\",\"image-20220613162920590\",\"Cookie\",\"首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到 Cookie。\",\"image-20220613163248334\"]},\"786\":{\"h\":\"6.8 其他首部字段\",\"t\":[\"X-Frame-Options\",\"image-20220613163630941\",\"X-XSS-Protection\",\"image-20220613163715233\",\"DNT\",\"image-20220613163753679\",\"P3P\",\"image-20220613163853802\"]},\"787\":{\"h\":\"第七章 确保 Web 安全的 HTTPS\"},\"788\":{\"h\":\"Cpp\"},\"789\":{\"h\":\"Database\"},\"790\":{\"h\":\"Essay\"},\"791\":{\"h\":\"Java\"},\"792\":{\"h\":\"Leetcode\"},\"793\":{\"h\":\"Network\"}},\"dirtCount\":0,\"index\":[[\"透明代理\",{\"1\":{\"780\":1}}],[\"透明协商\",{\"1\":{\"771\":1}}],[\"角色\",{\"1\":{\"780\":1}}],[\"角色不同\",{\"1\":{\"69\":1}}],[\"隧道本身不会去解析\",{\"1\":{\"780\":1}}],[\"隧道的目的是确保客户端与服务器\",{\"1\":{\"780\":1}}],[\"隧道是在相隔甚远的客户端和服务器之间进行中转\",{\"1\":{\"780\":1}}],[\"隧道\",{\"0\":{\"780\":1},\"1\":{\"780\":1}}],[\"规范允许一台\",{\"1\":{\"779\":1}}],[\"规则和数组类似\",{\"1\":{\"386\":1}}],[\"希望用户能够使用新的uri访问\",{\"1\":{\"775\":1}}],[\"永久重定向\",{\"1\":{\"775\":1}}],[\"遵守以上定义\",{\"1\":{\"773\":1}}],[\"管线化使得不用等待前一个请求的响应即可发送下一个请求\",{\"1\":{\"764\":1}}],[\"管理镜像\",{\"1\":{\"611\":1}}],[\"管理指用\",{\"1\":{\"557\":1}}],[\"管理员\",{\"1\":{\"501\":1}}],[\"管理数据\",{\"1\":{\"348\":1}}],[\"管理\",{\"0\":{\"556\":1,\"557\":1,\"561\":1},\"1\":{\"165\":1,\"547\":1}}],[\"管理建造出来的实例的依赖关系\",{\"1\":{\"107\":1}}],[\"旧版的http协议每次发送http请求时都要断开tcp连接\",{\"1\":{\"764\":1}}],[\"追踪路径\",{\"1\":{\"763\":1}}],[\"追加模式\",{\"1\":{\"477\":1}}],[\"追加到文件后面\",{\"1\":{\"477\":1}}],[\"询问支持\",{\"1\":{\"763\":1}}],[\"告知从服务器端返回得请求结果\",{\"0\":{\"773\":1}}],[\"告知服务器意图的\",{\"0\":{\"763\":1}}],[\"告诉服务器当前配置的地址给哪个程序使用\",{\"1\":{\"327\":1}}],[\"告诉了\",{\"1\":{\"70\":1}}],[\"片段标识符\",{\"1\":{\"757\":1}}],[\"登录信息\",{\"1\":{\"757\":1}}],[\"登录系统的cookie和session如何设计\",{\"0\":{\"165\":1}}],[\"了解web及网络基础\",{\"0\":{\"744\":1}}],[\"了解oom的具体原因和位置\",{\"1\":{\"146\":1}}],[\"剪一段j\",{\"1\":{\"736\":1}}],[\"剪完子段的最大乘积\",{\"1\":{\"736\":1}}],[\"剪绳子\",{\"0\":{\"735\":1,\"738\":1}}],[\"剪枝\",{\"1\":{\"689\":1,\"690\":1,\"701\":1}}],[\"剪枝优化\",{\"1\":{\"683\":1,\"687\":1}}],[\"走到遍历过的区域返回0\",{\"1\":{\"734\":1}}],[\"走线\",{\"1\":{\"104\":1}}],[\"题解\",{\"0\":{\"734\":1,\"737\":1,\"740\":1}}],[\"题目描述\",{\"1\":{\"729\":1,\"730\":1}}],[\"题意\",{\"1\":{\"634\":1,\"636\":1}}],[\"待删除数的索引\",{\"1\":{\"721\":1}}],[\"逐出\",{\"1\":{\"720\":1}}],[\"逐个翻转字符串中的每个单词\",{\"1\":{\"645\":1}}],[\"约束的数据结构\",{\"1\":{\"720\":1}}],[\"外面的list记录的是按顺序的模块列表\",{\"1\":{\"718\":1}}],[\"外部属性文件\",{\"0\":{\"562\":1}}],[\"外部其他类不能访问局部内部类\",{\"1\":{\"418\":1}}],[\"外部类需要先创建对象再调用\",{\"1\":{\"418\":1}}],[\"外部类f3\",{\"1\":{\"418\":1}}],[\"外部类n1\",{\"1\":{\"418\":1}}],[\"外部类访问局部类要先创建局部类对象再访问其成员\",{\"1\":{\"418\":2}}],[\"外部类\",{\"1\":{\"418\":1}}],[\"样例2\",{\"1\":{\"718\":1}}],[\"样例1\",{\"1\":{\"718\":1}}],[\"样式化\",{\"0\":{\"35\":1}}],[\"某部门在开发一个代码分析工具\",{\"1\":{\"718\":1}}],[\"华为笔试\",{\"0\":{\"718\":1}}],[\"华为机考\",{\"0\":{\"88\":1}}],[\"利⽤布尔数组\",{\"1\":{\"717\":1}}],[\"利用网关可以提高通信的安全性\",{\"1\":{\"780\":1}}],[\"利用备忘录当在同一位置\",{\"1\":{\"687\":1}}],[\"利用resttemplate发起http请求\",{\"1\":{\"597\":1}}],[\"利用反射分析类的能力\",{\"1\":{\"486\":1}}],[\"利用反射机制\",{\"1\":{\"419\":1}}],[\"利用method对象\",{\"1\":{\"486\":1}}],[\"利用代理可以在运行时创建实现一组给定接口的新类\",{\"1\":{\"419\":1}}],[\"利用多个处理单元或多台计算机来同时处理不同的任务\",{\"1\":{\"151\":1}}],[\"利用其中的阻塞和唤醒机制实现线程的等待和通知\",{\"1\":{\"144\":1}}],[\"利用已有的一个原型对象\",{\"1\":{\"116\":1}}],[\"利用\",{\"1\":{\"72\":1,\"159\":1,\"567\":1}}],[\"学习课程\",{\"1\":{\"717\":1}}],[\"想要学习课程\",{\"1\":{\"717\":1}}],[\"想在国外插线充电\",{\"1\":{\"95\":1}}],[\"门课程\",{\"1\":{\"717\":2}}],[\"课程表\",{\"0\":{\"717\":1}}],[\"既然输⼊的图是无环的\",{\"1\":{\"715\":1}}],[\"既可以消除不同节点流的的实现差异\",{\"1\":{\"478\":1}}],[\"未找到\",{\"1\":{\"720\":2}}],[\"未遍历且不在deadend中的相邻节点加入队列\",{\"1\":{\"713\":1}}],[\"未出租\",{\"1\":{\"408\":3}}],[\"讲起点加入队列\",{\"1\":{\"711\":1}}],[\"讲讲一个http请求发到controller的过程\",{\"0\":{\"161\":1}}],[\"讲讲jmm内存模型\",{\"0\":{\"140\":1}}],[\"ｘ\",{\"1\":{\"709\":1}}],[\"ｘ为二维数组的一维索引\",{\"1\":{\"709\":2}}],[\"点替换为\",{\"1\":{\"709\":1}}],[\"ｏ\",{\"1\":{\"709\":1}}],[\"ｙ为二维数组的二维索引\",{\"1\":{\"709\":2}}],[\"填充\",{\"1\":{\"709\":1}}],[\"围绕的区域\",{\"1\":{\"709\":1}}],[\"围成一圈\",{\"1\":{\"698\":1}}],[\"灰色区域的岛屿是封闭岛屿\",{\"1\":{\"708\":1}}],[\"封闭岛屿\",{\"1\":{\"708\":1}}],[\"封闭岛是一个\",{\"1\":{\"708\":1}}],[\"封装user到order\",{\"1\":{\"597\":1}}],[\"封装到一起\",{\"1\":{\"417\":1}}],[\"封装实现步骤\",{\"1\":{\"398\":1}}],[\"封装在一起\",{\"1\":{\"398\":1}}],[\"封装就是把抽象出的数据\",{\"1\":{\"398\":1}}],[\"封装\",{\"0\":{\"398\":1}}],[\"封装不变部分\",{\"1\":{\"104\":1}}],[\"封装了\",{\"1\":{\"72\":1,\"495\":1}}],[\"岛是由最大的4个方向连通的\",{\"1\":{\"708\":1}}],[\"岛屿的最大面积\",{\"0\":{\"707\":1}}],[\"岛屿总是被水包围\",{\"1\":{\"706\":1}}],[\"岛屿数量\",{\"0\":{\"706\":1}}],[\"土地\",{\"1\":{\"708\":1}}],[\"统计封闭岛屿的数目\",{\"0\":{\"708\":1}}],[\"统一资源标识符\",{\"0\":{\"757\":1}}],[\"统一资源定位符\",{\"1\":{\"746\":1}}],[\"统一网关gateway\",{\"0\":{\"607\":1}}],[\"统一配置管理\",{\"0\":{\"602\":1}}],[\"淹掉\",{\"1\":{\"707\":1,\"708\":1,\"709\":2}}],[\"淹没相邻的陆地\",{\"1\":{\"706\":1,\"707\":1,\"708\":1,\"709\":2}}],[\"陆地\",{\"1\":{\"706\":1}}],[\"矩阵中的路径\",{\"0\":{\"705\":1}}],[\"匹配零个或多个前面的那一个元素\",{\"1\":{\"702\":1}}],[\"匹配任意单个字符\",{\"1\":{\"702\":1}}],[\"匹配所有的html结尾的文件\",{\"1\":{\"343\":1}}],[\"背包没有空间时\",{\"1\":{\"701\":1}}],[\"背包问题参数\",{\"1\":{\"701\":1}}],[\"背包问题模板\",{\"0\":{\"700\":1},\"1\":{\"701\":1}}],[\"背包容量不够\",{\"1\":{\"700\":1}}],[\"首部字段一览\",{\"1\":{\"784\":1}}],[\"首部字段根据实际用途被分为4类\",{\"1\":{\"784\":1}}],[\"首部字段类型\",{\"1\":{\"784\":1}}],[\"首部字段格式\",{\"1\":{\"784\":1}}],[\"首部字段\",{\"0\":{\"784\":1},\"1\":{\"785\":1}}],[\"首部字段以标记出经过的代理服务器信息\",{\"1\":{\"780\":1}}],[\"首部\",{\"0\":{\"782\":1}}],[\"首部内完整指定主机名或域名的\",{\"1\":{\"779\":1}}],[\"首不抢尾抢\",{\"1\":{\"698\":1}}],[\"首抢尾不抢\",{\"1\":{\"698\":1}}],[\"首尾都不抢\",{\"1\":{\"698\":1}}],[\"首先按照上一步\",{\"1\":{\"628\":1}}],[\"首先看子类是否有该属性\",{\"1\":{\"399\":1}}],[\"首先需要明确的是\",{\"1\":{\"318\":1}}],[\"首先调用interupt方法\",{\"1\":{\"267\":1}}],[\"首先检查singletonobjects\",{\"1\":{\"163\":1}}],[\"首先\",{\"1\":{\"146\":1,\"260\":1,\"267\":1}}],[\"首先会由当前类加载器\",{\"1\":{\"147\":1}}],[\"首先会尝试获取对象的monitor锁\",{\"1\":{\"139\":1}}],[\"首先会判断创建的对象值是否在\",{\"1\":{\"130\":1}}],[\"首先从远程的origin的master主分支下载最新的版本到origin\",{\"1\":{\"86\":1}}],[\"首先用户发送请求\",{\"1\":{\"76\":1}}],[\"首先是版本的选择\",{\"1\":{\"49\":1}}],[\"今晚能够偷窃到的最高金额\",{\"1\":{\"698\":1}}],[\"偷或不偷对应两种情况\",{\"1\":{\"697\":1}}],[\"偷窃到的最高金额\",{\"1\":{\"697\":1}}],[\"偷窃\",{\"1\":{\"697\":1}}],[\"金额\",{\"1\":{\"697\":2,\"698\":2}}],[\"障碍物处理\",{\"1\":{\"696\":1}}],[\"边上的格子缺少\",{\"1\":{\"695\":1}}],[\"边界收缩一次\",{\"1\":{\"632\":1}}],[\"省空间o\",{\"1\":{\"694\":1}}],[\"斐波那契数\",{\"0\":{\"694\":1},\"1\":{\"694\":1}}],[\"斐波那契数列\",{\"1\":{\"391\":2,\"694\":1}}],[\"剑指\",{\"0\":{\"693\":1,\"705\":1,\"732\":1,\"735\":1,\"738\":1,\"741\":1}}],[\"剑指offer58\",{\"0\":{\"646\":1}}],[\"剑指offer\",{\"0\":{\"644\":1,\"731\":1}}],[\"⼀定全部⽤完了\",{\"1\":{\"689\":1,\"701\":1}}],[\"⽽且\",{\"1\":{\"689\":1,\"701\":1}}],[\"划分相等子集\",{\"0\":{\"689\":1}}],[\"划分成两个子集\",{\"1\":{\"687\":1}}],[\"画出回溯树\",{\"1\":{\"687\":1}}],[\"种\",{\"1\":{\"784\":1}}],[\"种方法让最终目标和为\",{\"1\":{\"687\":1}}],[\"种类\",{\"1\":{\"631\":1}}],[\"幂集\",{\"1\":{\"686\":1}}],[\"答案可以按\",{\"1\":{\"684\":1}}],[\"搜索的起始位置\",{\"1\":{\"683\":1}}],[\"搜索引擎\",{\"1\":{\"111\":1}}],[\"撤销\",{\"1\":{\"715\":2}}],[\"撤销标记\",{\"1\":{\"705\":1}}],[\"撤销选择\",{\"1\":{\"683\":1,\"684\":1,\"686\":2,\"689\":1,\"701\":1,\"718\":1}}],[\"撤销处理结果\",{\"1\":{\"682\":1}}],[\"撤销日志\",{\"1\":{\"177\":1}}],[\"棋盘问题\",{\"1\":{\"681\":1}}],[\"理论\",{\"0\":{\"681\":1}}],[\"理解main方法语法\",{\"0\":{\"412\":1}}],[\"理解和学会设计模式\",{\"1\":{\"93\":1}}],[\"连续子数组\",{\"1\":{\"693\":1}}],[\"连续子数组的最大和\",{\"0\":{\"693\":1}}],[\"连通问题\",{\"0\":{\"679\":1}}],[\"连接池配置\",{\"1\":{\"606\":1}}],[\"连接点\",{\"1\":{\"570\":1}}],[\"连接在一起的行为是基于一种称为\",{\"1\":{\"545\":1}}],[\"连接到该端口\",{\"1\":{\"485\":1}}],[\"连接上后\",{\"1\":{\"485\":1}}],[\"连接服务端\",{\"1\":{\"485\":1}}],[\"连接中可进行大数据量传输\",{\"1\":{\"482\":1}}],[\"连接性\",{\"1\":{\"156\":1}}],[\"连接\",{\"1\":{\"49\":1,\"209\":1,\"660\":1}}],[\"预订记录\",{\"1\":{\"678\":3}}],[\"预期原值\",{\"1\":{\"295\":1}}],[\"预期值\",{\"1\":{\"6\":1}}],[\"航班编号\",{\"1\":{\"678\":1}}],[\"航班预定统计\",{\"0\":{\"678\":1}}],[\"呆在车上的区间为\",{\"1\":{\"677\":1}}],[\"站点\",{\"1\":{\"779\":1}}],[\"站下车\",{\"1\":{\"677\":1}}],[\"站上车\",{\"1\":{\"677\":1}}],[\"车\",{\"1\":{\"677\":1}}],[\"车上最初有\",{\"1\":{\"677\":1}}],[\"拼车\",{\"0\":{\"677\":1}}],[\"拼接\",{\"1\":{\"431\":3,\"517\":1}}],[\"拼接字符串\",{\"1\":{\"429\":1}}],[\"拼接为111\",{\"1\":{\"7\":1}}],[\"差分数组⼯具类\",{\"1\":{\"677\":1,\"678\":1}}],[\"差分数组法\",{\"1\":{\"677\":1}}],[\"差分数组\",{\"0\":{\"676\":1},\"1\":{\"677\":1,\"678\":1}}],[\"倒着插入单词\",{\"1\":{\"675\":1}}],[\"倒着插入单词到前缀树即可以判断后缀\",{\"1\":{\"675\":1}}],[\"倒计时门闩\",{\"1\":{\"144\":1}}],[\"技巧\",{\"0\":{\"670\":1,\"673\":1,\"676\":1,\"679\":1}}],[\"技术独立\",{\"1\":{\"595\":1}}],[\"技术部\",{\"1\":{\"557\":1}}],[\"技术实现相对难理解些\",{\"1\":{\"492\":1}}],[\"翻转这棵二叉树\",{\"1\":{\"667\":1}}],[\"翻转字符串里的单词\",{\"0\":{\"645\":1}}],[\"柱状图中最大的矩形\",{\"0\":{\"662\":1}}],[\"缩小窗口\",{\"1\":{\"661\":1}}],[\"肯定错的\",{\"1\":{\"659\":1}}],[\"括号组合\",{\"1\":{\"690\":1}}],[\"括号生成\",{\"0\":{\"690\":1}}],[\"括号字符串才是有效的\",{\"1\":{\"660\":1}}],[\"括号不是成双成对出现\",{\"1\":{\"659\":1}}],[\"括起来的代码\",{\"1\":{\"259\":1}}],[\"辅助队列\",{\"1\":{\"657\":1}}],[\"队列存储node节点\",{\"1\":{\"666\":1,\"669\":1}}],[\"队列\",{\"0\":{\"666\":1}}],[\"队列的操作方法\",{\"1\":{\"656\":1}}],[\"队列中的节点循环等待前驱节点为头节点时方可获取资源\",{\"1\":{\"316\":1}}],[\"出现循环依赖\",{\"1\":{\"718\":1}}],[\"出现了闭环\",{\"1\":{\"717\":1}}],[\"出末尾的数\",{\"1\":{\"655\":3}}],[\"出门禁的所有时间\",{\"1\":{\"89\":1}}],[\"出门禁次数\",{\"1\":{\"89\":1}}],[\"递推\",{\"1\":{\"704\":1}}],[\"递推公式\",{\"1\":{\"697\":1}}],[\"递推开始\",{\"1\":{\"650\":1}}],[\"递归遍历\",{\"1\":{\"716\":1}}],[\"递归结束的判断\",{\"1\":{\"715\":1}}],[\"递归参数\",{\"1\":{\"704\":1}}],[\"递归穷举下⼀个数字是否装⼊当前桶\",{\"1\":{\"689\":1,\"701\":1}}],[\"递归穷举下⼀个桶的选择\",{\"1\":{\"689\":1,\"701\":1}}],[\"递归下一层\",{\"1\":{\"683\":1}}],[\"递归\",{\"1\":{\"682\":1,\"684\":1,\"686\":2,\"688\":1,\"690\":1,\"715\":2,\"718\":1}}],[\"递归计算\",{\"1\":{\"627\":1}}],[\"递归的重要规则\",{\"1\":{\"391\":1}}],[\"递归锁\",{\"0\":{\"263\":1}}],[\"起点\",{\"1\":{\"713\":1}}],[\"起点加入队列\",{\"1\":{\"712\":1}}],[\"起始点在下图中标记为\",{\"1\":{\"695\":1,\"696\":1}}],[\"起始索引等于\",{\"1\":{\"649\":2}}],[\"起字段别名\",{\"1\":{\"522\":1}}],[\"收缩\",{\"1\":{\"648\":1}}],[\"收缩一格\",{\"1\":{\"632\":1}}],[\"滑动窗口的位置\",{\"1\":{\"661\":1}}],[\"滑动窗口的最大值\",{\"0\":{\"661\":1}}],[\"滑动窗口中的最大值\",{\"1\":{\"661\":1}}],[\"滑动窗口每次只向右移动一位\",{\"1\":{\"661\":1}}],[\"滑动窗口\",{\"0\":{\"647\":1,\"648\":1},\"1\":{\"648\":1}}],[\"滑动窗口法\",{\"0\":{\"630\":1},\"1\":{\"630\":2,\"631\":1,\"647\":1,\"648\":1}}],[\"遇到已经访问过的则不遍历\",{\"1\":{\"716\":1}}],[\"遇到一块陆地就res++\",{\"1\":{\"706\":1}}],[\"遇到右括号就去栈中寻找最近的左括号\",{\"1\":{\"659\":1}}],[\"遇到左括号就⼊栈\",{\"1\":{\"659\":1}}],[\"遇到空格就append\",{\"1\":{\"644\":1}}],[\"遇到非空格就append\",{\"1\":{\"644\":1}}],[\"遇到相同则直接返回\",{\"1\":{\"639\":1}}],[\"头尾指针指向的char交换\",{\"1\":{\"642\":1,\"643\":1}}],[\"末尾数的索引更改为删除数的索引\",{\"1\":{\"721\":1}}],[\"末尾数替换到删除数的位置\",{\"1\":{\"721\":1}}],[\"末尾位置对齐\",{\"1\":{\"639\":1}}],[\"末尾对齐的位置\",{\"1\":{\"639\":1}}],[\"末尾+1\",{\"1\":{\"635\":1}}],[\"螺旋矩阵\",{\"0\":{\"632\":1}}],[\"何时减小窗口\",{\"1\":{\"631\":1}}],[\"何时使用\",{\"1\":{\"98\":1,\"101\":1,\"104\":1,\"107\":1,\"113\":1,\"116\":1}}],[\"涉及到多类型\",{\"1\":{\"631\":1}}],[\"纯数量问题选用int类型就行\",{\"1\":{\"631\":1}}],[\"棵树\",{\"1\":{\"631\":1}}],[\"棵树上的水果\",{\"1\":{\"631\":1}}],[\"恰好摘一个水果\",{\"1\":{\"631\":1}}],[\"树的输入\",{\"0\":{\"730\":1}}],[\"树中节点孩子的数量就是集合的大小\",{\"1\":{\"682\":1}}],[\"树\",{\"1\":{\"631\":1}}],[\"篮子\",{\"1\":{\"631\":1}}],[\"农场的主人设定了一些严格的规矩\",{\"1\":{\"631\":1}}],[\"农场从左到右种植了一排果树\",{\"1\":{\"631\":1}}],[\"停止增加right\",{\"1\":{\"630\":1}}],[\"停止上面的线程\",{\"1\":{\"268\":3}}],[\"≥\",{\"1\":{\"630\":1}}],[\"组成\",{\"1\":{\"708\":1}}],[\"组成的群\",{\"1\":{\"708\":1}}],[\"组成的的二维网格\",{\"1\":{\"706\":1}}],[\"组成的新数组\",{\"1\":{\"629\":1}}],[\"组合问题\",{\"0\":{\"683\":1},\"1\":{\"681\":1}}],[\"组件扫描\",{\"1\":{\"583\":1}}],[\"组件扫描配置过滤器\",{\"1\":{\"563\":1}}],[\"组件\",{\"1\":{\"76\":1}}],[\"尽可能小的\",{\"1\":{\"628\":1}}],[\"尽可能靠右的低位\",{\"1\":{\"628\":1}}],[\"尽快恢复缓存\",{\"1\":{\"198\":1}}],[\"小雨coding\",{\"1\":{\"730\":1}}],[\"小树链接到大树上\",{\"1\":{\"709\":2}}],[\"小数\",{\"1\":{\"628\":2}}],[\"小时\",{\"1\":{\"436\":1}}],[\"思路\",{\"0\":{\"733\":1,\"736\":1,\"739\":1,\"742\":1},\"1\":{\"628\":1}}],[\"思想基于\",{\"1\":{\"555\":1}}],[\"思想\",{\"1\":{\"555\":1}}],[\"排除\",{\"1\":{\"687\":1}}],[\"排除掉靠边岛屿\",{\"1\":{\"708\":1,\"709\":1}}],[\"排除掉缺少与左括号对应的右括号的情况\",{\"1\":{\"659\":1}}],[\"排除掉括号闭合顺序错误的情况\",{\"1\":{\"659\":1}}],[\"排除长度为1的情况\",{\"1\":{\"650\":1}}],[\"排列问题\",{\"1\":{\"681\":1}}],[\"排列\",{\"1\":{\"628\":1}}],[\"排序后\",{\"1\":{\"629\":1}}],[\"排序后的左右指针\",{\"0\":{\"627\":1}}],[\"排序的整数数组\",{\"1\":{\"629\":1}}],[\"排序是用红黑树结构完成的\",{\"1\":{\"447\":1}}],[\"排序\",{\"1\":{\"433\":1,\"451\":1,\"452\":1,\"629\":1}}],[\"排序和查找\",{\"0\":{\"380\":1}}],[\"排序等操作\",{\"1\":{\"184\":1}}],[\"排序任意类型\",{\"1\":{\"45\":1}}],[\"轴共同构成的容器可以容纳最多的水\",{\"1\":{\"625\":1}}],[\"条不同的路径\",{\"1\":{\"696\":1}}],[\"条预订记录\",{\"1\":{\"678\":1}}],[\"条线的两个端点是\",{\"1\":{\"625\":1}}],[\"条垂线\",{\"1\":{\"625\":1}}],[\"条件查询\",{\"1\":{\"527\":1}}],[\"条件阻塞队列中的节点将被唤醒并挂载到锁阻塞队列中\",{\"1\":{\"319\":1}}],[\"条件表达式\",{\"1\":{\"6\":1,\"366\":1,\"371\":2}}],[\"条件判断函数\",{\"0\":{\"6\":1}}],[\"盛水最多的容器\",{\"0\":{\"625\":1}}],[\"很明显可以优化到1\",{\"1\":{\"624\":1}}],[\"很多国家的插座跟我们不一样\",{\"1\":{\"95\":1}}],[\"备忘录优化\",{\"1\":{\"624\":1}}],[\"备忘录\",{\"1\":{\"624\":1,\"718\":1}}],[\"蓝色部分表示雨水\",{\"1\":{\"624\":1}}],[\"寻找新数组的元素\",{\"1\":{\"623\":1}}],[\"移出窗口\",{\"1\":{\"648\":1}}],[\"移出基于垃圾回收器状态和软引用规则的对象\",{\"1\":{\"536\":1}}],[\"移除栈顶元素\",{\"1\":{\"656\":1}}],[\"移除链表元素\",{\"0\":{\"634\":1}}],[\"移除元素\",{\"0\":{\"623\":1}}],[\"移动短板\",{\"1\":{\"625\":1}}],[\"暴力遍历\",{\"0\":{\"652\":1}}],[\"暴力\",{\"1\":{\"625\":1}}],[\"暴力解法\",{\"1\":{\"624\":1,\"630\":1}}],[\"暴力法\",{\"1\":{\"622\":1,\"629\":1,\"652\":1}}],[\"暴露端口\",{\"1\":{\"616\":2}}],[\"旋转数组的二分查找\",{\"0\":{\"621\":1}}],[\"装满背包意思就是\",{\"1\":{\"701\":1}}],[\"装满了当前桶\",{\"1\":{\"689\":1,\"701\":1}}],[\"装入或不装入背包\",{\"1\":{\"700\":1}}],[\"装程序\",{\"1\":{\"616\":1}}],[\"装系统\",{\"1\":{\"616\":1}}],[\"层数即深度\",{\"1\":{\"669\":1}}],[\"层序遍历\",{\"1\":{\"666\":1,\"669\":1}}],[\"层\",{\"1\":{\"616\":1}}],[\"层或其他相关组件进行业务处理\",{\"1\":{\"161\":1}}],[\"挂载目录到宿主机的数据卷html上\",{\"1\":{\"615\":1}}],[\"挂载数据卷\",{\"1\":{\"615\":1}}],[\"冒号左侧是宿主机端口\",{\"1\":{\"614\":1}}],[\"冒泡排序\",{\"1\":{\"381\":2}}],[\"远程使用docker\",{\"1\":{\"613\":1}}],[\"远程调用的问题\",{\"1\":{\"597\":1}}],[\"守护进程\",{\"1\":{\"611\":1}}],[\"守护线程运行中\",{\"1\":{\"468\":1}}],[\"守护线程自动结束\",{\"1\":{\"468\":1}}],[\"守护线程作为一个服务线程\",{\"1\":{\"227\":1}}],[\"守护线程\",{\"0\":{\"227\":1},\"1\":{\"227\":1,\"468\":1}}],[\"架构的程序\",{\"1\":{\"611\":1}}],[\"架构\",{\"0\":{\"611\":1},\"1\":{\"611\":1}}],[\"致就是跨域\",{\"1\":{\"607\":1}}],[\"致力于动态路由\",{\"1\":{\"593\":1}}],[\"跨域检测有效期\",{\"1\":{\"607\":1}}],[\"跨域问题\",{\"1\":{\"607\":1}}],[\"跨域\",{\"1\":{\"607\":1}}],[\"跨域cros设置\",{\"1\":{\"607\":1}}],[\"跨平台性\",{\"1\":{\"346\":1}}],[\"否\",{\"1\":{\"607\":1}}],[\"否则请返回\",{\"1\":{\"677\":1}}],[\"否则不变\",{\"1\":{\"675\":1}}],[\"否则不能通过编译\",{\"1\":{\"424\":1}}],[\"否则循环退出返回空指针\",{\"1\":{\"639\":1}}],[\"否则反转后会丢失连接\",{\"1\":{\"636\":1}}],[\"否则在加入头结点的操作中会出现null\",{\"1\":{\"635\":1}}],[\"否则会编译错误\",{\"1\":{\"491\":1}}],[\"否则写入不到指定文件\",{\"1\":{\"477\":1}}],[\"否则创建多级目录\",{\"1\":{\"475\":1}}],[\"否则就用数组扩容\",{\"1\":{\"445\":1}}],[\"否则该类也得声明为抽象类\",{\"1\":{\"416\":1}}],[\"否则返回\",{\"1\":{\"720\":1}}],[\"否则返回个数\",{\"1\":{\"313\":1}}],[\"否则返回result2\",{\"1\":{\"6\":1}}],[\"否则false\",{\"1\":{\"313\":3}}],[\"否则如果是\",{\"1\":{\"204\":1}}],[\"否则的话\",{\"1\":{\"190\":1}}],[\"否则\",{\"1\":{\"141\":1,\"705\":1,\"716\":1,\"717\":1,\"721\":2}}],[\"否则都是false\",{\"1\":{\"130\":1}}],[\"否则通过标准对象创建语法\",{\"1\":{\"130\":1}}],[\"否则下面的读取会有问题\",{\"1\":{\"55\":1}}],[\"放行\",{\"1\":{\"607\":1}}],[\"身份认证和权限校验\",{\"1\":{\"607\":1}}],[\"网站\",{\"1\":{\"778\":1}}],[\"网格的正中间有一个障碍物\",{\"1\":{\"696\":1}}],[\"网格的左上角\",{\"1\":{\"695\":1,\"696\":1}}],[\"网格中的障碍物和空位置分别用\",{\"1\":{\"696\":1}}],[\"网关的机制和代理相似\",{\"1\":{\"780\":1}}],[\"网关的实现包括两种\",{\"1\":{\"607\":1}}],[\"网关是转发其他服务器通信数据的服务器\",{\"1\":{\"780\":1}}],[\"网关\",{\"0\":{\"780\":1},\"1\":{\"780\":1}}],[\"网关技术实现\",{\"1\":{\"607\":1}}],[\"网关功能\",{\"1\":{\"607\":1}}],[\"网络适配器\",{\"1\":{\"749\":1}}],[\"网络基础\",{\"0\":{\"747\":1}}],[\"网络请求\",{\"1\":{\"593\":1}}],[\"网络套接字\",{\"0\":{\"484\":1}}],[\"网络通信其实就是socket间的通信\",{\"1\":{\"484\":1}}],[\"网络通信协议\",{\"1\":{\"482\":1}}],[\"网络通信\",{\"1\":{\"482\":1}}],[\"网络通信相关概念\",{\"0\":{\"482\":1}}],[\"网络通讯\",{\"1\":{\"476\":1}}],[\"网络编程\",{\"0\":{\"481\":1}}],[\"网络包\",{\"1\":{\"396\":1}}],[\"网络连接\",{\"1\":{\"209\":1}}],[\"网络连接断掉了\",{\"1\":{\"204\":1}}],[\"网络上说的redis是单线程\",{\"1\":{\"187\":1}}],[\"网络层用来处理网络上流动的数据包\",{\"1\":{\"749\":1}}],[\"网络层\",{\"1\":{\"152\":1,\"749\":1}}],[\"伪装成本地的接口进行调用\",{\"1\":{\"606\":1}}],[\"各字段值\",{\"1\":{\"785\":1}}],[\"各group容量信息表\",{\"1\":{\"605\":1}}],[\"各种数据持久性选项\",{\"1\":{\"545\":1}}],[\"聚合子配置最大个数\",{\"1\":{\"605\":2}}],[\"聚簇索引对于频繁基于范围查询和排序的操作非常有效\",{\"1\":{\"179\":1}}],[\"聚簇索引的叶子节点存储了实际的数据行\",{\"1\":{\"179\":1}}],[\"聚簇索引是一种特殊的索引类型\",{\"1\":{\"179\":1}}],[\"聚簇索引\",{\"1\":{\"179\":1}}],[\"租户容量信息表\",{\"1\":{\"605\":1}}],[\"租户字段\",{\"1\":{\"605\":4}}],[\"租金\",{\"1\":{\"408\":1}}],[\"`action`\",{\"1\":{\"605\":2}}],[\"`app\",{\"1\":{\"605\":5}}],[\"`resource`\",{\"1\":{\"605\":2}}],[\"`role`\",{\"1\":{\"605\":4}}],[\"`roles`\",{\"1\":{\"605\":1}}],[\"`permissions`\",{\"1\":{\"605\":1}}],[\"`password`\",{\"1\":{\"605\":1}}],[\"`enabled`\",{\"1\":{\"605\":1}}],[\"`effect`\",{\"1\":{\"605\":1}}],[\"`kp`\",{\"1\":{\"605\":2}}],[\"`op\",{\"1\":{\"605\":1}}],[\"`his\",{\"1\":{\"605\":1}}],[\"`max\",{\"1\":{\"605\":8}}],[\"`md5`\",{\"1\":{\"605\":4}}],[\"`username`\",{\"1\":{\"605\":3}}],[\"`users`\",{\"1\":{\"605\":1}}],[\"`usage`\",{\"1\":{\"605\":2}}],[\"`uk\",{\"1\":{\"605\":9}}],[\"`quota`\",{\"1\":{\"605\":2}}],[\"`idx\",{\"1\":{\"605\":6}}],[\"`id`\",{\"1\":{\"605\":17}}],[\"`nid`\",{\"1\":{\"605\":4}}],[\"`beta\",{\"1\":{\"605\":1}}],[\"`datum\",{\"1\":{\"605\":2}}],[\"`data\",{\"1\":{\"605\":11}}],[\"`tag\",{\"1\":{\"605\":6}}],[\"`type`\",{\"1\":{\"605\":1}}],[\"`tenant\",{\"1\":{\"605\":20}}],[\"`create\",{\"1\":{\"605\":1}}],[\"`c\",{\"1\":{\"605\":3}}],[\"`content`\",{\"1\":{\"605\":5}}],[\"`config\",{\"1\":{\"605\":5}}],[\"`src\",{\"1\":{\"605\":8}}],[\"`gmt\",{\"1\":{\"605\":17}}],[\"`group\",{\"1\":{\"605\":13}}],[\"```java\",{\"1\":{\"471\":1}}],[\"那样最大乘积就为j×dp\",{\"1\":{\"736\":1}}],[\"那就是我们的nacos服务地址是写在application\",{\"1\":{\"602\":1}}],[\"那么我们可以用两种颜色来代表这两种集合\",{\"1\":{\"716\":1}}],[\"那么\",{\"1\":{\"716\":1}}],[\"那么从左上角到右下角将会有多少条不同的路径\",{\"1\":{\"696\":1}}],[\"那么他们和\",{\"1\":{\"687\":1}}],[\"那么先将根节点放入栈中\",{\"1\":{\"665\":1}}],[\"那么把求得的最长相同前后缀的长度就是对应前缀表的元素\",{\"1\":{\"653\":1}}],[\"那么什么是前缀表\",{\"1\":{\"653\":1}}],[\"那么当这两个指针相遇的时候就是\",{\"1\":{\"640\":1}}],[\"那么当前类加载器会尝试自己去加载类\",{\"1\":{\"147\":1}}],[\"那么当前线程会进入同步队列中等待\",{\"1\":{\"141\":1}}],[\"那么新插入的节点为链表的新头节点\",{\"1\":{\"635\":1}}],[\"那么数组的\",{\"1\":{\"628\":1}}],[\"那么数据将按照\",{\"1\":{\"184\":2}}],[\"那么数据库可以直接利用索引定位到符合条件的数据行\",{\"1\":{\"176\":1}}],[\"那么初始化位置只能是定义时或静态代码块中\",{\"1\":{\"415\":1}}],[\"那么哈希值肯定不一样\",{\"1\":{\"406\":1}}],[\"那么哈希值肯定是一样的\",{\"1\":{\"406\":1}}],[\"那么就必须停止采摘\",{\"1\":{\"631\":1}}],[\"那么就创建threadlcoalmap\",{\"1\":{\"306\":1}}],[\"那么就通过threadlocalmap的set方法将值存储到当前线程对应的threadlocalmap中\",{\"1\":{\"306\":1}}],[\"那么就会执行一次resynchronization\",{\"1\":{\"204\":1}}],[\"那么就会导致大量的请求打在了数据库上面\",{\"1\":{\"198\":1}}],[\"那么处理器会自动将该位置值更新为新值\",{\"1\":{\"295\":1}}],[\"那么这两个操作之间必须存在happens\",{\"1\":{\"280\":1}}],[\"那么这个数组必须重排为字典序最小的排列\",{\"1\":{\"628\":1}}],[\"那么这个数据行对于该事务来说是不可见的\",{\"1\":{\"178\":1}}],[\"那么这个联合索引将无法被用到\",{\"1\":{\"175\":1}}],[\"那么这个联合索引可以被用到\",{\"1\":{\"175\":1}}],[\"那么再同步回主内存的时候应该以哪条数据为准呢\",{\"1\":{\"274\":1}}],[\"那么会调用轮询策略进行选取\",{\"1\":{\"598\":1}}],[\"那么会模拟一条\",{\"1\":{\"204\":1}}],[\"那么会触发一次\",{\"1\":{\"204\":1}}],[\"那么可以接着上次复制的地方\",{\"1\":{\"204\":1}}],[\"那么可以只使用rdb\",{\"1\":{\"189\":1}}],[\"那么master\",{\"1\":{\"204\":1}}],[\"那么它们会通过选举算法选择一个新的主节点\",{\"1\":{\"203\":1}}],[\"那么该事务中的所有命今都会被服务器执行\",{\"1\":{\"201\":1}}],[\"那么表之间的连接会在获取数据之前进行计算\",{\"1\":{\"184\":1}}],[\"那么查询时只能使用联合索引的最左边的列开始匹配\",{\"1\":{\"175\":1}}],[\"那么对数据库中的数据的改变就是永久性的\",{\"1\":{\"170\":1}}],[\"那么spring将返回earlysingletonobjects缓存中的占位符\",{\"1\":{\"163\":1}}],[\"那么线程将进入自旋或被阻塞\",{\"1\":{\"143\":1}}],[\"那么aqs会把当前线程以及等待状态封装成一个node节点加入到同步队列中\",{\"1\":{\"141\":1,\"312\":1}}],[\"那么结果就另当别论了\",{\"1\":{\"130\":1}}],[\"那么无论创建多少次\",{\"1\":{\"130\":1}}],[\"那么有两个方案\",{\"1\":{\"95\":1}}],[\"那么你多半也用过其中的状态管理工具\",{\"1\":{\"93\":1}}],[\"那么case语句将返回result\",{\"1\":{\"6\":1}}],[\"临时重定向\",{\"1\":{\"775\":1}}],[\"临时性重定向\",{\"1\":{\"775\":1}}],[\"临时节点\",{\"1\":{\"666\":1,\"669\":1}}],[\"临时实例心跳不正常回被剔除\",{\"1\":{\"600\":1}}],[\"临时实例会通过心跳监测告诉注册中心\",{\"1\":{\"600\":1}}],[\"临界值是16\",{\"1\":{\"445\":1}}],[\"懒加载\",{\"1\":{\"598\":1}}],[\"懒汉式\",{\"1\":{\"414\":1}}],[\"刚开始使用轮询策略并开启一个计时器\",{\"1\":{\"598\":1}}],[\"权重设置为0不会被访问\",{\"1\":{\"599\":1}}],[\"权重越高被选中的概率也越大\",{\"1\":{\"598\":1}}],[\"权重越小\",{\"1\":{\"598\":1}}],[\"权重策略\",{\"1\":{\"598\":2}}],[\"权限修饰符\",{\"1\":{\"571\":1}}],[\"权限检查\",{\"1\":{\"338\":1}}],[\"依次类推\",{\"1\":{\"598\":1}}],[\"依赖项注入的应用程序不是由组件自身创建和维护它们依赖的其他\",{\"1\":{\"545\":1}}],[\"依赖\",{\"0\":{\"498\":1},\"1\":{\"563\":1,\"571\":1,\"609\":1}}],[\"依赖两个阶段中的任何一个完成\",{\"1\":{\"248\":1}}],[\"依赖两个阶段都完成\",{\"1\":{\"248\":1}}],[\"依赖单个阶段\",{\"1\":{\"248\":1}}],[\"依赖注入\",{\"1\":{\"168\":1,\"545\":1,\"557\":1}}],[\"依赖注入和生命周期管理交给spring容器来完成\",{\"1\":{\"158\":1}}],[\"个⼦集\",{\"1\":{\"689\":1}}],[\"个⾮空⼦集\",{\"1\":{\"689\":1}}],[\"个数的组合\",{\"1\":{\"683\":1}}],[\"个数字\",{\"1\":{\"661\":1}}],[\"个座位\",{\"1\":{\"678\":1}}],[\"个航班\",{\"1\":{\"678\":1}}],[\"个空座位\",{\"1\":{\"677\":1}}],[\"个更新的操作\",{\"1\":{\"676\":1}}],[\"个\",{\"1\":{\"643\":2}}],[\"个字符中的前\",{\"1\":{\"643\":1}}],[\"个字符\",{\"1\":{\"643\":3}}],[\"个结点\",{\"1\":{\"638\":1}}],[\"个元素前添加\",{\"1\":{\"635\":1}}],[\"个节点的\",{\"1\":{\"715\":1}}],[\"个节点之前插入一个新节点\",{\"1\":{\"635\":1}}],[\"个节点\",{\"1\":{\"635\":1,\"716\":1,\"717\":1}}],[\"个正整数的数组和一个正整数\",{\"1\":{\"630\":1}}],[\"个单位的雨水\",{\"1\":{\"624\":1}}],[\"个非负整数表示每个宽度为\",{\"1\":{\"624\":1}}],[\"个int类型的order值\",{\"1\":{\"607\":1}}],[\"个服务\",{\"1\":{\"598\":1}}],[\"个确切的\",{\"1\":{\"71\":1}}],[\"心跳\",{\"1\":{\"597\":1}}],[\"供其他微服务调用\",{\"1\":{\"596\":1}}],[\"降级\",{\"1\":{\"595\":1}}],[\"降低了使用者开发和维护服务的成本\",{\"1\":{\"606\":1}}],[\"降低耦合度\",{\"1\":{\"595\":1}}],[\"降低代码耦合\",{\"1\":{\"554\":1}}],[\"降低\",{\"1\":{\"549\":1}}],[\"团队独立\",{\"1\":{\"595\":1}}],[\"拆分粒度更小\",{\"1\":{\"595\":1}}],[\"称为临时网络文件\",{\"1\":{\"781\":1}}],[\"称为一个窗口\",{\"1\":{\"630\":1}}],[\"称为服务\",{\"1\":{\"595\":1}}],[\"称为函数式接口\",{\"1\":{\"129\":1}}],[\"认证信息等内容\",{\"1\":{\"784\":1}}],[\"认使安装nacos\",{\"1\":{\"599\":1}}],[\"认识微服务\",{\"0\":{\"595\":1}}],[\"认为自己在使用数据的时候不会有别的线程来修改数据\",{\"1\":{\"258\":1}}],[\"认为自己在使用数据的时候一定有别的线程来修改数据\",{\"1\":{\"258\":1}}],[\"熔断器\",{\"1\":{\"593\":1}}],[\"熔断机制\",{\"1\":{\"198\":1}}],[\"仓库读取\",{\"1\":{\"593\":1}}],[\"弹性伸缩和安全\",{\"1\":{\"593\":1}}],[\"监控\",{\"1\":{\"593\":2}}],[\"监控一直持续到\",{\"1\":{\"202\":1}}],[\"官方建议使用\",{\"1\":{\"586\":1}}],[\"块钱\",{\"1\":{\"583\":2}}],[\"虚读\",{\"1\":{\"582\":2}}],[\"虚拟链表头\",{\"1\":{\"637\":1}}],[\"虚拟头\",{\"1\":{\"638\":1}}],[\"虚拟头结点\",{\"1\":{\"635\":1}}],[\"虚拟头指针dummy\",{\"0\":{\"634\":1}}],[\"虚拟机是在操作系统中模拟硬件设备\",{\"1\":{\"610\":1}}],[\"虚拟机错误\",{\"1\":{\"126\":1}}],[\"虚拟主机\",{\"1\":{\"209\":1}}],[\"银行转账\",{\"1\":{\"580\":1}}],[\"知道哪个类里的哪个方法需要增强\",{\"1\":{\"571\":1}}],[\"切割问题\",{\"1\":{\"681\":1}}],[\"切面\",{\"1\":{\"570\":1}}],[\"切入点表达式的作用\",{\"1\":{\"571\":1}}],[\"切入点表达式\",{\"1\":{\"571\":1,\"572\":1}}],[\"切入点\",{\"1\":{\"570\":1}}],[\"环形入口的节点\",{\"1\":{\"640\":1}}],[\"环形链表\",{\"0\":{\"640\":1}}],[\"环境\",{\"1\":{\"602\":1,\"616\":1}}],[\"环绕后置方法增强\",{\"1\":{\"572\":1}}],[\"环绕前置方法增强\",{\"1\":{\"572\":1}}],[\"环绕通知\",{\"1\":{\"570\":1}}],[\"环依赖\",{\"1\":{\"163\":1}}],[\"替代\",{\"1\":{\"565\":1}}],[\"替换空格\",{\"0\":{\"644\":1}}],[\"替换掉指定位置的元素\",{\"1\":{\"440\":1}}],[\"替换字符串中的字符\",{\"1\":{\"429\":1}}],[\"扫描上层目录\",{\"1\":{\"563\":1}}],[\"试一试默认情况下\",{\"1\":{\"559\":1}}],[\"营销部\",{\"1\":{\"557\":1}}],[\"级联赋值\",{\"1\":{\"557\":2}}],[\"级别的\",{\"1\":{\"534\":1}}],[\"级别\",{\"1\":{\"167\":1,\"535\":1}}],[\"员工属于某一个部门\",{\"1\":{\"557\":1}}],[\"员工类\",{\"1\":{\"557\":1}}],[\"员工当日进出门禁的时间\",{\"1\":{\"89\":1}}],[\"部署微服务\",{\"1\":{\"617\":1}}],[\"部署一个java应用\",{\"1\":{\"616\":1}}],[\"部署独立\",{\"1\":{\"595\":1}}],[\"部门类\",{\"1\":{\"557\":1}}],[\"部门和员工\",{\"1\":{\"557\":1}}],[\"部分缺少的数据\",{\"1\":{\"204\":1}}],[\"天\",{\"1\":{\"622\":1}}],[\"天蚕变\",{\"1\":{\"557\":2}}],[\"天后=\",{\"1\":{\"436\":1}}],[\"天后\",{\"1\":{\"436\":1}}],[\"斗罗大陆\",{\"1\":{\"557\":3}}],[\"唯一标识\",{\"1\":{\"557\":1}}],[\"唯一的\",{\"1\":{\"7\":1}}],[\"入栈\",{\"1\":{\"656\":1,\"659\":1}}],[\"入口\",{\"1\":{\"616\":3}}],[\"入门\",{\"0\":{\"608\":1}}],[\"入门案例就是\",{\"1\":{\"554\":1}}],[\"入门案例\",{\"0\":{\"550\":1}}],[\"入队此节点的线程\",{\"1\":{\"312\":1}}],[\"入队操作在附加之前不会为前置节点的next字段分配值\",{\"1\":{\"312\":1}}],[\"奢华版\",{\"0\":{\"541\":1}}],[\"逆向插件及其依赖\",{\"1\":{\"540\":1}}],[\"逆向工程\",{\"0\":{\"539\":1},\"1\":{\"540\":1}}],[\"慢指针一次走一步\",{\"1\":{\"640\":1}}],[\"慢指针指向要删除的节点前一位\",{\"1\":{\"638\":1}}],[\"慢指针\",{\"1\":{\"623\":1}}],[\"慢但是安全\",{\"1\":{\"536\":1}}],[\"慢查询日志\",{\"1\":{\"177\":1}}],[\"独写缓存\",{\"1\":{\"536\":1}}],[\"独立运行\",{\"1\":{\"80\":1}}],[\"太大容易导致内存溢出\",{\"1\":{\"536\":1}}],[\"刷新间隔\",{\"1\":{\"536\":1}}],[\"女\",{\"1\":{\"530\":1}}],[\"男\",{\"1\":{\"523\":1,\"530\":1}}],[\"联表查询语句如下\",{\"1\":{\"523\":1}}],[\"联合使用才能最终生效\",{\"1\":{\"209\":1}}],[\"联合索引为什么要遵守前缀匹配\",{\"0\":{\"176\":1}}],[\"占位符复制\",{\"1\":{\"510\":1}}],[\"占两个字节\",{\"1\":{\"482\":1}}],[\"$pwd\",{\"1\":{\"617\":2}}],[\"$proxy0\",{\"1\":{\"419\":1}}],[\"$2a$10$euwpzhzz32djn7jexm34moeyirddfazm2kuwj7veojhhzkdrxfvuu\",{\"1\":{\"605\":1}}],[\"$\",{\"1\":{\"507\":1,\"510\":1,\"511\":2,\"517\":1,\"518\":2,\"519\":1,\"562\":4,\"616\":3}}],[\"测试用例保证调用此方法时集合中至少存在一个元素\",{\"1\":{\"721\":1}}],[\"测试完全注解方式\",{\"1\":{\"584\":1}}],[\"测试转账功能\",{\"1\":{\"583\":1}}],[\"测试\",{\"1\":{\"576\":1,\"583\":1,\"584\":1,\"609\":1}}],[\"测试函数中加载配置类\",{\"1\":{\"565\":1}}],[\"测试下两个实例是否是同一地址\",{\"1\":{\"559\":1}}],[\"测试输出\",{\"1\":{\"552\":1,\"557\":1,\"559\":1,\"560\":1}}],[\"测试语句\",{\"1\":{\"524\":1}}],[\"测试插入功能\",{\"1\":{\"502\":1,\"512\":1}}],[\"测试功能\",{\"0\":{\"502\":1},\"1\":{\"565\":1}}],[\"测试到的已过期的\",{\"1\":{\"191\":1}}],[\"江苏南京\",{\"1\":{\"501\":1}}],[\"映射\",{\"0\":{\"501\":1},\"1\":{\"522\":1}}],[\"映射文件\",{\"1\":{\"499\":1,\"509\":1}}],[\"映射关系\",{\"1\":{\"190\":1}}],[\"搭建数据库\",{\"1\":{\"605\":1}}],[\"搭建集群的基本步骤\",{\"1\":{\"605\":1}}],[\"搭建nacos集群\",{\"0\":{\"605\":1}}],[\"搭建事务操作环境\",{\"0\":{\"581\":1}}],[\"搭建\",{\"0\":{\"497\":1,\"521\":1},\"1\":{\"581\":1}}],[\"搭配使用不会导致类加载\",{\"1\":{\"415\":1}}],[\"维护不易\",{\"1\":{\"496\":1}}],[\"耦合度高\",{\"1\":{\"496\":1,\"595\":1}}],[\"夹杂在\",{\"1\":{\"496\":1}}],[\"半自动的\",{\"1\":{\"495\":1}}],[\"顺势织入横切逻辑\",{\"1\":{\"492\":1}}],[\"顺序查找\",{\"1\":{\"381\":1}}],[\"顺序\",{\"1\":{\"359\":1}}],[\"顺序写入与零拷贝\",{\"1\":{\"214\":1}}],[\"获得对应的方法\",{\"1\":{\"486\":1}}],[\"获得访问权限\",{\"1\":{\"486\":1}}],[\"获得private\",{\"1\":{\"486\":1}}],[\"获得class对象\",{\"1\":{\"486\":2}}],[\"获取部分内容的\",{\"0\":{\"770\":1}}],[\"获取报文首部\",{\"1\":{\"763\":1}}],[\"获取资源\",{\"1\":{\"763\":1}}],[\"获取栈顶元素\",{\"1\":{\"656\":1}}],[\"获取第index个节点的数值\",{\"1\":{\"635\":1}}],[\"获取参数中的\",{\"1\":{\"607\":1}}],[\"获取参数值的两种方式\",{\"0\":{\"510\":1},\"1\":{\"510\":1}}],[\"获取请求参数\",{\"1\":{\"607\":1}}],[\"获取请求的参数\",{\"1\":{\"334\":2}}],[\"获取配置的步骤\",{\"1\":{\"602\":1}}],[\"获取配置创建的变量\",{\"1\":{\"552\":1,\"557\":1,\"559\":1,\"560\":1}}],[\"获取服务名称\",{\"1\":{\"598\":1}}],[\"获取对应\",{\"1\":{\"565\":1}}],[\"获取对应的string对象\",{\"1\":{\"486\":1}}],[\"获取对应的值\",{\"1\":{\"480\":1}}],[\"获取对应的\",{\"1\":{\"419\":1}}],[\"获取自增的主键\",{\"0\":{\"520\":1}}],[\"获取多个参数情况\",{\"0\":{\"512\":1}}],[\"获取单个参数情况\",{\"0\":{\"511\":1}}],[\"获取sqlsession对象\",{\"1\":{\"502\":1,\"512\":1}}],[\"获取sqlsessionfactory对象\",{\"1\":{\"502\":1}}],[\"获取sqlsessionfactorybuilder对象\",{\"1\":{\"502\":1}}],[\"获取servlet\",{\"1\":{\"341\":1}}],[\"获取核心配置文件的输入流\",{\"1\":{\"502\":1}}],[\"获取inetaddress对象的地址\",{\"1\":{\"483\":1}}],[\"获取inetaddress对象的主机名\",{\"1\":{\"483\":1}}],[\"获取init\",{\"1\":{\"341\":1}}],[\"获取本机inetaddress对象getlocalhost\",{\"1\":{\"483\":1}}],[\"获取本机inetaddress对象\",{\"1\":{\"483\":1}}],[\"获取文件的信息\",{\"1\":{\"475\":1}}],[\"获取文件的相关信息\",{\"1\":{\"475\":1}}],[\"获取元素个数\",{\"1\":{\"439\":1}}],[\"获取到时分秒\",{\"1\":{\"436\":1}}],[\"获取日历对象的某个日历字段\",{\"1\":{\"436\":1}}],[\"获取当前的系统时间\",{\"1\":{\"436\":1}}],[\"获取当前线程对应的threadlocalmap\",{\"1\":{\"307\":1}}],[\"获取当前线程\",{\"1\":{\"306\":1,\"307\":1}}],[\"获取某索引处的字符\",{\"1\":{\"429\":1}}],[\"获取字符在字符串中最后一次出现的索引\",{\"1\":{\"429\":1}}],[\"获取字符在字符串中第一次出现的索引\",{\"1\":{\"429\":1}}],[\"获取字符个数\",{\"1\":{\"429\":1}}],[\"获取所有接口的class\",{\"1\":{\"419\":1}}],[\"获取线程中的threadlocalmap\",{\"1\":{\"306\":1}}],[\"获取结果和触发计算\",{\"1\":{\"239\":1}}],[\"获取异步任务执行的结果\",{\"1\":{\"229\":1}}],[\"获取异步方法返回值\",{\"1\":{\"164\":1}}],[\"获取锁\",{\"1\":{\"141\":1}}],[\"获取\",{\"0\":{\"502\":1},\"1\":{\"104\":1,\"341\":1,\"483\":2,\"502\":1,\"512\":1}}],[\"服务的首部字段\",{\"0\":{\"785\":1}}],[\"服务的工具\",{\"1\":{\"593\":1}}],[\"服务路由\",{\"1\":{\"607\":1}}],[\"服务列表更新更及时\",{\"1\":{\"600\":1}}],[\"服务跨集群调用问题\",{\"1\":{\"599\":1}}],[\"服务\",{\"1\":{\"599\":1,\"780\":1}}],[\"服务提供方与eureka之间通过\",{\"1\":{\"597\":1}}],[\"服务提供者\",{\"1\":{\"596\":1}}],[\"服务消费者该如何获取服务提供者的地址信息\",{\"1\":{\"597\":1}}],[\"服务消息队列\",{\"1\":{\"592\":1}}],[\"服务远程调用resttemplate实现调用其他服务的接口\",{\"1\":{\"596\":1}}],[\"服务远程调用\",{\"1\":{\"595\":1}}],[\"服务做好隔离\",{\"1\":{\"595\":1}}],[\"服务健康如何感知\",{\"1\":{\"595\":1}}],[\"服务之间如何远程调用\",{\"1\":{\"595\":1}}],[\"服务之间互相协调\",{\"1\":{\"591\":1}}],[\"服务集群地址如何维护\",{\"1\":{\"595\":1}}],[\"服务拆分和远程调用\",{\"1\":{\"596\":1}}],[\"服务拆分颗粒度如何\",{\"1\":{\"595\":1}}],[\"服务拆分会导致部署困难\",{\"1\":{\"595\":1}}],[\"服务链路追踪\",{\"1\":{\"593\":1}}],[\"服务或\",{\"1\":{\"593\":1}}],[\"服务注册\",{\"1\":{\"597\":1}}],[\"服务注册到eureka\",{\"1\":{\"597\":1}}],[\"服务注册和发现\",{\"1\":{\"593\":1}}],[\"服务注册与开发\",{\"1\":{\"592\":1}}],[\"服务定时任务\",{\"1\":{\"592\":1}}],[\"服务监控和保护\",{\"1\":{\"595\":1}}],[\"服务监控\",{\"1\":{\"592\":1,\"593\":1}}],[\"服务网关\",{\"1\":{\"592\":1,\"595\":1}}],[\"服务降级\",{\"1\":{\"592\":1}}],[\"服务熔断\",{\"1\":{\"592\":1}}],[\"服务调用者无需自己寻找服务\",{\"1\":{\"597\":1}}],[\"服务调用\",{\"1\":{\"592\":1}}],[\"服务与服务间采用轻量级的通信机制互相协作\",{\"1\":{\"591\":1}}],[\"服务端发送指令\",{\"1\":{\"611\":1}}],[\"服务端在9999端口监听\",{\"1\":{\"485\":1}}],[\"服务端\",{\"1\":{\"485\":2,\"611\":1}}],[\"服务器搭建多个\",{\"1\":{\"779\":1}}],[\"服务器可搭建多个独立域名的\",{\"1\":{\"778\":1}}],[\"服务器\",{\"0\":{\"778\":1}}],[\"服务器超载或正在停机维护\",{\"1\":{\"777\":1}}],[\"服务器错误状态码\",{\"0\":{\"777\":1}}],[\"服务器上没有请求的资源\",{\"1\":{\"776\":1}}],[\"服务器允许访问资源\",{\"1\":{\"775\":1}}],[\"服务器端在执行请求时发生错误\",{\"1\":{\"777\":1}}],[\"服务器端和客户端各自进行内容协商\",{\"1\":{\"771\":1}}],[\"服务器端维护一个\",{\"1\":{\"165\":1}}],[\"服务器驱动协商和客户端驱动协商的结合体\",{\"1\":{\"771\":1}}],[\"服务器驱动协商\",{\"1\":{\"771\":1}}],[\"服务器发现客户端发送的cookie后会对比服务器上的记录\",{\"1\":{\"765\":1}}],[\"服务器应答\",{\"1\":{\"759\":1}}],[\"服务器地址\",{\"1\":{\"757\":1}}],[\"服务器的查询语句\",{\"1\":{\"177\":1}}],[\"服务器运行过程中出现的错误和异常信息\",{\"1\":{\"177\":1}}],[\"服务器接收到请求时\",{\"1\":{\"165\":1}}],[\"服务器接收到加密的会话密钥后\",{\"1\":{\"155\":1}}],[\"服务器验证\",{\"1\":{\"165\":1}}],[\"服务器验证用户凭据\",{\"1\":{\"165\":1}}],[\"服务器在响应客户端请求时\",{\"1\":{\"155\":1}}],[\"服务器需要配置有效的ssl\",{\"1\":{\"155\":1}}],[\"服务器需要获得一个有效的数字证书\",{\"1\":{\"154\":1}}],[\"服务器配置ssl\",{\"1\":{\"155\":1}}],[\"案例\",{\"1\":{\"483\":1,\"485\":1,\"596\":1,\"616\":1}}],[\"速度快\",{\"1\":{\"482\":1}}],[\"速度和效率\",{\"1\":{\"156\":1}}],[\"须先建立tcp连接\",{\"1\":{\"482\":1}}],[\"须传入实际的执行对象\",{\"1\":{\"419\":1}}],[\"端口不同\",{\"1\":{\"607\":1}}],[\"端口\",{\"1\":{\"485\":1}}],[\"端口范围0~65535\",{\"1\":{\"482\":1}}],[\"端口号\",{\"1\":{\"203\":1,\"482\":1,\"757\":1}}],[\"概念\",{\"0\":{\"544\":1,\"554\":1,\"567\":1,\"574\":1},\"1\":{\"482\":1}}],[\"码值\",{\"1\":{\"480\":1}}],[\"码和依赖包\",{\"1\":{\"81\":1}}],[\"汤姆\",{\"1\":{\"480\":1}}],[\"值就行\",{\"1\":{\"693\":1}}],[\"值无法修改\",{\"1\":{\"492\":1}}],[\"值不需要引号\",{\"1\":{\"480\":1}}],[\"值2\",{\"1\":{\"480\":1}}],[\"值1\",{\"1\":{\"480\":1}}],[\"值按数字顺序排列\",{\"1\":{\"312\":1}}],[\"专门用于读写配置文件的集合类\",{\"1\":{\"480\":1}}],[\"严明奎\",{\"1\":{\"478\":1}}],[\"严重拖累了计算机的运行效率\",{\"1\":{\"274\":1}}],[\"恢复数据的值和数据类型\",{\"1\":{\"478\":1}}],[\"恢复挂起的线程到真正锁的获取还是有时间差的\",{\"1\":{\"262\":1}}],[\"序列化具备可继承性\",{\"1\":{\"478\":1}}],[\"序列化对象时\",{\"1\":{\"478\":2}}],[\"序列化对象需实现serializable\",{\"1\":{\"478\":1}}],[\"序列化的类中建议添加serialversionuid\",{\"1\":{\"478\":1}}],[\"序列化就是在保存数据时\",{\"1\":{\"478\":1}}],[\"序列化与反序列化\",{\"1\":{\"478\":1}}],[\"序列号和重传机制来确保数据的正确性和完整性\",{\"1\":{\"156\":1}}],[\"韩顺平零基础学\",{\"1\":{\"478\":1}}],[\"韩顺平教育~\",{\"1\":{\"479\":1}}],[\"韩顺平教育\",{\"1\":{\"430\":1,\"477\":1,\"478\":3}}],[\"拷贝到服务集群项目的对应子目录中\",{\"1\":{\"617\":1}}],[\"拷贝java项目的包\",{\"1\":{\"616\":1}}],[\"拷贝jdk和java项目的包\",{\"1\":{\"616\":1}}],[\"拷贝本地文件到指定目录\",{\"1\":{\"616\":1}}],[\"拷贝文件\",{\"1\":{\"478\":1}}],[\"拷贝完成\",{\"1\":{\"477\":1}}],[\"低级流\",{\"1\":{\"478\":1}}],[\"低16位表示当前等待获取锁的线程数\",{\"1\":{\"141\":1}}],[\"老韩看源码就知道原因\",{\"1\":{\"477\":1}}],[\"老年代通常使用标记\",{\"1\":{\"148\":1}}],[\"风雨之后\",{\"1\":{\"477\":1}}],[\"批量初始化顺序为\",{\"1\":{\"718\":1}}],[\"批量初始化\",{\"1\":{\"718\":4}}],[\"批量初始化次数\",{\"0\":{\"718\":1},\"1\":{\"718\":1}}],[\"批量添加用户\",{\"1\":{\"531\":1}}],[\"批量添加功能\",{\"1\":{\"531\":1}}],[\"批量删除功能\",{\"1\":{\"531\":2}}],[\"批量删除\",{\"0\":{\"518\":1}}],[\"批量读取多个字符到数组\",{\"1\":{\"477\":1}}],[\"批量发送和压缩\",{\"1\":{\"214\":1}}],[\"体系图\",{\"1\":{\"477\":1}}],[\"得\",{\"1\":{\"650\":1}}],[\"得不到\",{\"1\":{\"471\":2}}],[\"得到之前的状态信息\",{\"1\":{\"765\":1}}],[\"得到\",{\"1\":{\"628\":2}}],[\"得到该区域接的雨水\",{\"1\":{\"624\":1}}],[\"得到结果\",{\"1\":{\"524\":1}}],[\"得到对应信息\",{\"1\":{\"475\":1}}],[\"得到对象的锁\",{\"1\":{\"470\":1}}],[\"得到对称密钥\",{\"1\":{\"155\":1}}],[\"得到节点\",{\"1\":{\"443\":1}}],[\"得到col的迭代器\",{\"1\":{\"439\":1}}],[\"得到异常对象后\",{\"1\":{\"424\":1}}],[\"得到枚举常量所属类型的class对象\",{\"1\":{\"421\":1}}],[\"得到当前常量的次序\",{\"1\":{\"421\":1}}],[\"得到当前枚举对象的名称\",{\"1\":{\"421\":1}}],[\"尚未启动\",{\"1\":{\"469\":1}}],[\"礼让不一定成功\",{\"1\":{\"468\":1}}],[\"售出一张票\",{\"1\":{\"466\":1,\"471\":1}}],[\"售票系统\",{\"1\":{\"466\":1}}],[\"窗口中的水果种类大于两种时\",{\"1\":{\"631\":1}}],[\"窗口值减小\",{\"1\":{\"630\":1}}],[\"窗口宽度\",{\"1\":{\"630\":1}}],[\"窗口\",{\"1\":{\"466\":1,\"471\":1}}],[\"票已售完\",{\"1\":{\"466\":1,\"471\":1}}],[\"举例推导dp数组\",{\"1\":{\"692\":1}}],[\"举例\",{\"1\":{\"466\":1,\"571\":1}}],[\"举个例子\",{\"1\":{\"176\":1}}],[\"坦克大战\",{\"0\":{\"463\":1}}],[\"故禁止使用\",{\"1\":{\"461\":1}}],[\"任何不在边界上\",{\"1\":{\"709\":1}}],[\"任何边界上的\",{\"1\":{\"709\":1}}],[\"任何顺序\",{\"1\":{\"683\":1}}],[\"任意字符\",{\"1\":{\"702\":1}}],[\"任意字母都可以\",{\"1\":{\"456\":1}}],[\"任意顺序\",{\"1\":{\"684\":1,\"686\":1}}],[\"任务会被添加到阻塞队列中\",{\"1\":{\"135\":1}}],[\"任务\",{\"1\":{\"132\":1}}],[\"任务依赖关系\",{\"1\":{\"91\":1}}],[\"任务个数\",{\"1\":{\"91\":2}}],[\"任务之间相互依赖\",{\"1\":{\"91\":1}}],[\"任务占用一定内存\",{\"1\":{\"91\":1}}],[\"任务列表\",{\"0\":{\"25\":1}}],[\"柯基\",{\"1\":{\"454\":2}}],[\"旺财\",{\"1\":{\"454\":2}}],[\"升序排列就是最小的排列\",{\"1\":{\"628\":1}}],[\"升序\",{\"1\":{\"452\":1}}],[\"键值对不需要空格\",{\"1\":{\"480\":1}}],[\"键2\",{\"1\":{\"480\":1}}],[\"键1\",{\"1\":{\"480\":1}}],[\"键盘\",{\"1\":{\"478\":1}}],[\"键盘输入\",{\"0\":{\"368\":1}}],[\"键插入和取出顺序一致\",{\"1\":{\"451\":1}}],[\"键排序\",{\"1\":{\"451\":1}}],[\"键无序\",{\"1\":{\"451\":1}}],[\"改进\",{\"1\":{\"655\":1}}],[\"改进aba问题\",{\"1\":{\"300\":1}}],[\"改变了字符串的长度\",{\"1\":{\"644\":1}}],[\"改变name值\",{\"1\":{\"486\":1}}],[\"改查多\",{\"1\":{\"451\":1}}],[\"总共有\",{\"1\":{\"717\":1}}],[\"总座位数\",{\"1\":{\"678\":1}}],[\"总页数\",{\"1\":{\"542\":1}}],[\"总数据\",{\"1\":{\"542\":1}}],[\"总结\",{\"0\":{\"451\":1}}],[\"总的来说\",{\"1\":{\"62\":1}}],[\"宋喆\",{\"1\":{\"448\":1}}],[\"鹿晗\",{\"1\":{\"448\":1}}],[\"马蓉\",{\"1\":{\"448\":2}}],[\"王宝强\",{\"1\":{\"448\":1}}],[\"孙俪\",{\"1\":{\"448\":1}}],[\"邓超\",{\"1\":{\"448\":1}}],[\"变为\",{\"1\":{\"713\":2}}],[\"变为32\",{\"1\":{\"445\":1}}],[\"变量作用域\",{\"0\":{\"491\":1}}],[\"变量迭代语句\",{\"1\":{\"374\":1}}],[\"变量和类型\",{\"1\":{\"304\":1}}],[\"迭代法\",{\"1\":{\"665\":1}}],[\"迭代器\",{\"1\":{\"444\":1,\"448\":1}}],[\"迭代输出有序序列\",{\"1\":{\"193\":1}}],[\"满后按2倍扩容如果指定大小\",{\"1\":{\"442\":1}}],[\"满足\",{\"1\":{\"318\":1}}],[\"清楚未使用的数据卷\",{\"1\":{\"615\":1}}],[\"清空\",{\"1\":{\"439\":1}}],[\"清除算法类似\",{\"1\":{\"148\":1}}],[\"秒=\",{\"1\":{\"436\":1}}],[\"秒\",{\"1\":{\"436\":1}}],[\"水\",{\"1\":{\"706\":1,\"708\":1}}],[\"水果成篮\",{\"0\":{\"631\":1}}],[\"水浒传\",{\"1\":{\"433\":1}}],[\"水管都一样\",{\"1\":{\"104\":1}}],[\"西游记\",{\"1\":{\"433\":1}}],[\"西游记里面菩萨定好的\",{\"1\":{\"104\":1}}],[\"红楼梦\",{\"1\":{\"433\":1}}],[\"红黑树的效率低于跳表\",{\"1\":{\"193\":1}}],[\"红黑树也能完成\",{\"1\":{\"193\":1}}],[\"红黑树\",{\"1\":{\"124\":1}}],[\"平均\",{\"1\":{\"721\":1}}],[\"平方后\",{\"1\":{\"629\":1}}],[\"平方根\",{\"1\":{\"432\":1}}],[\"平台运行\",{\"1\":{\"346\":1}}],[\"平台或\",{\"1\":{\"346\":1}}],[\"商品名\",{\"1\":{\"430\":1}}],[\"删\",{\"1\":{\"430\":1}}],[\"删除文件\",{\"1\":{\"763\":1}}],[\"删除val对应的索引\",{\"1\":{\"721\":1}}],[\"删除volume\",{\"1\":{\"615\":1}}],[\"删除nums末尾的多余数\",{\"1\":{\"721\":1}}],[\"删除和获取随机元素\",{\"0\":{\"721\":1}}],[\"删除和更新等操作时\",{\"1\":{\"125\":1}}],[\"删除头部的key\",{\"1\":{\"720\":1}}],[\"删除key\",{\"1\":{\"720\":2}}],[\"删除窗口左侧元素时\",{\"1\":{\"661\":1}}],[\"删除pre后的节点\",{\"1\":{\"638\":1}}],[\"删除的节点大于链表长度\",{\"1\":{\"638\":1}}],[\"删除链表的倒数第\",{\"1\":{\"638\":1}}],[\"删除链表的的倒数第n个节点\",{\"0\":{\"638\":1}}],[\"删除链表中等于给定值\",{\"1\":{\"634\":1}}],[\"删除操作\",{\"1\":{\"635\":1}}],[\"删除第index个节点\",{\"1\":{\"635\":1}}],[\"删除镜像\",{\"1\":{\"613\":1}}],[\"删除了一个数\",{\"1\":{\"623\":1}}],[\"删除了\",{\"1\":{\"577\":1}}],[\"删除了迭代器右边的元素\",{\"1\":{\"443\":1}}],[\"删除了迭代器左边的元素\",{\"1\":{\"443\":1}}],[\"删除目录或文件\",{\"1\":{\"475\":1}}],[\"删除节点\",{\"1\":{\"443\":1}}],[\"删除多个元素\",{\"1\":{\"439\":1}}],[\"删除指定元素\",{\"1\":{\"439\":1}}],[\"删除指定索引之内的字符\",{\"1\":{\"430\":1}}],[\"删除完成\",{\"1\":{\"408\":1}}],[\"删除房屋\",{\"1\":{\"408\":1}}],[\"删除房源\",{\"1\":{\"408\":2}}],[\"删除当前行\",{\"1\":{\"395\":1}}],[\"删除此线程局部变量的当前线程值\",{\"1\":{\"304\":1}}],[\"删除时报错\",{\"1\":{\"196\":1}}],[\"删除缓存\",{\"1\":{\"195\":1}}],[\"删除一个数据\",{\"1\":{\"193\":1}}],[\"删除\",{\"0\":{\"577\":1},\"1\":{\"188\":1,\"408\":1,\"419\":1,\"577\":1}}],[\"删除元素\",{\"1\":{\"188\":1}}],[\"看是否匹配\",{\"1\":{\"659\":1}}],[\"看如下两个链表\",{\"1\":{\"639\":1}}],[\"看起来像是返回void\",{\"1\":{\"489\":1}}],[\"看起来cas比锁的效率高\",{\"1\":{\"299\":1}}],[\"看这个索引位置是否已经存放元素\",{\"1\":{\"445\":1}}],[\"看看在\",{\"1\":{\"436\":1}}],[\"看看\",{\"1\":{\"430\":1,\"436\":1}}],[\"看\",{\"1\":{\"430\":1}}],[\"截取指定范围的字符串\",{\"1\":{\"429\":1}}],[\"忽略大小写的判断\",{\"1\":{\"429\":1}}],[\"手动获取属性\",{\"1\":{\"603\":1}}],[\"手动拆箱\",{\"1\":{\"427\":1}}],[\"手动装箱\",{\"1\":{\"427\":1}}],[\"手动依赖管理\",{\"1\":{\"168\":1}}],[\"针对范围请求\",{\"1\":{\"770\":1}}],[\"针对指定的资源可以使用查询字符串传入任意参数\",{\"1\":{\"757\":1}}],[\"针对八种基本定义相应的引用类型\",{\"1\":{\"427\":1}}],[\"针对先删缓存后更新数据\",{\"1\":{\"196\":1}}],[\"抛出异常\",{\"0\":{\"425\":1}}],[\"始终要执行finally\",{\"1\":{\"424\":1}}],[\"捕获到异常\",{\"1\":{\"424\":1}}],[\"派生出runtimeexception和ioexception\",{\"1\":{\"424\":1}}],[\"十九\",{\"0\":{\"487\":1}}],[\"十八\",{\"0\":{\"486\":1}}],[\"十七\",{\"0\":{\"481\":1}}],[\"十六\",{\"0\":{\"473\":1}}],[\"十五\",{\"0\":{\"465\":1}}],[\"十四\",{\"0\":{\"463\":1}}],[\"十三\",{\"0\":{\"453\":1}}],[\"十二\",{\"0\":{\"437\":1}}],[\"十一\",{\"0\":{\"426\":1}}],[\"十\",{\"0\":{\"423\":1}}],[\"抑制编译器警告\",{\"1\":{\"422\":1}}],[\"寒冷\",{\"1\":{\"421\":2}}],[\"冬天\",{\"1\":{\"421\":2}}],[\"凉爽\",{\"1\":{\"421\":2}}],[\"秋天\",{\"1\":{\"421\":2}}],[\"炎热\",{\"1\":{\"421\":2}}],[\"夏天\",{\"1\":{\"421\":2}}],[\"温暖\",{\"1\":{\"421\":2}}],[\"春天\",{\"1\":{\"421\":2}}],[\"枚举左边界\",{\"1\":{\"650\":1}}],[\"枚举类型不能clone\",{\"1\":{\"421\":1}}],[\"枚举类型构造器默认是private\",{\"1\":{\"421\":1}}],[\"枚举类常用方法\",{\"1\":{\"421\":1}}],[\"枚举类也可以实现接口\",{\"1\":{\"421\":1}}],[\"枚举对象必须放在类的第一行\",{\"1\":{\"421\":1}}],[\"枚举\",{\"0\":{\"421\":1}}],[\"枚举和注解\",{\"0\":{\"420\":1}}],[\"真实主题角色\",{\"1\":{\"419\":1}}],[\"真正的性能瓶颈在于网络\",{\"1\":{\"187\":1}}],[\"准备工作\",{\"0\":{\"575\":1}}],[\"准备\",{\"1\":{\"419\":1}}],[\"匿名类名称为外部类名称加个$1\",{\"1\":{\"418\":1}}],[\"匿名类名称\",{\"1\":{\"418\":3}}],[\"匿名内部类既是一个类的定义\",{\"1\":{\"418\":1}}],[\"匿名内部类的使用\",{\"1\":{\"418\":1}}],[\"匿名内部类\",{\"1\":{\"418\":2}}],[\"又由于后两次的范围对于第一次是包含关系\",{\"1\":{\"698\":1}}],[\"又是一个类的对象\",{\"1\":{\"418\":1}}],[\"又进行一次读取操作\",{\"1\":{\"171\":1}}],[\"又进行了一次读取操作\",{\"1\":{\"171\":1}}],[\"局部类访问外部类可以直接访问\",{\"1\":{\"418\":1}}],[\"局部内部类是局部变量\",{\"1\":{\"418\":1}}],[\"局部内部类的使用\",{\"1\":{\"418\":1}}],[\"局部内部类\",{\"1\":{\"418\":1}}],[\"局部变量必须赋值后使用\",{\"1\":{\"391\":1}}],[\"局部变量作用域在代码块中\",{\"1\":{\"391\":1}}],[\"局部变量一般是指在方法中定义的变量\",{\"1\":{\"391\":1}}],[\"局部变量\",{\"1\":{\"388\":1}}],[\"练习\",{\"0\":{\"631\":1},\"1\":{\"417\":1,\"430\":1}}],[\"像类一样的多态\",{\"1\":{\"417\":1}}],[\"像mybatis的mybatis\",{\"1\":{\"81\":1}}],[\"耗时\",{\"1\":{\"416\":1}}],[\"耗时较长\",{\"1\":{\"173\":1}}],[\"防止之后重复遍历\",{\"1\":{\"706\":1}}],[\"防止访问同一片区域\",{\"1\":{\"705\":1,\"734\":1}}],[\"防止重复访问同一片区域\",{\"1\":{\"704\":1}}],[\"防止修改内部属性\",{\"1\":{\"421\":1}}],[\"防止直接new对象\",{\"1\":{\"414\":1}}],[\"防火墙\",{\"1\":{\"49\":1}}],[\"饿汉式\",{\"1\":{\"414\":2}}],[\"采摘的水果应当符合篮子中的水果类型\",{\"1\":{\"631\":1}}],[\"采取一定方法保证在整个的软件系统中\",{\"1\":{\"414\":1}}],[\"采用cp模式\",{\"1\":{\"600\":1}}],[\"采用异步响应式编程\",{\"1\":{\"588\":1}}],[\"采用命令式编程\",{\"1\":{\"588\":1}}],[\"采用了非常底层的字节码技术\",{\"1\":{\"492\":1}}],[\"采用了无阻塞算法\",{\"1\":{\"125\":1}}],[\"采用三次握手方式\",{\"1\":{\"482\":1}}],[\"采用模版方法的模式提供实现类以下方法\",{\"1\":{\"313\":1}}],[\"采用no\",{\"1\":{\"192\":1}}],[\"采用单线程\",{\"1\":{\"186\":1}}],[\"采用的是英制的插头\",{\"1\":{\"95\":1}}],[\"号房屋\",{\"1\":{\"697\":2,\"698\":2}}],[\"号桶初始什么都没装\",{\"1\":{\"689\":1,\"701\":1}}],[\"号可以省略\",{\"1\":{\"413\":1}}],[\"号的使用\",{\"0\":{\"357\":1}}],[\"深度为字符串长度\",{\"1\":{\"688\":1}}],[\"深度为输入字符串的长度\",{\"1\":{\"684\":1}}],[\"深度在变化\",{\"1\":{\"686\":2}}],[\"深度+1\",{\"1\":{\"669\":1}}],[\"深度\",{\"1\":{\"669\":1}}],[\"深入理解main方法\",{\"1\":{\"412\":1}}],[\"深拷贝是通过实现\",{\"1\":{\"116\":1}}],[\"仍要遵守访问权限规则\",{\"1\":{\"411\":1}}],[\"仍然使用字符数组来存储\",{\"1\":{\"121\":1}}],[\"推荐使用\",{\"1\":{\"411\":1}}],[\"九\",{\"0\":{\"410\":1}}],[\"九九乘法表\",{\"1\":{\"376\":1}}],[\"完整uri\",{\"1\":{\"762\":1}}],[\"完美满足差分数组法\",{\"1\":{\"678\":1}}],[\"完成对象创建和注入关系\",{\"1\":{\"581\":1}}],[\"完成对房屋信息的各种操作\",{\"1\":{\"409\":1}}],[\"完善\",{\"0\":{\"503\":1}}],[\"完全\",{\"1\":{\"708\":1}}],[\"完全注解方式\",{\"0\":{\"584\":1}}],[\"完全注解开发\",{\"0\":{\"565\":1}}],[\"完全基于内存\",{\"1\":{\"186\":1}}],[\"完全二叉树已知所有路径的和\",{\"1\":{\"90\":1}}],[\"响应首部字段\",{\"1\":{\"784\":1}}],[\"响应会返回状态码\",{\"1\":{\"770\":1}}],[\"响应中的各个属性进行处理\",{\"1\":{\"607\":1}}],[\"响应转换成需要的响应对象\",{\"1\":{\"606\":1}}],[\"响应时间越长\",{\"1\":{\"598\":1}}],[\"响应式编程模型以及许多其他功能\",{\"1\":{\"545\":1}}],[\"响应houseview的调用\",{\"1\":{\"409\":1}}],[\"响应结果\",{\"1\":{\"76\":1}}],[\"业务\",{\"1\":{\"409\":1}}],[\"业务模块名\",{\"1\":{\"396\":1}}],[\"界面\",{\"1\":{\"409\":1}}],[\"房主\",{\"1\":{\"408\":1}}],[\"房屋列表\",{\"1\":{\"408\":3}}],[\"房屋出租系统\",{\"0\":{\"407\":1},\"1\":{\"408\":1}}],[\"昌平区\",{\"1\":{\"408\":2}}],[\"朝各个方向开始递归\",{\"1\":{\"704\":1}}],[\"朝阳区\",{\"1\":{\"408\":1}}],[\"朝花夕拾\",{\"0\":{\"47\":1}}],[\"地址对象\",{\"1\":{\"483\":1}}],[\"地址\",{\"1\":{\"408\":2}}],[\"地基\",{\"1\":{\"104\":1}}],[\"电话号码的字母组合\",{\"0\":{\"684\":1}}],[\"电话\",{\"1\":{\"408\":2}}],[\"电商网站比价\",{\"0\":{\"254\":1}}],[\"姓名\",{\"1\":{\"408\":1}}],[\"确定遍历顺序\",{\"1\":{\"692\":1}}],[\"确定递推公式\",{\"1\":{\"692\":1}}],[\"确定dp数组\",{\"1\":{\"692\":1}}],[\"确定类型\",{\"1\":{\"459\":1}}],[\"确认请求的远程地址匹配指定的模式\",{\"1\":{\"607\":1}}],[\"确认请求的查询参数中是否包含指定的参数或参数值\",{\"1\":{\"607\":1}}],[\"确认请求的路径符合指定的模式\",{\"1\":{\"607\":1}}],[\"确认请求的http方法与指定的方法匹配\",{\"1\":{\"607\":1}}],[\"确认请求的host匹配指定的模式\",{\"1\":{\"607\":1}}],[\"确认请求中是否包含指定header或header值\",{\"1\":{\"607\":1}}],[\"确认请求中是否包含指定cookie或cookie值\",{\"1\":{\"607\":1}}],[\"确认请求是否在两个指定的时间之间\",{\"1\":{\"607\":1}}],[\"确认请求是否在某个时间之前\",{\"1\":{\"607\":1}}],[\"确认请求是否在某个时间之后\",{\"1\":{\"607\":1}}],[\"确认是否删除\",{\"1\":{\"408\":1}}],[\"确保\",{\"0\":{\"787\":1}}],[\"确保可靠性的tcp协议\",{\"0\":{\"753\":1}}],[\"确保docker\",{\"1\":{\"617\":1}}],[\"确保数据发送成功\",{\"1\":{\"753\":1}}],[\"确保数据能准确发送\",{\"1\":{\"753\":1}}],[\"确保数据不会被别的线程修改\",{\"1\":{\"258\":1}}],[\"确保数据的机密性和完整性\",{\"1\":{\"154\":1}}],[\"确保读请求结束\",{\"1\":{\"196\":1}}],[\"确保读取到最新的数据\",{\"1\":{\"125\":1}}],[\"确保其他事务无法同时修改被锁定的数据\",{\"1\":{\"171\":1}}],[\"确保方法a和b都处于同一个事务的管理下\",{\"1\":{\"166\":1}}],[\"确保代理机制能够拦截方法b的调用\",{\"1\":{\"166\":1}}],[\"确保这些参数足够大\",{\"1\":{\"146\":1}}],[\"确保没有使用过多的内存或存在内存泄漏的情况\",{\"1\":{\"146\":1}}],[\"海淀区\",{\"1\":{\"408\":1}}],[\"退出当前程序\",{\"1\":{\"434\":1}}],[\"退出\",{\"1\":{\"408\":1}}],[\"退出switch\",{\"1\":{\"372\":1}}],[\"八\",{\"0\":{\"407\":1}}],[\"垃圾回收机制\",{\"1\":{\"468\":1}}],[\"垃圾回收机制的调用\",{\"1\":{\"406\":1}}],[\"垃圾的自动收集\",{\"1\":{\"346\":1}}],[\"源码下载地址\",{\"0\":{\"551\":1}}],[\"源码分析\",{\"1\":{\"220\":1}}],[\"源\",{\"1\":{\"482\":1}}],[\"源代码中object类中的equles方法\",{\"1\":{\"406\":1}}],[\"示例\",{\"0\":{\"724\":1,\"726\":1},\"1\":{\"404\":1,\"622\":1,\"624\":1,\"625\":1,\"629\":2,\"630\":1,\"631\":4,\"632\":1,\"634\":3,\"636\":1,\"643\":1,\"645\":3,\"647\":1,\"648\":1,\"649\":1,\"650\":1,\"651\":2,\"659\":2,\"660\":2,\"661\":1,\"667\":3,\"668\":2,\"669\":1,\"677\":1,\"678\":1,\"684\":3,\"686\":1,\"687\":1,\"688\":1,\"689\":1,\"690\":2,\"696\":1,\"697\":1,\"698\":1,\"701\":1,\"702\":1,\"706\":1,\"708\":1,\"709\":1,\"716\":1,\"717\":1}}],[\"哪里声明哪里使用\",{\"1\":{\"403\":1}}],[\"引用数目\",{\"1\":{\"536\":1}}],[\"引用名\",{\"1\":{\"402\":2}}],[\"引起报错\",{\"1\":{\"491\":1}}],[\"引出\",{\"1\":{\"478\":1}}],[\"引入httpclient依赖\",{\"1\":{\"606\":1}}],[\"引入html页面\",{\"1\":{\"332\":1}}],[\"引入依赖\",{\"1\":{\"606\":2}}],[\"引入eureka\",{\"1\":{\"597\":2}}],[\"引入外部属性文件\",{\"1\":{\"562\":2}}],[\"引入外部属性文件配置数据库连接池\",{\"1\":{\"562\":1}}],[\"引入德鲁伊连接池依赖\",{\"1\":{\"562\":1}}],[\"引入\",{\"1\":{\"499\":1,\"507\":1,\"509\":1,\"563\":1,\"575\":1,\"586\":1}}],[\"引入图片\",{\"1\":{\"332\":1}}],[\"引入js\",{\"1\":{\"332\":1}}],[\"引入css\",{\"1\":{\"332\":1}}],[\"引入多线程处理异步任务\",{\"1\":{\"187\":1}}],[\"引入了一个新的内部数据结构\",{\"1\":{\"121\":1}}],[\"谁在叫\",{\"1\":{\"402\":1}}],[\"覆盖模式\",{\"1\":{\"477\":1}}],[\"覆盖\",{\"0\":{\"401\":1}}],[\"隐藏实现细节\",{\"1\":{\"398\":1}}],[\"隐式锁\",{\"1\":{\"263\":1}}],[\"好处\",{\"1\":{\"398\":1}}],[\"私有\",{\"1\":{\"397\":1}}],[\"❌\",{\"1\":{\"397\":6}}],[\"受保护\",{\"1\":{\"397\":1}}],[\"✔\",{\"1\":{\"397\":10}}],[\"项目部署问题\",{\"1\":{\"609\":1}}],[\"项目启动\",{\"1\":{\"602\":2}}],[\"项目中配置nacos依赖\",{\"1\":{\"599\":1}}],[\"项目需求\",{\"0\":{\"408\":1}}],[\"项目\",{\"0\":{\"407\":1}}],[\"项目名\",{\"1\":{\"396\":1}}],[\"项目结构\",{\"1\":{\"82\":1}}],[\"公开\",{\"1\":{\"397\":1}}],[\"公司名\",{\"1\":{\"396\":1}}],[\"公平锁\",{\"1\":{\"262\":1}}],[\"公平锁和非公平锁\",{\"0\":{\"262\":1}}],[\"补全代码\",{\"1\":{\"395\":1}}],[\"补码都是0\",{\"1\":{\"369\":1}}],[\"补码都一样\",{\"1\":{\"369\":1}}],[\"补码\",{\"0\":{\"369\":1}}],[\"⬇\",{\"1\":{\"395\":1}}],[\"七\",{\"0\":{\"394\":1}}],[\"阶乘问题\",{\"1\":{\"391\":1}}],[\"克隆对象\",{\"0\":{\"390\":1}}],[\"堆\",{\"1\":{\"388\":1}}],[\"栈与队列\",{\"0\":{\"654\":1}}],[\"栈\",{\"0\":{\"665\":1},\"1\":{\"388\":1}}],[\"栈溢出\",{\"1\":{\"126\":1}}],[\"访问上\",{\"1\":{\"704\":1}}],[\"访问接口的x就用a\",{\"1\":{\"417\":1}}],[\"访问本类中的方法\",{\"1\":{\"400\":1}}],[\"访问本类中的属性\",{\"1\":{\"400\":1}}],[\"访问父类中的属性\",{\"1\":{\"400\":1}}],[\"访问父类的x就用super\",{\"1\":{\"417\":1}}],[\"访问父类的构造器\",{\"1\":{\"400\":1}}],[\"访问父类的属性\",{\"1\":{\"400\":1}}],[\"访问属性\",{\"1\":{\"400\":1}}],[\"访问控制修饰符\",{\"1\":{\"397\":1}}],[\"访问级别\",{\"1\":{\"397\":1}}],[\"访问修饰符\",{\"0\":{\"397\":1},\"1\":{\"386\":1}}],[\"访问方式\",{\"1\":{\"153\":1}}],[\"六\",{\"0\":{\"383\":1}}],[\"杨辉三角\",{\"1\":{\"382\":1}}],[\"赋值可以在定义时\",{\"1\":{\"415\":1}}],[\"赋值\",{\"1\":{\"382\":1}}],[\"赋值运算符\",{\"0\":{\"365\":1},\"1\":{\"365\":1,\"367\":1}}],[\"赋的是地址\",{\"1\":{\"381\":1}}],[\"五\",{\"0\":{\"380\":1}}],[\"跳过行数和列数后的换行符\",{\"1\":{\"728\":1}}],[\"跳过行数后的换行符\",{\"1\":{\"727\":1}}],[\"跳过换行\",{\"1\":{\"728\":1}}],[\"跳过重复数\",{\"1\":{\"627\":1}}],[\"跳过所有重复的元素\",{\"1\":{\"627\":1}}],[\"跳过相同的数\",{\"1\":{\"627\":1}}],[\"跳出循环\",{\"1\":{\"377\":1}}],[\"跳转控制语句\",{\"0\":{\"377\":1,\"378\":1,\"379\":1}}],[\"跳表可以做到o\",{\"1\":{\"193\":1}}],[\"若有循环依赖无法完成初始化\",{\"1\":{\"718\":1}}],[\"若多100这个操作失败\",{\"1\":{\"580\":1}}],[\"若修改\",{\"1\":{\"496\":1}}],[\"若不同就以链表形式添加到后面\",{\"1\":{\"445\":1}}],[\"若不定义构造器\",{\"1\":{\"392\":1}}],[\"若相同就不添加\",{\"1\":{\"445\":1}}],[\"若出错则会抛出一个filenotfoundexception异常\",{\"1\":{\"425\":1}}],[\"若对象为null则创建一个对象\",{\"1\":{\"414\":1}}],[\"若使用super父类中没有\",{\"1\":{\"400\":1}}],[\"若没有指定类型\",{\"1\":{\"457\":1}}],[\"若没有指定break\",{\"1\":{\"377\":1}}],[\"若没有则会执行编译类型中的方法\",{\"1\":{\"402\":1}}],[\"若没有break则会顺序执行下一个语句块\",{\"1\":{\"372\":1}}],[\"若要中断一个线程\",{\"1\":{\"267\":1}}],[\"四数之和\",{\"0\":{\"627\":1}}],[\"四\",{\"0\":{\"370\":1}}],[\"四舍五入到小数点后两位\",{\"1\":{\"5\":1}}],[\"反向生成资源\",{\"1\":{\"540\":1}}],[\"反之\",{\"1\":{\"492\":1}}],[\"反序列化就是在恢复数据时\",{\"1\":{\"478\":1}}],[\"反转二叉树\",{\"0\":{\"667\":1}}],[\"反转到另一个栈\",{\"1\":{\"655\":3}}],[\"反转区间为n到末尾的子串\",{\"1\":{\"646\":1}}],[\"反转区间为前n的子串\",{\"1\":{\"646\":1}}],[\"反转各个单词\",{\"1\":{\"645\":2}}],[\"反转整个字符串\",{\"1\":{\"645\":2,\"646\":1}}],[\"反转字符串指定区间\",{\"1\":{\"645\":1}}],[\"反转字符串2\",{\"0\":{\"643\":1}}],[\"反转字符串\",{\"0\":{\"642\":1}}],[\"反转两个指针指向节点的next\",{\"1\":{\"636\":1}}],[\"反转一个单链表\",{\"1\":{\"636\":1}}],[\"反转链表\",{\"0\":{\"636\":1}}],[\"反转\",{\"1\":{\"452\":1}}],[\"反码\",{\"0\":{\"369\":1},\"1\":{\"369\":2}}],[\"反射操作多\",{\"1\":{\"496\":1}}],[\"反射\",{\"0\":{\"486\":1},\"1\":{\"63\":1,\"555\":1}}],[\"反射机制\",{\"1\":{\"63\":1}}],[\"位是否是\",{\"1\":{\"689\":1,\"701\":1}}],[\"位置为\",{\"1\":{\"689\":2,\"701\":2}}],[\"位置的数\",{\"1\":{\"628\":1}}],[\"位置\",{\"1\":{\"540\":2}}],[\"位移运算符\",{\"1\":{\"367\":1}}],[\"位图是由二进制位组成的数据结构\",{\"1\":{\"188\":1}}],[\"位图\",{\"1\":{\"188\":1}}],[\"~\",{\"1\":{\"367\":1}}],[\"找出是否有可能把这个数组分成\",{\"1\":{\"689\":1}}],[\"找出其最小深度\",{\"1\":{\"712\":1}}],[\"找出其最大深度\",{\"1\":{\"669\":1}}],[\"找出其中的两条线\",{\"1\":{\"625\":1}}],[\"找出该数组中满足其和\",{\"1\":{\"630\":1}}],[\"找出\",{\"1\":{\"628\":1}}],[\"找左边最高的柱子\",{\"1\":{\"624\":1}}],[\"找右边最高的柱子\",{\"1\":{\"624\":1}}],[\"找好区间\",{\"1\":{\"620\":1}}],[\"找到一个当前长度的乘积最大剪法\",{\"1\":{\"737\":1}}],[\"找到所有被\",{\"1\":{\"709\":1}}],[\"找到了模式串中第三个字符b继续开始匹配\",{\"1\":{\"653\":1}}],[\"找到了则返回下标\",{\"1\":{\"381\":1}}],[\"找到\",{\"1\":{\"649\":1,\"650\":1}}],[\"找到字符串中所有字母异位词\",{\"0\":{\"649\":1}}],[\"找到前驱\",{\"1\":{\"635\":1}}],[\"找到要插入节点的前驱\",{\"1\":{\"635\":1}}],[\"找到存储表table\",{\"1\":{\"445\":1}}],[\"找不到则返回\",{\"1\":{\"429\":2}}],[\"找三个数中的最大值\",{\"1\":{\"366\":1}}],[\"找数组中的最大最小值\",{\"0\":{\"46\":1}}],[\"左儿子left是第left\",{\"1\":{\"730\":1}}],[\"左\",{\"1\":{\"704\":1,\"708\":1}}],[\"左括号剩余\",{\"1\":{\"690\":1}}],[\"左括号必须以正确的顺序闭合\",{\"1\":{\"659\":1}}],[\"左括号必须用相同类型的右括号闭合\",{\"1\":{\"659\":1}}],[\"左子树和右子树分别从左和右前序遍历\",{\"1\":{\"668\":1}}],[\"左指针\",{\"1\":{\"649\":1}}],[\"左移窗口\",{\"1\":{\"647\":1}}],[\"左旋转字符串\",{\"0\":{\"646\":1}}],[\"左到右\",{\"1\":{\"632\":1}}],[\"左边界的上限设置可以宽松一些\",{\"1\":{\"650\":1}}],[\"左边界右移\",{\"1\":{\"630\":2}}],[\"左边最高的柱子\",{\"1\":{\"624\":1}}],[\"左边写的是形参列表\",{\"1\":{\"129\":1}}],[\"左右括号都用完时结束回溯\",{\"1\":{\"690\":1}}],[\"左右括号数量应该相同\",{\"1\":{\"690\":1}}],[\"左右子节点都不存在则不操作\",{\"1\":{\"667\":1}}],[\"左右指针\",{\"1\":{\"625\":2}}],[\"左右指针法\",{\"0\":{\"620\":1}}],[\"左右两边的表达式\",{\"1\":{\"364\":1}}],[\"逻辑上的一组操作\",{\"1\":{\"580\":1}}],[\"逻辑异或\",{\"1\":{\"364\":1}}],[\"逻辑或\",{\"1\":{\"364\":1}}],[\"逻辑与\",{\"1\":{\"364\":1}}],[\"逻辑运算符一览\",{\"1\":{\"364\":1}}],[\"逻辑运算符\",{\"0\":{\"364\":1},\"1\":{\"367\":1}}],[\"短路或\",{\"1\":{\"364\":1}}],[\"短路与\",{\"1\":{\"364\":1}}],[\"短信\",{\"1\":{\"207\":1}}],[\"取模后的结果无法用math\",{\"1\":{\"739\":1}}],[\"取最大价值\",{\"1\":{\"700\":1}}],[\"取出节点\",{\"1\":{\"666\":1,\"669\":1}}],[\"取出由数据库表内部生成的主键值\",{\"1\":{\"501\":1}}],[\"取出所有value再遍历\",{\"1\":{\"448\":1}}],[\"取反\",{\"1\":{\"364\":1}}],[\"取余\",{\"1\":{\"362\":1}}],[\"取消注释\",{\"1\":{\"395\":1}}],[\"取消的线程永远不会成功获取\",{\"1\":{\"312\":1}}],[\"取消任务的执行\",{\"1\":{\"229\":1}}],[\"乘客数量\",{\"1\":{\"677\":1}}],[\"乘客\",{\"1\":{\"677\":1}}],[\"乘\",{\"1\":{\"362\":1}}],[\"减\",{\"1\":{\"362\":1}}],[\"减少\",{\"1\":{\"583\":1}}],[\"减少cpu的空闲状态时间\",{\"1\":{\"262\":1}}],[\"减少网络开销\",{\"1\":{\"214\":1}}],[\"减少了类型转换的次数\",{\"1\":{\"454\":1}}],[\"减少了线程之间等待的时间\",{\"1\":{\"299\":1}}],[\"减少了线程开销\",{\"1\":{\"262\":1}}],[\"减少了数据的大小\",{\"1\":{\"214\":1}}],[\"减少了数据在内核空间和用户空间之间的复制\",{\"1\":{\"214\":1}}],[\"减少了比较的次数\",{\"1\":{\"172\":1}}],[\"减少了内存的开销\",{\"1\":{\"98\":1}}],[\"减少类型转换\",{\"1\":{\"123\":1}}],[\"减少它们之间耦合\",{\"1\":{\"113\":1}}],[\"负载均衡策略\",{\"1\":{\"598\":1}}],[\"负载均衡流程\",{\"1\":{\"598\":1}}],[\"负载均衡原理\",{\"0\":{\"598\":1},\"1\":{\"598\":1}}],[\"负载均衡\",{\"1\":{\"592\":1,\"593\":1,\"607\":1}}],[\"负数的补码\",{\"1\":{\"369\":1}}],[\"负数的反码\",{\"1\":{\"369\":1}}],[\"负号\",{\"1\":{\"362\":1}}],[\"负责域名解析的dns服务\",{\"0\":{\"754\":1}}],[\"负责传输的ip协议\",{\"0\":{\"752\":1}}],[\"负责处理docker\",{\"1\":{\"611\":1}}],[\"负责处理所有的请求分发和委派\",{\"1\":{\"161\":1}}],[\"负责管理\",{\"1\":{\"597\":1}}],[\"负责执行指令\",{\"1\":{\"348\":1}}],[\"负责协调和管理spring\",{\"1\":{\"162\":1}}],[\"负责完成接收http请求\",{\"1\":{\"69\":1}}],[\"正整数\",{\"1\":{\"720\":1}}],[\"正则表达式匹配\",{\"0\":{\"702\":1}}],[\"正在执行方法\",{\"1\":{\"569\":1}}],[\"正在等待另一个线程执行动作达到指定时间\",{\"1\":{\"469\":1}}],[\"正在等待另一个线程执行特定动作\",{\"1\":{\"469\":1}}],[\"正向工程\",{\"1\":{\"540\":1}}],[\"正余弦\",{\"1\":{\"432\":1}}],[\"正数的原码\",{\"1\":{\"369\":1}}],[\"正号\",{\"1\":{\"362\":1}}],[\"正确的数组赋值方法\",{\"1\":{\"381\":1}}],[\"正确\",{\"1\":{\"358\":1,\"359\":3,\"365\":1,\"460\":3}}],[\"范例\",{\"1\":{\"362\":1}}],[\"范围请求\",{\"0\":{\"770\":1}}],[\"范围不同\",{\"1\":{\"359\":1}}],[\"范围的用户控制\",{\"1\":{\"209\":1}}],[\"范围查询只需要遍历叶子节点链表即可\",{\"1\":{\"172\":1}}],[\"范围有限制\",{\"1\":{\"107\":1}}],[\"运算结果等于\",{\"1\":{\"687\":1}}],[\"运算顺序从右向左\",{\"1\":{\"365\":1}}],[\"运算\",{\"1\":{\"362\":1}}],[\"运算符优先级\",{\"0\":{\"367\":1}}],[\"运算符\",{\"1\":{\"362\":1}}],[\"运行结果\",{\"1\":{\"560\":1}}],[\"运行时使用\",{\"1\":{\"616\":1}}],[\"运行时监视\",{\"1\":{\"545\":1}}],[\"运行时错误\",{\"1\":{\"3\":2}}],[\"运行期间每个对象都有一个运行时类型标识\",{\"1\":{\"486\":1}}],[\"运行垃圾回收机制\",{\"1\":{\"434\":1}}],[\"运行类型是匿名内部类\",{\"1\":{\"418\":1}}],[\"运行类型可以改变\",{\"1\":{\"402\":1}}],[\"运行构造器\",{\"1\":{\"414\":1}}],[\"运行消耗\",{\"1\":{\"256\":2}}],[\"运行\",{\"1\":{\"225\":1,\"349\":1}}],[\"算数运算符\",{\"1\":{\"367\":1}}],[\"算数运算符一览\",{\"1\":{\"362\":1}}],[\"算术运算符\",{\"0\":{\"362\":1}}],[\"强制将代码转换为不是实例的子类\",{\"1\":{\"424\":1}}],[\"强制将高精度转换为低精度\",{\"1\":{\"359\":1}}],[\"强制类型转换\",{\"1\":{\"359\":1,\"402\":1}}],[\"强类型机制\",{\"1\":{\"346\":1}}],[\"细节\",{\"1\":{\"359\":2,\"364\":1,\"365\":1,\"366\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"377\":1,\"382\":1,\"389\":1,\"392\":1,\"393\":1,\"397\":1,\"399\":1,\"400\":1,\"401\":1,\"406\":1,\"411\":1,\"413\":1,\"417\":1,\"421\":1,\"457\":1}}],[\"细胞分裂\",{\"1\":{\"116\":1}}],[\"→ln\",{\"1\":{\"729\":1}}],[\"→\",{\"1\":{\"359\":9,\"363\":1}}],[\"​\",{\"1\":{\"359\":1,\"371\":5,\"372\":10,\"373\":1,\"374\":2,\"375\":2,\"377\":3,\"378\":3,\"389\":2,\"417\":5,\"418\":1,\"439\":1,\"457\":1,\"458\":1,\"459\":1,\"470\":2,\"557\":1,\"754\":1}}],[\"精确到毫秒\",{\"1\":{\"436\":1}}],[\"精确匹配\",{\"1\":{\"343\":1}}],[\"精度降低\",{\"1\":{\"359\":1}}],[\"精度高的类型也不能赋值给精度低的类型\",{\"1\":{\"359\":1}}],[\"精度最高\",{\"1\":{\"359\":1}}],[\"精度小的类型自动转换为精度大的类型\",{\"1\":{\"359\":1}}],[\"科学计数法\",{\"1\":{\"358\":1}}],[\"报文得结构为\",{\"1\":{\"783\":1}}],[\"报文首部又分为\",{\"1\":{\"783\":1}}],[\"报文首部\",{\"0\":{\"783\":1}}],[\"报文中存在语法错误\",{\"1\":{\"776\":1}}],[\"报文中使用多部分对象集合时\",{\"1\":{\"769\":1}}],[\"报文主体是用来传输主体\",{\"1\":{\"768\":1}}],[\"报错信息\",{\"1\":{\"491\":1}}],[\"报错\",{\"1\":{\"358\":1}}],[\"报告在首次登录的第二天再次登录的玩家的比率\",{\"1\":{\"5\":1}}],[\"尾数位\",{\"1\":{\"358\":1}}],[\"符号和空格组成\",{\"1\":{\"647\":1}}],[\"符号\",{\"1\":{\"422\":1}}],[\"符号位\",{\"1\":{\"358\":1}}],[\"符合要求\",{\"1\":{\"649\":1}}],[\"符合要求的接口\",{\"1\":{\"95\":1}}],[\"符合赋值运算符会进行类型转换\",{\"1\":{\"365\":1}}],[\"符合上述情况\",{\"1\":{\"318\":1}}],[\"浮点类型在内存中存放形式\",{\"1\":{\"358\":1}}],[\"浮点类型\",{\"1\":{\"358\":1}}],[\"汉字占3个字节\",{\"1\":{\"356\":1}}],[\"汉堡\",{\"1\":{\"107\":1}}],[\"浪费空间\",{\"1\":{\"356\":1}}],[\"英文字母和汉字都占用2个字节\",{\"1\":{\"356\":1}}],[\"回文串\",{\"1\":{\"688\":2}}],[\"回溯path中是否有相同的节点\",{\"1\":{\"718\":1}}],[\"回溯遍历\",{\"1\":{\"716\":1}}],[\"回溯撤销\",{\"1\":{\"690\":2}}],[\"回溯的index为左括号和右括号的剩余个数\",{\"1\":{\"690\":1}}],[\"回溯树中每次可选择+nums\",{\"1\":{\"687\":1}}],[\"回溯\",{\"1\":{\"682\":1,\"687\":1,\"715\":2}}],[\"回溯法暴力搜索\",{\"1\":{\"701\":1}}],[\"回溯法\",{\"1\":{\"681\":1}}],[\"回溯算法框架\",{\"1\":{\"684\":1}}],[\"回溯算法\",{\"0\":{\"680\":1},\"1\":{\"690\":1,\"718\":1}}],[\"回车与换行不同\",{\"1\":{\"353\":1}}],[\"回滚日志记录了事务所做的修改操作的反向操作\",{\"1\":{\"180\":1}}],[\"回滚日志\",{\"1\":{\"180\":1}}],[\"制表符\",{\"1\":{\"353\":1}}],[\"制作\",{\"1\":{\"102\":1}}],[\"程序会高效很多\",{\"1\":{\"643\":1}}],[\"程序会阻塞\",{\"1\":{\"485\":1}}],[\"程序依赖\",{\"1\":{\"616\":1}}],[\"程序\",{\"1\":{\"593\":1}}],[\"程序结束\",{\"1\":{\"477\":1}}],[\"程序调用sleep\",{\"1\":{\"472\":1}}],[\"程序框架设计\",{\"0\":{\"409\":1}}],[\"程序的其他部分只有通过被授权的操作\",{\"1\":{\"398\":1}}],[\"程序入口\",{\"1\":{\"351\":1,\"409\":1}}],[\"程序员自己处理\",{\"1\":{\"424\":1}}],[\"程序员不重复写那些已经规范好的代码\",{\"1\":{\"104\":1}}],[\"程序员仅可以使用右值对unique\",{\"1\":{\"3\":1}}],[\"共需\",{\"1\":{\"718\":1}}],[\"共5个模块\",{\"1\":{\"718\":1}}],[\"共有类\",{\"1\":{\"351\":1}}],[\"共享一个对象\",{\"1\":{\"471\":1}}],[\"共享锁功能\",{\"1\":{\"313\":1}}],[\"共享进程的资源\",{\"1\":{\"150\":1}}],[\"寄存器\",{\"1\":{\"348\":1}}],[\"判读是否登录\",{\"1\":{\"339\":1}}],[\"判断其是否是一个有效的二叉搜索树\",{\"1\":{\"730\":1}}],[\"判断\",{\"1\":{\"716\":1}}],[\"判断二分图\",{\"0\":{\"716\":1}}],[\"判断该层节点是否有叶子节点\",{\"1\":{\"712\":1}}],[\"判断坐标\",{\"1\":{\"704\":1}}],[\"判断背包容量不足时\",{\"1\":{\"701\":1}}],[\"判断能不能恰好装满一个背包\",{\"1\":{\"701\":1}}],[\"判断结束\",{\"1\":{\"690\":1}}],[\"判断第\",{\"1\":{\"689\":1,\"701\":1}}],[\"判断path中是否已经有当前数来判断是否已经排列过这个数\",{\"1\":{\"685\":1}}],[\"判断左括号是否与相同类型的右括号闭合\",{\"1\":{\"659\":1}}],[\"判断字符串是否有效\",{\"1\":{\"659\":1}}],[\"判断尾数够不够k个来取决end指针的位置\",{\"1\":{\"643\":1}}],[\"判断链表是否有环\",{\"1\":{\"640\":1}}],[\"判断链表是否为空\",{\"1\":{\"637\":1}}],[\"判断索引是否有效\",{\"1\":{\"635\":1}}],[\"判断是哪一边遍历时间更短\",{\"1\":{\"635\":1}}],[\"判断是否与上个节点颜色不同\",{\"1\":{\"716\":1}}],[\"判断是否出现两个相邻节点颜色相同的情况\",{\"1\":{\"716\":1}}],[\"判断是否结束\",{\"1\":{\"713\":1}}],[\"判断是否和为target\",{\"1\":{\"687\":1}}],[\"判断是否到达底部\",{\"1\":{\"684\":1}}],[\"判断是否超载\",{\"1\":{\"677\":1}}],[\"判断是否遍历到叶子节点\",{\"1\":{\"674\":1}}],[\"判断是否收缩窗口\",{\"1\":{\"648\":1}}],[\"判断是否有环\",{\"1\":{\"640\":1}}],[\"判断是否为deadend\",{\"1\":{\"713\":1}}],[\"判断是否为叶子节点\",{\"1\":{\"712\":1}}],[\"判断是否为最小深度\",{\"1\":{\"712\":1}}],[\"判断是否为回文字符串\",{\"1\":{\"688\":1}}],[\"判断是否为新数组的元素\",{\"1\":{\"623\":1}}],[\"判断是否为空\",{\"1\":{\"439\":1}}],[\"判断是否还有下个元素\",{\"1\":{\"439\":1}}],[\"判断index是否有效\",{\"1\":{\"635\":1}}],[\"判断n为奇数情况\",{\"1\":{\"632\":1}}],[\"判断mid的左右哪边是升序数组\",{\"1\":{\"621\":1}}],[\"判断参数值是否等于\",{\"1\":{\"607\":1}}],[\"判断路径是否是以\",{\"1\":{\"607\":1}}],[\"判断请求是否符合规则\",{\"1\":{\"607\":1}}],[\"判断目录是否存在\",{\"1\":{\"475\":1}}],[\"判断内容是否相等\",{\"1\":{\"429\":1}}],[\"判断引用类型\",{\"1\":{\"406\":1}}],[\"判断基本类型\",{\"1\":{\"406\":1}}],[\"判断线程是否独占资源\",{\"1\":{\"313\":1}}],[\"判断中断标志位是否置1\",{\"1\":{\"268\":1}}],[\"判断任务是否执行完毕\",{\"1\":{\"229\":1}}],[\"判断任务是否被取消\",{\"1\":{\"229\":1}}],[\"判断系统是否已经有这个单例\",{\"1\":{\"98\":1}}],[\"判断不为空后\",{\"1\":{\"83\":1}}],[\"显然\",{\"1\":{\"628\":1}}],[\"显示时间和一些内容属性\",{\"1\":{\"760\":1}}],[\"显示一个或多个volume\",{\"1\":{\"615\":1}}],[\"显示到控制台\",{\"1\":{\"480\":1}}],[\"显示器\",{\"1\":{\"478\":1}}],[\"显示界面\",{\"1\":{\"409\":1}}],[\"显示中文\",{\"1\":{\"335\":1}}],[\"显式锁\",{\"1\":{\"263\":1}}],[\"显式释放内存\",{\"1\":{\"3\":1}}],[\"柜台1的章\",{\"1\":{\"334\":1}}],[\"域名相同\",{\"1\":{\"607\":1}}],[\"域名不同\",{\"1\":{\"607\":1}}],[\"域名不\",{\"1\":{\"607\":1}}],[\"域名获取\",{\"1\":{\"483\":1}}],[\"域名获取ip地址对象\",{\"1\":{\"483\":1}}],[\"域名\",{\"1\":{\"482\":1}}],[\"域名系统\",{\"1\":{\"156\":1}}],[\"域对象可以像map一样存取数据\",{\"1\":{\"331\":1}}],[\"属于响应式编程的实现\",{\"1\":{\"607\":1}}],[\"属于阻塞式编程\",{\"1\":{\"607\":1}}],[\"属于整个web工程\",{\"1\":{\"327\":1}}],[\"属性值包含特殊符号\",{\"1\":{\"557\":1}}],[\"属性来实现延迟加载还是立即加载\",{\"1\":{\"524\":1}}],[\"属性的输出看其编译类型\",{\"1\":{\"402\":1}}],[\"属性的定义语法同变量\",{\"1\":{\"386\":1}}],[\"属性没有重写一说\",{\"1\":{\"402\":1}}],[\"属性与方法不同\",{\"1\":{\"402\":1}}],[\"属性重写问题\",{\"1\":{\"402\":1}}],[\"属性如果不赋值\",{\"1\":{\"386\":1}}],[\"属性名\",{\"1\":{\"386\":1,\"400\":1}}],[\"属性类型\",{\"1\":{\"386\":1}}],[\"属性是类的组成部分\",{\"1\":{\"386\":1}}],[\"属性\",{\"0\":{\"386\":1},\"1\":{\"384\":1,\"386\":1,\"398\":1,\"417\":1,\"457\":1,\"506\":4,\"523\":1,\"557\":4,\"559\":1}}],[\"属性赋值\",{\"1\":{\"160\":1}}],[\"持有\",{\"1\":{\"318\":2,\"471\":2}}],[\"持久连接节省通信量\",{\"0\":{\"764\":1}}],[\"持久化\",{\"1\":{\"200\":1,\"211\":1}}],[\"持久化或\",{\"1\":{\"200\":1}}],[\"持久化到磁盘\",{\"1\":{\"200\":1}}],[\"持久化机制\",{\"1\":{\"198\":1}}],[\"持久化机制可以说是部分地遵守wal\",{\"1\":{\"181\":1}}],[\"持久化方式\",{\"0\":{\"189\":1}}],[\"持久性是指一个事务一旦被提交了\",{\"1\":{\"170\":1}}],[\"持久性\",{\"1\":{\"170\":1,\"580\":1}}],[\"虽然10默认是int类型\",{\"1\":{\"359\":1,\"365\":1}}],[\"虽然实现tryacquire\",{\"1\":{\"313\":1}}],[\"虽然保证了可见性\",{\"1\":{\"128\":1}}],[\"失败返回负数\",{\"1\":{\"313\":1}}],[\"失效\",{\"1\":{\"3\":1,\"198\":1}}],[\"仅记录左最大和右最大\",{\"1\":{\"624\":1}}],[\"仅系统的内核\",{\"1\":{\"609\":1}}],[\"仅对insert有用\",{\"1\":{\"501\":2}}],[\"仅在doreleaseshared中为头节点设置\",{\"1\":{\"312\":1}}],[\"仅仅会启动一个\",{\"1\":{\"204\":1}}],[\"状态管理支持时\",{\"1\":{\"785\":1}}],[\"状态码类别\",{\"1\":{\"773\":1}}],[\"状态码是服务器端响应时得请求结果\",{\"1\":{\"773\":1}}],[\"状态码\",{\"0\":{\"773\":1}}],[\"状态转移方程\",{\"1\":{\"700\":1}}],[\"状态转移方程有变化\",{\"1\":{\"698\":1}}],[\"状态转移式如上所示\",{\"1\":{\"694\":1}}],[\"状态转移\",{\"1\":{\"687\":1,\"694\":1,\"700\":1,\"701\":1,\"736\":1}}],[\"状态监控\",{\"1\":{\"597\":1}}],[\"状态\",{\"1\":{\"408\":2,\"469\":3}}],[\"状态字段\",{\"1\":{\"312\":1}}],[\"状态维护\",{\"1\":{\"141\":1}}],[\"诸如reentrantlock\",{\"1\":{\"311\":1}}],[\"描述动态代理的几种实现方式\",{\"1\":{\"492\":1}}],[\"描述\",{\"1\":{\"304\":1}}],[\"经过检查这个值确实没有修改过\",{\"1\":{\"299\":1}}],[\"循环依赖通过判断\",{\"1\":{\"718\":1}}],[\"循环几圈\",{\"1\":{\"632\":1}}],[\"循环的读取文件\",{\"1\":{\"478\":1}}],[\"循环的依赖将会导致注入死循环\",{\"1\":{\"163\":1}}],[\"循环读取\",{\"1\":{\"477\":2}}],[\"循环调用动态数组\",{\"1\":{\"404\":1}}],[\"循环体语句\",{\"1\":{\"374\":1,\"375\":1}}],[\"循环判断条件\",{\"1\":{\"373\":1}}],[\"循环操作语句\",{\"1\":{\"373\":1}}],[\"循环变量迭代\",{\"1\":{\"373\":1,\"375\":1}}],[\"循环变量初始化\",{\"1\":{\"373\":1}}],[\"循环条件\",{\"1\":{\"373\":1,\"374\":1,\"375\":1}}],[\"循环开始新一轮的资源竞争\",{\"1\":{\"317\":1}}],[\"循环获取锁不会阻塞\",{\"1\":{\"298\":1}}],[\"比\",{\"1\":{\"628\":1}}],[\"比当前数大\",{\"1\":{\"628\":1}}],[\"比eureka功能更加丰富\",{\"1\":{\"599\":1}}],[\"比成员内部类多个static\",{\"1\":{\"418\":1}}],[\"比查找的数大则说明在左半边\",{\"1\":{\"381\":1}}],[\"比查找的数小则说明查找的数在右半边\",{\"1\":{\"381\":1}}],[\"比较他们在堆内存的地址是否相等\",{\"1\":{\"492\":1}}],[\"比较的区别\",{\"1\":{\"492\":1}}],[\"比较简单\",{\"1\":{\"436\":1}}],[\"比较两个数组元素是否一致\",{\"1\":{\"433\":1}}],[\"比较两个字符串相等时\",{\"1\":{\"429\":1}}],[\"比较\",{\"1\":{\"429\":1}}],[\"比较运算符一览\",{\"1\":{\"363\":1}}],[\"比较运算符\",{\"0\":{\"363\":1},\"1\":{\"367\":1}}],[\"比较并交换\",{\"1\":{\"295\":1}}],[\"比如按os类型自动切换成pc版或手机版页面\",{\"1\":{\"771\":1}}],[\"比如可能存在一份英文版和中文版的页面\",{\"1\":{\"771\":1}}],[\"比如文档的某个位置\",{\"1\":{\"757\":1}}],[\"比如本题的水果有多种类\",{\"1\":{\"631\":1}}],[\"比如开发用的ubuntu\",{\"1\":{\"609\":1}}],[\"比如开启事务\",{\"1\":{\"104\":1}}],[\"比如添加头信息\",{\"1\":{\"607\":1}}],[\"比如一共有\",{\"1\":{\"598\":1}}],[\"比如一个tcp连接\",{\"1\":{\"209\":1}}],[\"比如一个电脑有两台打印机\",{\"1\":{\"98\":1}}],[\"比如ssh占用22\",{\"1\":{\"482\":1}}],[\"比如方法内\",{\"1\":{\"418\":1}}],[\"比如锁再被占用时\",{\"1\":{\"264\":1}}],[\"比如放弃更改\",{\"1\":{\"258\":1}}],[\"比如说注册功能要写\",{\"1\":{\"207\":1}}],[\"比如日志\",{\"1\":{\"207\":1}}],[\"比如缓存等\",{\"1\":{\"189\":1}}],[\"比如a正在从一张银行卡中取钱\",{\"1\":{\"170\":1}}],[\"比如a向b转账\",{\"1\":{\"170\":1}}],[\"比如操作同一张表时\",{\"1\":{\"170\":1}}],[\"比如扩展类加载器\",{\"1\":{\"147\":1}}],[\"比如应用程序类加载器\",{\"1\":{\"147\":1}}],[\"比如抛出异常\",{\"1\":{\"135\":1}}],[\"比如写文件操作\",{\"1\":{\"98\":1}}],[\"比如管理学院首页页面缓存\",{\"1\":{\"98\":1}}],[\"比如有个类\",{\"1\":{\"95\":1}}],[\"比如香港\",{\"1\":{\"95\":1}}],[\"比如当我们引用第三方库中的类需要装配到\",{\"1\":{\"70\":1}}],[\"比如\",{\"1\":{\"7\":1,\"73\":1,\"93\":2,\"501\":1,\"628\":2,\"646\":1}}],[\"双色问题的方法\",{\"1\":{\"716\":1}}],[\"双色问题\",{\"0\":{\"716\":1}}],[\"双队列实现\",{\"0\":{\"657\":1}}],[\"双栈\",{\"1\":{\"655\":1}}],[\"双链表\",{\"1\":{\"635\":1}}],[\"双dp数组\",{\"1\":{\"624\":1}}],[\"双指针后移\",{\"1\":{\"638\":1}}],[\"双指针不断向后移动\",{\"1\":{\"636\":1}}],[\"双指针法\",{\"1\":{\"629\":2,\"642\":2,\"643\":1}}],[\"双指针\",{\"1\":{\"623\":1,\"628\":1}}],[\"双层for循环\",{\"1\":{\"622\":1}}],[\"双向链表\",{\"1\":{\"451\":1,\"635\":1}}],[\"双列\",{\"1\":{\"451\":2}}],[\"双分支语法\",{\"1\":{\"371\":1}}],[\"双精度\",{\"1\":{\"358\":1}}],[\"双重校验锁\",{\"1\":{\"292\":1}}],[\"双亲委派机制\",{\"1\":{\"147\":1}}],[\"双亲委派机制的作用\",{\"0\":{\"147\":1}}],[\"现给定一组模块间的依赖关系\",{\"1\":{\"718\":1}}],[\"现代计算机系统在cpu与内存之间加入了一层或多层高速缓存\",{\"1\":{\"274\":1}}],[\"现在考虑网格中有障碍物\",{\"1\":{\"696\":1}}],[\"现在不再需要打成war包部署到容器中\",{\"1\":{\"80\":1}}],[\"现在p3是数据唯\",{\"1\":{\"3\":1}}],[\"屏蔽各个硬件平台和操作系统的内存访问差异以实现让java程序在各种平台下都能达到一致的内存访问效果\",{\"1\":{\"273\":1}}],[\"屏蔽产品的具体实现\",{\"1\":{\"101\":1}}],[\"申请停止线程\",{\"1\":{\"268\":3}}],[\"延迟加载\",{\"0\":{\"524\":1}}],[\"延迟10秒后结束子线程\",{\"1\":{\"467\":1}}],[\"延迟3秒后\",{\"1\":{\"268\":3}}],[\"延时双删\",{\"1\":{\"196\":1}}],[\"结尾有分号\",{\"1\":{\"375\":1}}],[\"结束\",{\"1\":{\"268\":3,\"717\":1}}],[\"结果数组从大到小存\",{\"1\":{\"629\":1}}],[\"结果会从缓存中获取\",{\"1\":{\"535\":1}}],[\"结果\",{\"1\":{\"263\":1,\"304\":1,\"362\":1,\"559\":2}}],[\"结果为\",{\"1\":{\"249\":1,\"530\":1}}],[\"结果2\",{\"1\":{\"6\":1}}],[\"结果1\",{\"1\":{\"6\":1}}],[\"检测到一个错误\",{\"1\":{\"425\":1}}],[\"检测线程是否终止执行\",{\"1\":{\"287\":1}}],[\"检测死锁\",{\"1\":{\"264\":1}}],[\"检查它是否轴对称\",{\"1\":{\"668\":1}}],[\"检查是否为类的对象\",{\"1\":{\"363\":1}}],[\"检查元素\",{\"1\":{\"194\":1}}],[\"检查自己是否已经加载过这个类\",{\"1\":{\"147\":1}}],[\"检查jvm的内存配置参数\",{\"1\":{\"146\":1}}],[\"检查jvm内存配置\",{\"1\":{\"146\":1}}],[\"检查代码逻辑\",{\"1\":{\"146\":1}}],[\"检查错误日志\",{\"1\":{\"146\":1}}],[\"死锁\",{\"0\":{\"264\":1}}],[\"死信队列\",{\"1\":{\"211\":1}}],[\"张三\",{\"1\":{\"523\":1,\"530\":3}}],[\"张\",{\"1\":{\"262\":1}}],[\"张票\",{\"1\":{\"262\":1}}],[\"剩余的数回到原来的栈\",{\"1\":{\"655\":2}}],[\"剩余票数\",{\"1\":{\"466\":1,\"471\":1}}],[\"剩余\",{\"1\":{\"262\":1}}],[\"购得第\",{\"1\":{\"262\":1}}],[\"买票小程序demo\",{\"1\":{\"262\":1}}],[\"整合了\",{\"1\":{\"586\":1}}],[\"整合第三方缓存\",{\"0\":{\"538\":1}}],[\"整除0\",{\"1\":{\"424\":1}}],[\"整型在内存中第一位存放符号位\",{\"1\":{\"358\":1}}],[\"整型类型\",{\"1\":{\"358\":1}}],[\"整个静态方法\",{\"1\":{\"259\":1}}],[\"整个方法\",{\"1\":{\"259\":1}}],[\"整数数组的\",{\"1\":{\"628\":1}}],[\"整数数组的一个\",{\"1\":{\"628\":1}}],[\"整数形式\",{\"1\":{\"482\":1}}],[\"整数或浮点数\",{\"1\":{\"188\":1}}],[\"整数类型比字符类型更适合作为索引列\",{\"1\":{\"174\":1}}],[\"被返回\",{\"1\":{\"721\":1}}],[\"被围绕的区间不会存在于边界上\",{\"1\":{\"709\":1}}],[\"被围绕的区域\",{\"0\":{\"709\":1}}],[\"被选中的可能性也就越低\",{\"1\":{\"598\":1}}],[\"被其他微服务调用的\",{\"1\":{\"596\":1}}],[\"被增强的方法称为切入点\",{\"1\":{\"570\":1}}],[\"被识别为字符串\",{\"1\":{\"517\":1}}],[\"被管理\",{\"1\":{\"506\":1}}],[\"被多个对象引用\",{\"1\":{\"431\":1}}],[\"被代理的对象\",{\"1\":{\"419\":2}}],[\"被阻塞等待监视器锁定\",{\"1\":{\"469\":1}}],[\"被阻塞\",{\"1\":{\"312\":1}}],[\"被唤醒\",{\"1\":{\"271\":3}}],[\"被修饰的方法称为同步方法\",{\"1\":{\"259\":1}}],[\"被修饰的代码块称为同步语句块\",{\"1\":{\"259\":1}}],[\"被当做一个持久化存储使用\",{\"1\":{\"190\":1}}],[\"被当作缓存使用\",{\"1\":{\"190\":1}}],[\"乐观锁认为不会有线程来争抢\",{\"1\":{\"295\":1}}],[\"乐观锁\",{\"1\":{\"258\":1}}],[\"乐观锁悲观锁\",{\"0\":{\"258\":1}}],[\"悲观锁认为更新数据时\",{\"1\":{\"295\":1}}],[\"悲观锁与乐观锁\",{\"1\":{\"295\":1}}],[\"悲观锁\",{\"1\":{\"258\":1}}],[\"毫秒\",{\"1\":{\"256\":2}}],[\"需释放已简历的连接\",{\"1\":{\"482\":1}}],[\"需求\",{\"0\":{\"255\":1}}],[\"需要一种可恢复的机制\",{\"1\":{\"770\":1}}],[\"需要一个右括号\",{\"1\":{\"660\":1}}],[\"需要分析代码模块之间的赖关系\",{\"1\":{\"718\":1}}],[\"需要分别记录数量\",{\"1\":{\"631\":1}}],[\"需要在首部字段里加上content\",{\"1\":{\"769\":1}}],[\"需要在每次递归调用之前判断是否超出数组边界\",{\"1\":{\"704\":1}}],[\"需要在一个java配置类中定义bean\",{\"1\":{\"62\":1}}],[\"需要回溯\",{\"1\":{\"672\":1}}],[\"需要判断窗口中的数的大小\",{\"1\":{\"661\":1}}],[\"需要补一个左括号\",{\"1\":{\"660\":1}}],[\"需要更改\",{\"1\":{\"649\":1}}],[\"需要将\",{\"1\":{\"628\":1}}],[\"需要\",{\"1\":{\"628\":1}}],[\"需要掌握\",{\"1\":{\"588\":1}}],[\"需要这种接口得对象时\",{\"1\":{\"490\":1}}],[\"需要被同步代码\",{\"1\":{\"470\":1}}],[\"需要被同步的代码\",{\"1\":{\"470\":1}}],[\"需要添加以下jvm启动参数\",{\"1\":{\"466\":1}}],[\"需要用到下面的类方法\",{\"1\":{\"435\":1}}],[\"需要用到的依赖\",{\"1\":{\"81\":1}}],[\"需要重写compare方法\",{\"1\":{\"433\":1}}],[\"需要放在构造器第一行\",{\"1\":{\"399\":1}}],[\"需要通过创建新数组的方式来扩容\",{\"1\":{\"381\":1}}],[\"需要导入\",{\"1\":{\"368\":1}}],[\"需要遵循缓存一致性协议\",{\"1\":{\"274\":1}}],[\"需要先将要运算的数据从内存读取\",{\"1\":{\"274\":1}}],[\"需要借用分布式锁来完成上锁\",{\"1\":{\"216\":1}}],[\"需要与交换器类型和绑定键\",{\"1\":{\"209\":1}}],[\"需要扫描索引中所有\",{\"1\":{\"176\":1}}],[\"需要快速地查询和获取数据\",{\"1\":{\"156\":1}}],[\"需要手动选择方法\",{\"1\":{\"417\":1}}],[\"需要手动调用lock\",{\"1\":{\"142\":1}}],[\"需要手动进行配置和启用\",{\"1\":{\"167\":1}}],[\"需要手动进行\",{\"1\":{\"55\":1}}],[\"需要使用synchronized关键字或java\",{\"1\":{\"128\":1}}],[\"需要经过哈希函数的计算来确定元素在数组中的位置\",{\"1\":{\"124\":1}}],[\"需要生成的对象内部属性本身相互依赖\",{\"1\":{\"107\":1}}],[\"需要生成的对象具有复杂的内部结构\",{\"1\":{\"107\":1}}],[\"需要由工程师根据业务需求\",{\"1\":{\"76\":1}}],[\"需要工程师开发jsp\",{\"1\":{\"76\":1}}],[\"需要工程师开发\",{\"1\":{\"76\":1}}],[\"需要注意的是\",{\"1\":{\"68\":1,\"164\":1}}],[\"需要自己配置销毁的方法\",{\"1\":{\"66\":1,\"560\":1}}],[\"需要自己配置初始化方法\",{\"1\":{\"66\":1,\"560\":1}}],[\"例子\",{\"0\":{\"254\":1,\"583\":1},\"1\":{\"258\":2,\"429\":1,\"580\":1}}],[\"例如提块1依赖模块2\",{\"1\":{\"718\":1}}],[\"例如把\",{\"1\":{\"713\":1}}],[\"例如index为0\",{\"1\":{\"635\":1}}],[\"例如path=\",{\"1\":{\"607\":1}}],[\"例如fileinputstream构造器\",{\"1\":{\"425\":1}}],[\"例如父类返回object\",{\"1\":{\"401\":1}}],[\"例如double赋给int\",{\"1\":{\"359\":1}}],[\"例如dao层\",{\"1\":{\"69\":1}}],[\"例如比较和交换操作\",{\"1\":{\"297\":1}}],[\"例如在订单服务中\",{\"1\":{\"216\":1}}],[\"例如select\",{\"1\":{\"178\":1}}],[\"例如数据库连接池\",{\"1\":{\"144\":1}}],[\"例如可指定公平性\",{\"1\":{\"142\":1}}],[\"例如maven\",{\"1\":{\"82\":1}}],[\"例如\",{\"1\":{\"76\":1,\"116\":2,\"128\":1,\"135\":1,\"141\":1,\"156\":1,\"158\":1,\"167\":1,\"171\":1,\"200\":1,\"274\":1,\"381\":1,\"506\":1,\"604\":2,\"628\":2,\"660\":1,\"687\":1,\"705\":1,\"717\":1,\"730\":1}}],[\"例如是否存在循环引用\",{\"1\":{\"62\":1}}],[\"记为\",{\"1\":{\"717\":1}}],[\"记得要关闭\",{\"1\":{\"249\":1}}],[\"记录每个元素对应在\",{\"1\":{\"721\":1}}],[\"记录每一个模块的依赖深度\",{\"1\":{\"718\":1}}],[\"记录图中节点是否被访问过\",{\"1\":{\"716\":1}}],[\"记录图中节点的颜⾊\",{\"1\":{\"716\":1}}],[\"记录图是否符合⼆分图性质\",{\"1\":{\"716\":1}}],[\"记录此时的深度\",{\"1\":{\"712\":1}}],[\"记录扩散的步数\",{\"1\":{\"711\":1}}],[\"记录最大的连续子数组和\",{\"1\":{\"693\":2}}],[\"记录最短的覆盖串长度\",{\"1\":{\"648\":1}}],[\"记录最短覆盖串的起始位置\",{\"1\":{\"648\":1}}],[\"记录和满足目标的表达式个数\",{\"1\":{\"687\":1}}],[\"记录当前窗口最大值\",{\"1\":{\"661\":1}}],[\"记录当前的最大长度\",{\"1\":{\"647\":1}}],[\"记录下标i之前\",{\"1\":{\"653\":1}}],[\"记录128个字符出现的个数\",{\"1\":{\"647\":1}}],[\"记录链表的虚拟头结点和尾结点\",{\"1\":{\"635\":1}}],[\"记录链表中元素的数量\",{\"1\":{\"635\":1}}],[\"记录删除的个数\",{\"1\":{\"623\":1}}],[\"记录服务提供者的信息\",{\"1\":{\"597\":1}}],[\"记录事务中对数据的修改\",{\"1\":{\"177\":1}}],[\"记录已提交事务的修改\",{\"1\":{\"177\":1}}],[\"记录执行时间超过阈值的查询语句\",{\"1\":{\"177\":1}}],[\"记录所有进入\",{\"1\":{\"177\":1}}],[\"记录\",{\"1\":{\"177\":1}}],[\"记录对数据库的修改操作\",{\"1\":{\"177\":1}}],[\"传输文件\",{\"1\":{\"763\":1}}],[\"传输实体\",{\"1\":{\"763\":1}}],[\"传输层提供处于网络连接中的两台计算机的数据传输\",{\"1\":{\"749\":1}}],[\"传输层\",{\"1\":{\"749\":1}}],[\"传输完毕\",{\"1\":{\"482\":1}}],[\"传输前\",{\"1\":{\"482\":1}}],[\"传输控制协议\",{\"1\":{\"482\":1}}],[\"传入的\",{\"1\":{\"478\":1}}],[\"传入一个集合\",{\"1\":{\"440\":1}}],[\"传入了一个异步线程池\",{\"1\":{\"247\":1}}],[\"传递的参数\",{\"1\":{\"569\":1}}],[\"传递枚举对象和枚举常量名称给静态方法valueof\",{\"1\":{\"421\":1}}],[\"传递规则\",{\"0\":{\"284\":1}}],[\"传送到transservlet2\",{\"1\":{\"334\":1}}],[\"传统synchronized\",{\"0\":{\"259\":1}}],[\"传统赋值\",{\"1\":{\"252\":1}}],[\"传统的并发模型\",{\"1\":{\"186\":1}}],[\"立马获取结果\",{\"1\":{\"241\":1}}],[\"暂停\",{\"1\":{\"233\":1}}],[\"终止条件\",{\"1\":{\"682\":1,\"686\":1,\"687\":1,\"688\":1,\"704\":1}}],[\"终止\",{\"1\":{\"225\":1}}],[\"超文本标记语言\",{\"1\":{\"746\":1}}],[\"超出索引边界\",{\"1\":{\"706\":1,\"707\":1,\"708\":1,\"709\":2}}],[\"超过两数之和\",{\"1\":{\"627\":1}}],[\"超过该时间\",{\"1\":{\"135\":1}}],[\"超类的方法优先\",{\"1\":{\"417\":1}}],[\"超类的默认方法优先\",{\"1\":{\"417\":1}}],[\"超时等待\",{\"1\":{\"225\":1}}],[\"阻塞节点被唤醒后\",{\"1\":{\"317\":1}}],[\"阻塞与非阻塞\",{\"1\":{\"295\":1}}],[\"阻塞线程\",{\"1\":{\"270\":1}}],[\"阻塞获取结果\",{\"1\":{\"240\":1}}],[\"阻塞\",{\"1\":{\"225\":1}}],[\"阻塞队列\",{\"1\":{\"135\":1}}],[\"微服务在启动时会在nacos读取多个配置文件\",{\"1\":{\"604\":1}}],[\"微服务数据独立\",{\"1\":{\"596\":1}}],[\"微服务技术对比\",{\"1\":{\"595\":1}}],[\"微服务结构\",{\"1\":{\"595\":1}}],[\"微服务对外暴露业务接口\",{\"1\":{\"595\":1}}],[\"微服务治理\",{\"0\":{\"594\":1}}],[\"微服务系统需要增加安全验证\",{\"1\":{\"593\":1}}],[\"微服务的组成\",{\"0\":{\"592\":1}}],[\"微服务架构图\",{\"1\":{\"595\":1}}],[\"微服务架构的演变\",{\"1\":{\"595\":1}}],[\"微服务架构提倡将单一的应用程序划分成一组小的服务\",{\"1\":{\"591\":1}}],[\"微服务架构理论\",{\"0\":{\"590\":1}}],[\"微服务springcloud\",{\"0\":{\"589\":1}}],[\"微服务支持\",{\"1\":{\"545\":1}}],[\"微服务\",{\"0\":{\"215\":1},\"1\":{\"593\":1,\"595\":1}}],[\"订阅模型\",{\"1\":{\"213\":1}}],[\"订阅队列还是接收消息\",{\"1\":{\"209\":1}}],[\"kmp精讲8\",{\"1\":{\"653\":1}}],[\"kmp精讲7\",{\"1\":{\"653\":1}}],[\"kmp精讲6\",{\"1\":{\"653\":1}}],[\"kmp精讲5\",{\"1\":{\"653\":1}}],[\"kmp详解1\",{\"1\":{\"653\":1}}],[\"kmp的主要思想\",{\"1\":{\"653\":1}}],[\"kmp\",{\"0\":{\"653\":1}}],[\"k++\",{\"1\":{\"652\":1}}],[\"k指针指向结果数组的最后一位\",{\"1\":{\"629\":1}}],[\"kptenantid`\",{\"1\":{\"605\":1}}],[\"kp\",{\"1\":{\"605\":1}}],[\"koala\",{\"1\":{\"478\":1}}],[\"k\",{\"0\":{\"671\":1},\"1\":{\"456\":1,\"459\":3,\"480\":2,\"629\":3,\"643\":12,\"652\":2,\"661\":6,\"671\":4,\"672\":5,\"676\":2,\"683\":10,\"689\":8,\"701\":5,\"705\":8,\"734\":8}}],[\"king\",{\"1\":{\"408\":1}}],[\"kafka使用了一种基于磁盘的持久化存储方式\",{\"1\":{\"214\":1}}],[\"kafka使用消费者组\",{\"1\":{\"214\":1}}],[\"kafka还提供了消息压缩功能\",{\"1\":{\"214\":1}}],[\"kafka还采用零拷贝技术\",{\"1\":{\"214\":1}}],[\"kafka支持批量发送消息\",{\"1\":{\"214\":1}}],[\"kafka将消息以连续的方式追加写入日志文件\",{\"1\":{\"214\":1}}],[\"kafka采用分布式的设计\",{\"1\":{\"214\":1}}],[\"kafka采用发布\",{\"1\":{\"213\":1}}],[\"kafka更注重吞吐量和持久性\",{\"1\":{\"213\":1}}],[\"kafka通过分布式日志存储和复制机制来保证数据的持久性和高可用性\",{\"1\":{\"213\":1}}],[\"kafka\",{\"1\":{\"213\":3,\"592\":1}}],[\"keep\",{\"1\":{\"760\":1}}],[\"keepalivetime的时间单位\",{\"1\":{\"135\":1}}],[\"keepalivetime\",{\"1\":{\"135\":1}}],[\"key=\",{\"1\":{\"557\":2}}],[\"keyproperty=\",{\"1\":{\"501\":1,\"520\":1}}],[\"keyproperty\",{\"1\":{\"501\":1}}],[\"key和value可以是任何引用类型数据\",{\"1\":{\"448\":1}}],[\"key是锁的唯一标识\",{\"1\":{\"205\":1}}],[\"keys\",{\"1\":{\"190\":1}}],[\"keyset\",{\"1\":{\"124\":1,\"448\":4,\"720\":1}}],[\"key\",{\"1\":{\"124\":1,\"191\":2,\"197\":2,\"198\":1,\"202\":1,\"204\":5,\"205\":7,\"209\":3,\"334\":4,\"448\":7,\"450\":1,\"480\":3,\"507\":1,\"514\":1,\"605\":23,\"616\":1,\"648\":9,\"649\":1,\"720\":18}}],[\"元素\",{\"1\":{\"656\":1}}],[\"元素出现次数\",{\"1\":{\"452\":1}}],[\"元素按照一定的数量进行分页处理\",{\"1\":{\"199\":1}}],[\"元注解种类\",{\"1\":{\"422\":1}}],[\"元注解用于修饰其他注解\",{\"1\":{\"422\":1}}],[\"元数据指\",{\"1\":{\"212\":1}}],[\"跟着图的顺序递归\",{\"1\":{\"715\":1}}],[\"跟普通集群模式不一样的是\",{\"1\":{\"212\":1}}],[\"跟我们预期的接口不一致\",{\"1\":{\"95\":1}}],[\"没找到升序对\",{\"1\":{\"628\":1}}],[\"没人生产用单机模式\",{\"1\":{\"212\":1}}],[\"没有物品可以选择时\",{\"1\":{\"701\":1}}],[\"没有客户端连接9999端口时\",{\"1\":{\"485\":1}}],[\"没有方法\",{\"1\":{\"478\":1}}],[\"没有本质上区别\",{\"1\":{\"466\":1}}],[\"没有指定类型\",{\"1\":{\"458\":1}}],[\"没有索引\",{\"1\":{\"444\":1}}],[\"没有线程同步\",{\"1\":{\"443\":1}}],[\"没有专门的格式化方法\",{\"1\":{\"436\":1}}],[\"没有static修饰\",{\"1\":{\"418\":1}}],[\"没有static\",{\"1\":{\"418\":1}}],[\"没有类名\",{\"1\":{\"418\":1}}],[\"没有参数\",{\"1\":{\"413\":1}}],[\"没有返回\",{\"1\":{\"413\":1}}],[\"没有该房屋\",{\"1\":{\"408\":1}}],[\"没有动态绑定机制\",{\"1\":{\"403\":1}}],[\"没有修饰符\",{\"1\":{\"397\":1}}],[\"没有break\",{\"1\":{\"372\":1}}],[\"没有其他节点可以取消\",{\"1\":{\"312\":1}}],[\"没有cas时怎么保证数据的原子性\",{\"1\":{\"295\":1}}],[\"没有人使用的\",{\"1\":{\"195\":1}}],[\"没有死锁问题导致的性能消耗\",{\"1\":{\"186\":1}}],[\"没有新的任务到来\",{\"1\":{\"136\":1}}],[\"没有找到\",{\"1\":{\"111\":1}}],[\"没有接口也能实现动态代理\",{\"1\":{\"492\":1}}],[\"没有接口\",{\"1\":{\"98\":1}}],[\"没有接口情况\",{\"1\":{\"72\":1,\"568\":1}}],[\"镜像运行的入口\",{\"1\":{\"616\":1}}],[\"镜像结构\",{\"1\":{\"616\":1}}],[\"镜像的托管平台像github\",{\"1\":{\"611\":1}}],[\"镜像中应用的启动命令\",{\"1\":{\"616\":1}}],[\"镜像中的程序运行后形成的进程就是容器\",{\"1\":{\"611\":1}}],[\"镜像中包含完整运行环境\",{\"1\":{\"609\":1}}],[\"镜像\",{\"1\":{\"611\":1}}],[\"镜像和容器\",{\"1\":{\"611\":1}}],[\"镜像集群模式\",{\"1\":{\"212\":2}}],[\"镜像模式\",{\"1\":{\"211\":1}}],[\"普通\",{\"1\":{\"558\":1}}],[\"普通类中的泛型方法\",{\"1\":{\"459\":1}}],[\"普通成员\",{\"1\":{\"457\":1}}],[\"普通方法\",{\"1\":{\"454\":1}}],[\"普通的迭代器只有remove方法\",{\"1\":{\"443\":1}}],[\"普通的代码块\",{\"1\":{\"413\":1}}],[\"普通代码块可以调用任意成员\",{\"1\":{\"413\":1}}],[\"普通代码块\",{\"1\":{\"413\":3}}],[\"普通集群模式\",{\"1\":{\"212\":2}}],[\"普通模式\",{\"1\":{\"211\":1}}],[\"声明式调用\",{\"1\":{\"593\":1}}],[\"声明检查型异常\",{\"1\":{\"425\":1}}],[\"声明对象\",{\"1\":{\"387\":1}}],[\"声明一个队列并设置好相关属性\",{\"1\":{\"210\":1}}],[\"声明一个交换器并设置好相关属性\",{\"1\":{\"210\":1}}],[\"声明为内部\",{\"1\":{\"67\":1}}],[\"绑定\",{\"1\":{\"209\":1}}],[\"路由过滤器和defaultfilter的order由spring指定\",{\"1\":{\"607\":1}}],[\"路由过滤器\",{\"1\":{\"607\":2}}],[\"路由断言工厂\",{\"1\":{\"607\":1}}],[\"路由断言\",{\"1\":{\"607\":1}}],[\"路由的目标地址\",{\"1\":{\"607\":1}}],[\"路由标示\",{\"1\":{\"607\":1}}],[\"路由网关\",{\"1\":{\"593\":1}}],[\"路由键\",{\"1\":{\"209\":1}}],[\"路由关键字\",{\"1\":{\"209\":1}}],[\"路径被压缩\",{\"1\":{\"709\":2}}],[\"路径压缩\",{\"1\":{\"709\":2}}],[\"路径\",{\"1\":{\"682\":2}}],[\"路径总和\",{\"0\":{\"672\":1}}],[\"路径断言\",{\"1\":{\"607\":1}}],[\"路径名\",{\"1\":{\"354\":1}}],[\"路径和\",{\"1\":{\"90\":1}}],[\"路径导航\",{\"1\":{\"10\":1,\"42\":1}}],[\"交点不是数值相等\",{\"1\":{\"639\":1}}],[\"交换指向的数\",{\"1\":{\"642\":1}}],[\"交换left\",{\"1\":{\"628\":1}}],[\"交换而不是把\",{\"1\":{\"628\":1}}],[\"交换就能得到一个更大的数\",{\"1\":{\"628\":1}}],[\"交换\",{\"1\":{\"628\":4,\"637\":1,\"642\":1,\"643\":1}}],[\"交换器等信息\",{\"1\":{\"210\":1}}],[\"交换器就知道将消息路由给哪个队列了\",{\"1\":{\"209\":1}}],[\"交换器\",{\"1\":{\"209\":1}}],[\"交给spring管理\",{\"1\":{\"554\":1}}],[\"交替执行\",{\"1\":{\"224\":1}}],[\"交互演示\",{\"0\":{\"36\":1,\"37\":1}}],[\"给整数数组赋值\",{\"1\":{\"729\":1}}],[\"给这个节点涂上与上个节点不同的颜色\",{\"1\":{\"716\":1}}],[\"给出\",{\"1\":{\"717\":1}}],[\"给出数字到字母的映射如下\",{\"1\":{\"684\":1}}],[\"给出一个求n数之和的框架\",{\"1\":{\"627\":1}}],[\"给出一些没有实现的方法\",{\"1\":{\"417\":1}}],[\"给闭区间\",{\"1\":{\"677\":1,\"678\":1}}],[\"给你一棵二叉树的根节点\",{\"1\":{\"667\":1}}],[\"给你一个二维数组\",{\"1\":{\"716\":1}}],[\"给你一个二叉树的根节点\",{\"1\":{\"668\":1}}],[\"给你一个有\",{\"1\":{\"715\":1}}],[\"给你一个由\",{\"1\":{\"706\":1}}],[\"给你一个\",{\"1\":{\"701\":1,\"709\":1}}],[\"给你一个字符串\",{\"1\":{\"648\":1,\"650\":1,\"688\":1,\"702\":1}}],[\"给你一个链表\",{\"1\":{\"638\":1}}],[\"给你一个按\",{\"1\":{\"629\":1}}],[\"给你一个整数数组\",{\"1\":{\"628\":1,\"631\":1,\"661\":1,\"686\":1,\"687\":1}}],[\"给你二叉树的根节点\",{\"1\":{\"666\":1}}],[\"给你两个单链表的头节点\",{\"1\":{\"639\":1}}],[\"给定⼀个整数数组\",{\"1\":{\"689\":1}}],[\"给定两个整数\",{\"1\":{\"683\":1}}],[\"给定两个字符串\",{\"1\":{\"649\":1}}],[\"给定整数\",{\"1\":{\"677\":1}}],[\"给定二叉树\",{\"1\":{\"669\":1}}],[\"给定一个代表每个房屋存放金额的非负整数数组\",{\"1\":{\"697\":1,\"698\":1}}],[\"给定一个不含重复数字的数组\",{\"1\":{\"685\":1}}],[\"给定一个仅包含数字\",{\"1\":{\"684\":1}}],[\"给定一个二叉树\",{\"1\":{\"669\":1,\"712\":1,\"730\":1}}],[\"给定一个括号字符串\",{\"1\":{\"660\":1}}],[\"给定一个只包括\",{\"1\":{\"659\":1}}],[\"给定一个\",{\"1\":{\"651\":1,\"705\":1}}],[\"给定一个字符串\",{\"1\":{\"643\":1,\"645\":1,\"647\":1}}],[\"给定一个链表\",{\"1\":{\"637\":1,\"640\":1}}],[\"给定一个正整数\",{\"1\":{\"632\":1}}],[\"给定一个含有\",{\"1\":{\"630\":1}}],[\"给定一个长度为\",{\"1\":{\"625\":1}}],[\"给定一个整数数组\",{\"1\":{\"622\":1}}],[\"给定\",{\"1\":{\"624\":1,\"694\":1}}],[\"给当前进入的容器创建一个标准输入\",{\"1\":{\"614\":1}}],[\"给容器起一个名字\",{\"1\":{\"614\":1}}],[\"给了泛型具体类型后\",{\"1\":{\"456\":1}}],[\"给材料盖一个章\",{\"1\":{\"334\":1}}],[\"给servlet程序配置访问地址\",{\"1\":{\"327\":1}}],[\"给servlet标签起个别名\",{\"1\":{\"327\":1}}],[\"给多个消费者进行处理\",{\"1\":{\"209\":1}}],[\"给客户端\",{\"1\":{\"191\":1}}],[\"轮询策略\",{\"1\":{\"598\":1}}],[\"轮询的方式会耗费无谓的cpu资源\",{\"1\":{\"234\":1}}],[\"轮询\",{\"1\":{\"209\":1}}],[\"三家店同时卖\",{\"1\":{\"466\":1,\"471\":1}}],[\"三国演义\",{\"1\":{\"433\":1}}],[\"三种string类比较\",{\"1\":{\"431\":1}}],[\"三个窗口售票总共100张\",{\"1\":{\"466\":1}}],[\"三个基本的注解\",{\"1\":{\"422\":1}}],[\"三个类都有name属性\",{\"1\":{\"399\":1}}],[\"三个使用场景\",{\"1\":{\"207\":1}}],[\"三元运算符的嵌套\",{\"1\":{\"366\":1}}],[\"三元运算符\",{\"0\":{\"366\":1},\"1\":{\"367\":1,\"427\":1}}],[\"三\",{\"0\":{\"337\":1,\"361\":1}}],[\"三大特性\",{\"0\":{\"276\":1}}],[\"三层协议\",{\"0\":{\"208\":1}}],[\"突然有5k个请求\",{\"1\":{\"207\":1}}],[\"削峰\",{\"1\":{\"207\":1}}],[\"邮件通过\",{\"1\":{\"207\":1}}],[\"里的方法\",{\"1\":{\"569\":1}}],[\"里的消息都会存在于多个实例上\",{\"1\":{\"212\":1}}],[\"里\",{\"1\":{\"559\":2}}],[\"里定义的\",{\"1\":{\"558\":2}}],[\"里面的linkedlist记录了该index模块的依赖模块列表\",{\"1\":{\"718\":1}}],[\"里面的元素是每个航班预定的座位总数\",{\"1\":{\"678\":1}}],[\"里面的属性也要实现序列化接口\",{\"1\":{\"478\":1}}],[\"里面保存的实际元素为子类类型\",{\"1\":{\"404\":1}}],[\"里面有两个public方法a和b\",{\"0\":{\"166\":1}}],[\"里进行消息同步\",{\"1\":{\"212\":1}}],[\"里获得就行\",{\"1\":{\"207\":1}}],[\"消耗一个左括号\",{\"1\":{\"660\":1}}],[\"消费前一个阶段的计算结果\",{\"1\":{\"245\":1}}],[\"消费消息的流程\",{\"0\":{\"210\":1}}],[\"消费消息时只消费消息体\",{\"1\":{\"209\":1}}],[\"消费消息\",{\"1\":{\"209\":1}}],[\"消费者如何得知服务提供者的健康状态\",{\"1\":{\"597\":1}}],[\"消费者该如何选择\",{\"1\":{\"597\":1}}],[\"消费者组可以订阅相同的主题\",{\"1\":{\"214\":1}}],[\"消费者在接收到消息后需要发送确认回执\",{\"1\":{\"213\":1}}],[\"消费者\",{\"1\":{\"213\":1,\"596\":1}}],[\"消费者模式将消息通过中间件传递\",{\"1\":{\"213\":1}}],[\"消费者确认收到的消息\",{\"1\":{\"210\":1}}],[\"消费者连接到rabbitmq服务器\",{\"1\":{\"209\":1}}],[\"消费者consumer\",{\"1\":{\"209\":1}}],[\"消费者直接从\",{\"1\":{\"207\":1}}],[\"消息总线\",{\"1\":{\"593\":1}}],[\"消息传输延迟\",{\"1\":{\"213\":1}}],[\"消息发布者将消息写入主题的分区中\",{\"1\":{\"213\":1}}],[\"消息发布者\",{\"1\":{\"213\":1}}],[\"消息补偿机制\",{\"1\":{\"211\":1}}],[\"消息\",{\"1\":{\"209\":1}}],[\"消息体是不透明的\",{\"1\":{\"209\":1}}],[\"消息体\",{\"1\":{\"209\":1}}],[\"消息一般包含两个部分\",{\"1\":{\"209\":1}}],[\"消息队列等\",{\"1\":{\"609\":1}}],[\"消息队列高可用\",{\"0\":{\"212\":1}}],[\"消息队列和相关对象\",{\"1\":{\"209\":1}}],[\"消息队列\",{\"0\":{\"206\":1},\"1\":{\"209\":1}}],[\"消息队列发送缓存删除补偿\",{\"1\":{\"196\":1}}],[\"已遍历过\",{\"1\":{\"704\":1}}],[\"已经遍历过的区域是否需要打上标记防止重复访问\",{\"1\":{\"704\":1}}],[\"已经被装⼊别的桶中\",{\"1\":{\"689\":1,\"701\":1}}],[\"已经移除了\",{\"1\":{\"586\":1}}],[\"已经存在\",{\"1\":{\"205\":1,\"720\":1}}],[\"已退出\",{\"1\":{\"469\":1}}],[\"已过时\",{\"1\":{\"422\":1}}],[\"已出租\",{\"1\":{\"408\":3}}],[\"已取消节点的next字段被设置为指向节点本身而不是null\",{\"1\":{\"312\":1}}],[\"已知公式\",{\"1\":{\"90\":1}}],[\"说明遇到了环\",{\"1\":{\"717\":1}}],[\"说明包含该字母\",{\"1\":{\"705\":1}}],[\"说明剩余的数恰好也能装满另一个背包\",{\"1\":{\"701\":1}}],[\"说明已经不需要向后递归了\",{\"1\":{\"683\":1}}],[\"说明存在连续的数和为k\",{\"1\":{\"671\":1}}],[\"说明它在push\",{\"1\":{\"661\":1}}],[\"说明前面缺少对应的左括号\",{\"1\":{\"660\":1}}],[\"说明无法匹配了\",{\"1\":{\"649\":1}}],[\"说明有环\",{\"1\":{\"640\":1}}],[\"说明这个链表有环\",{\"1\":{\"640\":1}}],[\"说明\",{\"1\":{\"205\":1,\"443\":1,\"478\":2,\"651\":1,\"669\":1,\"689\":1,\"712\":1}}],[\"说一下string内部结构\",{\"0\":{\"121\":1}}],[\"淘汰了一个\",{\"1\":{\"204\":1}}],[\"继续优化dp数组的空间\",{\"1\":{\"624\":1}}],[\"继续执行下次循环\",{\"1\":{\"378\":1}}],[\"继续释放线程d\",{\"1\":{\"318\":1}}],[\"继续复制下去\",{\"1\":{\"204\":1}}],[\"继承thread\",{\"1\":{\"466\":1}}],[\"继承thread类\",{\"1\":{\"132\":1,\"466\":1}}],[\"继承接口时指定泛型接口的类型\",{\"1\":{\"458\":1}}],[\"继承的本质分析\",{\"1\":{\"399\":1}}],[\"继承是子类继承父类的除了静态方法和静态字段的所有方法和字段\",{\"1\":{\"120\":1}}],[\"继承和多态\",{\"1\":{\"120\":1}}],[\"继承\",{\"0\":{\"78\":1,\"399\":1}}],[\"断开了连接\",{\"1\":{\"204\":1}}],[\"开启饥饿加载\",{\"1\":{\"598\":1}}],[\"开启事务功能\",{\"1\":{\"584\":1}}],[\"开启注解扫描\",{\"1\":{\"572\":1}}],[\"开启组件扫描\",{\"1\":{\"563\":2,\"584\":1}}],[\"开启延迟加载\",{\"1\":{\"524\":1}}],[\"开启一个信道\",{\"1\":{\"210\":1}}],[\"开辟新空间\",{\"1\":{\"381\":1}}],[\"开始链表转换\",{\"1\":{\"729\":1}}],[\"开始选数字\",{\"1\":{\"689\":1,\"701\":1}}],[\"开始做选择\",{\"1\":{\"689\":1,\"701\":1}}],[\"开始位置\",{\"1\":{\"627\":1}}],[\"开始编号\",{\"1\":{\"436\":1}}],[\"开始生成一份rdb快照文件\",{\"1\":{\"204\":1}}],[\"开始\",{\"1\":{\"204\":1,\"640\":1,\"694\":1,\"696\":1}}],[\"开发部\",{\"1\":{\"557\":1}}],[\"开发效率稍逊\",{\"1\":{\"496\":1}}],[\"开发中如何选择集合实现类\",{\"0\":{\"451\":1}}],[\"开发\",{\"1\":{\"168\":2,\"588\":1,\"609\":1}}],[\"开发具体的页面\",{\"1\":{\"76\":1}}],[\"选取连接数最小的⼀个服务实例\",{\"1\":{\"598\":1}}],[\"选用何种数据类型来存储窗口\",{\"1\":{\"631\":1}}],[\"选用\",{\"1\":{\"564\":1}}],[\"选出一个新的主节点\",{\"1\":{\"203\":1}}],[\"选择装入或不装入背包\",{\"1\":{\"701\":1}}],[\"选择列表\",{\"1\":{\"682\":1}}],[\"选择\",{\"1\":{\"682\":1,\"686\":2,\"688\":1}}],[\"选择从后向前遍历\",{\"1\":{\"622\":1}}],[\"选择同步代码块或同步方法\",{\"1\":{\"471\":1}}],[\"选择rabbitmq还是kafka取决于具体的应用场景和需求\",{\"1\":{\"213\":1}}],[\"选择性是指索引列中不同值的数量与总行数的比例\",{\"1\":{\"174\":1}}],[\"选择其他的依赖注入框架\",{\"1\":{\"168\":1}}],[\"选择其他\",{\"1\":{\"168\":1}}],[\"选择其他框架\",{\"1\":{\"168\":1}}],[\"哨兵\",{\"1\":{\"662\":1}}],[\"哨兵节点会使用sentinel\",{\"1\":{\"203\":1}}],[\"哨兵会通过互相交流来达成共识\",{\"1\":{\"203\":1}}],[\"哨兵会自动进行选举\",{\"1\":{\"203\":1}}],[\"哨兵模式\",{\"1\":{\"203\":1}}],[\"哨兵选举过程\",{\"0\":{\"203\":1},\"1\":{\"203\":1}}],[\"初次连接\",{\"1\":{\"203\":1}}],[\"初始状态也有变化\",{\"1\":{\"698\":1}}],[\"初始状态下\",{\"1\":{\"139\":1}}],[\"初始情况下所有的数字均为\",{\"1\":{\"676\":1}}],[\"初始值为空\",{\"1\":{\"307\":1}}],[\"初始值为null\",{\"1\":{\"307\":1}}],[\"初始值\",{\"1\":{\"304\":1}}],[\"初始化一个整数数组\",{\"1\":{\"729\":1}}],[\"初始化dp\",{\"1\":{\"694\":1,\"701\":1}}],[\"初始化dp数组\",{\"1\":{\"624\":1,\"687\":1,\"697\":1,\"700\":1}}],[\"初始化差分数组\",{\"1\":{\"678\":1}}],[\"初始化操作\",{\"1\":{\"635\":1}}],[\"初始化链表\",{\"1\":{\"635\":1}}],[\"初始化left\",{\"1\":{\"630\":1}}],[\"初始化数据库表结构\",{\"1\":{\"605\":1}}],[\"初始化之后会执行\",{\"1\":{\"560\":2}}],[\"初始化之前会执行\",{\"1\":{\"560\":2}}],[\"初始化顺序如下\",{\"1\":{\"413\":1}}],[\"初始化顺序取决于定义顺序\",{\"1\":{\"413\":6}}],[\"初始化方法\",{\"1\":{\"328\":1,\"560\":3}}],[\"初始化\",{\"1\":{\"160\":1,\"194\":1,\"382\":1,\"419\":1,\"624\":1,\"648\":1,\"650\":1,\"720\":1,\"721\":1}}],[\"初始堆内存\",{\"1\":{\"146\":1}}],[\"到节点\",{\"1\":{\"715\":2}}],[\"到某个类要使用的时候\",{\"1\":{\"417\":1}}],[\"到0结束递归\",{\"1\":{\"391\":1}}],[\"到web\",{\"1\":{\"327\":1}}],[\"到高速缓存中\",{\"1\":{\"274\":1}}],[\"到消费者\",{\"1\":{\"211\":1}}],[\"到\",{\"1\":{\"203\":1,\"628\":1,\"632\":1,\"678\":2,\"716\":1,\"717\":1}}],[\"本题把所有的边缘区域看做是一整块联通区域\",{\"1\":{\"709\":1}}],[\"本题特点\",{\"1\":{\"696\":1}}],[\"本层集合中元素\",{\"1\":{\"682\":1}}],[\"本地根据dockerfile\",{\"1\":{\"613\":1}}],[\"本身没有影响\",{\"1\":{\"430\":1}}],[\"本类\",{\"1\":{\"401\":1}}],[\"本质上char类型保存的是整数\",{\"1\":{\"358\":1}}],[\"本质\",{\"1\":{\"203\":1,\"402\":1}}],[\"本页面就是一个示例\",{\"1\":{\"10\":1}}],[\"硬盘故障\",{\"1\":{\"203\":1}}],[\"硬件资源等\",{\"1\":{\"116\":1}}],[\"问总共有多少条不同的路径\",{\"1\":{\"695\":1}}],[\"问路\",{\"1\":{\"334\":1}}],[\"问题\",{\"0\":{\"302\":1,\"310\":1},\"1\":{\"278\":1}}],[\"问题二\",{\"1\":{\"203\":1}}],[\"问题一\",{\"1\":{\"203\":1}}],[\"问点\",{\"1\":{\"76\":1}}],[\"然而\",{\"1\":{\"274\":1,\"631\":1}}],[\"然而如果网络中断事件是发生在客户端执行\",{\"1\":{\"201\":1}}],[\"然后偷窃\",{\"1\":{\"697\":1,\"698\":1}}],[\"然后串联起来得到表达式\",{\"1\":{\"687\":1}}],[\"然后串联起所有整数\",{\"1\":{\"687\":1}}],[\"然后把节点的左右子节点对调\",{\"1\":{\"667\":1}}],[\"然后判断是否需要有反转的区间\",{\"1\":{\"643\":1}}],[\"然后让cura移动到\",{\"1\":{\"639\":1}}],[\"然后需要将\",{\"1\":{\"628\":1}}],[\"然后运行另一个操作系统\",{\"1\":{\"610\":1}}],[\"然后分别启动三个nacos节点\",{\"1\":{\"605\":1}}],[\"然后分别修改三个文件夹中的application\",{\"1\":{\"605\":1}}],[\"然后修改application\",{\"1\":{\"605\":1}}],[\"然后添加内容\",{\"1\":{\"605\":1}}],[\"然后一个负载均衡器代理3个nacos\",{\"1\":{\"605\":1}}],[\"然后eureka会把符合你需求的服务告诉你\",{\"1\":{\"597\":1}}],[\"然后尝试去获取\",{\"1\":{\"471\":2}}],[\"然后尝试再次提交新任务\",{\"1\":{\"134\":1}}],[\"然后调用newinstance\",{\"1\":{\"419\":1}}],[\"然后根据相应的字节码转换成对应的class\",{\"1\":{\"419\":1}}],[\"然后服务器让客户端重新定向到新地址\",{\"1\":{\"336\":1}}],[\"然后unpark线程c\",{\"1\":{\"318\":2}}],[\"然后重试原子性的acquire操作\",{\"1\":{\"312\":1}}],[\"然后拿到当前线程的threadlocalmap\",{\"1\":{\"307\":1}}],[\"然后从当前线程中获取threadlocalmap\",{\"1\":{\"306\":1}}],[\"然后解码并确定其类型和操作数\",{\"1\":{\"274\":1}}],[\"然后自行了断\",{\"1\":{\"267\":1}}],[\"然后释放同步状态\",{\"1\":{\"262\":1}}],[\"然后由消息订阅者\",{\"1\":{\"213\":1}}],[\"然后由工厂方法提供给调用者\",{\"1\":{\"116\":1}}],[\"然后每次你写消息到\",{\"1\":{\"212\":1}}],[\"然后发送给slave\",{\"1\":{\"204\":1}}],[\"然后\",{\"1\":{\"204\":1,\"274\":1}}],[\"然后在原始链表顺序往后遍历即可\",{\"1\":{\"193\":1}}],[\"然后才将其应用到数据库中\",{\"1\":{\"180\":1}}],[\"然后再选择连接数较小的服务实例\",{\"1\":{\"598\":1}}],[\"然后再给每个服务提供者附上一个权重\",{\"1\":{\"598\":1}}],[\"然后再将运算后的数据写入到高速缓存\",{\"1\":{\"274\":1}}],[\"然后再从本地磁盘加载到内存中\",{\"1\":{\"204\":1}}],[\"然后再根据需要进行展示或处理\",{\"1\":{\"199\":1}}],[\"然后再执行\",{\"1\":{\"184\":1}}],[\"然后再使用指针获取相应的数据\",{\"1\":{\"179\":1}}],[\"然后再决定是否合并\",{\"1\":{\"86\":1}}],[\"然后通过叶子节点指针快速定位到对应的数据节点\",{\"1\":{\"172\":1}}],[\"然后将右孩子加入栈\",{\"1\":{\"665\":1}}],[\"然后将它们转移到队列以便重新获取\",{\"1\":{\"312\":1}}],[\"然后将值存储到threadlocalmap中\",{\"1\":{\"306\":1}}],[\"然后将结果写回数据库\",{\"1\":{\"171\":1}}],[\"然后将存活对象压缩到一端\",{\"1\":{\"148\":1}}],[\"然后返回给\",{\"1\":{\"161\":1}}],[\"然后清理掉末端的全部内存\",{\"1\":{\"148\":1}}],[\"然后使用\",{\"1\":{\"132\":1}}],[\"然后比较本地的master分支和origin\",{\"1\":{\"86\":1}}],[\"然后除以玩家总数\",{\"1\":{\"5\":1}}],[\"按行遍历\",{\"1\":{\"695\":1,\"696\":1}}],[\"按任意顺序\",{\"1\":{\"685\":1}}],[\"按对象进入缓存的顺序来移出他们\",{\"1\":{\"536\":1}}],[\"按流的角色不同分为\",{\"1\":{\"476\":1}}],[\"按数据流的流向不同分为\",{\"1\":{\"476\":1}}],[\"按字符\",{\"1\":{\"476\":1}}],[\"按操作数据单位不同分为\",{\"1\":{\"476\":1}}],[\"按format来转换字符串\",{\"1\":{\"436\":1}}],[\"按业务来决定命名\",{\"1\":{\"205\":1}}],[\"按命令执行的先后顺序排列\",{\"1\":{\"202\":1}}],[\"按顺序地执行\",{\"1\":{\"201\":1}}],[\"按照服务名来对应配置名\",{\"1\":{\"602\":1}}],[\"按照轮询策略来获取服务\",{\"1\":{\"598\":1}}],[\"按照一定的顺序依次调用服务实例\",{\"1\":{\"598\":1}}],[\"按照类名来注入\",{\"1\":{\"564\":1}}],[\"按照查找关系来返回属性\",{\"1\":{\"399\":1}}],[\"按照区间查找数据\",{\"1\":{\"193\":1}}],[\"按照插入顺序存储的字符串元素列表\",{\"1\":{\"188\":1}}],[\"按照入度从小到大执行任务\",{\"1\":{\"91\":1}}],[\"按照特定规则\",{\"1\":{\"76\":1}}],[\"按照如下顺序执行\",{\"1\":{\"53\":1}}],[\"鉴于这个原因\",{\"1\":{\"201\":1}}],[\"策略等来淘汰不常用的数据\",{\"1\":{\"200\":1}}],[\"策略或\",{\"1\":{\"200\":1}}],[\"控制方法和属性的访问权限\",{\"1\":{\"397\":1}}],[\"控制访问范围\",{\"1\":{\"396\":1}}],[\"控制结构\",{\"0\":{\"370\":1}}],[\"控制互斥锁或者消息队列来控制读写缓存的线程数量\",{\"1\":{\"198\":1}}],[\"控制反转\",{\"1\":{\"61\":1,\"158\":2,\"547\":1}}],[\"互不相同\",{\"1\":{\"686\":1}}],[\"互斥锁\",{\"0\":{\"471\":1},\"1\":{\"198\":1}}],[\"互相之间持有对方的引用就会发生循\",{\"1\":{\"163\":1}}],[\"热点数据永不过期\",{\"1\":{\"198\":1}}],[\"设计链表\",{\"0\":{\"635\":1}}],[\"设计模式提出于1990年\",{\"1\":{\"93\":1}}],[\"设计模式离我们并不远\",{\"1\":{\"93\":1}}],[\"设计模式指北\",{\"0\":{\"93\":1}}],[\"设计模式\",{\"0\":{\"92\":1}}],[\"设备驱动\",{\"1\":{\"749\":1}}],[\"设备\",{\"1\":{\"479\":1}}],[\"设置环境变量\",{\"1\":{\"616\":1}}],[\"设置环境的唯一标识\",{\"1\":{\"506\":1}}],[\"设置状态码\",{\"1\":{\"607\":1}}],[\"设置集群名称\",{\"1\":{\"599\":1}}],[\"设置负载均衡\",{\"1\":{\"598\":4}}],[\"设置不包含service注解的类\",{\"1\":{\"563\":1}}],[\"设置不同的过期时间\",{\"1\":{\"198\":1}}],[\"设置包含service注解的类\",{\"1\":{\"563\":1}}],[\"设置\",{\"1\":{\"559\":2}}],[\"设置创建\",{\"1\":{\"559\":1}}],[\"设置对象类型属性\",{\"1\":{\"557\":2}}],[\"设置属性为空\",{\"1\":{\"557\":1}}],[\"设置是否在getter方法中\",{\"1\":{\"540\":1}}],[\"设置多个赋值之间的分隔符\",{\"1\":{\"531\":1}}],[\"设置中开启延迟加载\",{\"1\":{\"524\":1}}],[\"设置写一步的查询语句的唯一标识\",{\"1\":{\"523\":1,\"524\":1}}],[\"设置要处理的属性类型\",{\"1\":{\"523\":1,\"527\":1}}],[\"设置需要处理映射关系的属性和属性名\",{\"1\":{\"523\":2,\"524\":1,\"527\":1}}],[\"设置resultmap\",{\"1\":{\"523\":1}}],[\"设置数据源的类型\",{\"1\":{\"506\":1}}],[\"设置事数据源\",{\"1\":{\"506\":1}}],[\"设置事务管理的方式\",{\"1\":{\"506\":1}}],[\"设置事务管理器\",{\"1\":{\"506\":1}}],[\"设置一个具体的数据库的环境\",{\"1\":{\"506\":1}}],[\"设置一个标记变量\",{\"1\":{\"467\":1}}],[\"设置默认使用的环境的\",{\"1\":{\"506\":1}}],[\"设置键值对\",{\"1\":{\"480\":1}}],[\"设置为守护线程\",{\"1\":{\"468\":1}}],[\"设置守护线程\",{\"1\":{\"468\":1}}],[\"设置线程名称\",{\"1\":{\"468\":1}}],[\"设置变量可以保存动态代理类\",{\"1\":{\"419\":1}}],[\"设置合理的过期时间\",{\"1\":{\"200\":1}}],[\"均匀过期\",{\"1\":{\"198\":1}}],[\"存在时\",{\"1\":{\"721\":1}}],[\"存在于缓存中\",{\"1\":{\"720\":1}}],[\"存在于网格中\",{\"1\":{\"705\":1}}],[\"存在循环依赖\",{\"1\":{\"718\":1}}],[\"存在一个\",{\"1\":{\"716\":1}}],[\"存在一条有向边\",{\"1\":{\"715\":1}}],[\"存在如下关系\",{\"1\":{\"687\":1}}],[\"存结果\",{\"1\":{\"678\":1}}],[\"存放的键和值都不能为null\",{\"1\":{\"449\":1}}],[\"存放对象\",{\"1\":{\"388\":1}}],[\"存放6个int\",{\"1\":{\"381\":1}}],[\"存入结果列表\",{\"1\":{\"666\":1}}],[\"存入\",{\"1\":{\"197\":1}}],[\"存储元素的值\",{\"1\":{\"721\":1}}],[\"存储不选中当前节点的最高金额\",{\"1\":{\"699\":1}}],[\"存储选中当前节点的最高金额\",{\"1\":{\"699\":1}}],[\"存储当前层的节点值\",{\"1\":{\"666\":1,\"669\":1}}],[\"存储最终结果\",{\"1\":{\"666\":1}}],[\"存储左括号\",{\"1\":{\"659\":1}}],[\"存储的有效字符相同\",{\"1\":{\"649\":1}}],[\"存储滑动窗口中有效字符出现的次数\",{\"1\":{\"649\":1}}],[\"存储目标值中各个单词出现的次数\",{\"1\":{\"649\":1}}],[\"存储传入的多个参数\",{\"1\":{\"512\":2}}],[\"存储过程及高级映射的持久层框架\",{\"1\":{\"495\":1}}],[\"存储文件中即可\",{\"1\":{\"480\":1}}],[\"存储了当前对象的地址\",{\"1\":{\"393\":1}}],[\"存储容量\",{\"1\":{\"153\":1}}],[\"存储位置\",{\"1\":{\"153\":1}}],[\"存储结构\",{\"1\":{\"124\":1}}],[\"存储每个节点的入度\",{\"1\":{\"91\":1}}],[\"甚至导致数据库承受不住而宕机崩溃\",{\"1\":{\"197\":1}}],[\"造成死锁的原因\",{\"1\":{\"264\":1}}],[\"造成数据库压力过大\",{\"1\":{\"197\":1}}],[\"造成了一定的空间浪费\",{\"1\":{\"191\":1}}],[\"系统的标准压缩\",{\"1\":{\"768\":1}}],[\"系统会自动报警\",{\"1\":{\"697\":1,\"698\":1}}],[\"系统会提供默认的构造器\",{\"1\":{\"392\":1}}],[\"系统函数库\",{\"1\":{\"616\":1}}],[\"系统保护\",{\"1\":{\"593\":1}}],[\"系统自动调用该对象的finalize方法\",{\"1\":{\"406\":1}}],[\"系统自动调用该类的构造\",{\"1\":{\"392\":1}}],[\"系统首先自动将数据转换成容量最大\",{\"1\":{\"359\":1}}],[\"系统资源不足\",{\"1\":{\"264\":1}}],[\"系统工作线程\",{\"1\":{\"227\":1}}],[\"系统崩溃\",{\"1\":{\"203\":1}}],[\"系统接受到消息后再次删除\",{\"1\":{\"196\":1}}],[\"系统执行所有任务需要的最小内存\",{\"1\":{\"91\":1}}],[\"休眠1秒\",{\"1\":{\"196\":1}}],[\"误判率取决于位数组的大小\",{\"1\":{\"194\":2}}],[\"长度i\",{\"1\":{\"736\":1}}],[\"长度最小的子数组\",{\"0\":{\"630\":1}}],[\"长度\",{\"1\":{\"430\":1}}],[\"长度为前6个字符的子串aabaaf\",{\"1\":{\"653\":1}}],[\"长度为前5个字符的子串aabaa\",{\"1\":{\"653\":1}}],[\"长度为前4个字符的子串aaba\",{\"1\":{\"653\":1}}],[\"长度为前3个字符的子串aab\",{\"1\":{\"653\":1}}],[\"长度为前2个字符的子串aa\",{\"1\":{\"653\":1}}],[\"长度为前1个字符的子串a\",{\"1\":{\"653\":1}}],[\"长度为\",{\"1\":{\"194\":1}}],[\"长时间运行导致内存占用累积而触发oom\",{\"1\":{\"146\":1}}],[\"长时间面向对象编程之后\",{\"1\":{\"93\":1}}],[\"布尔类型\",{\"1\":{\"358\":1}}],[\"布隆过滤器\",{\"1\":{\"194\":1,\"197\":1}}],[\"布隆过滤器原理\",{\"0\":{\"194\":1}}],[\"布局与功能禁用\",{\"0\":{\"10\":1}}],[\"zlib\",{\"1\":{\"768\":1}}],[\"zip\",{\"1\":{\"768\":1}}],[\"zone\",{\"1\":{\"598\":1}}],[\"zoneavoidancerule\",{\"1\":{\"598\":2}}],[\"zookeeper\",{\"1\":{\"595\":1}}],[\"zookeeper临时节点只在session生命周期存在\",{\"1\":{\"217\":1}}],[\"zookeeper中规定\",{\"1\":{\"217\":1}}],[\"zookeeper分布式锁实现原理\",{\"0\":{\"217\":1}}],[\"zuul是基于servlet实现\",{\"1\":{\"607\":1}}],[\"zuul\",{\"1\":{\"592\":1,\"593\":2,\"595\":2,\"607\":1}}],[\"zuoye\",{\"1\":{\"99\":1}}],[\"ztt\",{\"1\":{\"414\":2,\"445\":1,\"557\":1,\"583\":1,\"584\":1}}],[\"z3\",{\"1\":{\"297\":4}}],[\"zhangsan\",{\"1\":{\"252\":1}}],[\"zrevrange\",{\"1\":{\"199\":1}}],[\"zrange\",{\"1\":{\"199\":1}}],[\"zset\",{\"0\":{\"193\":1}}],[\"线用jps\",{\"1\":{\"264\":1}}],[\"线上任务也不能持续进行\",{\"1\":{\"192\":1}}],[\"线程执行同步代码块时\",{\"1\":{\"472\":1}}],[\"线程执行同步代码块或同步方法时\",{\"1\":{\"472\":1}}],[\"线程\",{\"1\":{\"471\":4}}],[\"线程死锁\",{\"1\":{\"471\":1}}],[\"线程同步机制\",{\"1\":{\"470\":1}}],[\"线程同步\",{\"0\":{\"470\":1}}],[\"线程睡眠时处于timed\",{\"1\":{\"469\":1}}],[\"线程状态转换图\",{\"1\":{\"469\":1}}],[\"线程插队\",{\"1\":{\"468\":1}}],[\"线程常用方法\",{\"0\":{\"468\":1}}],[\"线程终止\",{\"0\":{\"467\":1}}],[\"线程终止规则\",{\"0\":{\"287\":1}}],[\"线程安全\",{\"1\":{\"442\":2}}],[\"线程不安全\",{\"1\":{\"441\":1,\"443\":1}}],[\"线程b也释放锁\",{\"1\":{\"318\":1}}],[\"线程d这时请求资源将d挂载到阻塞队列队尾\",{\"1\":{\"318\":1}}],[\"线程c判断h\",{\"1\":{\"318\":1}}],[\"线程c尝试获取锁tryacquiredshared\",{\"1\":{\"318\":2}}],[\"线程a释放锁\",{\"1\":{\"318\":2}}],[\"线程释放时要唤醒的后继节点的链接\",{\"1\":{\"312\":1}}],[\"线程依赖的前置节点的链接\",{\"1\":{\"312\":1}}],[\"线程中的所有操作都先行发生于对此线程的终止检测\",{\"1\":{\"287\":1}}],[\"线程中断规则\",{\"0\":{\"286\":1}}],[\"线程中断机制\",{\"0\":{\"266\":1}}],[\"线程启动规则\",{\"0\":{\"285\":1}}],[\"线程间变量值的传递需要通过主内存来完成\",{\"1\":{\"279\":1}}],[\"线程对变量的所有操作都必须在工作内存中进行\",{\"1\":{\"279\":1}}],[\"线程的生命周期\",{\"0\":{\"469\":1}}],[\"线程的礼让\",{\"1\":{\"468\":1}}],[\"线程的基本使用\",{\"0\":{\"466\":1}}],[\"线程的工作内存中保存了被线程使用的变量的主内存副本\",{\"1\":{\"279\":1}}],[\"线程的6个状态\",{\"0\":{\"225\":1}}],[\"线程号来查找死锁\",{\"1\":{\"264\":1}}],[\"线程在获取锁的时候\",{\"1\":{\"260\":1}}],[\"线程开启底层\",{\"0\":{\"220\":1}}],[\"线程知识\",{\"0\":{\"219\":1}}],[\"线程可能会被阻塞\",{\"1\":{\"143\":1}}],[\"线程会在自旋或阻塞状态下等待\",{\"1\":{\"143\":1}}],[\"线程会使用cas\",{\"1\":{\"143\":1}}],[\"线程会被封装成一个node节点\",{\"1\":{\"143\":1}}],[\"线程之间无法直接访问对方的工作内存\",{\"1\":{\"140\":1}}],[\"线程通过cas操作来竞争锁\",{\"1\":{\"139\":1}}],[\"线程工厂\",{\"1\":{\"135\":1}}],[\"线程空闲时间\",{\"1\":{\"135\":1}}],[\"线程池等\",{\"1\":{\"144\":1}}],[\"线程池配置无界队列了之后\",{\"0\":{\"137\":1}}],[\"线程池会创建一个新的临时线程来处理该任务\",{\"1\":{\"135\":1}}],[\"线程池会首先判断是否已经达到了corepoolsize限制\",{\"1\":{\"135\":1}}],[\"线程池会自动分配可用的线程来执行任务\",{\"1\":{\"132\":1}}],[\"线程池中的线程都从该队列中获取任务进行处理\",{\"1\":{\"135\":1}}],[\"线程池中允许存在的最大线程数\",{\"1\":{\"135\":1}}],[\"线程池中始终保持活动状态的线程数\",{\"1\":{\"135\":1}}],[\"线程池的7个参数\",{\"1\":{\"135\":1}}],[\"线程池7个参数\",{\"0\":{\"135\":1}}],[\"线程池拒绝策略\",{\"1\":{\"134\":1}}],[\"线程池\",{\"1\":{\"133\":1}}],[\"线程任务与线程控制分离\",{\"1\":{\"132\":1}}],[\"意味着在从\",{\"1\":{\"678\":1}}],[\"意思就是在多台机器上启动多个rabbitmo实例\",{\"1\":{\"212\":1}}],[\"意思是当内存不足以容纳新入数据时\",{\"1\":{\"192\":1}}],[\"意图\",{\"1\":{\"98\":1,\"101\":1,\"104\":1,\"107\":1,\"113\":1,\"116\":1}}],[\"驱逐\",{\"1\":{\"192\":1}}],[\"惰性删除不会去主动删除数据\",{\"1\":{\"191\":1}}],[\"惰性删除\",{\"1\":{\"191\":1}}],[\"惰性删除和定期删除两种策略配合使用\",{\"1\":{\"191\":1}}],[\"过滤器链执行顺序\",{\"1\":{\"607\":1}}],[\"过滤\",{\"1\":{\"593\":1}}],[\"过滤响应\",{\"1\":{\"338\":1}}],[\"过期了一个\",{\"1\":{\"204\":1}}],[\"过期\",{\"1\":{\"204\":2}}],[\"过期键的删除策略\",{\"0\":{\"191\":1}}],[\"过多的索引会增加维护成本\",{\"1\":{\"174\":1}}],[\"命名规范\",{\"1\":{\"396\":1}}],[\"命名的\",{\"1\":{\"81\":1}}],[\"命令都是在信道中进行的\",{\"1\":{\"209\":1}}],[\"命令发送给\",{\"1\":{\"204\":1}}],[\"命令传播阶段\",{\"1\":{\"203\":1}}],[\"命令可以取消\",{\"1\":{\"202\":1}}],[\"命令被调用时\",{\"1\":{\"202\":1}}],[\"命令用于开启一个事务\",{\"1\":{\"202\":1}}],[\"命令\",{\"1\":{\"202\":1,\"613\":1,\"616\":1}}],[\"命令是一个乐观锁\",{\"1\":{\"202\":1}}],[\"命令之后\",{\"1\":{\"201\":1}}],[\"命令的集合\",{\"1\":{\"189\":1}}],[\"集群负载均衡\",{\"1\":{\"599\":1}}],[\"集群名称\",{\"1\":{\"599\":2,\"602\":1}}],[\"集群2\",{\"1\":{\"599\":1}}],[\"集群1\",{\"1\":{\"599\":1}}],[\"集群式消费和水平扩展\",{\"1\":{\"214\":1}}],[\"集群中的节点被组织成多个揭示槽\",{\"1\":{\"203\":1}}],[\"集群方式\",{\"0\":{\"203\":1},\"1\":{\"203\":1}}],[\"集群\",{\"1\":{\"200\":1,\"211\":1,\"605\":1}}],[\"集群避免全盘崩溃\",{\"1\":{\"198\":1}}],[\"集群可以做到这样\",{\"1\":{\"190\":1}}],[\"集合的理解和好处\",{\"0\":{\"438\":1}}],[\"集合\",{\"0\":{\"437\":1,\"679\":1},\"1\":{\"188\":1,\"438\":1,\"515\":1,\"716\":2}}],[\"集成使用mybatis非常简单\",{\"1\":{\"83\":1}}],[\"哈希链表\",{\"1\":{\"720\":1}}],[\"哈希表查找快\",{\"1\":{\"720\":1}}],[\"哈希值的十六进制\",{\"1\":{\"406\":1}}],[\"哈希值主要是根据地址号来的\",{\"1\":{\"406\":1}}],[\"哈希\",{\"1\":{\"188\":1}}],[\"哈希函数的数量和哈希函数的质量\",{\"1\":{\"194\":2}}],[\"哈希函数应该返回相同的哈希码\",{\"1\":{\"124\":1}}],[\"哈希函数将键对象映射为数组索引\",{\"1\":{\"124\":1}}],[\"目前cura指向链表a的头结点\",{\"1\":{\"639\":1}}],[\"目前主要用第三和第四种方案\",{\"1\":{\"195\":1}}],[\"目标和\",{\"0\":{\"687\":1},\"1\":{\"627\":1}}],[\"目标对象与代理类都要同时修改\",{\"1\":{\"419\":1}}],[\"目的封装成数据包\",{\"1\":{\"482\":1}}],[\"目的就是为了更好的支持高并发任务\",{\"1\":{\"222\":1}}],[\"目redis6\",{\"1\":{\"187\":1}}],[\"目录的操作和文件的删除\",{\"1\":{\"475\":1}}],[\"目录下的全部资源\",{\"1\":{\"343\":1}}],[\"目录匹配\",{\"1\":{\"343\":1}}],[\"目录\",{\"0\":{\"9\":1}}],[\"密码\",{\"1\":{\"540\":1,\"605\":1}}],[\"密码是=\",{\"1\":{\"480\":1}}],[\"密码加密的文章\",{\"0\":{\"11\":1}}],[\"密集型\",{\"1\":{\"187\":1}}],[\"密集型的\",{\"1\":{\"187\":1}}],[\"流的分类\",{\"1\":{\"476\":1}}],[\"流的状态\",{\"1\":{\"186\":1}}],[\"流量达到阈值直接返回系统拥挤\",{\"1\":{\"198\":1}}],[\"流\",{\"1\":{\"186\":1,\"476\":1}}],[\"流都有一个新的线程管理\",{\"1\":{\"186\":1}}],[\"流程图\",{\"0\":{\"30\":1}}],[\"模块5没有依赖任何模块\",{\"1\":{\"718\":1}}],[\"模块4依赖模块5\",{\"1\":{\"718\":1}}],[\"模块3依赖模块5\",{\"1\":{\"718\":1}}],[\"模块3也依模块2\",{\"1\":{\"718\":1}}],[\"模块1依赖模块2\",{\"1\":{\"718\":1}}],[\"模块1和3\",{\"1\":{\"718\":1}}],[\"模块总数n取值范围1<=n<=1000\",{\"1\":{\"718\":1}}],[\"模块d的取值一定在1\",{\"1\":{\"718\":1}}],[\"模块2依赖模块5\",{\"1\":{\"718\":1}}],[\"模块2\",{\"1\":{\"718\":1}}],[\"模糊查询\",{\"0\":{\"517\":1}}],[\"模拟异常\",{\"1\":{\"583\":1}}],[\"模拟死锁现象\",{\"1\":{\"471\":1}}],[\"模拟线程死锁\",{\"1\":{\"471\":1}}],[\"模拟出来多条线程\",{\"1\":{\"224\":1}}],[\"模式串的第六个字符f\",{\"1\":{\"653\":1}}],[\"模式串应该从哪里开始重新匹配\",{\"1\":{\"653\":1}}],[\"模式下\",{\"1\":{\"203\":1}}],[\"模式\",{\"1\":{\"203\":1}}],[\"模型\",{\"1\":{\"186\":1}}],[\"模板\",{\"0\":{\"682\":1,\"692\":1,\"711\":1},\"1\":{\"104\":1,\"395\":1}}],[\"模板模式\",{\"0\":{\"103\":1}}],[\"模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤\",{\"1\":{\"104\":1}}],[\"模板方法\",{\"1\":{\"73\":1}}],[\"绝大部分请求是纯粹的内存操作\",{\"1\":{\"186\":1}}],[\"子集\",{\"0\":{\"686\":1}}],[\"子集问题看成深度在变化的组合问题\",{\"1\":{\"686\":1}}],[\"子集问题\",{\"1\":{\"681\":1}}],[\"子数组\",{\"1\":{\"630\":2}}],[\"子线程已经终止\",{\"1\":{\"469\":1}}],[\"子线程运行结束\",{\"1\":{\"468\":1}}],[\"子类会继承父类注解\",{\"1\":{\"422\":1}}],[\"子类继承父类就自动拥有父类的功能\",{\"1\":{\"417\":1}}],[\"子类继承了所有的属性和方法\",{\"1\":{\"399\":1}}],[\"子类的构造方法\",{\"1\":{\"413\":1}}],[\"子类的普通代码块和普通属性\",{\"1\":{\"413\":1}}],[\"子类的静态代码块和静态属性\",{\"1\":{\"413\":1}}],[\"子类可以重写该方法\",{\"1\":{\"406\":1}}],[\"子类往往重写tostring方法\",{\"1\":{\"406\":1}}],[\"子类中往往重写该方法\",{\"1\":{\"406\":1}}],[\"子类中访问父类对象\",{\"1\":{\"400\":1}}],[\"子类类型\",{\"1\":{\"402\":2}}],[\"子类名\",{\"1\":{\"402\":1}}],[\"子类不能缩小父类访问权限\",{\"1\":{\"401\":1}}],[\"子类方法不能缩小父类方法的访问权限\",{\"1\":{\"401\":1}}],[\"子类方法的返回类型需和父类方法返回类型一样\",{\"1\":{\"401\":1}}],[\"子类方法的名称\",{\"1\":{\"401\":1}}],[\"子类返回string\",{\"1\":{\"401\":1}}],[\"子类属性由子类初始化\",{\"1\":{\"400\":1}}],[\"子类必须调用父类的构造器完成父类的初始化\",{\"1\":{\"399\":1}}],[\"子类通过继承父类中的共有属性和方法\",{\"1\":{\"399\":1}}],[\"子类\",{\"1\":{\"397\":1,\"399\":1,\"478\":1}}],[\"子类实现\",{\"1\":{\"104\":1}}],[\"子句指定的列进行排序\",{\"1\":{\"184\":1}}],[\"子句用于限制结果集的数量\",{\"1\":{\"184\":1}}],[\"子句用于选择需要返回的列\",{\"1\":{\"184\":1}}],[\"子句用于筛选\",{\"1\":{\"184\":1}}],[\"子句在\",{\"1\":{\"184\":2}}],[\"子句不同\",{\"1\":{\"184\":1}}],[\"子句中的值必须是常量\",{\"1\":{\"372\":1}}],[\"子句中的列进行分组\",{\"1\":{\"184\":1}}],[\"子句中的条件将被应用于结果集\",{\"1\":{\"184\":1}}],[\"子句中指定的表开始执行\",{\"1\":{\"184\":1}}],[\"子句中指定的表\",{\"1\":{\"184\":1}}],[\"子句\",{\"1\":{\"184\":10}}],[\"具备更好的性能\",{\"1\":{\"607\":1}}],[\"具有指令集并使用不同的存储区域\",{\"1\":{\"348\":1}}],[\"具有较好的并发性能和数据完整性\",{\"1\":{\"183\":1}}],[\"具体到\",{\"1\":{\"187\":1}}],[\"具体执行顺序如下\",{\"1\":{\"184\":1}}],[\"非空\",{\"1\":{\"701\":1}}],[\"非递减顺序\",{\"1\":{\"629\":2}}],[\"非临时实例不会\",{\"1\":{\"600\":1}}],[\"非临时实例\",{\"1\":{\"600\":1}}],[\"非静态的同步方法的锁可以是this也可以是其他对象\",{\"1\":{\"471\":1}}],[\"非静态方法可以访问所有成员\",{\"1\":{\"411\":1}}],[\"非法索引访问数组\",{\"1\":{\"424\":1}}],[\"非负值表示节点不需要信号量\",{\"1\":{\"312\":1}}],[\"非公平锁能更充分的利用cpu时间片\",{\"1\":{\"262\":1}}],[\"非公平锁\",{\"1\":{\"261\":1,\"262\":2}}],[\"非阻塞原子性操作\",{\"1\":{\"295\":1}}],[\"非阻塞\",{\"1\":{\"186\":1}}],[\"非常重要\",{\"0\":{\"403\":1}}],[\"非常迅速\",{\"1\":{\"186\":1}}],[\"非常方便\",{\"1\":{\"61\":1}}],[\"非聚簇索引的叶子节点并不存储实际的数据行\",{\"1\":{\"179\":1}}],[\"非聚簇索引是另一种常见的索引类型\",{\"1\":{\"179\":1}}],[\"非聚簇索引\",{\"1\":{\"179\":1}}],[\"间隙锁\",{\"1\":{\"178\":1}}],[\"快慢指针相遇\",{\"1\":{\"640\":1}}],[\"快慢指针之间间距为\",{\"1\":{\"638\":1}}],[\"快慢指针\",{\"0\":{\"640\":1},\"1\":{\"638\":1}}],[\"快慢指针法\",{\"1\":{\"623\":1,\"640\":1}}],[\"快指针一次走两步\",{\"1\":{\"640\":1}}],[\"快指针\",{\"1\":{\"623\":1}}],[\"快捷方式\",{\"1\":{\"616\":1}}],[\"快速排序\",{\"1\":{\"629\":1}}],[\"快速跳转方法的定义\",{\"1\":{\"395\":1}}],[\"快速格式化代码\",{\"1\":{\"395\":1}}],[\"快速地生成和原型对象一样的实例\",{\"1\":{\"116\":1}}],[\"快照读\",{\"1\":{\"178\":1}}],[\"版本\",{\"1\":{\"442\":1}}],[\"版本号机制version\",{\"1\":{\"258\":1}}],[\"版本号\",{\"1\":{\"178\":1}}],[\"版本变化\",{\"0\":{\"59\":1}}],[\"或逆向从ip地址反查域名的服务\",{\"1\":{\"754\":1}}],[\"或不与边界上的\",{\"1\":{\"709\":1}}],[\"或不满足word中的单词则返回false\",{\"1\":{\"705\":1}}],[\"或竖直方向上相邻的陆地连接形成\",{\"1\":{\"706\":1}}],[\"或结束括号为\",{\"1\":{\"660\":1}}],[\"或已经失效\",{\"1\":{\"598\":1}}],[\"或spring\",{\"1\":{\"593\":1}}],[\"或用逗号隔开多个包\",{\"1\":{\"563\":1}}],[\"或注解用于配置和原始映射\",{\"1\":{\"495\":1}}],[\"或刷新\",{\"1\":{\"477\":1}}],[\"或一组键值对\",{\"1\":{\"451\":1}}],[\"或代码块中\",{\"1\":{\"415\":1}}],[\"或特殊值shared\",{\"1\":{\"312\":1}}],[\"或在可能时使用无条件的volatile写操作\",{\"1\":{\"312\":1}}],[\"或删除\",{\"1\":{\"202\":1}}],[\"或\",{\"1\":{\"199\":1,\"488\":1,\"545\":1,\"687\":1}}],[\"或重做日志\",{\"1\":{\"177\":1}}],[\"或者添加\",{\"1\":{\"607\":1}}],[\"或者是参数类型\",{\"1\":{\"455\":1}}],[\"或者是某个方法的返回值类型\",{\"1\":{\"455\":1}}],[\"或者是父类方法返回类型的子类\",{\"1\":{\"401\":1}}],[\"或者\",{\"1\":{\"427\":1,\"477\":1,\"531\":1,\"660\":2,\"687\":1}}],[\"或者atom相关类来确保操作的原子性\",{\"1\":{\"293\":1}}],[\"或者代码重排序\",{\"1\":{\"280\":1}}],[\"或者直接返回this\",{\"1\":{\"252\":1}}],[\"或者通过\",{\"1\":{\"204\":1}}],[\"或者两者结合使用\",{\"1\":{\"200\":1}}],[\"或者定期执行bgsave做快照备份\",{\"1\":{\"189\":1}}],[\"或者在方法a上也添加\",{\"1\":{\"166\":1}}],[\"或者持久性的\",{\"1\":{\"153\":1}}],[\"或者用于实现线程间的通信\",{\"1\":{\"144\":1}}],[\"或者引用含有循环结构的时候\",{\"1\":{\"116\":1}}],[\"列\",{\"1\":{\"706\":1,\"707\":1,\"708\":1,\"709\":1}}],[\"列数\",{\"1\":{\"696\":1}}],[\"列出所有的volume\",{\"1\":{\"615\":1}}],[\"列表\",{\"1\":{\"188\":1,\"713\":1}}],[\"列表示任务之间的依赖\",{\"1\":{\"91\":1}}],[\"列等于\",{\"1\":{\"176\":1}}],[\"假设一个二叉搜索树具有如下特征\",{\"1\":{\"730\":1}}],[\"假设你有⼀个⻓度为\",{\"1\":{\"676\":1}}],[\"假设节点元素数值相等\",{\"1\":{\"639\":1}}],[\"假设资源数量为2\",{\"1\":{\"318\":2}}],[\"假设计算需要1s\",{\"1\":{\"256\":1}}],[\"假设有一个联合索引\",{\"1\":{\"176\":1}}],[\"假如我一个\",{\"0\":{\"166\":1}}],[\"定见彩虹\",{\"1\":{\"477\":1}}],[\"定制排序\",{\"1\":{\"433\":2}}],[\"定位区间的起点\",{\"1\":{\"193\":1}}],[\"定时保存\",{\"1\":{\"189\":1}}],[\"定期删除\",{\"1\":{\"191\":1}}],[\"定期对索引进行更新和重新组织可以保持索引的效率\",{\"1\":{\"174\":1}}],[\"定期更新和重新组织索引\",{\"1\":{\"174\":1}}],[\"定义\",{\"1\":{\"716\":1}}],[\"定义tire\",{\"1\":{\"675\":1}}],[\"定义相符\",{\"1\":{\"651\":1}}],[\"定义远程接口\",{\"1\":{\"606\":1}}],[\"定义在外部类的成员位置上\",{\"1\":{\"418\":1}}],[\"定义在外部类的局部位置上\",{\"1\":{\"418\":1}}],[\"定义了异步任务执行的一些方法\",{\"1\":{\"229\":1}}],[\"定义了对外的create方法\",{\"1\":{\"105\":1}}],[\"定义一个新的irule\",{\"1\":{\"598\":1}}],[\"定义一个static静态属性对象\",{\"1\":{\"414\":1}}],[\"定义一个操作中的算法的骨架\",{\"1\":{\"104\":1}}],[\"定义一个创建对象的接口\",{\"1\":{\"101\":1}}],[\"定义对象键一种一对多的依赖关系\",{\"1\":{\"73\":1}}],[\"定义bean之间的关系\",{\"1\":{\"64\":1}}],[\"复用一下pop\",{\"1\":{\"655\":1}}],[\"复合赋值运算符\",{\"1\":{\"365\":1}}],[\"复合索引可以提高多个列组合查询的效率\",{\"1\":{\"174\":1}}],[\"复合索引\",{\"1\":{\"174\":1}}],[\"复制代码\",{\"1\":{\"598\":6}}],[\"复制数组元素\",{\"1\":{\"434\":1}}],[\"复制当前行\",{\"1\":{\"395\":1}}],[\"复制\",{\"1\":{\"203\":1}}],[\"复制算法的效率会降低\",{\"1\":{\"148\":1}}],[\"复制算法\",{\"1\":{\"148\":1}}],[\"考虑到头指针可能为删除节点的情况\",{\"1\":{\"634\":1}}],[\"考虑多列索引\",{\"1\":{\"174\":1}}],[\"考虑列的选择性\",{\"1\":{\"174\":1}}],[\"考虑优化内存使用\",{\"1\":{\"146\":1}}],[\"索引从\",{\"1\":{\"640\":1}}],[\"索引可能会变得不均衡或不连续\",{\"1\":{\"174\":1}}],[\"索引列的大小应尽可能小\",{\"1\":{\"174\":1}}],[\"索引应该选择在经常使用的查询条件\",{\"1\":{\"174\":1}}],[\"索引失效\",{\"1\":{\"173\":1}}],[\"全排列问题因为有顺序的原因所以for循环遍历都是从0开始\",{\"1\":{\"685\":1}}],[\"全排列\",{\"0\":{\"685\":1}}],[\"全局过滤器\",{\"1\":{\"607\":2}}],[\"全局变量可以加修饰符\",{\"1\":{\"391\":1}}],[\"全局变量可以不赋值直接使用\",{\"1\":{\"391\":1}}],[\"全局变量就是属性\",{\"1\":{\"391\":1}}],[\"全链路追踪\",{\"1\":{\"592\":1}}],[\"全映射的全自动框架\",{\"1\":{\"496\":1}}],[\"全类名\",{\"1\":{\"406\":1}}],[\"全表扫描需要遍历每一行数据\",{\"1\":{\"173\":1}}],[\"全称为\",{\"1\":{\"72\":1}}],[\"随后的n行依次表示模块1到n的依赖数据\",{\"1\":{\"718\":1}}],[\"随着类的加载而执行\",{\"1\":{\"413\":1}}],[\"随着数据的插入\",{\"1\":{\"174\":1}}],[\"随着行数的增加\",{\"1\":{\"173\":3}}],[\"随机数\",{\"1\":{\"721\":1}}],[\"随机数random\",{\"1\":{\"432\":1}}],[\"随机返回现有集合中的一项\",{\"1\":{\"721\":1}}],[\"随机排序\",{\"1\":{\"452\":1}}],[\"随机选择要淘汰的缓存数据\",{\"1\":{\"192\":1}}],[\"随机策略\",{\"1\":{\"192\":1,\"598\":2}}],[\"随机访问效率\",{\"1\":{\"122\":1}}],[\"随机打印20次以内\",{\"1\":{\"114\":1}}],[\"磁盘io操作可能会变得更频繁\",{\"1\":{\"173\":1}}],[\"磁盘io操作会变得频繁\",{\"1\":{\"172\":1}}],[\"磁盘io\",{\"1\":{\"173\":1}}],[\"叶子节点是指没有子节点的节点\",{\"1\":{\"669\":1,\"712\":1}}],[\"叶子节点存储所有数据\",{\"1\":{\"172\":1}}],[\"叶子节点的数目和路径和\",{\"1\":{\"90\":1}}],[\"节点0表示空\",{\"1\":{\"730\":1}}],[\"节点的右子树只包含大于当前节点的数\",{\"1\":{\"730\":1}}],[\"节点的左子树只包含小于当前节点的数\",{\"1\":{\"730\":1}}],[\"节点的数量一旦确定不能变化\",{\"1\":{\"190\":1}}],[\"节点流是底层流\",{\"1\":{\"478\":1}}],[\"节点流可以从一个特定的数据源读写数据\",{\"1\":{\"478\":1}}],[\"节点流和处理流的区别和联系\",{\"1\":{\"478\":1}}],[\"节点流和处理流\",{\"0\":{\"478\":1}}],[\"节点流\",{\"1\":{\"476\":1}}],[\"节点只有在成功获取后才会成为头节点\",{\"1\":{\"312\":1}}],[\"节点永远不会离开此状态\",{\"1\":{\"312\":1}}],[\"节点上\",{\"1\":{\"200\":1}}],[\"节点利用率较高\",{\"1\":{\"172\":1}}],[\"节点既存储数据也存储关键字\",{\"1\":{\"172\":1}}],[\"节省系统资源的时候\",{\"1\":{\"98\":1}}],[\"节省维护成本\",{\"1\":{\"95\":1}}],[\"串行化\",{\"0\":{\"243\":1,\"244\":1},\"1\":{\"171\":1,\"429\":1}}],[\"隔离级别\",{\"1\":{\"171\":1}}],[\"隔离性强\",{\"1\":{\"595\":1}}],[\"隔离性和持久性\",{\"1\":{\"183\":1}}],[\"隔离性是当多个用户并发访问数据库时\",{\"1\":{\"170\":1}}],[\"隔离性\",{\"1\":{\"170\":1,\"580\":1}}],[\"幻读是指一个事务在同样的查询条件下\",{\"1\":{\"171\":1}}],[\"幻读\",{\"1\":{\"171\":1}}],[\"幻灯片\",{\"0\":{\"38\":1}}],[\"脏读是指一个事务在读取了另一个事务未提交的数据之后\",{\"1\":{\"171\":1}}],[\"脏读\",{\"1\":{\"171\":1,\"582\":2}}],[\"两一种是将其中一段继续剪\",{\"1\":{\"736\":1}}],[\"两段\",{\"1\":{\"736\":1}}],[\"两指针分别指向头和尾\",{\"1\":{\"642\":1}}],[\"两指针相遇节点为环入口\",{\"1\":{\"640\":1}}],[\"两指针相减得到res\",{\"1\":{\"622\":1}}],[\"两两交换其中相邻的节点\",{\"1\":{\"637\":1}}],[\"两两交换链表中的节点1\",{\"1\":{\"637\":1}}],[\"两两交换链表中的节点\",{\"0\":{\"637\":1}}],[\"两节点反转\",{\"1\":{\"636\":1}}],[\"两数之和\",{\"0\":{\"626\":1},\"1\":{\"627\":1}}],[\"两次查询之间执行了任意的增删改\",{\"1\":{\"535\":1}}],[\"两次查询期间手动清空了缓存\",{\"1\":{\"534\":1}}],[\"两次查询期间执行了任意一次增删查改操作\",{\"1\":{\"534\":1}}],[\"两次只运行了一次构造器\",{\"1\":{\"414\":1}}],[\"两者都可以使用构造器来相互转化\",{\"1\":{\"430\":1}}],[\"两个栈都空时为empty\",{\"1\":{\"655\":1}}],[\"两个框架都可以使用注解方式\",{\"1\":{\"588\":1}}],[\"两个一致\",{\"1\":{\"501\":1}}],[\"两个属性first和last分别指向首节点和尾节点\",{\"1\":{\"443\":1}}],[\"两个instance都指向同一个实例\",{\"1\":{\"414\":1}}],[\"两个引用\",{\"1\":{\"406\":1}}],[\"两个值\",{\"1\":{\"358\":1}}],[\"两个流同时只能使用一个\",{\"1\":{\"335\":1}}],[\"两个输出流\",{\"1\":{\"335\":1}}],[\"两个处理器都对这一数据进行了修改\",{\"1\":{\"274\":1}}],[\"两个阶段谁先完成就输出结果\",{\"1\":{\"248\":1}}],[\"两个阶段都完成才能输出结果\",{\"1\":{\"248\":1}}],[\"两个\",{\"1\":{\"223\":1,\"631\":1}}],[\"两个事务同时读取一个数据并进行修改\",{\"1\":{\"171\":1}}],[\"两种处理方法\",{\"1\":{\"7\":1}}],[\"丢失更新\",{\"1\":{\"171\":1}}],[\"丢弃标签\",{\"1\":{\"209\":1}}],[\"丢弃任务等\",{\"1\":{\"135\":1}}],[\"丢弃最早提交的任务\",{\"1\":{\"134\":1}}],[\"弱引用\",{\"1\":{\"167\":1,\"536\":1}}],[\"软引用\",{\"1\":{\"167\":1,\"536\":1}}],[\"先构建一个节点类\",{\"1\":{\"729\":1}}],[\"先构造图的数据结构list<linkedlist<integer>>\",{\"1\":{\"718\":1}}],[\"先修课程对\",{\"1\":{\"717\":1}}],[\"先修课程按数组\",{\"1\":{\"717\":1}}],[\"先学习课程\",{\"1\":{\"717\":1}}],[\"先预处理\",{\"1\":{\"709\":1}}],[\"先给边缘的陆地打上标记\",{\"1\":{\"709\":1}}],[\"先排除掉靠边的岛屿\",{\"1\":{\"708\":1}}],[\"先对单词列表根据单词长度由长到短排序\",{\"1\":{\"675\":1}}],[\"先把头节点加入队列\",{\"1\":{\"666\":1,\"669\":1}}],[\"先把栈中的数从后往前依次出栈\",{\"1\":{\"662\":1}}],[\"先填满窗口\",{\"1\":{\"661\":1}}],[\"先放在辅助队列中\",{\"1\":{\"657\":1}}],[\"先存在辅助队列中\",{\"1\":{\"657\":1}}],[\"先枚举子串长度\",{\"1\":{\"650\":1}}],[\"先保存反转的两个节点之后的节点\",{\"1\":{\"636\":1}}],[\"先平方再排序\",{\"1\":{\"629\":1}}],[\"先提前计算好每个位置的左右最大柱子高度\",{\"1\":{\"624\":1}}],[\"先找极小值\",{\"1\":{\"624\":1}}],[\"先过滤掉非健康的服务实例\",{\"1\":{\"598\":1}}],[\"先配置xml中的后置处理器\",{\"1\":{\"560\":1}}],[\"先设置两个普通属性\",{\"1\":{\"557\":2}}],[\"先创建数据库表\",{\"1\":{\"540\":1}}],[\"先创建\",{\"1\":{\"540\":1}}],[\"先创建文件对象\",{\"1\":{\"475\":1}}],[\"先查询二级缓存\",{\"1\":{\"537\":1}}],[\"先分析需要上锁的代码\",{\"1\":{\"471\":1}}],[\"先判断能否整除2\",{\"1\":{\"689\":1,\"701\":3}}],[\"先判断存储类型\",{\"1\":{\"451\":1}}],[\"先判断再执行\",{\"1\":{\"374\":1}}],[\"先取出所有key\",{\"1\":{\"448\":1}}],[\"先得到hash值\",{\"1\":{\"445\":1}}],[\"先声明一个bean\",{\"1\":{\"606\":1}}],[\"先声明再创建\",{\"1\":{\"387\":1}}],[\"先声明数组\",{\"1\":{\"381\":1}}],[\"先升序排序\",{\"1\":{\"381\":1}}],[\"先执行\",{\"1\":{\"375\":1}}],[\"先用interupt\",{\"1\":{\"286\":1}}],[\"先行发生于它的finalize\",{\"1\":{\"288\":1}}],[\"先行发生\",{\"1\":{\"280\":1}}],[\"先连接到broker\",{\"1\":{\"210\":1}}],[\"先淘汰缓存\",{\"1\":{\"196\":1}}],[\"先删除缓存\",{\"1\":{\"195\":1}}],[\"先更新缓存\",{\"1\":{\"195\":1}}],[\"先更新数据库\",{\"1\":{\"195\":2}}],[\"先进先出策略\",{\"1\":{\"192\":1}}],[\"先进先出\",{\"1\":{\"167\":1,\"536\":1}}],[\"先标记出所有可达对象\",{\"1\":{\"148\":1}}],[\"带层次的文件路径\",{\"1\":{\"757\":1}}],[\"带参数的查询语句\",{\"1\":{\"504\":1}}],[\"带有被取消节点的线程永远不会再次被阻塞\",{\"1\":{\"312\":1}}],[\"带有泛型类型参数的方法\",{\"1\":{\"123\":1}}],[\"带有泛型类型参数的接口\",{\"1\":{\"123\":1}}],[\"带有泛型类型属性的类\",{\"1\":{\"123\":1}}],[\"带着问题学习\",{\"0\":{\"273\":1}}],[\"带上\",{\"1\":{\"165\":1}}],[\"添加一个虚拟节点\",{\"1\":{\"709\":1}}],[\"添加一个元素时\",{\"1\":{\"445\":1}}],[\"添加右括号\",{\"1\":{\"690\":1}}],[\"添加左括号\",{\"1\":{\"690\":1}}],[\"添加服务的刷新注解\",{\"1\":{\"603\":1}}],[\"添加bootstrap文件\",{\"1\":{\"602\":1}}],[\"添加discovery属性\",{\"1\":{\"599\":1}}],[\"添加新的配置\",{\"1\":{\"598\":1}}],[\"添加的新模块\",{\"1\":{\"588\":1}}],[\"添加数据库配置\",{\"1\":{\"605\":1}}],[\"添加数据库修改\",{\"0\":{\"577\":1}}],[\"添加数据库功能\",{\"0\":{\"576\":1}}],[\"添加方法\",{\"1\":{\"576\":1}}],[\"添加外部配置文件\",{\"1\":{\"562\":1}}],[\"添加对应属性\",{\"1\":{\"557\":1}}],[\"添加查询功能\",{\"0\":{\"504\":1}}],[\"添加k\",{\"1\":{\"448\":1}}],[\"添加多个元素\",{\"1\":{\"439\":1}}],[\"添加单个元素\",{\"1\":{\"439\":1}}],[\"添加\",{\"1\":{\"395\":1,\"540\":2,\"576\":1,\"577\":1,\"614\":1}}],[\"添加元素\",{\"1\":{\"194\":1}}],[\"添加到并查集中\",{\"1\":{\"709\":1}}],[\"添加到\",{\"1\":{\"165\":1}}],[\"添加拦截器\",{\"1\":{\"78\":1}}],[\"异位词\",{\"1\":{\"649\":2}}],[\"异步方法\",{\"1\":{\"246\":1}}],[\"异步方法使用注解\",{\"1\":{\"164\":1}}],[\"异步方法使用static关键词修饰\",{\"1\":{\"164\":1}}],[\"异步处理\",{\"1\":{\"207\":1}}],[\"异步\",{\"1\":{\"207\":1}}],[\"异步类不是一个spring容器的bean\",{\"1\":{\"164\":1}}],[\"异步的方法交给特定的线程池完成\",{\"1\":{\"164\":1}}],[\"异常通知\",{\"1\":{\"570\":1}}],[\"异常分类\",{\"1\":{\"424\":1}}],[\"异常对象都派生于throwable类\",{\"1\":{\"424\":1}}],[\"异常介绍\",{\"0\":{\"424\":1}}],[\"异常\",{\"0\":{\"423\":1},\"1\":{\"134\":1,\"147\":1,\"249\":1,\"583\":1}}],[\"异常处理机制\",{\"1\":{\"424\":1}}],[\"异常处理\",{\"1\":{\"133\":1,\"162\":1,\"346\":1}}],[\"处理节点\",{\"1\":{\"682\":1}}],[\"处理一对多映射\",{\"1\":{\"525\":1}}],[\"处理多对一的映射关系\",{\"1\":{\"523\":2,\"524\":1,\"527\":1}}],[\"处理多对一映射关系\",{\"1\":{\"523\":1}}],[\"处理字段名和属性名不一致的情况\",{\"0\":{\"522\":1}}],[\"处理纯文本数据时转换为字符流效率更高\",{\"1\":{\"478\":1}}],[\"处理流对节点流进行包装\",{\"1\":{\"478\":1}}],[\"处理流是连接已存在的流之上\",{\"1\":{\"478\":1}}],[\"处理流\",{\"1\":{\"476\":1,\"478\":3}}],[\"处理所有的代理对象上的方法调用\",{\"1\":{\"419\":1}}],[\"处理\",{\"1\":{\"204\":1,\"715\":2,\"718\":1}}],[\"处理请求和生成响应\",{\"1\":{\"168\":1}}],[\"处理完成后\",{\"1\":{\"161\":1}}],[\"处理响应\",{\"1\":{\"161\":1}}],[\"处理器不做任何操作\",{\"1\":{\"295\":1}}],[\"处理器1与处理器2都从主内存读取了同一个数据分别存储到自己的高速缓存区域\",{\"1\":{\"274\":1}}],[\"处理器可能将共享变量的值缓存在寄存器或者缓存中\",{\"1\":{\"140\":1}}],[\"处理器handler\",{\"1\":{\"76\":1}}],[\"处理器适配器handleradapter\",{\"1\":{\"76\":1}}],[\"处理器映射器handlermapping\",{\"1\":{\"76\":1}}],[\"处理器映射器找到具体的处理器\",{\"1\":{\"76\":1}}],[\"拦截\",{\"1\":{\"607\":1}}],[\"拦截到客户端发送的请求\",{\"1\":{\"161\":1}}],[\"拦截请求的场景有\",{\"1\":{\"338\":1}}],[\"拦截请求\",{\"1\":{\"161\":1,\"607\":1}}],[\"协作的\",{\"0\":{\"778\":1}}],[\"协议采用了类似mime机制\",{\"1\":{\"769\":1}}],[\"协议最高层\",{\"1\":{\"208\":1}}],[\"协议进行节点之间的通信\",{\"1\":{\"203\":1}}],[\"协议向服务器发送请求\",{\"1\":{\"161\":1}}],[\"协商加密算法\",{\"1\":{\"155\":1}}],[\"销毁方法\",{\"1\":{\"560\":3}}],[\"销毁\",{\"1\":{\"160\":1,\"560\":1}}],[\"销毁的方法\",{\"1\":{\"66\":1,\"560\":1}}],[\"常规的循环相乘x\",{\"1\":{\"742\":1}}],[\"常见方法\",{\"1\":{\"430\":1,\"480\":1}}],[\"常见运行时异常\",{\"1\":{\"424\":1}}],[\"常见的编码格式有\",{\"1\":{\"768\":1}}],[\"常见的销毁回调方法有disposablebean接口的destroy\",{\"1\":{\"160\":1}}],[\"常见的初始化回调方法有initializingbean接口的afterpropertiesset\",{\"1\":{\"160\":1}}],[\"常量池中已经出现了\",{\"1\":{\"429\":1}}],[\"常量池中创建了3个变量\",{\"1\":{\"429\":1}}],[\"常量池\",{\"1\":{\"388\":1}}],[\"常量2\",{\"1\":{\"372\":1}}],[\"常量1\",{\"1\":{\"372\":1}}],[\"常量\",{\"1\":{\"365\":1}}],[\"常用文件操作\",{\"0\":{\"475\":1}}],[\"常用t表示\",{\"1\":{\"456\":1}}],[\"常用string类来做key\",{\"1\":{\"448\":1}}],[\"常用类\",{\"0\":{\"426\":1}}],[\"常用于回传字符串\",{\"1\":{\"335\":1}}],[\"常用于下载\",{\"1\":{\"335\":1}}],[\"常用方法第二组\",{\"1\":{\"468\":1}}],[\"常用方法第一组\",{\"1\":{\"468\":1}}],[\"常用方法\",{\"1\":{\"237\":1,\"432\":1,\"433\":1,\"434\":1,\"435\":1,\"439\":1,\"440\":1,\"444\":1,\"448\":1}}],[\"常用策略\",{\"1\":{\"192\":1}}],[\"常用的方式是增加\",{\"1\":{\"593\":1}}],[\"常用的方法是\",{\"1\":{\"129\":4}}],[\"常用的类\",{\"0\":{\"477\":1}}],[\"常用的包\",{\"1\":{\"396\":1}}],[\"常用的服务器\",{\"0\":{\"324\":1}}],[\"常用的重写方法列举几个\",{\"0\":{\"78\":1}}],[\"机器人的运动范围\",{\"0\":{\"732\":1}}],[\"机器人试图达到网格的右下角\",{\"1\":{\"695\":1,\"696\":1}}],[\"机器人每次只能向下或者向右移动一步\",{\"1\":{\"695\":1,\"696\":1}}],[\"机器故障\",{\"1\":{\"203\":1}}],[\"机制进行监控\",{\"1\":{\"597\":1}}],[\"机制\",{\"1\":{\"186\":1,\"211\":2}}],[\"机制将配置的属性值设置到bean实例中\",{\"1\":{\"160\":1}}],[\"机考记录\",{\"0\":{\"87\":1}}],[\"字符常量用单引号括起来\",{\"1\":{\"358\":1}}],[\"字符类型\",{\"1\":{\"358\":1}}],[\"字符流\",{\"1\":{\"335\":1,\"476\":2,\"478\":1}}],[\"字符串反转与原字符串相等即为回文\",{\"1\":{\"688\":1}}],[\"字符串出现的第一个位置\",{\"1\":{\"651\":1}}],[\"字符串中找出\",{\"1\":{\"651\":1}}],[\"字符串和一个\",{\"1\":{\"651\":1}}],[\"字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部\",{\"1\":{\"646\":1}}],[\"字符串的字符使用unicode编码\",{\"1\":{\"429\":1}}],[\"字符串替换\",{\"1\":{\"518\":1}}],[\"字符串拼接\",{\"1\":{\"510\":1}}],[\"字符串常量\",{\"1\":{\"429\":1}}],[\"字符串相加\",{\"1\":{\"362\":1}}],[\"字符串\",{\"0\":{\"641\":1},\"1\":{\"188\":1,\"651\":1,\"713\":1}}],[\"字节\",{\"1\":{\"475\":1}}],[\"字节流传输\",{\"1\":{\"753\":1}}],[\"字节流\",{\"1\":{\"335\":1,\"476\":2,\"478\":1}}],[\"字节码生成库\",{\"1\":{\"159\":1}}],[\"字段\",{\"1\":{\"6\":1,\"386\":1,\"522\":1}}],[\"增删多\",{\"1\":{\"451\":1}}],[\"增删改查\",{\"1\":{\"409\":1}}],[\"增\",{\"1\":{\"430\":1}}],[\"增强\",{\"1\":{\"570\":1}}],[\"增强方法所在的类\",{\"1\":{\"569\":1}}],[\"增强方法的可靠性和可理解性\",{\"1\":{\"127\":1}}],[\"增强for\",{\"1\":{\"448\":1}}],[\"增强的代理\",{\"1\":{\"419\":1}}],[\"增加步数\",{\"1\":{\"712\":1}}],[\"增加的幅度尽可能的小\",{\"1\":{\"628\":1}}],[\"增加租户字段\",{\"1\":{\"605\":1}}],[\"增加\",{\"1\":{\"583\":1,\"676\":1,\"677\":1,\"678\":1}}],[\"增加在末尾\",{\"1\":{\"430\":1}}],[\"增加错误发生的概率\",{\"1\":{\"262\":1}}],[\"增加一些额外的功能和行为\",{\"1\":{\"158\":1}}],[\"能解决的问题\",{\"1\":{\"711\":1}}],[\"能够阻止分布式系统中出现联动故障\",{\"1\":{\"593\":1}}],[\"能够实现对房屋信息的添加\",{\"1\":{\"408\":1}}],[\"能够识别\",{\"1\":{\"203\":1}}],[\"能够降低代码的耦合性\",{\"1\":{\"158\":1}}],[\"能防止指令重排\",{\"0\":{\"140\":1}}],[\"广播和多播\",{\"1\":{\"156\":1}}],[\"视频\",{\"1\":{\"323\":1}}],[\"视频会议和直播等\",{\"1\":{\"156\":1}}],[\"视图解析\",{\"1\":{\"162\":1}}],[\"视图解析器view\",{\"1\":{\"76\":1}}],[\"视图跳转控制器\",{\"1\":{\"78\":1}}],[\"视图view\",{\"1\":{\"76\":1}}],[\"验证\",{\"1\":{\"419\":1,\"776\":1}}],[\"验证包括检查证书的签名是否有效\",{\"1\":{\"155\":1}}],[\"验证服务器证书\",{\"1\":{\"155\":1}}],[\"客户端也可以有缓存\",{\"1\":{\"781\":1}}],[\"客户端的缓存\",{\"1\":{\"781\":1}}],[\"客户端驱动协商\",{\"1\":{\"771\":1}}],[\"客户端调用过程变的简单\",{\"1\":{\"593\":1}}],[\"客户端退出\",{\"1\":{\"485\":1}}],[\"客户端\",{\"1\":{\"485\":3,\"599\":1,\"611\":1}}],[\"客户端和服务端\",{\"1\":{\"482\":1}}],[\"客户端和服务器使用对称密钥来加密和解密传输的数据\",{\"1\":{\"155\":1}}],[\"客户端和服务器都会生成用于加密通信的会话密钥\",{\"1\":{\"155\":1}}],[\"客户端可以建立多个channel\",{\"1\":{\"209\":1}}],[\"客户端可以用这些命令实现自己的业务逻辑\",{\"1\":{\"208\":1}}],[\"客户端可以清空事务队列\",{\"1\":{\"202\":1}}],[\"客户端可以继续向服务器发送任意多条命令\",{\"1\":{\"202\":1}}],[\"客户端在后续的请求中会自动将\",{\"1\":{\"165\":1}}],[\"客户端请求\",{\"1\":{\"165\":1}}],[\"客户端通过\",{\"1\":{\"161\":1}}],[\"客户端发送请求\",{\"1\":{\"161\":1,\"759\":1}}],[\"客户端发起连接\",{\"1\":{\"155\":1}}],[\"客户端使用服务器的公钥对会话密钥进行加密\",{\"1\":{\"155\":1}}],[\"客户端会提供一组支持的加密算法供服务器选择\",{\"1\":{\"155\":1}}],[\"客户端会发出警告或终止连接\",{\"1\":{\"155\":1}}],[\"客户端选择与服务器进行安全通信所使用的加密算法和密钥长度\",{\"1\":{\"155\":1}}],[\"客户端收到服务器证书后\",{\"1\":{\"155\":1}}],[\"客户端向服务器发送https请求时\",{\"1\":{\"155\":1}}],[\"客户端错误状态码\",{\"0\":{\"776\":1},\"1\":{\"155\":1}}],[\"成立\",{\"1\":{\"650\":1}}],[\"成为镜像\",{\"1\":{\"611\":1}}],[\"成员\",{\"1\":{\"457\":1}}],[\"成员名重名时采用就近原则\",{\"1\":{\"418\":1}}],[\"成员内部类定义在外部类的成员位置\",{\"1\":{\"418\":1}}],[\"成员内部类\",{\"1\":{\"418\":2}}],[\"成员方法的定义\",{\"1\":{\"389\":1}}],[\"成员方法\",{\"0\":{\"389\":1}}],[\"成员变量\",{\"0\":{\"386\":1},\"1\":{\"386\":1,\"391\":1}}],[\"成员和构造函数都是私有的\",{\"1\":{\"99\":1}}],[\"成功状态码\",{\"0\":{\"774\":1},\"1\":{\"155\":1}}],[\"签发\",{\"1\":{\"154\":1,\"155\":1}}],[\"证书是否过期等\",{\"1\":{\"155\":1}}],[\"证书通常由可信任的第三方机构\",{\"1\":{\"155\":1}}],[\"证书\",{\"1\":{\"154\":1}}],[\"容量只会不变或者上升\",{\"1\":{\"625\":1}}],[\"容量瓶颈\",{\"1\":{\"203\":1}}],[\"容错\",{\"1\":{\"595\":1}}],[\"容易被窃听和篡改\",{\"1\":{\"154\":1}}],[\"容器能够容纳水\",{\"1\":{\"625\":1}}],[\"容器操作\",{\"0\":{\"614\":1}}],[\"容器从暂停恢复运行状态\",{\"1\":{\"613\":1}}],[\"容器相关命令\",{\"1\":{\"613\":1}}],[\"容器等\",{\"1\":{\"611\":1}}],[\"容器实现\",{\"1\":{\"555\":1}}],[\"容器实现的两种方式\",{\"1\":{\"555\":1}}],[\"容器底层就是对象工厂\",{\"1\":{\"555\":1}}],[\"容器完成\",{\"1\":{\"555\":1}}],[\"容器时\",{\"1\":{\"70\":1}}],[\"容器中\",{\"1\":{\"70\":2}}],[\"容器\",{\"0\":{\"553\":1},\"1\":{\"61\":1,\"545\":2,\"588\":1,\"611\":1}}],[\"生产环境是centos\",{\"1\":{\"609\":1}}],[\"生产的环境有差异问题\",{\"1\":{\"609\":1}}],[\"生产的数据直接发送到\",{\"1\":{\"207\":1}}],[\"生产者\",{\"1\":{\"213\":1}}],[\"生产者到\",{\"1\":{\"211\":1}}],[\"生产者publisher\",{\"1\":{\"209\":1}}],[\"生产消息\",{\"1\":{\"209\":1}}],[\"生命周期\",{\"0\":{\"160\":1,\"560\":1},\"1\":{\"153\":1,\"560\":1}}],[\"生成二维方格数组\",{\"1\":{\"734\":1}}],[\"生成图结构\",{\"1\":{\"717\":2}}],[\"生成新链表的指针\",{\"1\":{\"634\":1}}],[\"生成一个包含\",{\"1\":{\"632\":1}}],[\"生成代理对象\",{\"1\":{\"572\":1}}],[\"生成dao接口\",{\"1\":{\"540\":1}}],[\"生成xml映射文件\",{\"1\":{\"540\":1}}],[\"生成大量的代理类造成的冗余\",{\"1\":{\"492\":1}}],[\"生成socket\",{\"1\":{\"485\":1}}],[\"生成构造器\",{\"1\":{\"395\":1}}],[\"生成密钥\",{\"1\":{\"155\":1}}],[\"生成\",{\"1\":{\"114\":1}}],[\"生成出所谓的\",{\"1\":{\"107\":1}}],[\"生成了一个单实例对象\",{\"1\":{\"99\":1}}],[\"生成处理器对象及处理器拦截器\",{\"1\":{\"76\":1}}],[\"生成目标类的代理对象动态代理拼接\",{\"1\":{\"159\":1}}],[\"生成目标类的代理对象\",{\"1\":{\"72\":1}}],[\"浏览器禁止请求的发起者与服务端发生跨域ajax请求\",{\"1\":{\"607\":1}}],[\"浏览器关闭后失效\",{\"1\":{\"153\":1}}],[\"浏览器\",{\"1\":{\"153\":1}}],[\"浏览器会重新发起一个新的请求去获取这个新url的资源\",{\"1\":{\"77\":1}}],[\"资源耗尽\",{\"1\":{\"424\":1}}],[\"资源占用\",{\"1\":{\"150\":1}}],[\"资源优化场景\",{\"1\":{\"116\":1}}],[\"压缩算法\",{\"1\":{\"148\":2}}],[\"适合锁大量的同步代码\",{\"1\":{\"261\":1}}],[\"适合锁少量的代码同步问题\",{\"1\":{\"261\":1}}],[\"适合读操作多的场景\",{\"1\":{\"258\":1}}],[\"适合写操作多的场景\",{\"1\":{\"258\":1}}],[\"适合对实时性要求较高的应用场景\",{\"1\":{\"213\":1}}],[\"适合存储对象\",{\"1\":{\"188\":1}}],[\"适合频繁回收\",{\"1\":{\"148\":1}}],[\"适用于顺序访问和范围查询\",{\"1\":{\"172\":1}}],[\"适用于随机访问和插入操作\",{\"1\":{\"172\":1}}],[\"适配器可以方便我们和其它系统进行集成\",{\"1\":{\"95\":1}}],[\"适配器\",{\"1\":{\"95\":1}}],[\"适配器模式就是后者\",{\"1\":{\"95\":1}}],[\"适配器模式\",{\"0\":{\"94\":1}}],[\"新版只要任意一端没有明确提出断开连接\",{\"1\":{\"764\":1}}],[\"新数组下标的位置\",{\"1\":{\"623\":1}}],[\"新数组就是不含有目标元素的数组\",{\"1\":{\"623\":1}}],[\"新数组大小减减\",{\"1\":{\"623\":1}}],[\"新功能\",{\"0\":{\"585\":1}}],[\"新建结点\",{\"1\":{\"635\":1}}],[\"新建一个测试类\",{\"1\":{\"552\":1}}],[\"新建多个代理类\",{\"1\":{\"419\":1}}],[\"新值替换list中的所有旧值\",{\"1\":{\"452\":1}}],[\"新增房源\",{\"1\":{\"408\":1}}],[\"新head指向c\",{\"1\":{\"318\":1}}],[\"新生\",{\"1\":{\"225\":1}}],[\"新生代通常使用复制算法\",{\"1\":{\"148\":1}}],[\"新写入操作就会报错\",{\"1\":{\"192\":1}}],[\"新的响应里包含了一个指向新url的location头字段\",{\"1\":{\"77\":1}}],[\"父工程\",{\"1\":{\"599\":1}}],[\"父子类\",{\"1\":{\"401\":1}}],[\"父子类的静态初始化代码块\",{\"0\":{\"53\":1}}],[\"父类写前面\",{\"1\":{\"424\":1}}],[\"父类异常写在后面\",{\"1\":{\"424\":1}}],[\"父类的构造方法\",{\"1\":{\"413\":1}}],[\"父类的普通代码块和普通属性\",{\"1\":{\"413\":1}}],[\"父类的静态代码块和静态属性\",{\"1\":{\"413\":1}}],[\"父类也会被加载\",{\"1\":{\"413\":1}}],[\"父类引用\",{\"1\":{\"402\":1}}],[\"父类引用指向子类对象\",{\"1\":{\"402\":1}}],[\"父类类型\",{\"1\":{\"402\":1}}],[\"父类中没有则往父类中的父类查找\",{\"1\":{\"400\":1}}],[\"父类属性由父类初始化\",{\"1\":{\"400\":1}}],[\"父类构造器的调用不仅仅调用定义的父类\",{\"1\":{\"399\":1}}],[\"父类\",{\"1\":{\"399\":1}}],[\"父类加载器也会按照同样的逻辑继续向上委派\",{\"1\":{\"147\":1}}],[\"帮助识别哪些对象或数据结构占用大量内存\",{\"1\":{\"146\":1}}],[\"调转right后面的数\",{\"1\":{\"628\":1}}],[\"调度操作\",{\"1\":{\"592\":1}}],[\"调整数据结构大小等\",{\"1\":{\"146\":1}}],[\"调用负载均衡策略\",{\"1\":{\"598\":1}}],[\"调用其他服务的\",{\"1\":{\"596\":1}}],[\"调用其他服务的接口\",{\"1\":{\"596\":1}}],[\"调用其他类完成对房屋信息的各种操作\",{\"1\":{\"409\":1}}],[\"调用语句时刷新\",{\"1\":{\"536\":1}}],[\"调用class对应的方法\",{\"1\":{\"486\":1}}],[\"调用相应的方法\",{\"1\":{\"475\":1}}],[\"调用时\",{\"1\":{\"459\":1}}],[\"调用equals比较\",{\"1\":{\"445\":1}}],[\"调用valueof\",{\"1\":{\"427\":1}}],[\"调用了一个抛出检查型异常的方法\",{\"1\":{\"425\":1}}],[\"调用了start0方法\",{\"1\":{\"220\":1}}],[\"调用代理的方法\",{\"1\":{\"419\":1}}],[\"调用代理类\",{\"1\":{\"419\":1}}],[\"调用invoke方法之后执行\",{\"1\":{\"419\":1}}],[\"调用invoke方法之前执行\",{\"1\":{\"419\":1}}],[\"调用普通代码块\",{\"1\":{\"413\":1}}],[\"调用普通代码块和普通属性初始化\",{\"1\":{\"413\":1}}],[\"调用构造方法\",{\"1\":{\"413\":1}}],[\"调用构造器\",{\"1\":{\"400\":1}}],[\"调用静态代码块和静态属性初始化\",{\"1\":{\"413\":1}}],[\"调用父类构造器\",{\"1\":{\"400\":1}}],[\"调用父类构造器的好处\",{\"1\":{\"400\":1}}],[\"调用本类的构造器\",{\"1\":{\"400\":1}}],[\"调用方法\",{\"1\":{\"400\":1}}],[\"调用类型对应的parsexxx方法即可\",{\"1\":{\"360\":1}}],[\"调用unsafe类的cas方法\",{\"1\":{\"296\":1}}],[\"调用这个方法的对象\",{\"1\":{\"259\":1}}],[\"调用这个代码块的对象\",{\"1\":{\"259\":1}}],[\"调用该方法的线程会阻塞\",{\"1\":{\"144\":1}}],[\"调用者只关心产品的接口\",{\"1\":{\"101\":1}}],[\"调用业务逻辑处理模块\",{\"1\":{\"69\":1}}],[\"调用\",{\"1\":{\"66\":3,\"161\":2,\"419\":1,\"560\":3,\"569\":1}}],[\"及时释放不再使用的对象\",{\"1\":{\"146\":1}}],[\"另一个栈用来在取数据时反转数据\",{\"1\":{\"655\":1}}],[\"另一种是使用concat\",{\"1\":{\"7\":1}}],[\"另外\",{\"1\":{\"146\":1}}],[\"缓存的有效期限\",{\"1\":{\"781\":1}}],[\"缓存指代理服务器保存的资源副本\",{\"1\":{\"781\":1}}],[\"缓存代理\",{\"1\":{\"780\":1}}],[\"缓存中不存在该key\",{\"1\":{\"720\":1}}],[\"缓存中是否存在该bean的实例\",{\"1\":{\"163\":1}}],[\"缓存容量\",{\"1\":{\"720\":1}}],[\"缓存是\",{\"1\":{\"720\":4}}],[\"缓存结果\",{\"1\":{\"689\":1,\"701\":1}}],[\"缓存查询顺序\",{\"0\":{\"537\":1}}],[\"缓存回收策略\",{\"1\":{\"536\":1}}],[\"缓存失效后\",{\"1\":{\"198\":1}}],[\"缓存穿透是指用户请求的数据在缓存中不存在即没有命中\",{\"1\":{\"197\":1}}],[\"缓存与数据库一致性问题\",{\"0\":{\"195\":1}}],[\"缓存策略\",{\"1\":{\"167\":1}}],[\"缓存会失效\",{\"1\":{\"167\":1}}],[\"缓存机制\",{\"1\":{\"167\":1}}],[\"缓存\",{\"0\":{\"185\":1,\"533\":1},\"1\":{\"146\":1,\"720\":2}}],[\"审查代码\",{\"1\":{\"146\":1}}],[\"大于链表的长度\",{\"1\":{\"635\":1}}],[\"大者存入结果数组的末端\",{\"1\":{\"629\":1}}],[\"大的最小的数\",{\"1\":{\"628\":1}}],[\"大数\",{\"1\":{\"628\":4}}],[\"大型项目运行环境要配置很多软件\",{\"1\":{\"609\":1}}],[\"大黄\",{\"1\":{\"454\":2}}],[\"大小\",{\"1\":{\"381\":1,\"382\":2}}],[\"大多数代码不需要检查特定的值\",{\"1\":{\"312\":1}}],[\"大概率会有其他线程来争抢\",{\"1\":{\"295\":1}}],[\"大括号需要指定表达式返回了一个数值\",{\"1\":{\"488\":1}}],[\"大括号\",{\"1\":{\"259\":1}}],[\"大大提高了范围查询的效率\",{\"1\":{\"172\":1}}],[\"大量数据处理\",{\"1\":{\"146\":1}}],[\"大家可以随手拿来使用\",{\"1\":{\"116\":1}}],[\"错误\",{\"1\":{\"359\":4,\"365\":1,\"460\":1}}],[\"错误检测和数据表示等\",{\"1\":{\"208\":1}}],[\"错误检查不同\",{\"1\":{\"62\":1}}],[\"错误日志\",{\"1\":{\"177\":1}}],[\"错误信息通常会提供一些线索来定位问题\",{\"1\":{\"146\":1}}],[\"错误时\",{\"1\":{\"146\":1}}],[\"释放资源\",{\"1\":{\"482\":1}}],[\"释放一个许可\",{\"1\":{\"144\":1}}],[\"释放锁的最简单方式就是执行\",{\"1\":{\"205\":1}}],[\"释放锁\",{\"0\":{\"472\":1},\"1\":{\"141\":1,\"216\":1}}],[\"尝试释放成功后\",{\"1\":{\"317\":1}}],[\"尝试释放共享锁\",{\"1\":{\"313\":1}}],[\"尝试释放独占锁\",{\"1\":{\"313\":1}}],[\"尝试以共享方式获取锁\",{\"1\":{\"313\":1}}],[\"尝试获取独占锁\",{\"1\":{\"313\":1}}],[\"尝试获取一个许可\",{\"1\":{\"144\":1}}],[\"尝试将该节点加入到aqs的同步队列的尾部\",{\"1\":{\"143\":1}}],[\"信息\",{\"1\":{\"615\":1}}],[\"信息时\",{\"1\":{\"524\":1}}],[\"信息容器\",{\"1\":{\"18\":1}}],[\"信道\",{\"1\":{\"209\":1}}],[\"信道服用\",{\"1\":{\"208\":1}}],[\"信号量\",{\"1\":{\"144\":1}}],[\"才可以记录当前的起始索引\",{\"1\":{\"649\":1}}],[\"才存入\",{\"1\":{\"649\":1}}],[\"才说明\",{\"1\":{\"649\":1}}],[\"才会写入数据到文件\",{\"1\":{\"479\":1}}],[\"才会继续执行\",{\"1\":{\"144\":1}}],[\"才能修课程\",{\"1\":{\"717\":1}}],[\"才能算一次有效包含\",{\"1\":{\"649\":1}}],[\"才能真正的把数据写入到文件\",{\"1\":{\"477\":1}}],[\"才能操作同步代码\",{\"1\":{\"470\":1}}],[\"才能对数据进行操作\",{\"1\":{\"398\":1}}],[\"才能将\",{\"1\":{\"67\":1}}],[\"才是所谓的\",{\"1\":{\"212\":1}}],[\"加载bean\",{\"1\":{\"602\":2}}],[\"加载配置类\",{\"1\":{\"565\":1}}],[\"加载配置文件时就会把对象创建\",{\"1\":{\"555\":1}}],[\"加载配置文件时不会加载里面的对象\",{\"1\":{\"555\":1}}],[\"加载配置文件的键值对到properties对象\",{\"1\":{\"480\":1}}],[\"加载spring配置文件\",{\"1\":{\"552\":1,\"557\":1,\"559\":1,\"560\":1}}],[\"加载指定配置文件\",{\"1\":{\"480\":1}}],[\"加载数据到properties类对象\",{\"1\":{\"450\":1}}],[\"加载\",{\"1\":{\"419\":1,\"559\":1}}],[\"加入路径\",{\"1\":{\"717\":1}}],[\"加入了游戏\",{\"1\":{\"411\":1}}],[\"加入队列\",{\"1\":{\"143\":1}}],[\"加上static\",{\"1\":{\"411\":1}}],[\"加\",{\"1\":{\"362\":1}}],[\"加锁保证原子性\",{\"1\":{\"295\":1}}],[\"加锁\",{\"1\":{\"205\":1}}],[\"加索引为什么会快\",{\"0\":{\"173\":1},\"1\":{\"173\":1}}],[\"加密展示\",{\"1\":{\"9\":1,\"33\":1}}],[\"操作数据卷\",{\"1\":{\"615\":1}}],[\"操作命令\",{\"1\":{\"613\":1}}],[\"操作系统中运行\",{\"1\":{\"609\":1}}],[\"操作系统与计算机网络\",{\"0\":{\"149\":1}}],[\"操作准备\",{\"0\":{\"571\":1}}],[\"操作术语\",{\"0\":{\"570\":1}}],[\"操作简便\",{\"1\":{\"496\":1}}],[\"操作对象内容\",{\"1\":{\"486\":1}}],[\"操作与其相同\",{\"1\":{\"480\":1}}],[\"操作\",{\"0\":{\"572\":1},\"1\":{\"143\":1,\"204\":1,\"571\":2,\"667\":1}}],[\"锁定规则\",{\"0\":{\"282\":1}}],[\"锁定机制\",{\"1\":{\"171\":1}}],[\"锁超时知道的是\",{\"1\":{\"205\":1}}],[\"锁超时\",{\"1\":{\"205\":1}}],[\"锁竞争的概率也增大\",{\"1\":{\"173\":1}}],[\"锁竞争\",{\"1\":{\"173\":1}}],[\"锁的初始数字为\",{\"1\":{\"713\":1}}],[\"锁的灵活性\",{\"1\":{\"142\":1}}],[\"锁的获取方式\",{\"1\":{\"142\":1}}],[\"锁会膨胀为重量级锁\",{\"1\":{\"139\":1}}],[\"唤醒机制来管理线程的竞争和等待\",{\"1\":{\"141\":1}}],[\"基础镜像\",{\"1\":{\"616\":1}}],[\"基础\",{\"0\":{\"383\":1}}],[\"基础概念\",{\"0\":{\"221\":1}}],[\"基本打家劫舍问题算法\",{\"1\":{\"698\":1}}],[\"基本字典树\",{\"0\":{\"674\":1}}],[\"基本操作\",{\"0\":{\"613\":1}}],[\"基本说明\",{\"1\":{\"467\":1}}],[\"基本概念\",{\"0\":{\"588\":1},\"1\":{\"424\":1}}],[\"基本包\",{\"1\":{\"396\":1}}],[\"基本介绍\",{\"1\":{\"386\":1,\"397\":1,\"413\":1,\"415\":1,\"417\":1,\"422\":1,\"471\":1,\"485\":1}}],[\"基本语法\",{\"1\":{\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"377\":1,\"378\":1,\"399\":1,\"400\":1,\"413\":1,\"457\":1,\"458\":1,\"459\":1}}],[\"基本赋值运算符\",{\"1\":{\"365\":1}}],[\"基本数据类型和string类型的转换\",{\"0\":{\"360\":1}}],[\"基本数据类型转换\",{\"0\":{\"359\":1}}],[\"基本类型形参的改变不会改变原来实参\",{\"1\":{\"389\":1}}],[\"基本类型转string\",{\"1\":{\"360\":1}}],[\"基本类型\",{\"0\":{\"188\":1},\"1\":{\"360\":1}}],[\"基本结构\",{\"1\":{\"141\":1}}],[\"基于compose\",{\"1\":{\"617\":1}}],[\"基于spingboot实现自动装配\",{\"1\":{\"595\":1}}],[\"基于spring\",{\"1\":{\"81\":1}}],[\"基于注解方式实现\",{\"1\":{\"571\":1}}],[\"基于注解方式实现属性的注入\",{\"0\":{\"564\":1}}],[\"基于注解方式实现对象的创建\",{\"1\":{\"563\":1}}],[\"基于注解方式操作\",{\"0\":{\"563\":1}}],[\"基于注解的配置\",{\"1\":{\"64\":1}}],[\"基于\",{\"1\":{\"557\":5,\"571\":2,\"588\":1}}],[\"基于抽象类的匿名内部类与普通类的区别是必须要重写抽象方法\",{\"1\":{\"418\":1}}],[\"基于类的匿名内部类\",{\"1\":{\"418\":1}}],[\"基于类的代理\",{\"1\":{\"159\":1}}],[\"基于接口的匿名内部类\",{\"1\":{\"418\":1}}],[\"基于接口的代理\",{\"1\":{\"159\":1}}],[\"基于传统的消息队列模型\",{\"1\":{\"213\":1}}],[\"基于java的配置\",{\"1\":{\"64\":1}}],[\"基于xml的配置\",{\"1\":{\"64\":1}}],[\"读写顺序要一致\",{\"1\":{\"478\":1}}],[\"读写\",{\"1\":{\"476\":1}}],[\"读视图\",{\"1\":{\"178\":1}}],[\"读已提交\",{\"1\":{\"171\":1}}],[\"读未提交\",{\"1\":{\"171\":1}}],[\"读操作和写操作都有相应的内存屏障\",{\"1\":{\"140\":1}}],[\"读取二维数组\",{\"0\":{\"728\":1}}],[\"读取二进制流\",{\"1\":{\"116\":1}}],[\"读取一维数组\",{\"0\":{\"727\":1}}],[\"读取bootstrap\",{\"1\":{\"602\":1}}],[\"读取本地配置文件application\",{\"1\":{\"602\":2}}],[\"读取nacos中的配置文件\",{\"1\":{\"602\":2}}],[\"读取客户端写入到数据通道的数据\",{\"1\":{\"485\":1}}],[\"读取转换的fileinputstream\",{\"1\":{\"478\":1}}],[\"读取完成\",{\"1\":{\"478\":1}}],[\"读取\",{\"1\":{\"478\":2}}],[\"读取外部数据到程序中\",{\"1\":{\"476\":1}}],[\"读取文件\",{\"1\":{\"451\":1}}],[\"读取示例\",{\"1\":{\"55\":1}}],[\"原地\",{\"1\":{\"628\":1}}],[\"原来远程调用userservice的请求为\",{\"1\":{\"606\":1}}],[\"原码符号位不变\",{\"1\":{\"369\":1}}],[\"原码\",{\"0\":{\"369\":1}}],[\"原子意味着多个线程试图改变同一个atomicreference\",{\"1\":{\"297\":1}}],[\"原子性是指事务包含的所有操作要么全部成功\",{\"1\":{\"170\":1}}],[\"原子性\",{\"1\":{\"140\":1,\"170\":1,\"183\":1,\"273\":1,\"580\":1}}],[\"原本不存在\",{\"1\":{\"205\":1}}],[\"原则\",{\"1\":{\"181\":1,\"280\":1}}],[\"原理\",{\"0\":{\"178\":1}}],[\"原因是\",{\"1\":{\"164\":1}}],[\"原型模式是通过拷贝一个现有对象生成新对象的\",{\"1\":{\"116\":1}}],[\"原型模式已经与\",{\"1\":{\"116\":1}}],[\"原型模式很少单独出现\",{\"1\":{\"116\":1}}],[\"原型模式同样用于隔离类对象的使用者和具体类型\",{\"1\":{\"116\":1}}],[\"原型模式\",{\"0\":{\"115\":1},\"1\":{\"116\":1}}],[\"之前添加\",{\"1\":{\"687\":2}}],[\"之前\",{\"1\":{\"286\":1,\"717\":1}}],[\"之前的命令不会回滚\",{\"1\":{\"201\":1}}],[\"之前应用\",{\"1\":{\"184\":1}}],[\"之后每次扩容为1\",{\"1\":{\"441\":1}}],[\"之后的数字表示当前模块依赖的块1序列\",{\"1\":{\"718\":1}}],[\"之后的数重置为升序\",{\"1\":{\"628\":1}}],[\"之后的then异步阶段传入默认线程池forkjoinpool\",{\"1\":{\"247\":1}}],[\"之后的事务就不会执行\",{\"1\":{\"202\":1}}],[\"之后应用\",{\"1\":{\"184\":1}}],[\"之后该线程直接进入临界区执行\",{\"1\":{\"139\":1}}],[\"之间可能不存在一条连通彼此的路径\",{\"1\":{\"716\":1}}],[\"之间共享缓存\",{\"1\":{\"167\":1}}],[\"之间的无向边\",{\"1\":{\"716\":1}}],[\"之间的唯一编号\",{\"1\":{\"716\":1}}],[\"之间的缓存\",{\"1\":{\"167\":1}}],[\"之间的耦合关系\",{\"1\":{\"116\":1}}],[\"之间\",{\"1\":{\"130\":1}}],[\"偏向锁\",{\"1\":{\"139\":1}}],[\"空行之后是内容的实体\",{\"1\":{\"760\":1}}],[\"空字符表示整个集群\",{\"1\":{\"605\":1}}],[\"空心三角形\",{\"1\":{\"376\":1}}],[\"空间占用方面\",{\"0\":{\"150\":1}}],[\"空闲线程会被销毁\",{\"1\":{\"135\":1}}],[\"空闲线程在被回收之前等待新任务的最长时间\",{\"1\":{\"135\":1}}],[\"空格分隔\",{\"1\":{\"89\":1}}],[\"静默地丢弃无法处理的任务\",{\"1\":{\"134\":1}}],[\"静态的同步方法的锁为当前类本身\",{\"1\":{\"471\":1}}],[\"静态成员也不能使用泛型\",{\"1\":{\"458\":1}}],[\"静态方法互斥锁在类对象\",{\"1\":{\"471\":1}}],[\"静态方法中不能使用类的泛型\",{\"1\":{\"457\":1}}],[\"静态方法只能访问静态成员\",{\"1\":{\"411\":1}}],[\"静态代理的缺点\",{\"1\":{\"419\":1}}],[\"静态代理\",{\"1\":{\"419\":1,\"492\":2}}],[\"静态代码块被执行\",{\"1\":{\"415\":1}}],[\"静态代码块只能调用静态成员\",{\"1\":{\"413\":1}}],[\"静态代码块\",{\"1\":{\"413\":2}}],[\"静态内部类\",{\"1\":{\"418\":2}}],[\"静态域存储于定义类型的class对象中\",{\"1\":{\"411\":1}}],[\"静态导入\",{\"1\":{\"396\":1}}],[\"静态资源\",{\"1\":{\"323\":1}}],[\"静态资源处理\",{\"1\":{\"78\":1}}],[\"静态工厂\",{\"1\":{\"130\":1}}],[\"静态初始化代码块\",{\"1\":{\"53\":1}}],[\"拒绝新任务的提交\",{\"1\":{\"134\":1}}],[\"拒绝策略怎么搞\",{\"0\":{\"137\":1}}],[\"拒绝策略\",{\"1\":{\"135\":1}}],[\"拒绝策略是在线程池无法接受新任务时采取的一种策略\",{\"1\":{\"134\":1}}],[\"拒绝策略有什么\",{\"0\":{\"134\":1}}],[\"怎么计算前缀表\",{\"1\":{\"653\":1}}],[\"怎么走\",{\"1\":{\"334\":1}}],[\"怎么解决\",{\"0\":{\"197\":1,\"198\":1}}],[\"怎么设计数据库索引\",{\"0\":{\"174\":1}}],[\"怎么设置线程池的大小\",{\"0\":{\"134\":1}}],[\"怎么使事务生效\",{\"1\":{\"166\":1}}],[\"怎么动态修改线程池的大小\",{\"1\":{\"134\":1}}],[\"怎么处理exception\",{\"0\":{\"126\":1},\"1\":{\"126\":1}}],[\"区域包围\",{\"1\":{\"708\":1}}],[\"区域敏感策略\",{\"1\":{\"598\":2}}],[\"区间操作将在这个数组上进⾏\",{\"1\":{\"677\":1,\"678\":1}}],[\"区间化操作\",{\"1\":{\"677\":1}}],[\"区间的起点\",{\"1\":{\"643\":1}}],[\"区间的整数\",{\"1\":{\"114\":1}}],[\"区分大小写\",{\"1\":{\"429\":1}}],[\"区分名字相同的类\",{\"1\":{\"396\":1}}],[\"区分get请求和post请求\",{\"0\":{\"332\":1}}],[\"区别是\",{\"1\":{\"557\":1}}],[\"区别点\",{\"1\":{\"400\":1}}],[\"区别\",{\"0\":{\"133\":1,\"213\":1},\"1\":{\"244\":1}}],[\"启动nacos集群\",{\"1\":{\"605\":1}}],[\"启动\",{\"1\":{\"132\":1}}],[\"启动器\",{\"1\":{\"81\":1}}],[\"启动器不能以spring\",{\"1\":{\"81\":1}}],[\"～\",{\"1\":{\"130\":1}}],[\"函数\",{\"1\":{\"651\":1,\"720\":1}}],[\"函数式接口\",{\"0\":{\"251\":1,\"490\":1}}],[\"函数式接口的定义是\",{\"1\":{\"129\":1}}],[\"函数式编程\",{\"0\":{\"250\":1}}],[\"函数的区别是\",{\"1\":{\"7\":1}}],[\"形式上\",{\"1\":{\"716\":1}}],[\"形成的序列称为\",{\"1\":{\"694\":1}}],[\"形成数据传输通道\",{\"1\":{\"482\":1}}],[\"形参可以为子类类型\",{\"1\":{\"405\":1}}],[\"形参列表\",{\"1\":{\"389\":1,\"401\":1}}],[\"形参列表中只有一个参数\",{\"1\":{\"129\":1}}],[\"形如其名地\",{\"1\":{\"3\":1}}],[\"右儿子right是第right\",{\"1\":{\"730\":1}}],[\"右\",{\"1\":{\"708\":1}}],[\"右四个相邻结点\",{\"1\":{\"704\":1}}],[\"右括号剩余\",{\"1\":{\"690\":1}}],[\"右孩子\",{\"1\":{\"665\":1}}],[\"右指针\",{\"1\":{\"649\":1}}],[\"右到左\",{\"1\":{\"632\":1}}],[\"右侧是容器端口\",{\"1\":{\"614\":1}}],[\"右边最高的柱子\",{\"1\":{\"624\":1}}],[\"右边是运行类型\",{\"1\":{\"402\":1}}],[\"右边可以是变量\",{\"1\":{\"365\":1}}],[\"右边就是对抽象方法的处理\",{\"1\":{\"129\":1}}],[\"右值对象中的指针即被\",{\"1\":{\"3\":1}}],[\"要根据不同题的逻辑来对数组进行初始化\",{\"1\":{\"700\":1}}],[\"要减一\",{\"1\":{\"676\":1}}],[\"要在文本串\",{\"1\":{\"653\":1}}],[\"要在类名后面指定类型参数\",{\"1\":{\"456\":1}}],[\"要进入的容器名称\",{\"1\":{\"614\":1}}],[\"要么都失败\",{\"1\":{\"580\":1}}],[\"要么这些操作都成功\",{\"1\":{\"580\":1}}],[\"要么全部失败回滚\",{\"1\":{\"170\":1}}],[\"要生成的表\",{\"1\":{\"540\":1}}],[\"要注意序列化文件的保存格式\",{\"1\":{\"478\":1}}],[\"要使用treeset\",{\"1\":{\"447\":1}}],[\"要考getinstance\",{\"1\":{\"436\":1}}],[\"要用equals\",{\"1\":{\"429\":1}}],[\"要访问父类成员必须用super\",{\"1\":{\"400\":1}}],[\"要通过公共的方法去访问\",{\"1\":{\"399\":1}}],[\"要保证原子性\",{\"1\":{\"128\":1}}],[\"要求用隧道协议链接代理\",{\"1\":{\"763\":1}}],[\"要求时间复杂度为o\",{\"1\":{\"693\":1}}],[\"要求也按\",{\"1\":{\"629\":1}}],[\"要求多个线程的锁对象为同一个即可\",{\"1\":{\"471\":1}}],[\"要求t是实现了comparable接口的类\",{\"1\":{\"461\":1}}],[\"要求必须排好序\",{\"1\":{\"433\":1}}],[\"要求子类异常写在前面\",{\"1\":{\"424\":1}}],[\"要求父类引用必须指向当前子类类型\",{\"1\":{\"402\":1}}],[\"要求\",{\"1\":{\"339\":1,\"596\":1}}],[\"要求开发者针对抽象进行设计与编程\",{\"1\":{\"113\":1}}],[\"要求将第二行开始的数据存入数组\",{\"1\":{\"55\":1}}],[\"从中断处继续下载\",{\"1\":{\"770\":1}}],[\"从集合中移除该项\",{\"1\":{\"721\":1}}],[\"从一个点向四周遍历\",{\"1\":{\"704\":1}}],[\"从第一层开始遍历\",{\"1\":{\"666\":1,\"669\":1}}],[\"从第二次开始1\",{\"1\":{\"442\":1}}],[\"从左上角到右下角一共有\",{\"1\":{\"696\":1}}],[\"从左往右添加括号\",{\"1\":{\"690\":1}}],[\"从左到右访问所有节点\",{\"1\":{\"666\":1}}],[\"从左向右计算\",{\"1\":{\"624\":1}}],[\"从队列首部移除元素\",{\"1\":{\"655\":1}}],[\"从队列中接收和处理消息\",{\"1\":{\"213\":1}}],[\"从队列中删除已经确定的消息\",{\"1\":{\"210\":1}}],[\"从0开始\",{\"1\":{\"651\":1}}],[\"从字符串开头算起\",{\"1\":{\"643\":1}}],[\"从相遇节点\",{\"1\":{\"640\":1}}],[\"从头结点出发一个指针\",{\"1\":{\"640\":1}}],[\"从头结点出发\",{\"1\":{\"640\":1}}],[\"从头到尾遍历数组\",{\"1\":{\"623\":1}}],[\"从后往前找第一个升序的数对\",{\"1\":{\"628\":1}}],[\"从后向前\",{\"1\":{\"628\":1}}],[\"从右向左计算\",{\"1\":{\"624\":1}}],[\"从低到高\",{\"1\":{\"616\":1}}],[\"从服务提供者的列表中随机选择一个服务实例\",{\"1\":{\"598\":1}}],[\"从输入流读取最多readbuff\",{\"1\":{\"477\":1}}],[\"从输入流读取一个字节的数据\",{\"1\":{\"477\":1}}],[\"从java设计来看\",{\"1\":{\"466\":1}}],[\"从现在开始将介绍以下两种最常见的方式\",{\"1\":{\"419\":1}}],[\"从threadlocalmap中取出值\",{\"1\":{\"307\":1}}],[\"从阻塞机制变成了非阻塞机制\",{\"1\":{\"299\":1}}],[\"从\",{\"1\":{\"209\":1,\"689\":1,\"696\":1,\"701\":1}}],[\"从redis\",{\"1\":{\"204\":1}}],[\"从数据集\",{\"1\":{\"192\":1}}],[\"从数据集中挑选使用频率最低的数据淘汰\",{\"1\":{\"192\":1}}],[\"从数据集中挑选最近最少使用的数据淘汰\",{\"1\":{\"192\":1}}],[\"从已设置过期时间的数据集挑选使用频率最低的数据淘汰\",{\"1\":{\"192\":1}}],[\"从已设置过期时间的数据集中任意选择数据淘汰\",{\"1\":{\"192\":1}}],[\"从已设置过期时间的数据集中挑选将要过期的数据淘汰\",{\"1\":{\"192\":1}}],[\"从已设置过期时间的数据集中挑选最近最少使用的数据淘汰\",{\"1\":{\"192\":1}}],[\"从而实现对请求的过滤和改造\",{\"1\":{\"607\":1}}],[\"从而使得业务逻辑各部分之间的耦合度降低\",{\"1\":{\"567\":1}}],[\"从而出现重复订单号\",{\"1\":{\"216\":1}}],[\"从而避免数据丢失\",{\"1\":{\"213\":1}}],[\"从而导致某些元素的存在被错误地判断为存在\",{\"1\":{\"194\":2}}],[\"从而导致部分更新的丢失\",{\"1\":{\"171\":1}}],[\"从而提高安全性\",{\"1\":{\"492\":1}}],[\"从而提高吞吐量\",{\"1\":{\"214\":1}}],[\"从而提高查询效率\",{\"1\":{\"175\":1}}],[\"从而提供了一致性的读取\",{\"1\":{\"178\":1}}],[\"从而大大减少了扫描的数据量\",{\"1\":{\"176\":1}}],[\"从而影响查询性能\",{\"1\":{\"173\":1}}],[\"从而确保线程间操作的正确顺序\",{\"1\":{\"128\":1}}],[\"从而减小了并发操作的粒度\",{\"1\":{\"125\":1}}],[\"从早上至下午\",{\"1\":{\"108\":1}}],[\"散列表\",{\"1\":{\"124\":1}}],[\"链路层用来处理连接网络的硬件部分\",{\"1\":{\"749\":1}}],[\"链式\",{\"1\":{\"252\":1}}],[\"链式编程原理\",{\"1\":{\"252\":1}}],[\"链式编程\",{\"0\":{\"252\":1}}],[\"链表初始化并放入stack中\",{\"1\":{\"729\":1}}],[\"链表输入\",{\"0\":{\"729\":1}}],[\"链表有顺序之分\",{\"1\":{\"720\":1}}],[\"链表相交\",{\"0\":{\"639\":1},\"1\":{\"639\":2}}],[\"链表操作注意顺序\",{\"1\":{\"637\":1}}],[\"链表数组\",{\"1\":{\"451\":1}}],[\"链表长度在大于8以后再出现hash碰撞的可能性几乎为0\",{\"1\":{\"124\":1}}],[\"链表的查找时间复杂度是o\",{\"1\":{\"124\":1}}],[\"链表\",{\"0\":{\"633\":1},\"1\":{\"124\":1}}],[\"链接到在条件上等待的下一个节点\",{\"1\":{\"312\":1}}],[\"链接\",{\"1\":{\"5\":1,\"10\":1,\"18\":1,\"730\":1}}],[\"扩大窗口\",{\"1\":{\"648\":1}}],[\"扩容倍数\",{\"1\":{\"442\":1}}],[\"扩容时\",{\"1\":{\"124\":1}}],[\"扩展起来不灵活\",{\"1\":{\"113\":1}}],[\"扩展可变部分\",{\"1\":{\"104\":1}}],[\"扩展性高\",{\"1\":{\"101\":1}}],[\"扩展\",{\"0\":{\"15\":1,\"16\":1},\"1\":{\"16\":1}}],[\"遍历所有剪法\",{\"1\":{\"737\":1}}],[\"遍历所有的节点下的路径\",{\"1\":{\"716\":1}}],[\"遍历所有情况\",{\"1\":{\"625\":1}}],[\"遍历到没有依赖的模块\",{\"1\":{\"718\":1}}],[\"遍历到没有要求的课程\",{\"1\":{\"717\":1}}],[\"遍历到底结束\",{\"1\":{\"715\":1}}],[\"遍历到陆地\",{\"1\":{\"707\":1}}],[\"遍历完一层节点\",{\"1\":{\"712\":1}}],[\"遍历完后need中存储需要的右括号数量\",{\"1\":{\"660\":2}}],[\"遍历当前队列中的一层节点\",{\"1\":{\"712\":1}}],[\"遍历过程中当判断到叶子节点时\",{\"1\":{\"712\":1}}],[\"遍历过的陆地直接淹没\",{\"1\":{\"706\":1}}],[\"遍历过的区域\",{\"1\":{\"707\":1,\"708\":1,\"709\":2}}],[\"遍历过的区域打上标记\",{\"1\":{\"705\":1,\"734\":1}}],[\"遍历过的区域可以打上标记\",{\"1\":{\"704\":1}}],[\"遍历搜索相邻的ｏ\",{\"1\":{\"709\":1}}],[\"遍历图\",{\"1\":{\"709\":1}}],[\"遍历整张图\",{\"1\":{\"706\":2}}],[\"遍历一颗回溯树\",{\"1\":{\"686\":1}}],[\"遍历一遍过程中记录后面是否有满足与前面和=target的数\",{\"1\":{\"626\":1}}],[\"遍历指针指向根节点\",{\"1\":{\"666\":1,\"669\":1}}],[\"遍历字符串数组\",{\"1\":{\"644\":1}}],[\"遍历cura\",{\"1\":{\"639\":1}}],[\"遍历col\",{\"1\":{\"439\":1}}],[\"遍历原链表的指针\",{\"1\":{\"634\":1,\"636\":1}}],[\"遍历的过程还需要一个指针来遍历原链表\",{\"1\":{\"634\":1}}],[\"遍历方法\",{\"1\":{\"448\":1}}],[\"遍历方式\",{\"1\":{\"444\":1}}],[\"遍历\",{\"1\":{\"443\":1,\"454\":1,\"667\":1,\"668\":1,\"697\":1,\"698\":1}}],[\"遍历接口元素方式\",{\"1\":{\"439\":1}}],[\"遍历复制\",{\"1\":{\"381\":1}}],[\"遍历键值对\",{\"1\":{\"124\":1}}],[\"遍历二叉树数组\",{\"1\":{\"90\":1}}],[\"泛型不具有继承性\",{\"1\":{\"460\":1}}],[\"泛型语法\",{\"0\":{\"456\":1}}],[\"泛型介绍\",{\"0\":{\"455\":1}}],[\"泛型好处\",{\"1\":{\"454\":1}}],[\"泛型\",{\"0\":{\"453\":1}}],[\"泛型方法\",{\"1\":{\"123\":1,\"459\":1}}],[\"泛型接口的类型\",{\"1\":{\"458\":1}}],[\"泛型接口\",{\"1\":{\"123\":1}}],[\"泛型类的静态成员和方法无效\",{\"1\":{\"461\":1}}],[\"泛型类的类型\",{\"1\":{\"457\":1}}],[\"泛型类中的泛型方法\",{\"1\":{\"459\":1}}],[\"泛型类\",{\"1\":{\"123\":1}}],[\"泛型可以避免繁琐的类型转换操作\",{\"1\":{\"123\":1}}],[\"泛型的继承和通配符\",{\"0\":{\"460\":1}}],[\"泛型的使用细节\",{\"1\":{\"456\":1}}],[\"泛型的使用方式\",{\"1\":{\"123\":1}}],[\"泛型的使用方式有哪几种\",{\"0\":{\"123\":1}}],[\"泛型的实例化\",{\"1\":{\"456\":1}}],[\"泛型的声明\",{\"1\":{\"456\":1}}],[\"泛型的理解和好处\",{\"0\":{\"454\":1}}],[\"泛型的作用\",{\"0\":{\"123\":1},\"1\":{\"123\":1}}],[\"参考统计封闭岛屿数目的方法\",{\"1\":{\"709\":1}}],[\"参考200题\",{\"1\":{\"708\":1}}],[\"参考代码随想录学习\",{\"1\":{\"618\":1}}],[\"参考上面的collection遍历\",{\"1\":{\"440\":1}}],[\"参考1050\",{\"1\":{\"7\":1}}],[\"参数为行列索引\",{\"1\":{\"704\":1}}],[\"参数可以持续查看日志\",{\"1\":{\"614\":1}}],[\"参数\",{\"1\":{\"542\":1,\"607\":1,\"682\":1}}],[\"参数要和父类方法完全相同\",{\"1\":{\"401\":1}}],[\"参数列表\",{\"1\":{\"393\":1,\"400\":1,\"459\":1,\"571\":1}}],[\"参数化类型\",{\"1\":{\"123\":1}}],[\"什么是前缀表\",{\"1\":{\"653\":1}}],[\"什么是dockercompose\",{\"1\":{\"617\":1}}],[\"什么是docker\",{\"0\":{\"609\":1}}],[\"什么是\",{\"0\":{\"557\":1},\"1\":{\"567\":1}}],[\"什么是单例模式\",{\"1\":{\"414\":1}}],[\"什么是类变量\",{\"1\":{\"411\":1}}],[\"什么是filter\",{\"0\":{\"338\":1}}],[\"什么是aqs\",{\"1\":{\"310\":1}}],[\"什么是中断机制\",{\"0\":{\"267\":1}}],[\"什么是缓存雪崩\",{\"0\":{\"198\":1}}],[\"什么是缓存穿透\",{\"0\":{\"197\":1}}],[\"什么是非聚簇索引\",{\"0\":{\"179\":1}}],[\"什么是聚簇索引\",{\"0\":{\"179\":1}}],[\"什么是cgi\",{\"0\":{\"159\":1}}],[\"什么是动态代理\",{\"0\":{\"159\":1}}],[\"什么是泛型\",{\"0\":{\"123\":1},\"1\":{\"123\":1}}],[\"什么时候结束\",{\"1\":{\"718\":1}}],[\"什么时候被回收\",{\"1\":{\"406\":1}}],[\"什么时候用非公平锁\",{\"1\":{\"262\":1}}],[\"什么时候用公平锁\",{\"1\":{\"262\":1}}],[\"什么时候用到无界对列\",{\"0\":{\"137\":1}}],[\"什么时候会出现oom问题\",{\"1\":{\"146\":1}}],[\"什么叫spring的内部bean\",{\"0\":{\"67\":1}}],[\"插⼊删除快\",{\"1\":{\"720\":1}}],[\"插队若成功\",{\"1\":{\"468\":1}}],[\"插\",{\"1\":{\"430\":1}}],[\"插入一个和系统相关的换行\",{\"1\":{\"478\":1}}],[\"插入一个数据\",{\"1\":{\"193\":1}}],[\"插入和取出顺序一致\",{\"1\":{\"451\":1}}],[\"插入和删除的时间复杂度又不可能是o\",{\"1\":{\"721\":1}}],[\"插入和删除元素可能需要进行数组的扩容或移动操作\",{\"1\":{\"122\":1}}],[\"插入和删除操作\",{\"1\":{\"122\":1}}],[\"插件的依赖\",{\"1\":{\"540\":1}}],[\"插件版本\",{\"1\":{\"82\":1}}],[\"插件来实现\",{\"1\":{\"15\":1}}],[\"紧凑字符串的引入主要是为了减少string对象的内存占用\",{\"1\":{\"121\":1}}],[\"紧凑字符串\",{\"1\":{\"121\":1}}],[\"底层实现\",{\"1\":{\"606\":1}}],[\"底层原理\",{\"0\":{\"555\":1,\"568\":1}}],[\"底层使用的是\",{\"1\":{\"479\":1}}],[\"底层使用代理\",{\"1\":{\"72\":1,\"568\":1}}],[\"底层会去关闭节点流\",{\"1\":{\"478\":1}}],[\"底层hashmap\",{\"1\":{\"451\":1}}],[\"底层双向链表\",{\"1\":{\"443\":1}}],[\"底层结构\",{\"1\":{\"442\":1}}],[\"底层为一条cpu原子指令\",{\"1\":{\"295\":1}}],[\"底层是一个linkedhashmap\",{\"1\":{\"446\":1}}],[\"底层是jvm中分配了一个线程\",{\"1\":{\"220\":1}}],[\"底层是默认长度为16的字符数组\",{\"1\":{\"120\":1}}],[\"修完课程\",{\"1\":{\"717\":1}}],[\"修改原key值\",{\"1\":{\"720\":1}}],[\"修改index\",{\"1\":{\"614\":1}}],[\"修改html文件内容\",{\"1\":{\"614\":1}}],[\"修改conf\",{\"1\":{\"605\":1}}],[\"修改配置文件cluster\",{\"1\":{\"605\":1}}],[\"修改时间\",{\"1\":{\"605\":7}}],[\"修改访问的url路径\",{\"1\":{\"597\":1}}],[\"修改orderservice的代码\",{\"1\":{\"597\":1}}],[\"修改num\",{\"1\":{\"491\":1}}],[\"修改了\",{\"1\":{\"479\":1,\"577\":1,\"583\":3}}],[\"修改节点\",{\"1\":{\"443\":1}}],[\"修改方法的时候\",{\"1\":{\"419\":1}}],[\"修改完成\",{\"1\":{\"408\":1}}],[\"修改客户\",{\"1\":{\"408\":1}}],[\"修改房源\",{\"1\":{\"408\":1}}],[\"修改房屋信息\",{\"1\":{\"408\":1}}],[\"修改\",{\"1\":{\"408\":1,\"480\":1,\"496\":1,\"577\":1,\"583\":2,\"628\":1}}],[\"修改类\",{\"1\":{\"95\":1}}],[\"修饰引用数据类型\",{\"1\":{\"492\":1}}],[\"修饰基本数据类型\",{\"1\":{\"492\":1}}],[\"修饰符后没有<>\",{\"1\":{\"459\":1}}],[\"修饰符可选\",{\"1\":{\"413\":1}}],[\"修饰符\",{\"1\":{\"401\":1,\"413\":1,\"459\":1}}],[\"修饰一个类\",{\"1\":{\"259\":1}}],[\"修饰一个静态的方法\",{\"1\":{\"259\":1}}],[\"修饰一个方法\",{\"1\":{\"259\":1,\"422\":1}}],[\"修饰一个代码块\",{\"1\":{\"259\":1}}],[\"修饰参数\",{\"1\":{\"127\":1}}],[\"修饰类\",{\"1\":{\"127\":1,\"492\":1}}],[\"修饰方法\",{\"1\":{\"127\":1,\"492\":1}}],[\"修饰变量\",{\"1\":{\"127\":1}}],[\"修饰的\",{\"1\":{\"120\":1}}],[\"效率低\",{\"1\":{\"482\":1}}],[\"效率不高\",{\"1\":{\"442\":1}}],[\"效率高\",{\"1\":{\"442\":1,\"492\":1}}],[\"效率相对较低\",{\"1\":{\"176\":1}}],[\"效率更高\",{\"1\":{\"156\":1,\"364\":1,\"443\":1}}],[\"效率较低\",{\"1\":{\"139\":1}}],[\"效率远远高于通过\",{\"1\":{\"130\":1}}],[\"效率比stringbuffer\",{\"1\":{\"120\":1}}],[\"效率就会比较低\",{\"1\":{\"93\":1}}],[\"面试题02\",{\"1\":{\"639\":2}}],[\"面试题\",{\"0\":{\"268\":1,\"492\":1},\"1\":{\"260\":1,\"262\":1,\"428\":1}}],[\"面对高并发情况\",{\"1\":{\"207\":1}}],[\"面经整理\",{\"0\":{\"118\":1}}],[\"面向服务\",{\"1\":{\"595\":1}}],[\"面向切面\",{\"0\":{\"566\":1},\"1\":{\"548\":1}}],[\"面向切面编程\",{\"1\":{\"158\":2,\"168\":1,\"567\":1}}],[\"面向切面编程的依赖库\",{\"1\":{\"81\":1}}],[\"面向切面编程可以将应用业务逻辑和系统服务分离\",{\"1\":{\"61\":1}}],[\"面向对象1\",{\"1\":{\"557\":1}}],[\"面向对象2\",{\"1\":{\"557\":1}}],[\"面向对象特征\",{\"0\":{\"398\":1,\"399\":1,\"402\":1}}],[\"面向对象编程\",{\"0\":{\"383\":1,\"394\":1,\"410\":1}}],[\"面向对象当然也有缺点\",{\"1\":{\"93\":1}}],[\"面向对象\",{\"0\":{\"52\":1},\"1\":{\"346\":1,\"557\":1}}],[\"浅拷贝实现\",{\"1\":{\"116\":1}}],[\"融为浑然一体\",{\"1\":{\"116\":1}}],[\"产生了不同组件依赖的兼容性问题\",{\"1\":{\"609\":1}}],[\"产生异常\",{\"1\":{\"461\":1}}],[\"产生一个对象需要非常繁琐的数据准备或访问权限\",{\"1\":{\"116\":1}}],[\"产品必须有共同点\",{\"1\":{\"107\":1}}],[\"性能好的机器权重设置大一点\",{\"1\":{\"599\":1}}],[\"性能也不错\",{\"1\":{\"492\":1}}],[\"性能\",{\"1\":{\"142\":1}}],[\"性能和安全要求的场景\",{\"1\":{\"116\":1}}],[\"性能提高\",{\"1\":{\"116\":1}}],[\"必须在\",{\"1\":{\"779\":1}}],[\"必须以\",{\"1\":{\"720\":2}}],[\"必须\",{\"1\":{\"628\":1,\"717\":1}}],[\"必须唯一\",{\"1\":{\"607\":1}}],[\"必须要关闭\",{\"1\":{\"477\":1}}],[\"必须赋初值\",{\"1\":{\"415\":1}}],[\"必须放在首行\",{\"1\":{\"400\":1}}],[\"必须放在构造器首行\",{\"1\":{\"400\":1}}],[\"必须手动释放锁\",{\"1\":{\"261\":1}}],[\"必须设置一个超时时间\",{\"1\":{\"205\":1}}],[\"必须使用紧凑数组\",{\"1\":{\"721\":1}}],[\"必须使用可以在运行时进行数据再平衡的一套系统\",{\"1\":{\"190\":1}}],[\"必须使用固定的\",{\"1\":{\"190\":1}}],[\"必须实现接口的抽象方法\",{\"1\":{\"417\":1}}],[\"必须实现\",{\"1\":{\"116\":1}}],[\"必须加上\",{\"1\":{\"55\":1}}],[\"特点\",{\"0\":{\"549\":1},\"1\":{\"402\":1}}],[\"特殊功能\",{\"0\":{\"516\":1}}],[\"特殊\",{\"1\":{\"382\":1,\"400\":1}}],[\"特殊的\",{\"1\":{\"363\":1}}],[\"特性\",{\"0\":{\"495\":1},\"1\":{\"183\":1}}],[\"特别地\",{\"1\":{\"312\":1}}],[\"特别是与内存相关的部分\",{\"1\":{\"146\":1}}],[\"特别当一个类引用不支持串行化的间接对象\",{\"1\":{\"116\":1}}],[\"特色功能\",{\"0\":{\"61\":1}}],[\"配额\",{\"1\":{\"605\":2}}],[\"配合usegeneratedkeys使用\",{\"1\":{\"501\":1}}],[\"配备克隆方法需要对类的功能进行通盘考虑\",{\"1\":{\"116\":1}}],[\"配置环境变量\",{\"1\":{\"616\":2}}],[\"配置基础镜像\",{\"1\":{\"616\":2}}],[\"配置基本功能\",{\"0\":{\"552\":1}}],[\"配置网关\",{\"1\":{\"607\":1}}],[\"配置如下\",{\"1\":{\"605\":1}}],[\"配置nacos\",{\"1\":{\"605\":1}}],[\"配置namespace\",{\"1\":{\"599\":1}}],[\"配置共享\",{\"0\":{\"604\":1}}],[\"配置热更新\",{\"0\":{\"603\":1}}],[\"配置管理服务会通知对应的服务\",{\"1\":{\"602\":1}}],[\"配置管理中心\",{\"1\":{\"592\":1}}],[\"配置更改热更新\",{\"1\":{\"602\":1}}],[\"配置好端口号并运行\",{\"1\":{\"599\":1}}],[\"配置中心\",{\"1\":{\"593\":1,\"595\":1}}],[\"配置简单的\",{\"1\":{\"586\":1}}],[\"配置类\",{\"1\":{\"584\":1,\"603\":1}}],[\"配置切面\",{\"1\":{\"583\":1}}],[\"配置切入点\",{\"1\":{\"583\":1}}],[\"配置切入点和切面\",{\"1\":{\"583\":1}}],[\"配置事务参数\",{\"1\":{\"583\":1}}],[\"配置通知\",{\"1\":{\"583\":1}}],[\"配置不同类型通知\",{\"1\":{\"572\":1}}],[\"配置连接池\",{\"1\":{\"562\":2,\"575\":1,\"583\":1,\"606\":1}}],[\"配置连接数据库的环境\",{\"1\":{\"506\":1}}],[\"配置德鲁伊连接池\",{\"1\":{\"562\":1}}],[\"配置后置处理器\",{\"1\":{\"560\":1}}],[\"配置时就会自动创建单实例对象\",{\"1\":{\"559\":1}}],[\"配置方式\",{\"1\":{\"557\":1}}],[\"配置方式不同\",{\"1\":{\"62\":1}}],[\"配置阿里云仓库\",{\"1\":{\"498\":1,\"540\":1}}],[\"配置文件中配置连接池\",{\"1\":{\"575\":1}}],[\"配置文件中开启生成代理对象\",{\"1\":{\"572\":1}}],[\"配置文件中\",{\"1\":{\"572\":1}}],[\"配置文件中引入名称空间\",{\"1\":{\"557\":1}}],[\"配置文件实现\",{\"1\":{\"571\":1}}],[\"配置文件时去创建对象\",{\"1\":{\"559\":1}}],[\"配置文件\",{\"0\":{\"562\":1},\"1\":{\"507\":1,\"540\":1,\"552\":1,\"565\":1}}],[\"配置文件格式\",{\"1\":{\"480\":1}}],[\"配置文件方式\",{\"1\":{\"76\":1,\"598\":1}}],[\"配置web\",{\"1\":{\"339\":1}}],[\"配置内容裁决的一些选项\",{\"1\":{\"78\":1}}],[\"配置\",{\"0\":{\"14\":1,\"498\":1,\"501\":1},\"1\":{\"63\":2,\"80\":1,\"522\":1,\"540\":1,\"552\":1,\"555\":2,\"557\":1,\"563\":1,\"575\":1,\"583\":1,\"586\":1,\"616\":2}}],[\"逃避构造函数的约束\",{\"1\":{\"116\":1}}],[\"易变类\",{\"1\":{\"116\":2}}],[\"易扩展\",{\"1\":{\"107\":1}}],[\"建表\",{\"1\":{\"581\":1}}],[\"建议使用runnable\",{\"1\":{\"466\":1}}],[\"建议优先使用\",{\"1\":{\"431\":1}}],[\"建议是rdb和aof都开启\",{\"1\":{\"189\":1}}],[\"建立一个\",{\"1\":{\"552\":1}}],[\"建立连接connection\",{\"1\":{\"210\":1}}],[\"建立连接阶段\",{\"1\":{\"203\":1}}],[\"建立\",{\"1\":{\"203\":1}}],[\"建立索引会更有优势\",{\"1\":{\"174\":1}}],[\"建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些\",{\"1\":{\"116\":1}}],[\"建造者独立\",{\"1\":{\"107\":1}}],[\"建造者\",{\"1\":{\"107\":1}}],[\"建造者模式更加关注与零件装配的顺序\",{\"1\":{\"107\":1}}],[\"建造者模式\",{\"0\":{\"106\":1},\"1\":{\"107\":1}}],[\"多用途因特网邮件扩展\",{\"1\":{\"769\":1}}],[\"多部分对象集合包含\",{\"1\":{\"769\":1}}],[\"多部分对象集合\",{\"0\":{\"769\":1}}],[\"多种uri请求方式\",{\"1\":{\"762\":1}}],[\"多了一步大数取模\",{\"1\":{\"739\":1}}],[\"多行输入\",{\"0\":{\"723\":1}}],[\"多行注释\",{\"1\":{\"354\":1}}],[\"多租户改造\",{\"1\":{\"605\":1}}],[\"多环境配置共享\",{\"1\":{\"604\":1}}],[\"多事务操作之间不会产生影响\",{\"1\":{\"582\":1}}],[\"多事务操作不会互相影响\",{\"1\":{\"580\":1}}],[\"多事务方法直接调用\",{\"1\":{\"582\":1}}],[\"多实例对象\",{\"1\":{\"559\":1}}],[\"多对一映射处理\",{\"0\":{\"523\":1}}],[\"多字符\",{\"1\":{\"477\":1}}],[\"多字节读取\",{\"1\":{\"477\":1}}],[\"多字段查询\",{\"0\":{\"7\":1}}],[\"多数java的开发环境都已经集成了junit作为单元测试的工具\",{\"1\":{\"462\":1}}],[\"多态参数\",{\"0\":{\"405\":1}}],[\"多态数组\",{\"0\":{\"404\":1},\"1\":{\"404\":1}}],[\"多态的应用\",{\"0\":{\"404\":1,\"405\":1}}],[\"多态的向下转型\",{\"1\":{\"402\":1}}],[\"多态的向上转型\",{\"1\":{\"402\":1}}],[\"多态的具体体现\",{\"1\":{\"402\":1}}],[\"多态是建立在封装和继承的基础上的\",{\"1\":{\"402\":1}}],[\"多态\",{\"0\":{\"402\":1}}],[\"多态分为类的多态和方法的多态\",{\"1\":{\"120\":1}}],[\"多重循环控制\",{\"0\":{\"376\":1}}],[\"多分支语法\",{\"1\":{\"371\":1}}],[\"多线程编程时\",{\"1\":{\"470\":1}}],[\"多线程执行\",{\"1\":{\"466\":1}}],[\"多线程基础\",{\"0\":{\"465\":1}}],[\"多线程环境下可能会出现问题的地方\",{\"1\":{\"292\":1}}],[\"多线程先行发生原则之happens\",{\"0\":{\"280\":1}}],[\"多线程对变量的独写过程\",{\"0\":{\"279\":1}}],[\"多线程锁\",{\"0\":{\"257\":1}}],[\"多线程操作同一个资源\",{\"1\":{\"224\":1}}],[\"多线程操作的可见性问题\",{\"1\":{\"140\":1}}],[\"多级缓存\",{\"1\":{\"198\":1}}],[\"多路复用来实现它的核心网络模型\",{\"1\":{\"187\":1}}],[\"多路复用\",{\"1\":{\"186\":1}}],[\"多版本并发控制\",{\"1\":{\"177\":1}}],[\"多个组合问题\",{\"1\":{\"686\":2}}],[\"多个线程都占用了对方的锁资源\",{\"1\":{\"471\":1}}],[\"多个线程同时执行cas操作只有一个会成功\",{\"1\":{\"295\":1}}],[\"多个线程同时进行\",{\"1\":{\"224\":2}}],[\"多个线程按照申请锁的顺序获取锁\",{\"1\":{\"262\":1}}],[\"多个线程访问同步代码块时\",{\"1\":{\"260\":1}}],[\"多个线程可以在同一个进程中并发执行\",{\"1\":{\"150\":1}}],[\"多个jvm之间无法通过常用的jvm锁来完成同步操作\",{\"1\":{\"216\":1}}],[\"多个消费者可以订阅同一队列\",{\"1\":{\"209\":1}}],[\"多个并发事务之间要相互隔离\",{\"1\":{\"170\":1}}],[\"多次显示\",{\"1\":{\"114\":1}}],[\"打家劫舍3\",{\"0\":{\"699\":1}}],[\"打家劫舍1的区别是首尾是相连的\",{\"1\":{\"698\":1}}],[\"打家劫舍2\",{\"0\":{\"698\":1}}],[\"打家劫舍\",{\"0\":{\"697\":1}}],[\"打包时\",{\"1\":{\"617\":1}}],[\"打印\",{\"1\":{\"729\":1}}],[\"打印日志越多越影响性能\",{\"1\":{\"606\":1}}],[\"打印流\",{\"0\":{\"479\":1}}],[\"打印问题\",{\"1\":{\"391\":1}}],[\"打印显示\",{\"1\":{\"382\":1}}],[\"打印杨辉三角\",{\"1\":{\"382\":1}}],[\"打开转盘锁\",{\"0\":{\"713\":1}}],[\"打开\",{\"1\":{\"114\":1}}],[\"打造的\",{\"1\":{\"93\":1}}],[\"且缓存已满\",{\"1\":{\"720\":1}}],[\"且剩余的值相同时\",{\"1\":{\"687\":1}}],[\"且元素按顺时针顺序螺旋排列的正方形矩阵\",{\"1\":{\"632\":1}}],[\"且table大小大于64就会进化成红黑树\",{\"1\":{\"445\":1}}],[\"且这是一条cpu原子指令\",{\"1\":{\"296\":1}}],[\"且这两个维度都需要进行扩展\",{\"1\":{\"113\":1}}],[\"且更可靠\",{\"1\":{\"295\":1}}],[\"且可以承受数分钟的数据丢失\",{\"1\":{\"189\":1}}],[\"且阻塞队列已满\",{\"1\":{\"135\":1}}],[\"且数组长度大于64时将链表转换为红黑树\",{\"1\":{\"124\":1}}],[\"且所有方法都是抽象方法\",{\"1\":{\"120\":1}}],[\"且在所指对象内存已经无效时\",{\"1\":{\"3\":1}}],[\"避免走回头路\",{\"1\":{\"711\":1}}],[\"避免冗余计算\",{\"1\":{\"689\":1,\"701\":1}}],[\"避免计算雨水时的重复计算\",{\"1\":{\"624\":1}}],[\"避免重复工作\",{\"1\":{\"616\":1}}],[\"避免重复业务开发\",{\"1\":{\"595\":1}}],[\"避免互相干扰\",{\"1\":{\"609\":1}}],[\"避免出现级联问题\",{\"1\":{\"595\":1}}],[\"避免了方法中使用了comparable接口方法\",{\"1\":{\"461\":1}}],[\"避免了不必要的上下文切换和竞争条件\",{\"1\":{\"186\":1}}],[\"避免压垮系统组件\",{\"1\":{\"207\":1}}],[\"避免创建过多冗余的索引\",{\"1\":{\"174\":1}}],[\"避免过多的索引\",{\"1\":{\"174\":1}}],[\"避免线程过度增长\",{\"1\":{\"135\":1}}],[\"避免在运行时出现类型转换错误\",{\"1\":{\"123\":1}}],[\"避免在两个层次之间建立静态的继承联系\",{\"1\":{\"113\":1}}],[\"避免对资源的多重占用\",{\"1\":{\"98\":1}}],[\"优化空间\",{\"1\":{\"697\":1}}],[\"优化dp数组\",{\"1\":{\"694\":1}}],[\"优化dp\",{\"1\":{\"693\":1}}],[\"优化一维dp必须倒着更新行\",{\"1\":{\"687\":1}}],[\"优化一维dp\",{\"1\":{\"687\":2}}],[\"优化时间\",{\"1\":{\"626\":1}}],[\"优化暴力法\",{\"1\":{\"622\":1}}],[\"优化部署\",{\"1\":{\"616\":1}}],[\"优化内存使用\",{\"1\":{\"146\":1}}],[\"优先级越高\",{\"1\":{\"607\":1}}],[\"优先级从右向左\",{\"1\":{\"367\":2}}],[\"优先本地集群负载均衡规则\",{\"1\":{\"599\":1}}],[\"优先本类的n1\",{\"1\":{\"418\":1}}],[\"优秀的扩展能力\",{\"1\":{\"113\":1}}],[\"优点\",{\"1\":{\"98\":1,\"101\":1,\"104\":1,\"107\":1,\"113\":1,\"116\":1,\"492\":3}}],[\"墙上的开关\",{\"1\":{\"113\":1}}],[\"让下⼀个桶从\",{\"1\":{\"689\":1,\"701\":1}}],[\"让cura和curb在同一起点上\",{\"1\":{\"639\":1}}],[\"让cura为最长链表的头\",{\"1\":{\"639\":1}}],[\"让\",{\"1\":{\"593\":1}}],[\"让这个类作为工厂\",{\"1\":{\"558\":1}}],[\"让子线程先运行\",{\"1\":{\"468\":1}}],[\"让其他线程执行\",{\"1\":{\"468\":1}}],[\"让其子类实现工厂接口\",{\"1\":{\"101\":1}}],[\"让其子类自己决定实例化哪一个工厂类\",{\"1\":{\"101\":1}}],[\"让出cpu\",{\"1\":{\"468\":1}}],[\"让程序继续访问用户的目标资源\",{\"1\":{\"339\":1}}],[\"让开发者进行多线程编程时减少竞争条件和死锁的问题\",{\"1\":{\"222\":1}}],[\"让spring容器在运行时动态地管理和组装对象\",{\"1\":{\"158\":1}}],[\"让它们独立变化\",{\"1\":{\"113\":1}}],[\"桥接\",{\"1\":{\"113\":1}}],[\"桥接模式尤为适用\",{\"1\":{\"113\":1}}],[\"桥接模式的引入会增加系统的理解与设计难度\",{\"1\":{\"113\":1}}],[\"桥接模式\",{\"0\":{\"112\":1}}],[\"光明日报\",{\"1\":{\"111\":1}}],[\"人民日报\",{\"1\":{\"111\":1}}],[\"人与人对世界的认识不同\",{\"1\":{\"93\":1}}],[\"抽象基类\",{\"1\":{\"476\":1}}],[\"抽象方法中可以使用泛型\",{\"1\":{\"458\":1}}],[\"抽象模板\",{\"1\":{\"416\":1}}],[\"抽象和实现的分离\",{\"1\":{\"113\":1}}],[\"抽象工厂模式\",{\"0\":{\"109\":1},\"1\":{\"110\":1}}],[\"抽象类与接口的区别\",{\"1\":{\"417\":1}}],[\"抽象类可以不用\",{\"1\":{\"417\":1}}],[\"抽象类不一定包含抽象方法\",{\"1\":{\"416\":1}}],[\"抽象类使用细节\",{\"1\":{\"416\":1}}],[\"抽象类的介绍\",{\"1\":{\"416\":1}}],[\"抽象类是类的抽象\",{\"1\":{\"120\":1}}],[\"抽象类中可以有构造函数和非抽象方法\",{\"1\":{\"120\":1}}],[\"抽象类依赖实现类\",{\"1\":{\"113\":1}}],[\"抽象类\",{\"0\":{\"78\":1,\"416\":1}}],[\"晚上好\",{\"1\":{\"108\":1}}],[\"早上好\",{\"1\":{\"108\":1}}],[\"早已渗入各种流行软件的设计当中\",{\"1\":{\"93\":1}}],[\"^=\",{\"1\":{\"689\":1,\"701\":1}}],[\"^\",{\"1\":{\"108\":1,\"260\":1,\"364\":1,\"367\":1}}],[\"套餐\",{\"1\":{\"107\":1}}],[\"炸鸡翅等是不变的\",{\"1\":{\"107\":1}}],[\"薯条\",{\"1\":{\"107\":1}}],[\"去除首尾以及中间多余空格\",{\"1\":{\"645\":2}}],[\"去前后空格\",{\"1\":{\"429\":1}}],[\"去加载\",{\"1\":{\"147\":1}}],[\"去肯德基\",{\"1\":{\"107\":1}}],[\"去执行handler\",{\"1\":{\"76\":1}}],[\"便于并查集使用\",{\"1\":{\"709\":2}}],[\"便于控制细节风险\",{\"1\":{\"107\":1}}],[\"便于维护\",{\"1\":{\"104\":1}}],[\"便是设计模式\",{\"1\":{\"93\":1}}],[\"直到小于该数\",{\"1\":{\"662\":1}}],[\"直到窗口不再满足\",{\"1\":{\"630\":1}}],[\"直到窗口中的值符合要求\",{\"1\":{\"630\":1}}],[\"直到一个父类有该属性\",{\"1\":{\"399\":1}}],[\"直到队头节点将其唤醒\",{\"1\":{\"318\":1}}],[\"直到被转移时\",{\"1\":{\"312\":1}}],[\"直到成功为止\",{\"1\":{\"295\":1}}],[\"直到达到最顶层的启动类加载器\",{\"1\":{\"147\":1}}],[\"直到计数器为0\",{\"1\":{\"144\":1}}],[\"直到它被唤醒并有机会重新尝试获取锁\",{\"1\":{\"143\":1}}],[\"直到最后一次释放锁为止\",{\"1\":{\"141\":1}}],[\"直到锁被释放\",{\"1\":{\"139\":1}}],[\"直接终止后面的递归\",{\"1\":{\"718\":1}}],[\"直接套回溯算法分割等和子集模板\",{\"1\":{\"701\":1}}],[\"直接结束赋值\",{\"1\":{\"696\":1}}],[\"直接返回\",{\"1\":{\"704\":1}}],[\"直接返回0\",{\"1\":{\"696\":1}}],[\"直接返回备忘录中的值\",{\"1\":{\"687\":1}}],[\"直接返回实例\",{\"1\":{\"163\":1}}],[\"直接配置数据库信息\",{\"1\":{\"562\":1}}],[\"直接传入参数的键值对\",{\"1\":{\"512\":1}}],[\"直接跟数据源相接\",{\"1\":{\"478\":1}}],[\"直接指定泛型接口的类型\",{\"1\":{\"458\":1}}],[\"直接存入\",{\"1\":{\"445\":1}}],[\"直接进到catch块\",{\"1\":{\"424\":1}}],[\"直接输出一个对象时tostring方法会默认调用\",{\"1\":{\"406\":1}}],[\"直接访问父类中的方法\",{\"1\":{\"400\":1}}],[\"直接创建\",{\"1\":{\"387\":1}}],[\"直接在\",{\"1\":{\"346\":1}}],[\"直接设置超时时间\",{\"1\":{\"205\":1}}],[\"直接把内存中的数据保存到一个dump的文件中\",{\"1\":{\"189\":1}}],[\"直接自己构建了\",{\"1\":{\"186\":1}}],[\"直接抛出\",{\"1\":{\"134\":1}}],[\"直接丢一个实体就可以保存\",{\"1\":{\"104\":1}}],[\"直观地看来\",{\"1\":{\"3\":1}}],[\"等加密手段进行通信\",{\"1\":{\"780\":1}}],[\"等于总和\",{\"1\":{\"689\":1}}],[\"等于链表的长度\",{\"1\":{\"635\":1}}],[\"等容器中\",{\"1\":{\"588\":1}}],[\"等价\",{\"1\":{\"477\":1}}],[\"等价于在最后一个元素\",{\"1\":{\"635\":1}}],[\"等价于在\",{\"1\":{\"635\":1}}],[\"等价于在第0个元素前添加\",{\"1\":{\"635\":2}}],[\"等价于\",{\"1\":{\"365\":1,\"563\":1}}],[\"等价于以默认属性使用\",{\"1\":{\"84\":1}}],[\"等号左边是编译类型\",{\"1\":{\"402\":1}}],[\"等待连接\",{\"1\":{\"485\":2}}],[\"等待状态\",{\"1\":{\"312\":4}}],[\"等待唤醒线程的三种方法\",{\"0\":{\"271\":1}}],[\"等待\",{\"1\":{\"225\":1}}],[\"等待一定时长再开始复制\",{\"1\":{\"204\":1}}],[\"等待获取锁\",{\"1\":{\"143\":1}}],[\"等持久化方案\",{\"1\":{\"187\":1}}],[\"等\",{\"1\":{\"104\":1,\"161\":1,\"167\":1,\"168\":3,\"177\":1,\"209\":1,\"367\":2}}],[\"难\",{\"1\":{\"104\":1}}],[\"将资源副本缓存在代理服务器上\",{\"1\":{\"780\":1}}],[\"将其翻转成\",{\"1\":{\"729\":1}}],[\"将新的key添加到链表尾部\",{\"1\":{\"720\":1}}],[\"将key变为最近使用\",{\"1\":{\"720\":1}}],[\"将与cur节点相邻的节点都加入队列\",{\"1\":{\"712\":1}}],[\"将cur的相邻节点加入队列\",{\"1\":{\"711\":1}}],[\"将char\",{\"1\":{\"477\":2}}],[\"将当前队列中的所有节点向四周扩散\",{\"1\":{\"711\":1}}],[\"将当前ｏ点与其下右两个方向的ｏ点相连接\",{\"1\":{\"709\":1}}],[\"将二维坐标转化为一维坐标\",{\"1\":{\"709\":2}}],[\"将格子标记为\",{\"1\":{\"704\":1}}],[\"将第\",{\"1\":{\"689\":2,\"701\":2}}],[\"将n加入尾部\",{\"1\":{\"661\":1}}],[\"将nacos文件夹复制三份\",{\"1\":{\"605\":1}}],[\"将队列中小于n的元素全部删除\",{\"1\":{\"661\":1}}],[\"将元素都放到queue1中\",{\"1\":{\"657\":1}}],[\"将反转后单词间的空格减少到只含一个\",{\"1\":{\"645\":1}}],[\"将空格换成多个字符\",{\"1\":{\"644\":1}}],[\"将后面的\",{\"1\":{\"628\":1}}],[\"将服务集群项目上传虚拟机\",{\"1\":{\"617\":1}}],[\"将app\",{\"1\":{\"617\":1}}],[\"将宿主机端口与容器端口映射\",{\"1\":{\"614\":1}}],[\"将返回的\",{\"1\":{\"606\":1}}],[\"将配置文件进行统一管理\",{\"1\":{\"593\":1}}],[\"将查询的字段作为下一步查询语句的的\",{\"1\":{\"523\":1,\"524\":1}}],[\"将某个字段的值作为大\",{\"1\":{\"514\":1}}],[\"将properties对象的键值对储存到配置文件中\",{\"1\":{\"480\":1}}],[\"将数据\",{\"1\":{\"482\":1}}],[\"将数据显示到指定设备\",{\"1\":{\"480\":1}}],[\"将数据分散到多个\",{\"1\":{\"200\":1}}],[\"将程序运行的完整环境打包在一起\",{\"1\":{\"611\":1}}],[\"将程序数据输出到存储设备\",{\"1\":{\"476\":1}}],[\"将程序执行中发生的不正常情况称为异常\",{\"1\":{\"424\":1}}],[\"将指定list集合中的i处元素和j处元素交换\",{\"1\":{\"452\":1}}],[\"将指针指向col的第一个元素\",{\"1\":{\"439\":1}}],[\"将所有与边界节点不相连的\",{\"1\":{\"709\":1}}],[\"将所有信息拼接在一个字符串\",{\"1\":{\"429\":1}}],[\"将所需的依赖注入到占位符中\",{\"1\":{\"163\":1}}],[\"将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\",{\"1\":{\"419\":1}}],[\"将这些横切关注点与核心业务逻辑进行解耦\",{\"1\":{\"158\":1}}],[\"将这些通用算法抽象出来\",{\"1\":{\"104\":1}}],[\"将属性进行私有化private\",{\"1\":{\"398\":1}}],[\"将值存储到threadlocalmap中\",{\"1\":{\"306\":1}}],[\"将此线程局部变量的当前线程副本设置为指定值\",{\"1\":{\"304\":1}}],[\"将不会使得atomicreference处于不一致的状态\",{\"1\":{\"297\":1}}],[\"将可能导致各自缓存数据不一致的问题\",{\"1\":{\"274\":1}}],[\"将消息持久化到日志文件中\",{\"1\":{\"213\":1}}],[\"将消息发送到队列\",{\"1\":{\"213\":1}}],[\"将消息存入对应的队列\",{\"1\":{\"210\":1}}],[\"将无效的\",{\"1\":{\"197\":1}}],[\"将被删除\",{\"1\":{\"191\":1}}],[\"将\",{\"1\":{\"165\":2,\"199\":1,\"480\":1,\"545\":1,\"593\":1,\"628\":2}}],[\"将earlysingletonobjects缓存中的占位符替换为真正的bean对象\",{\"1\":{\"163\":1}}],[\"将处理结果转化为具体的视图对象\",{\"1\":{\"162\":1}}],[\"将请求转发给对应的控制器\",{\"1\":{\"162\":1}}],[\"将存活的对象复制到另一个区域\",{\"1\":{\"148\":1}}],[\"将内存位置的值与预期原值比较\",{\"1\":{\"295\":1}}],[\"将内存分为两个相等大小的区域\",{\"1\":{\"148\":1}}],[\"将内存划分为不同的代\",{\"1\":{\"148\":1}}],[\"将该写操作变为原子操作\",{\"1\":{\"140\":1}}],[\"将锁记录中持有锁的线程id设置为当前线程id\",{\"1\":{\"139\":1}}],[\"将链表转换为红黑树\",{\"1\":{\"124\":1}}],[\"将抽象部分与实现部分分离\",{\"1\":{\"113\":1}}],[\"将变与不变分离开\",{\"1\":{\"107\":1}}],[\"将一个元素放入队列的尾部\",{\"1\":{\"655\":1}}],[\"将一个\",{\"1\":{\"628\":1}}],[\"将一个复杂的构建与其表示相分离\",{\"1\":{\"107\":1}}],[\"将一组值\",{\"1\":{\"433\":1}}],[\"将一直向上调用到object\",{\"1\":{\"399\":1}}],[\"将一些非核心的流程\",{\"1\":{\"207\":1}}],[\"将一些已经定好的方法封装起来\",{\"1\":{\"104\":1}}],[\"将它们分配到不同的命名空间中\",{\"1\":{\"69\":1}}],[\"却在每一个子类都重新写了这一方法\",{\"1\":{\"104\":1}}],[\"却并不拥有该内存\",{\"1\":{\"3\":1}}],[\"卡\",{\"1\":{\"102\":2}}],[\"卡片\",{\"0\":{\"27\":1}}],[\"都存在一条位于节点\",{\"1\":{\"716\":1}}],[\"都不会被填充为\",{\"1\":{\"709\":1}}],[\"都支持服务提供者心跳方式做健康监测\",{\"1\":{\"600\":1}}],[\"都支持服务注册和服务拉取\",{\"1\":{\"600\":1}}],[\"都运行在\",{\"1\":{\"588\":1}}],[\"都添加后置处理器\",{\"1\":{\"560\":1}}],[\"都会自动调用该对象的tostring形式\",{\"1\":{\"406\":1}}],[\"都会自动把消息到多个实例的\",{\"1\":{\"212\":1}}],[\"都会计算\",{\"1\":{\"364\":1}}],[\"都有一个自己的副本\",{\"1\":{\"303\":1}}],[\"都来重新连接\",{\"1\":{\"204\":1}}],[\"都需要增加一个具体类和对象实现工厂\",{\"1\":{\"101\":1}}],[\"都是有效字符串\",{\"1\":{\"660\":1}}],[\"都是非常昂贵的开销\",{\"1\":{\"209\":1}}],[\"都是一系列得到支持的管理传递性依赖\",{\"1\":{\"81\":1}}],[\"都是注入bean的注解\",{\"1\":{\"69\":1}}],[\"缺点改进\",{\"0\":{\"300\":1}}],[\"缺点是删除过期键不及时\",{\"1\":{\"191\":1}}],[\"缺点\",{\"1\":{\"98\":1,\"101\":1,\"104\":1,\"107\":1,\"113\":1,\"116\":1,\"356\":2,\"492\":3}}],[\"尤其是在高度较高的b树中\",{\"1\":{\"172\":1}}],[\"尤其是在处理大量拉丁字符的场景下可以显著降低内存消耗\",{\"1\":{\"121\":1}}],[\"尤其是频繁的创建和销毁实例\",{\"1\":{\"98\":1}}],[\"尤其在新老系统交替的时候\",{\"1\":{\"95\":1}}],[\"保持一致\",{\"1\":{\"501\":2}}],[\"保持一致性\",{\"1\":{\"419\":1}}],[\"保存资源的缓存\",{\"0\":{\"781\":1}}],[\"保存全部的路径\",{\"1\":{\"686\":1}}],[\"保存这些信息的类名为class\",{\"1\":{\"486\":1}}],[\"保存配置文件成功~\",{\"1\":{\"480\":1}}],[\"保存完毕\",{\"1\":{\"478\":1}}],[\"保存数据的值和数据类型\",{\"1\":{\"478\":1}}],[\"保存jdk动态代理生成的代理类\",{\"1\":{\"419\":1}}],[\"保存到服务器端\",{\"1\":{\"165\":1}}],[\"保存文档内容\",{\"1\":{\"108\":1}}],[\"保证是合法的二叉树\",{\"1\":{\"730\":1}}],[\"保证每个右括号都有一个左括号对应\",{\"1\":{\"690\":1}}],[\"保证多线程\",{\"1\":{\"471\":1}}],[\"保证数据完整性\",{\"1\":{\"470\":1}}],[\"保证数据的完整性\",{\"1\":{\"177\":1}}],[\"保证高可用性和扩展性\",{\"1\":{\"203\":1}}],[\"保证在快指针遍历到头时\",{\"1\":{\"638\":1}}],[\"保证在整个事务期间读取的数据不受其他事务的影响\",{\"1\":{\"171\":1}}],[\"保证在同一时刻只有一个线程可以执行该方法或代码块\",{\"1\":{\"138\":1}}],[\"保证程序按照代码顺序执行\",{\"1\":{\"140\":1}}],[\"保证了原子性\",{\"1\":{\"138\":1}}],[\"保证对其修饰的变量的修改对其他线程是可见的\",{\"1\":{\"138\":1}}],[\"保证可见性\",{\"1\":{\"138\":1}}],[\"保证一个类仅有一个实例\",{\"1\":{\"98\":1}}],[\"保护类的完整性和安全性\",{\"1\":{\"127\":1}}],[\"保护方法的稳定性和一致性\",{\"1\":{\"127\":1}}],[\"保留了移动构造函数的指针封装类型\",{\"1\":{\"3\":1}}],[\"应使用\",{\"1\":{\"775\":1}}],[\"应当输出true\",{\"1\":{\"429\":1}}],[\"应该将releaseshared传播到其他节点\",{\"1\":{\"312\":1}}],[\"应该在该线程内部实现一个判断interupted方法是否已被中断\",{\"1\":{\"267\":1}}],[\"应该知道\",{\"1\":{\"95\":1}}],[\"应用层决定了向用户提供应用服务时通信的活动\",{\"1\":{\"749\":1}}],[\"应用层\",{\"1\":{\"749\":1}}],[\"应用于现代应用程序开发\",{\"1\":{\"545\":1}}],[\"应用程序上下文中连接在一起以构成一个完整的应用程序\",{\"1\":{\"545\":1}}],[\"应用程序上下文\",{\"1\":{\"545\":1}}],[\"应用程序的内存需求超过了可用的物理内存或jvm的内存限制\",{\"1\":{\"146\":1}}],[\"应用实例\",{\"1\":{\"98\":1,\"101\":1,\"104\":1,\"107\":1,\"113\":1,\"116\":1}}],[\"应用监控\",{\"1\":{\"80\":1}}],[\"应用中才有意义\",{\"1\":{\"65\":1}}],[\"功能都是固定的\",{\"1\":{\"607\":1}}],[\"功能与\",{\"1\":{\"588\":1}}],[\"功能介绍\",{\"0\":{\"95\":1,\"98\":1,\"101\":1,\"104\":1,\"107\":1,\"110\":1,\"113\":1,\"116\":1}}],[\"功能描述\",{\"1\":{\"81\":1}}],[\"综上所述\",{\"1\":{\"93\":1,\"213\":1}}],[\"演化而来的\",{\"1\":{\"93\":1}}],[\"演示\",{\"1\":{\"13\":1,\"560\":1}}],[\"框架来保护微服务系统\",{\"1\":{\"593\":1}}],[\"框架对\",{\"1\":{\"574\":1}}],[\"框架一般基于\",{\"1\":{\"571\":1}}],[\"框架概述\",{\"0\":{\"546\":1}}],[\"框架\",{\"0\":{\"521\":1},\"1\":{\"93\":1,\"168\":3,\"545\":1,\"571\":1}}],[\"事后\",{\"1\":{\"198\":1}}],[\"事中\",{\"1\":{\"198\":1}}],[\"事前\",{\"1\":{\"198\":1}}],[\"事务开发\",{\"0\":{\"584\":1}}],[\"事务开始前和结束后\",{\"1\":{\"170\":1}}],[\"事务隔离级别\",{\"1\":{\"582\":1}}],[\"事务传播行为\",{\"1\":{\"582\":1}}],[\"事务操作\",{\"0\":{\"581\":1}}],[\"事务的参数\",{\"0\":{\"582\":1}}],[\"事务的四个特性\",{\"1\":{\"580\":1}}],[\"事务的概念\",{\"0\":{\"201\":1}}],[\"事务是数据库操作的基本单元\",{\"1\":{\"580\":1}}],[\"事务概念\",{\"0\":{\"580\":1}}],[\"事务\",{\"0\":{\"579\":1}}],[\"事务id\",{\"1\":{\"303\":1}}],[\"事务机制或者\",{\"1\":{\"211\":1}}],[\"事务提供\",{\"1\":{\"202\":1}}],[\"事务相关指令\",{\"0\":{\"202\":1}}],[\"事务中所有命令都会序列化\",{\"1\":{\"201\":1}}],[\"事务中如果有某一条命令执行失败\",{\"1\":{\"201\":1}}],[\"事务只能看到已提交事务开始之前的版本\",{\"1\":{\"178\":1}}],[\"事务只能读取其他事务已经提交的数据\",{\"1\":{\"171\":1}}],[\"事务日志\",{\"1\":{\"177\":1}}],[\"事务会在读取和修改数据时对数据进行锁定\",{\"1\":{\"171\":1}}],[\"事务会生效吗\",{\"0\":{\"166\":1}}],[\"事务在执行的过程中\",{\"1\":{\"201\":1}}],[\"事务在启动时创建一个一致性视图\",{\"1\":{\"171\":1}}],[\"事务在处理某个数据集时\",{\"1\":{\"171\":1}}],[\"事务可以运行直到执行完所有事务队列中的命令为止\",{\"1\":{\"201\":1}}],[\"事务可以读取其他事务尚未提交的数据\",{\"1\":{\"171\":1}}],[\"事务可能会在两次读取之间对数据进行了一些操作\",{\"1\":{\"171\":1}}],[\"事务可能基于不一致或临时的数据进行后续操作\",{\"1\":{\"171\":1}}],[\"事务调度算法\",{\"1\":{\"171\":1}}],[\"事务特性\",{\"0\":{\"170\":1}}],[\"事务管理等功能可以横切于多个对象和方法\",{\"1\":{\"158\":1}}],[\"事务管理\",{\"1\":{\"61\":1,\"338\":1}}],[\"事实上适配器模式的工作原理也差不多\",{\"1\":{\"95\":1}}],[\"事件机制就是观察者模式\",{\"1\":{\"93\":1}}],[\"除\",{\"1\":{\"362\":1}}],[\"除了最后一个元素外\",{\"1\":{\"658\":1}}],[\"除了其核心容器之外\",{\"1\":{\"545\":1}}],[\"除了static和transient成员\",{\"1\":{\"478\":1}}],[\"除了该类的方法外\",{\"1\":{\"398\":1}}],[\"除了long和double\",{\"1\":{\"140\":1}}],[\"除了本文将重点讲述的几个设计模式之外\",{\"1\":{\"93\":1}}],[\"除long和double之外的基本类型的赋值操作\",{\"1\":{\"57\":1}}],[\"距今将近30年\",{\"1\":{\"93\":1}}],[\"于是阅读其他人的代码时\",{\"1\":{\"93\":1}}],[\"最下面是内容实体\",{\"1\":{\"760\":1}}],[\"最近使用\",{\"1\":{\"720\":1}}],[\"最近最不常用\",{\"1\":{\"200\":1}}],[\"最近最少使用的\",{\"1\":{\"536\":1}}],[\"最近最少使用策略\",{\"1\":{\"192\":1}}],[\"最近最少使用\",{\"1\":{\"167\":1,\"200\":1,\"720\":1}}],[\"最久未使用的关键字\",{\"1\":{\"720\":1}}],[\"最多有1000个车站\",{\"1\":{\"677\":1}}],[\"最多只需log2n次\",{\"1\":{\"381\":1}}],[\"最长相同前后缀的长度为2\",{\"1\":{\"653\":1}}],[\"最长相同前后缀的长度为1\",{\"1\":{\"653\":2}}],[\"最长相同前后缀的长度为0\",{\"1\":{\"653\":3}}],[\"最长回文子串\",{\"0\":{\"650\":1}}],[\"最长子串\",{\"1\":{\"647\":1}}],[\"最好用basic或none\",{\"1\":{\"606\":1}}],[\"最大值\",{\"1\":{\"661\":1}}],[\"最大\",{\"1\":{\"631\":1}}],[\"最大连接数\",{\"1\":{\"606\":1}}],[\"最大变更历史数量\",{\"1\":{\"605\":2}}],[\"最大线程数\",{\"1\":{\"135\":1}}],[\"最小深度是从根节点到最近叶子节点的最短路径上的节点数量\",{\"1\":{\"712\":1}}],[\"最小覆盖子串\",{\"0\":{\"648\":1},\"1\":{\"648\":1}}],[\"最小连接数策略\",{\"1\":{\"598\":2}}],[\"最小值为0\",{\"1\":{\"358\":1}}],[\"最终都会被填充为\",{\"1\":{\"709\":1}}],[\"最终通知\",{\"1\":{\"570\":1}}],[\"最终生成的类放在这个package下\",{\"1\":{\"540\":1}}],[\"最值\",{\"1\":{\"432\":1}}],[\"最开始的值是a\",{\"1\":{\"299\":1}}],[\"最重要的是\",{\"1\":{\"209\":1}}],[\"最底层\",{\"1\":{\"208\":1}}],[\"最不经常使用策略\",{\"1\":{\"192\":1}}],[\"最左匹配原则\",{\"1\":{\"175\":1}}],[\"最左匹配原则是什么\",{\"0\":{\"175\":1}}],[\"最高的隔离级别\",{\"1\":{\"171\":1}}],[\"最低的隔离级别\",{\"1\":{\"171\":1}}],[\"最常见的\",{\"1\":{\"93\":1}}],[\"最后一块会使用\",{\"1\":{\"768\":1}}],[\"最后的http\",{\"1\":{\"760\":1}}],[\"最后再次遍历整张图\",{\"1\":{\"709\":1}}],[\"最后再把边缘区域还原\",{\"1\":{\"709\":1}}],[\"最后再从缓存同步回内存中\",{\"1\":{\"274\":1}}],[\"最后交换queue1和queue2\",{\"1\":{\"657\":1}}],[\"最后又变成了a\",{\"1\":{\"299\":1}}],[\"最后执行该指令\",{\"1\":{\"274\":1}}],[\"最后\",{\"1\":{\"163\":1}}],[\"最后进行合并\",{\"1\":{\"86\":1}}],[\"最后对view进行渲染将处理结果通过页面展示给用户\",{\"1\":{\"76\":1}}],[\"qq\",{\"1\":{\"501\":1}}],[\"qwewe\",{\"1\":{\"451\":1}}],[\"q\",{\"1\":{\"91\":6,\"661\":8,\"709\":16,\"711\":6,\"729\":8}}],[\"quicksort\",{\"1\":{\"629\":1}}],[\"queue=\",{\"1\":{\"666\":1,\"669\":1}}],[\"queue<string>\",{\"1\":{\"713\":1}}],[\"queue<node>\",{\"1\":{\"711\":1}}],[\"queue<treenode>\",{\"1\":{\"666\":1,\"669\":1,\"712\":1}}],[\"queue<integer>\",{\"1\":{\"91\":1,\"657\":3,\"658\":1}}],[\"queuetemp\",{\"1\":{\"657\":3}}],[\"queue2\",{\"1\":{\"657\":6}}],[\"queue1\",{\"1\":{\"657\":9}}],[\"queue\",{\"1\":{\"209\":1,\"212\":4,\"492\":1,\"658\":9,\"666\":6,\"669\":6,\"712\":7,\"713\":7}}],[\"queryorderbyid\",{\"1\":{\"597\":1}}],[\"query\",{\"1\":{\"177\":2,\"607\":1}}],[\"quartz调度框架的支持\",{\"1\":{\"81\":1}}],[\"quartz\",{\"1\":{\"81\":1}}],[\"qualifier\",{\"0\":{\"71\":1},\"1\":{\"71\":1,\"564\":3}}],[\"求所有子数组的和的最大值\",{\"1\":{\"693\":1}}],[\"求长度差\",{\"1\":{\"639\":1}}],[\"求链表b的长度\",{\"1\":{\"639\":1}}],[\"求链表a的长度\",{\"1\":{\"639\":1}}],[\"求得同时执行需要的最大内存值即为答案\",{\"1\":{\"91\":1}}],[\"求出每个节点的值\",{\"1\":{\"90\":1}}],[\"拓扑排序\",{\"1\":{\"91\":1}}],[\"行数\",{\"1\":{\"696\":1,\"727\":1}}],[\"行列指针\",{\"1\":{\"632\":1}}],[\"行为\",{\"1\":{\"202\":1}}],[\"行为由父类控制\",{\"1\":{\"104\":1}}],[\"行\",{\"1\":{\"91\":1,\"576\":1,\"577\":3,\"583\":3,\"706\":1,\"707\":1,\"708\":1,\"709\":1}}],[\"数值的整数次方\",{\"0\":{\"741\":1}}],[\"数位和大于k\",{\"1\":{\"734\":1}}],[\"数字\",{\"1\":{\"489\":1,\"647\":1,\"690\":1}}],[\"数字类型\",{\"1\":{\"489\":1}}],[\"数据每通过一层都会加上该层的首部\",{\"1\":{\"750\":1}}],[\"数据结构设计\",{\"0\":{\"719\":1}}],[\"数据结构简单\",{\"1\":{\"186\":1}}],[\"数据卷\",{\"1\":{\"615\":2}}],[\"数据卷操作\",{\"0\":{\"615\":1}}],[\"数据独立\",{\"1\":{\"595\":1}}],[\"数据表中的字段\",{\"1\":{\"501\":1}}],[\"数据在两个socket间通过io传输\",{\"1\":{\"484\":1}}],[\"数据在传输过程中不加密\",{\"1\":{\"154\":1}}],[\"数据被保护在内部\",{\"1\":{\"398\":1}}],[\"数据类型\",{\"1\":{\"381\":3}}],[\"数据保证\",{\"1\":{\"213\":1}}],[\"数据处理模式\",{\"1\":{\"213\":1}}],[\"数据根据键名的哈希值被分配到对应的揭示槽上\",{\"1\":{\"203\":1}}],[\"数据同步阶段\",{\"1\":{\"203\":1}}],[\"数据丢失\",{\"1\":{\"203\":1}}],[\"数据存储在了内存中\",{\"1\":{\"189\":1}}],[\"数据存在内存中\",{\"1\":{\"186\":1}}],[\"数据复制和主从同步\",{\"1\":{\"177\":1}}],[\"数据不一致\",{\"1\":{\"171\":1}}],[\"数据库全名\",{\"1\":{\"605\":7}}],[\"数据库批量操作\",{\"0\":{\"578\":1}}],[\"数据库\",{\"0\":{\"562\":1}}],[\"数据库中的表名或视图名\",{\"1\":{\"540\":1}}],[\"数据库连接驱动类\",{\"1\":{\"540\":1}}],[\"数据库管理系统的自动递增字段\",{\"1\":{\"501\":1}}],[\"数据库性能下降\",{\"1\":{\"496\":1}}],[\"数据库状态被修改后\",{\"1\":{\"203\":1}}],[\"数据库可以直接使用索引定位到对应的数据行\",{\"1\":{\"175\":1}}],[\"数据库引擎会根据最左匹配原则来定位索引中的数据\",{\"1\":{\"175\":1}}],[\"数据库的数据名\",{\"1\":{\"522\":1}}],[\"数据库的事务\",{\"0\":{\"171\":1}}],[\"数据库的完整性约束没有被破坏\",{\"1\":{\"170\":1}}],[\"数据库为每一个用户开启的事务\",{\"1\":{\"170\":1}}],[\"数据库操作\",{\"1\":{\"168\":1}}],[\"数据库或者缓存\",{\"1\":{\"165\":1}}],[\"数据变化时需要更新缓存\",{\"1\":{\"167\":1}}],[\"数据包可能以任意顺序到达\",{\"1\":{\"156\":1}}],[\"数据包顺序\",{\"1\":{\"156\":1}}],[\"数据的存储方式\",{\"1\":{\"153\":1}}],[\"数据链路层\",{\"1\":{\"152\":1,\"749\":1}}],[\"数组输入\",{\"0\":{\"725\":1}}],[\"数组可以快速的获取对应元素\",{\"1\":{\"721\":1}}],[\"数组可以分割成\",{\"1\":{\"701\":1}}],[\"数组辅助了\",{\"1\":{\"715\":1}}],[\"数组结构的动态规划\",{\"0\":{\"699\":1}}],[\"数组中每个数代表从起点到对应位置的路径数\",{\"1\":{\"696\":1}}],[\"数组中的一个或连续多个整数组成一个子数组\",{\"1\":{\"693\":1}}],[\"数组中的元素\",{\"1\":{\"686\":1}}],[\"数组内存占用\",{\"1\":{\"693\":1}}],[\"数组初始状态\",{\"1\":{\"693\":2}}],[\"数组变为\",{\"1\":{\"629\":2}}],[\"数组充当备忘录\",{\"1\":{\"624\":1}}],[\"数组类型注入\",{\"1\":{\"557\":1}}],[\"数组属性\",{\"1\":{\"557\":1}}],[\"数组加双向链表\",{\"1\":{\"446\":1,\"451\":1}}],[\"数组元素填充\",{\"1\":{\"433\":1}}],[\"数组元素复制\",{\"1\":{\"433\":1}}],[\"数组等\",{\"1\":{\"388\":1}}],[\"数组挨个判断\",{\"1\":{\"381\":1}}],[\"数组扩容\",{\"1\":{\"381\":1}}],[\"数组拷贝\",{\"1\":{\"381\":1}}],[\"数组名\",{\"1\":{\"381\":2,\"382\":1}}],[\"数组的边界判断\",{\"1\":{\"706\":1,\"707\":1,\"708\":1,\"709\":2}}],[\"数组的意义\",{\"1\":{\"700\":1}}],[\"数组的索引可能跟题目给的序号不一致\",{\"1\":{\"676\":1}}],[\"数组的参数在执行java命令时传递\",{\"1\":{\"412\":1}}],[\"数组的定义类型为父类类型\",{\"1\":{\"404\":1}}],[\"数组的赋值是引用传递\",{\"1\":{\"381\":1}}],[\"数组的赋值机制\",{\"1\":{\"381\":1}}],[\"数组的静态初始化\",{\"1\":{\"381\":1}}],[\"数组的动态初始化方法一\",{\"1\":{\"381\":1}}],[\"数组的同一个位置\",{\"1\":{\"124\":1}}],[\"数组长度至少应为4\",{\"1\":{\"124\":1}}],[\"数组\",{\"0\":{\"380\":1,\"381\":1,\"619\":1},\"1\":{\"121\":1,\"124\":1,\"389\":1,\"451\":1,\"627\":1,\"701\":1}}],[\"数组排序\",{\"0\":{\"45\":1}}],[\"数目\",{\"1\":{\"90\":1,\"631\":1}}],[\"二维矩阵\",{\"1\":{\"708\":1}}],[\"二维字符网格\",{\"1\":{\"705\":1}}],[\"二维数组实际上是由多个一维数组组成\",{\"1\":{\"382\":1}}],[\"二维数组的声明方式有\",{\"1\":{\"382\":1}}],[\"二维数组的遍历\",{\"1\":{\"382\":1}}],[\"二维数组的初始化\",{\"1\":{\"382\":1}}],[\"二维数组动态初始化\",{\"1\":{\"382\":1}}],[\"二维数组\",{\"0\":{\"382\":1}}],[\"二叉树中的前缀和\",{\"0\":{\"672\":1}}],[\"二叉树的最小深度\",{\"0\":{\"712\":1}}],[\"二叉树的最大深度\",{\"0\":{\"669\":1}}],[\"二叉树的深度为根节点到最远叶子节点的最长路径上的节点数\",{\"1\":{\"669\":1}}],[\"二叉树的遍历\",{\"0\":{\"664\":1}}],[\"二叉树层序遍历\",{\"0\":{\"666\":1}}],[\"二叉树前序遍历\",{\"1\":{\"665\":1}}],[\"二叉树迭代遍历\",{\"0\":{\"665\":1}}],[\"二叉树\",{\"0\":{\"663\":1}}],[\"二叉树数组形式的遍历\",{\"0\":{\"90\":1}}],[\"二分法的思路\",{\"1\":{\"742\":1}}],[\"二分法查找\",{\"1\":{\"381\":1,\"433\":1}}],[\"二分图即每条边的两个节点属于分别属于两个独立的节点集合\",{\"1\":{\"716\":1}}],[\"二分图\",{\"1\":{\"716\":2}}],[\"二分查找使用前提\",{\"1\":{\"620\":1}}],[\"二分查找\",{\"0\":{\"620\":1}}],[\"二十\",{\"0\":{\"492\":1}}],[\"二进制系统种无法精确的表示分数1\",{\"1\":{\"492\":1}}],[\"二进制文件\",{\"1\":{\"476\":1}}],[\"二进制日志\",{\"1\":{\"177\":1}}],[\"二\",{\"0\":{\"325\":1,\"355\":1}}],[\"二级缓存可以使用第三方的缓存\",{\"1\":{\"538\":1}}],[\"二级缓存没有再查一级缓存\",{\"1\":{\"537\":1}}],[\"二级缓存相关配置文件\",{\"0\":{\"536\":1}}],[\"二级缓存失效的情况\",{\"1\":{\"535\":1}}],[\"二级缓存必须在\",{\"1\":{\"535\":1}}],[\"二级缓存开启条件\",{\"1\":{\"535\":1}}],[\"二级缓存是\",{\"1\":{\"535\":1}}],[\"二级缓存是基于序列化来实现的\",{\"1\":{\"167\":1}}],[\"二级缓存\",{\"0\":{\"535\":1},\"1\":{\"163\":1,\"167\":1}}],[\"二者有以下区别\",{\"1\":{\"55\":1}}],[\"工具包\",{\"1\":{\"396\":1}}],[\"工程部署在硬盘的绝对路径\",{\"1\":{\"331\":1}}],[\"工厂\",{\"0\":{\"558\":1}}],[\"工厂方法或者特定的实例化策略来完成\",{\"1\":{\"160\":1}}],[\"工厂模式使其创建过程延迟到子类进行\",{\"1\":{\"101\":1}}],[\"工厂模式\",{\"0\":{\"100\":1},\"1\":{\"63\":3,\"73\":1,\"101\":1,\"555\":2}}],[\"工作时长\",{\"1\":{\"89\":1}}],[\"进入下一圈\",{\"1\":{\"632\":1}}],[\"进入容器后执行的命令\",{\"1\":{\"614\":1}}],[\"进入容器内部\",{\"1\":{\"614\":1}}],[\"进入容器\",{\"1\":{\"614\":1}}],[\"进入nginx的html所在目录\",{\"1\":{\"614\":1}}],[\"进入nginx容器\",{\"1\":{\"614\":1}}],[\"进入nacos的conf目录\",{\"1\":{\"605\":1}}],[\"进入\",{\"1\":{\"471\":4}}],[\"进入setheadandpropagate已经sethead\",{\"1\":{\"318\":1}}],[\"进入setheadandpropagate\",{\"1\":{\"318\":2}}],[\"进入临界区的线程需要在释放锁之前进行阻塞和唤醒操作\",{\"1\":{\"139\":1}}],[\"进一步提升了系统的并发性和容错性\",{\"1\":{\"214\":1}}],[\"进程线程的区别\",{\"0\":{\"150\":1}}],[\"进门禁的所有时间\",{\"1\":{\"89\":1}}],[\"进门禁次数\",{\"1\":{\"89\":1}}],[\"进行编号\",{\"1\":{\"678\":1}}],[\"进行平方的比较\",{\"1\":{\"629\":1}}],[\"进行交换\",{\"1\":{\"628\":1}}],[\"进行封装\",{\"1\":{\"574\":1}}],[\"进行通知的配置\",{\"1\":{\"572\":1}}],[\"进行功能增强\",{\"1\":{\"548\":1}}],[\"进行拼接\",{\"1\":{\"527\":1}}],[\"进行打印\",{\"1\":{\"479\":1}}],[\"进行原子操作\",{\"1\":{\"297\":1}}],[\"进行匹配\",{\"1\":{\"176\":1}}],[\"进行页面展示和动态内容生成\",{\"1\":{\"168\":1}}],[\"进行数据库操作\",{\"1\":{\"168\":1}}],[\"进行比较\",{\"1\":{\"165\":1}}],[\"进行处理\",{\"1\":{\"162\":1}}],[\"进行全局的流程控制\",{\"1\":{\"76\":1}}],[\"进行视图解析\",{\"1\":{\"76\":1}}],[\"进行引用\",{\"1\":{\"41\":2}}],[\"格式为\",{\"1\":{\"785\":1}}],[\"格式化的日期=\",{\"1\":{\"436\":1}}],[\"格式化和解析日期的类\",{\"1\":{\"436\":1}}],[\"格式命名\",{\"1\":{\"419\":1}}],[\"格式的增量数据\",{\"1\":{\"189\":1}}],[\"格式\",{\"1\":{\"89\":1,\"90\":1,\"91\":1}}],[\"每3剪一次绳\",{\"1\":{\"739\":1}}],[\"每行的第1个数据表示赖的模块数量不会超过n\",{\"1\":{\"718\":1}}],[\"每发现一个岛屿\",{\"1\":{\"707\":1,\"708\":1,\"709\":1}}],[\"每发现一块陆地就淹没该片的岛屿\",{\"1\":{\"706\":1}}],[\"每间房内都藏有一定的现金\",{\"1\":{\"698\":1}}],[\"每offer一个数进来都重新排序\",{\"1\":{\"658\":1}}],[\"每计数至\",{\"1\":{\"643\":1}}],[\"每循环一次\",{\"1\":{\"632\":1}}],[\"每采摘一次\",{\"1\":{\"631\":1}}],[\"每棵\",{\"1\":{\"631\":1}}],[\"每日温度\",{\"0\":{\"622\":1}}],[\"每页显示的条数\",{\"1\":{\"542\":1}}],[\"每100毫秒卖出去一张票\",{\"1\":{\"466\":1,\"471\":1}}],[\"每隔一秒输出\",{\"1\":{\"466\":2}}],[\"每隔一秒输出一次\",{\"1\":{\"466\":2}}],[\"每创建一次就会调用一次\",{\"1\":{\"413\":1}}],[\"每创建一个对象就会执行一次\",{\"1\":{\"413\":1}}],[\"每条线程还有自己的工作内存\",{\"1\":{\"279\":1}}],[\"每人机器启动一个\",{\"1\":{\"212\":1}}],[\"每秒钟最多处理2k个\",{\"1\":{\"207\":1}}],[\"每层缓存失效时间不同\",{\"1\":{\"198\":1}}],[\"每个拨轮可以自由旋转\",{\"1\":{\"713\":1}}],[\"每个拨轮都有10个数字\",{\"1\":{\"713\":1}}],[\"每个子集里的数字和正好等于sum\",{\"1\":{\"701\":1}}],[\"每个子集的和\",{\"1\":{\"689\":1,\"701\":2}}],[\"每个航班\",{\"1\":{\"678\":1}}],[\"每个操作会被表示为⼀个三元组\",{\"1\":{\"676\":1}}],[\"每个右括号都有一个对应的相同类型的左括号\",{\"1\":{\"659\":1}}],[\"每个循环的起始位置\",{\"1\":{\"632\":1}}],[\"每个篮子能够装的水果总量没有限制\",{\"1\":{\"631\":1}}],[\"每个数字的平方\",{\"1\":{\"629\":1}}],[\"每个数据包的大小限制在64k内\",{\"1\":{\"482\":1}}],[\"每个数据包都独立发送\",{\"1\":{\"156\":1}}],[\"每个数据行在插入或更新时都会有一个版本号\",{\"1\":{\"178\":1}}],[\"每个都向后查找一个比该天温度高的那天\",{\"1\":{\"622\":1}}],[\"每个服务对应唯一业务能力\",{\"1\":{\"595\":1}}],[\"每个服务运行在独立的进程中\",{\"1\":{\"591\":1}}],[\"每个业务模块独立开发\",{\"1\":{\"595\":1}}],[\"每个对象是user类\",{\"1\":{\"501\":1}}],[\"每个对象都有一个互斥锁\",{\"1\":{\"471\":1}}],[\"每个值将自动地按照排序后地顺序呈现\",{\"1\":{\"447\":1}}],[\"每个节点中prev指向前一个节点\",{\"1\":{\"443\":1}}],[\"每个元素应该有\",{\"1\":{\"721\":1}}],[\"每个元素有对应的索引\",{\"1\":{\"440\":1}}],[\"每个元素都会关联一个分数\",{\"1\":{\"188\":1}}],[\"每个目标对象对应一个代理类\",{\"1\":{\"419\":1}}],[\"每个方法不能绝对的比另一个好\",{\"1\":{\"299\":1}}],[\"每个线程在自己的工作内存中有个操作变量的副本\",{\"1\":{\"277\":1}}],[\"每个处理器都有自己的高速缓存\",{\"1\":{\"274\":1}}],[\"每个消费者负责处理一部分分区的消息\",{\"1\":{\"214\":1}}],[\"每个channel表示一个会话任务\",{\"1\":{\"209\":1}}],[\"每个\",{\"1\":{\"186\":1}}],[\"每个表只能有一个聚簇索引\",{\"1\":{\"179\":1}}],[\"每个事务在开始时会创建一个read\",{\"1\":{\"178\":1}}],[\"每个进程都有独立的内存空间和系统资源\",{\"1\":{\"150\":1}}],[\"每个段内部维护一个类似于hashmap的数据结构\",{\"1\":{\"125\":1}}],[\"每个生成的工厂都能按照工厂模式提供对象\",{\"1\":{\"110\":1}}],[\"每个任务内存大小\",{\"1\":{\"91\":1}}],[\"每个任务需要的内存大小\",{\"1\":{\"91\":1}}],[\"每次旋转都只能旋转一个拨轮的一位数字\",{\"1\":{\"713\":1}}],[\"每次偷当前人家\",{\"1\":{\"697\":1}}],[\"每次先处理的是中间节点\",{\"1\":{\"665\":1}}],[\"每次移动\",{\"1\":{\"643\":1}}],[\"每次移动的计数\",{\"1\":{\"632\":1}}],[\"每次创建变量时会创建不同的变量\",{\"1\":{\"559\":1}}],[\"每次读取单个字符\",{\"1\":{\"477\":1}}],[\"每次到临界值就会扩容2倍\",{\"1\":{\"445\":1}}],[\"每次都是一个新的对象\",{\"1\":{\"559\":1}}],[\"每次都按2倍扩容\",{\"1\":{\"442\":1}}],[\"每次都有很多的线程在竞争\",{\"1\":{\"299\":1}}],[\"每次扩容变1\",{\"1\":{\"441\":1}}],[\"每次扩容为数组原长度的2倍+2\",{\"1\":{\"120\":1}}],[\"每次操作的就是两个值\",{\"1\":{\"299\":1}}],[\"每次请求都会带上cookie信息\",{\"1\":{\"153\":1}}],[\"每次调用减少计数器的值\",{\"1\":{\"144\":1}}],[\"每次增加一个产品时\",{\"1\":{\"101\":1}}],[\"每次获取mapper时\",{\"1\":{\"83\":1}}],[\"每一行里面的数字按1个空格分隔\",{\"1\":{\"718\":1}}],[\"每一行是一个玩家的记录\",{\"1\":{\"5\":1}}],[\"每一次的重新赋值获得的都是一层的大小\",{\"1\":{\"666\":1,\"669\":1}}],[\"每一步的操作都是一层\",{\"1\":{\"616\":1}}],[\"每一段时间收集一次所有服务提供者的平均响应时间\",{\"1\":{\"598\":1}}],[\"每一种子接口都是一种规则\",{\"1\":{\"598\":1}}],[\"每一种角度都可能变化\",{\"1\":{\"113\":1}}],[\"每一个过滤器都必须指定一\",{\"1\":{\"607\":1}}],[\"每一个类编译后都会生成一个对应的\",{\"1\":{\"352\":1}}],[\"每一个不同的实现都需要一个子类来实现\",{\"1\":{\"104\":1}}],[\"每一个mapper底层其实是mapper工厂\",{\"1\":{\"83\":1}}],[\"把大块数据分割成报文段为单位的数据包进行管理\",{\"1\":{\"753\":1}}],[\"把幂指数二分\",{\"1\":{\"742\":1}}],[\"把对应的左右节点的值也存入数组\",{\"1\":{\"730\":1}}],[\"把对象创建和对象之间调用的过程\",{\"1\":{\"554\":1}}],[\"把node\",{\"1\":{\"730\":1}}],[\"把根节点不为虚拟节点的节点替换为x\",{\"1\":{\"709\":1}}],[\"把边界上的o都与一个虚拟根节点相连\",{\"1\":{\"709\":1}}],[\"把与之相邻的陆地都淹掉\",{\"1\":{\"706\":1}}],[\"把子集看成背包\",{\"1\":{\"701\":1}}],[\"把问题等效于每个时间段的总乘客数相加\",{\"1\":{\"677\":1}}],[\"把节点的左子节点和右子节点对调\",{\"1\":{\"667\":1}}],[\"把节点的左右都存入队列\",{\"1\":{\"666\":1,\"669\":1}}],[\"把字符串\",{\"1\":{\"644\":1}}],[\"把螺旋的运动分成多次的for循环\",{\"1\":{\"632\":1}}],[\"把索引左闭右开\",{\"1\":{\"630\":1}}],[\"把项目中每个微服务都打包成app\",{\"1\":{\"617\":1}}],[\"把同在一个机房的多个实例称为一个集群\",{\"1\":{\"599\":1}}],[\"把通知应用到切入点的过程\",{\"1\":{\"570\":1}}],[\"把外部文件引入spring配置\",{\"1\":{\"562\":1}}],[\"把集合注入部分提取出来\",{\"1\":{\"557\":1}}],[\"把创建对象的过程交给\",{\"1\":{\"547\":1}}],[\"把返回的数据转换成\",{\"1\":{\"504\":1}}],[\"把\",{\"1\":{\"436\":2,\"480\":1,\"507\":1,\"560\":1,\"564\":1}}],[\"把非数字字符串转换为int\",{\"1\":{\"424\":1}}],[\"把所有的对redis的服务器进行修改的命令都存到一个文件里\",{\"1\":{\"189\":1}}],[\"把任务加入thread类\",{\"1\":{\"132\":1}}],[\"把类型参数化\",{\"1\":{\"123\":1}}],[\"把这种多角度分类分离出来\",{\"1\":{\"113\":1}}],[\"把mapperscannerconfigurer的类注册进了spring容器中\",{\"1\":{\"83\":1}}],[\"把actor\",{\"1\":{\"7\":1}}],[\"分为长度j\",{\"1\":{\"736\":1}}],[\"分成两个子集\",{\"1\":{\"701\":1}}],[\"分成3次基本打家劫舍问题\",{\"1\":{\"698\":1}}],[\"分割发送的分块传输编码\",{\"1\":{\"768\":1}}],[\"分割等和子集\",{\"0\":{\"701\":1}}],[\"分割等和子集问题通用解法\",{\"0\":{\"689\":1}}],[\"分割成一些子串\",{\"1\":{\"688\":1}}],[\"分割回文串\",{\"0\":{\"688\":1}}],[\"分割字符串\",{\"1\":{\"429\":1}}],[\"分页功能\",{\"0\":{\"542\":1}}],[\"分页查询\",{\"1\":{\"199\":1}}],[\"分步查询可以实现延迟加载\",{\"1\":{\"524\":1}}],[\"分=\",{\"1\":{\"436\":1}}],[\"分钟前\",{\"1\":{\"436\":1}}],[\"分钟前是什么时候\",{\"1\":{\"436\":1}}],[\"分钟\",{\"1\":{\"436\":1}}],[\"分工明确\",{\"1\":{\"400\":1}}],[\"分号不能省略\",{\"1\":{\"373\":1}}],[\"分支控制if\",{\"0\":{\"371\":1}}],[\"分别表示第i个节点的值val是val\",{\"1\":{\"730\":1}}],[\"分别表示二叉树有n个节点\",{\"1\":{\"730\":1}}],[\"分别赋上不同的颜色\",{\"1\":{\"716\":1}}],[\"分别代表分配\",{\"1\":{\"687\":1}}],[\"分别代表版本号和引用\",{\"1\":{\"299\":1}}],[\"分别定义\",{\"1\":{\"640\":1}}],[\"分别记录每个i对应位置的左边最大值和右边最大值\",{\"1\":{\"624\":1}}],[\"分别命名为\",{\"1\":{\"605\":1}}],[\"分别说出相应的优缺点\",{\"1\":{\"492\":1}}],[\"分别起什么作用\",{\"0\":{\"177\":1}}],[\"分布式服务架构案例\",{\"0\":{\"596\":1}}],[\"分布式需要考虑的问题\",{\"1\":{\"595\":1}}],[\"分布式微服务架构的一站式解决方案\",{\"1\":{\"593\":1}}],[\"分布式环境下\",{\"1\":{\"216\":1}}],[\"分布式锁使用场景\",{\"0\":{\"216\":1}}],[\"分布式架构\",{\"1\":{\"214\":1,\"595\":1}}],[\"分三个环节保证可靠性\",{\"1\":{\"211\":1}}],[\"分片或集群化\",{\"1\":{\"200\":1}}],[\"分级缓存\",{\"1\":{\"198\":1}}],[\"分代回收算法\",{\"1\":{\"148\":1}}],[\"分段锁机制\",{\"1\":{\"125\":1}}],[\"分析导致慢查询的语句\",{\"1\":{\"182\":1}}],[\"分析\",{\"1\":{\"83\":1}}],[\"分类为\",{\"1\":{\"40\":1}}],[\"使⽤位图技巧\",{\"1\":{\"689\":1,\"701\":1}}],[\"使每个子串都是\",{\"1\":{\"688\":1}}],[\"使括号有效的最少添加\",{\"0\":{\"660\":1}}],[\"使\",{\"1\":{\"203\":1}}],[\"使其再次尝试获取同步状态\",{\"1\":{\"141\":1,\"312\":1}}],[\"使其他线程在读取该变量时能够获取最新值\",{\"1\":{\"140\":1}}],[\"使它们都可以独立的变化\",{\"1\":{\"113\":1}}],[\"使得两个子集的元素和相等\",{\"1\":{\"701\":1}}],[\"使得\",{\"1\":{\"687\":1}}],[\"使得它们与\",{\"1\":{\"625\":1}}],[\"使得此点之前的所有独写操作都执行后才可以开始执行此点之后的操作\",{\"1\":{\"290\":1}}],[\"使得可以长时间保留大量的消息\",{\"1\":{\"214\":1}}],[\"使得多个任务可以同时进行处理\",{\"1\":{\"151\":1}}],[\"使得其他等待的线程可以继续执行\",{\"1\":{\"144\":1}}],[\"使得元素能够均匀地分布在不同的桶中\",{\"1\":{\"124\":1}}],[\"使得实体类的功能独立于接口实现类\",{\"1\":{\"113\":1}}],[\"使得二者可以独立变化\",{\"1\":{\"113\":1}}],[\"使得同样的构建过程可以创建不同的表示\",{\"1\":{\"107\":1}}],[\"使得系统的设计更加清晰\",{\"1\":{\"158\":1}}],[\"使得系统更加庞大\",{\"1\":{\"104\":1}}],[\"使得系统中类的个数成倍增加\",{\"1\":{\"101\":1}}],[\"使得我们无需手动配置大量的插件来构建一个完整的spring\",{\"1\":{\"82\":1}}],[\"使用首部字段是为了给浏览器和服务器提供报文主体大小\",{\"1\":{\"784\":1}}],[\"使用cookie的状态管理\",{\"0\":{\"765\":1}}],[\"使用cas是一个很好的选择\",{\"1\":{\"299\":1}}],[\"使用cas后\",{\"1\":{\"295\":1}}],[\"使用快速幂法\",{\"1\":{\"742\":1}}],[\"使用贪心算法\",{\"1\":{\"739\":1}}],[\"使用回溯框架\",{\"1\":{\"716\":1}}],[\"使用数组来存储每个节点的根节点\",{\"1\":{\"709\":1}}],[\"使用数据确认\",{\"1\":{\"156\":1}}],[\"使用图的dfs框架\",{\"1\":{\"706\":1}}],[\"使用动态规划\",{\"1\":{\"687\":1}}],[\"使用深度优先遍历\",{\"1\":{\"669\":1}}],[\"使用单调队列作为窗口\",{\"1\":{\"661\":1}}],[\"使用队列实现栈的下列操作\",{\"1\":{\"656\":1}}],[\"使用栈实现队列的下列操作\",{\"1\":{\"655\":1}}],[\"使用整数\",{\"1\":{\"640\":1}}],[\"使用虚拟头指针next指向原head\",{\"1\":{\"634\":1}}],[\"使用long类型以防超出int类型范围\",{\"1\":{\"627\":1}}],[\"使用递归分解问题\",{\"1\":{\"627\":1}}],[\"使用二分查找法返回的元素下标可能不是唯一的\",{\"1\":{\"620\":1}}],[\"使用dockercompose\",{\"1\":{\"617\":1}}],[\"使用docker\",{\"1\":{\"613\":1,\"617\":1}}],[\"使用连接池代替默认的urlconnection\",{\"1\":{\"606\":1}}],[\"使用量\",{\"1\":{\"605\":2}}],[\"使用响应式编程\",{\"1\":{\"588\":1}}],[\"使用方法\",{\"1\":{\"558\":1}}],[\"使用方式\",{\"1\":{\"133\":1}}],[\"使用对象形式表示\",{\"1\":{\"557\":1}}],[\"使用有参构造器注入\",{\"1\":{\"557\":1}}],[\"使用有序集合\",{\"1\":{\"199\":1}}],[\"使用分步查询处理多对一映射关系\",{\"1\":{\"523\":1}}],[\"使用级联处理多对一映射\",{\"1\":{\"523\":1}}],[\"使用双引号\",{\"1\":{\"517\":1}}],[\"使用简单的\",{\"1\":{\"495\":1}}],[\"使用反射机制调用任意方法\",{\"1\":{\"486\":1}}],[\"使用temp遍历原链表\",{\"1\":{\"634\":1}}],[\"使用tcp协议前\",{\"1\":{\"482\":1}}],[\"使用thymeleaf模板引擎进行web视图的支持\",{\"1\":{\"81\":1}}],[\"使用properties类来读取\",{\"1\":{\"480\":1}}],[\"使用了修饰器设计模式\",{\"1\":{\"478\":1}}],[\"使用了面向对象的多态\",{\"1\":{\"96\":1}}],[\"使用案例\",{\"1\":{\"467\":1}}],[\"使用泛型的数组不能初始化\",{\"1\":{\"457\":1}}],[\"使用泛型\",{\"1\":{\"454\":1}}],[\"使用类似hashtable\",{\"1\":{\"450\":1}}],[\"使用类的静态成员时\",{\"1\":{\"413\":1}}],[\"使用hashcode方法\",{\"1\":{\"445\":1}}],[\"使用普通for\",{\"1\":{\"440\":1}}],[\"使用feign客户端\",{\"1\":{\"606\":1}}],[\"使用for\",{\"1\":{\"440\":1}}],[\"使用freemarker模板引擎进行web视图的支持\",{\"1\":{\"81\":1}}],[\"使用iterator\",{\"1\":{\"440\":1}}],[\"使用ifconfig命令查看主机的ip地址\",{\"1\":{\"49\":1}}],[\"使用while循环遍历\",{\"1\":{\"439\":1}}],[\"使用前必须先使用hasnext判断\",{\"1\":{\"439\":1}}],[\"使用的是\",{\"1\":{\"430\":1}}],[\"使用的底层模型不同\",{\"1\":{\"186\":1}}],[\"使用构造器来搞定\",{\"1\":{\"430\":1}}],[\"使用构造器\",{\"1\":{\"430\":1}}],[\"使用时要加\",{\"1\":{\"422\":1}}],[\"使用时要加上强制转换符\",{\"1\":{\"359\":1}}],[\"使用enum关键字之后就不能再继承其他类了\",{\"1\":{\"421\":1}}],[\"使用enum关键字的类默认会继承enum类\",{\"1\":{\"421\":1}}],[\"使用elasticsearch搜索引擎进行索引和搜索文档的支持\",{\"1\":{\"81\":1}}],[\"使用枚举类型就不需要\",{\"1\":{\"421\":1}}],[\"使用抽象模板来计算任意一段代码的运行时间\",{\"1\":{\"416\":2}}],[\"使用1\",{\"1\":{\"356\":1}}],[\"使用锁可能是个更好的选择\",{\"1\":{\"299\":1}}],[\"使用原子类atomicinteger\",{\"1\":{\"295\":1}}],[\"使用object中的notify\",{\"1\":{\"271\":1}}],[\"使用object中的wait\",{\"1\":{\"271\":1}}],[\"使用多线程很重点的考量点是切换线程的开销\",{\"1\":{\"262\":1}}],[\"使用多个独立的哈希函数将该元素映射到位数组的不同位置\",{\"1\":{\"194\":1}}],[\"使用多个简单的对象一步一步构建成一个复杂的对象\",{\"1\":{\"107\":1}}],[\"使用maven\",{\"1\":{\"617\":1}}],[\"使用main线程处理\",{\"1\":{\"247\":1}}],[\"使用mustache模板引擎进行web视图的支持\",{\"1\":{\"81\":1}}],[\"使用默认内置线程池forkjoinpool\",{\"1\":{\"238\":1,\"239\":1}}],[\"使用内存淘汰策略\",{\"1\":{\"200\":1}}],[\"使用内存分析工具\",{\"1\":{\"146\":2}}],[\"使用相同的哈希函数计算该元素对应的位数组位置\",{\"1\":{\"194\":1}}],[\"使用跳表而非红黑树实现\",{\"0\":{\"193\":1}}],[\"使用一致性哈希实现动态扩容缩容\",{\"1\":{\"190\":1}}],[\"使用频率高得列作为索引\",{\"1\":{\"174\":1}}],[\"使用其他\",{\"1\":{\"168\":1}}],[\"使用其他轻量级的依赖注入框架\",{\"1\":{\"168\":1}}],[\"使用中\",{\"1\":{\"160\":1}}],[\"使用udp进行域名解析\",{\"1\":{\"156\":1}}],[\"使用自己的私钥进行解密\",{\"1\":{\"155\":1}}],[\"使用私钥解密\",{\"1\":{\"155\":1}}],[\"使用服务器公钥加密\",{\"1\":{\"155\":1}}],[\"使用缓存技术\",{\"1\":{\"146\":1}}],[\"使用和实现原理\",{\"0\":{\"144\":1}}],[\"使用操作系统提供的互斥量\",{\"1\":{\"139\":1}}],[\"使用线程池操作\",{\"1\":{\"224\":1}}],[\"使用线程池\",{\"1\":{\"132\":1}}],[\"使用链表进行查找的性能可能变得很差\",{\"1\":{\"124\":1}}],[\"使用链表存储键值对\",{\"1\":{\"124\":1}}],[\"使用链表或红黑树来解决键冲突问题\",{\"1\":{\"124\":1}}],[\"使用迭代器\",{\"1\":{\"124\":1}}],[\"使用桥接模式再适合不过了\",{\"1\":{\"113\":1}}],[\"使用场景\",{\"1\":{\"107\":1,\"113\":1,\"116\":1,\"144\":2,\"177\":6,\"258\":2}}],[\"使用groovy模板引擎进行web视图的支持\",{\"1\":{\"81\":1}}],[\"使用jdk方式要更为合适一些\",{\"1\":{\"492\":1}}],[\"使用jdbc进行数据库访问的支持\",{\"1\":{\"81\":2}}],[\"使用juc包中的condition的await\",{\"1\":{\"271\":1}}],[\"使用jconsole\",{\"1\":{\"264\":1}}],[\"使用jax\",{\"1\":{\"81\":1}}],[\"使用java\",{\"1\":{\"81\":1}}],[\"使用aqs模板实现一个简单的互斥锁\",{\"1\":{\"313\":1}}],[\"使用atomic布尔值同样可以\",{\"1\":{\"268\":1}}],[\"使用apache\",{\"1\":{\"81\":1}}],[\"使用amqp\",{\"1\":{\"81\":1}}],[\"使用注解创建\",{\"1\":{\"572\":1}}],[\"使用注解进行自动装配时需要在配置类中使用\",{\"1\":{\"68\":1}}],[\"使用注解来简化配置\",{\"1\":{\"64\":1}}],[\"使用基于java的编程模式来配置spring应用程序上下文\",{\"1\":{\"64\":1}}],[\"使用技术\",{\"1\":{\"63\":1,\"555\":1}}],[\"使用\",{\"0\":{\"62\":1},\"1\":{\"62\":5,\"72\":2,\"90\":1,\"102\":1,\"124\":3,\"132\":2,\"168\":5,\"186\":1,\"200\":1,\"203\":1,\"205\":1,\"430\":1,\"436\":2,\"511\":2,\"517\":1,\"518\":1,\"522\":1,\"523\":1,\"527\":1,\"531\":1,\"557\":2,\"568\":2,\"569\":1,\"574\":1,\"593\":1,\"780\":1}}],[\"使用stringbuffer\",{\"1\":{\"431\":1}}],[\"使用stringbuilder\",{\"1\":{\"431\":1}}],[\"使用signal\",{\"1\":{\"271\":1}}],[\"使用set\",{\"1\":{\"205\":1}}],[\"使用select\",{\"1\":{\"5\":1}}],[\"使用spring\",{\"1\":{\"81\":1}}],[\"使用scanner读取示例\",{\"1\":{\"55\":1}}],[\"使用scanner读入数据一直超时\",{\"1\":{\"55\":1}}],[\"使用指南\",{\"1\":{\"40\":2}}],[\"使用函数date\",{\"1\":{\"5\":1}}],[\"构成和表示时\",{\"1\":{\"116\":1}}],[\"构建工具等\",{\"1\":{\"82\":1}}],[\"构造树需要的结点类\",{\"1\":{\"730\":1}}],[\"构造差分解法\",{\"1\":{\"677\":1}}],[\"构造器里使用了hashmap的构造器\",{\"1\":{\"445\":1}}],[\"构造器中使用泛型\",{\"1\":{\"457\":1}}],[\"构造器中\",{\"1\":{\"415\":1}}],[\"构造器私有化\",{\"1\":{\"414\":3}}],[\"构造器的最前面隐含了super\",{\"1\":{\"413\":1}}],[\"构造器完成对象的初始化\",{\"1\":{\"392\":1}}],[\"构造器可以不用写修饰符\",{\"1\":{\"392\":1}}],[\"构造器用于类的初始化\",{\"1\":{\"392\":1}}],[\"构造器\",{\"0\":{\"392\":1},\"1\":{\"384\":1,\"393\":1,\"400\":1,\"471\":1}}],[\"构造器方法\",{\"1\":{\"328\":1,\"340\":1}}],[\"构造函数执行结束\",{\"1\":{\"288\":1}}],[\"构造函数是私有的\",{\"1\":{\"98\":1}}],[\"构造\",{\"0\":{\"209\":1}}],[\"构造方法\",{\"1\":{\"53\":1}}],[\"构造方法执行顺序\",{\"0\":{\"53\":1}}],[\"构造代码块\",{\"0\":{\"53\":1},\"1\":{\"53\":1}}],[\"方便用contains方法判断\",{\"1\":{\"713\":1}}],[\"方便实现数据库的增删改查\",{\"1\":{\"574\":1}}],[\"方便进行事务的管理\",{\"1\":{\"549\":1}}],[\"方便和其他框架进行整合\",{\"1\":{\"549\":1}}],[\"方便程序测试\",{\"1\":{\"549\":1}}],[\"方便解耦\",{\"1\":{\"549\":1}}],[\"方便我们使用\",{\"1\":{\"82\":1}}],[\"方便我们构建spring\",{\"1\":{\"82\":1}}],[\"方式注入属性\",{\"1\":{\"557\":1}}],[\"方式创建对象\",{\"1\":{\"557\":1}}],[\"方式\",{\"0\":{\"583\":1},\"1\":{\"430\":4,\"557\":1}}],[\"方法定向获取请求的资源\",{\"1\":{\"775\":1}}],[\"方法定义的形参为父类类型\",{\"1\":{\"405\":1}}],[\"方法3\",{\"1\":{\"624\":1}}],[\"方法二\",{\"1\":{\"623\":1,\"629\":1,\"630\":1,\"635\":1}}],[\"方法一\",{\"1\":{\"623\":1,\"629\":1,\"630\":1,\"635\":1}}],[\"方法进行增强\",{\"1\":{\"571\":1}}],[\"方法之后\",{\"1\":{\"569\":1}}],[\"方法之前\",{\"1\":{\"569\":1}}],[\"方法执行结果为\",{\"1\":{\"569\":1}}],[\"方法执行\",{\"1\":{\"569\":1}}],[\"方法有三个参数\",{\"1\":{\"569\":1}}],[\"方法注入\",{\"1\":{\"557\":1}}],[\"方法便可以完成代理的实现\",{\"1\":{\"492\":1}}],[\"方法无法被子类重写\",{\"1\":{\"492\":1}}],[\"方法将该线程方法挂起\",{\"1\":{\"472\":1}}],[\"方法中返回值可以为泛型\",{\"1\":{\"457\":1}}],[\"方法重写\",{\"0\":{\"401\":1}}],[\"方法重载\",{\"1\":{\"391\":1}}],[\"方法递归调用\",{\"0\":{\"391\":1}}],[\"方法名称\",{\"1\":{\"571\":1}}],[\"方法名\",{\"1\":{\"389\":1,\"401\":1,\"459\":1}}],[\"方法区\",{\"1\":{\"388\":1}}],[\"方法的多态\",{\"1\":{\"402\":1}}],[\"方法的多态体现为对方法的重载\",{\"1\":{\"120\":1}}],[\"方法的局部变量时独立的\",{\"1\":{\"391\":1}}],[\"方法的调用机制\",{\"1\":{\"389\":1}}],[\"方法的作用\",{\"1\":{\"342\":1}}],[\"方法的开始\",{\"1\":{\"288\":1}}],[\"方法调用先行发生于interrupted\",{\"1\":{\"286\":1}}],[\"方法先行发生于此线程的每一个动作\",{\"1\":{\"285\":1}}],[\"方法唤醒线程\",{\"1\":{\"271\":2}}],[\"方法让线程等待\",{\"1\":{\"271\":2}}],[\"方法容易耗费cpu资源\",{\"1\":{\"235\":1}}],[\"方法会阻塞\",{\"1\":{\"235\":1}}],[\"方法会通过自旋和阻塞来等待可用的许可\",{\"1\":{\"144\":1}}],[\"方法会通过自旋和阻塞来等待计数器的值为0\",{\"1\":{\"144\":1}}],[\"方法被调用了\",{\"1\":{\"232\":1}}],[\"方法可以获得类名对应的class对象\",{\"1\":{\"486\":1}}],[\"方法可以返回类的名字\",{\"1\":{\"486\":1}}],[\"方法可以对当前时间进行加或者减\",{\"1\":{\"436\":1}}],[\"方法可以将某个线程设置为守护线程\",{\"1\":{\"227\":1}}],[\"方法可以判断该线程是否为守护线程\",{\"1\":{\"227\":1}}],[\"方法可以抛出受检异常\",{\"1\":{\"133\":1}}],[\"方法2\",{\"0\":{\"653\":1,\"658\":1},\"1\":{\"197\":1,\"624\":1,\"625\":1,\"669\":1,\"686\":1,\"687\":1,\"701\":1,\"709\":1}}],[\"方法1\",{\"0\":{\"652\":1,\"657\":1},\"1\":{\"197\":1,\"624\":1,\"625\":1,\"669\":1,\"701\":1,\"709\":1}}],[\"方法还是会异步执行\",{\"1\":{\"164\":1}}],[\"方法和类\",{\"1\":{\"492\":1}}],[\"方法和hashmap类似\",{\"1\":{\"449\":1}}],[\"方法和对象具有多种形态\",{\"1\":{\"402\":1}}],[\"方法和\",{\"1\":{\"160\":2}}],[\"方法则会通过cas操作将许可数量加1\",{\"1\":{\"144\":1}}],[\"方法则会通过cas操作将计数器的值减1\",{\"1\":{\"144\":1}}],[\"方法上等待的线程会被唤醒继续执行\",{\"1\":{\"144\":1}}],[\"方法释放锁\",{\"1\":{\"142\":1}}],[\"方法时\",{\"1\":{\"141\":1,\"400\":1,\"472\":1}}],[\"方法内部\",{\"1\":{\"141\":4}}],[\"方法设置一个全局的未捕获异常处理器\",{\"1\":{\"133\":1}}],[\"方法不能抛出受检异常\",{\"1\":{\"133\":1}}],[\"方法或\",{\"1\":{\"132\":1}}],[\"方法来构造一个实例\",{\"1\":{\"486\":1}}],[\"方法来动态修改线程池的大小\",{\"1\":{\"134\":1}}],[\"方法来获取任务执行过程中的异常信息\",{\"1\":{\"133\":1}}],[\"方法来定义线程执行的代码\",{\"1\":{\"133\":1}}],[\"方法来定义线程的执行逻辑\",{\"1\":{\"132\":1}}],[\"方法来提交任务\",{\"1\":{\"132\":1}}],[\"方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝\",{\"1\":{\"116\":1}}],[\"方法遍历值\",{\"1\":{\"124\":1}}],[\"方法遍历键值对\",{\"1\":{\"124\":1}}],[\"方法遍历键\",{\"1\":{\"124\":1}}],[\"方法都是synchronized\",{\"1\":{\"120\":1}}],[\"方法获取锁\",{\"1\":{\"142\":1}}],[\"方法获取了\",{\"1\":{\"83\":1}}],[\"方法获得mapper实例\",{\"1\":{\"83\":1}}],[\"方法\",{\"1\":{\"66\":1,\"116\":1,\"141\":5,\"198\":1,\"278\":1,\"304\":1,\"312\":1,\"328\":2,\"339\":1,\"384\":1,\"393\":1,\"398\":2,\"400\":4,\"417\":1,\"419\":1,\"422\":2,\"430\":2,\"457\":1,\"472\":1,\"479\":1,\"492\":1,\"540\":1,\"560\":3,\"569\":1,\"602\":1,\"622\":1,\"631\":1,\"632\":1,\"634\":1,\"636\":1,\"637\":1,\"638\":1,\"639\":1,\"640\":1,\"642\":1,\"643\":1,\"644\":1,\"645\":1,\"646\":1,\"647\":1,\"648\":1,\"650\":1,\"655\":1,\"659\":1,\"660\":1,\"661\":1,\"667\":1,\"668\":1,\"677\":1,\"678\":1,\"684\":1,\"685\":1,\"686\":1,\"687\":1,\"688\":1,\"690\":1,\"694\":1,\"696\":1,\"697\":1,\"698\":1,\"706\":1,\"708\":1,\"712\":1,\"715\":1,\"716\":1,\"717\":1,\"718\":1,\"720\":1,\"721\":1,\"775\":1}}],[\"稳健的基础\",{\"1\":{\"82\":1}}],[\"该题与上题逻辑相同\",{\"1\":{\"739\":1}}],[\"该题的关键是找一个能满足函数\",{\"1\":{\"720\":1}}],[\"该操作会使得关键字\",{\"1\":{\"720\":2}}],[\"该序列不会重复出现相同的数字\",{\"1\":{\"718\":1}}],[\"该图是无向图\",{\"1\":{\"716\":1}}],[\"该无向图同时具有以下属性\",{\"1\":{\"716\":1}}],[\"该数列由\",{\"1\":{\"694\":1}}],[\"该数据为常量\",{\"1\":{\"492\":1}}],[\"该数据永远都是脏数据\",{\"1\":{\"195\":1}}],[\"该策略和轮询策略类似\",{\"1\":{\"598\":1}}],[\"该策略定义了如何处理这些被拒绝的任务\",{\"1\":{\"135\":1}}],[\"该对象本身可以修改\",{\"1\":{\"492\":1}}],[\"该接口有方法需要实现\",{\"1\":{\"478\":1}}],[\"该接口用于创建当前对象的克隆\",{\"1\":{\"116\":1}}],[\"该函数将返回左旋转两位得到的结果\",{\"1\":{\"646\":1}}],[\"该函数的传入参数propagate一定是非负数\",{\"1\":{\"318\":1}}],[\"该函数式接口不接受任何输入参数\",{\"1\":{\"129\":1}}],[\"该函数式接口接受一个输入参数\",{\"1\":{\"129\":3}}],[\"该字段被初始化为condition\",{\"1\":{\"312\":1}}],[\"该字段被初始化为0\",{\"1\":{\"312\":1}}],[\"该线程不会释放锁\",{\"1\":{\"472\":1}}],[\"该线程抢锁失败\",{\"1\":{\"205\":1}}],[\"该线程成功得到了锁\",{\"1\":{\"205\":1}}],[\"该线程进入临界区执行\",{\"1\":{\"139\":1}}],[\"该方法会和对象的运行类型绑定\",{\"1\":{\"403\":1}}],[\"该方法就不能被子类重写或覆盖\",{\"1\":{\"127\":1}}],[\"该方案也会出问题\",{\"1\":{\"195\":1}}],[\"该类必须实现如下两个接口之一\",{\"1\":{\"478\":1}}],[\"该类所有对象共享的变量\",{\"1\":{\"411\":1}}],[\"该类就不能被继承\",{\"1\":{\"127\":1}}],[\"该类负责创建自己的对象\",{\"1\":{\"98\":1}}],[\"该变量就成为一个常量\",{\"1\":{\"127\":1}}],[\"该超级工厂又称为其他工厂的工厂\",{\"1\":{\"110\":1}}],[\"该\",{\"1\":{\"107\":1}}],[\"该二叉树的数组表示\",{\"1\":{\"90\":1}}],[\"该节点所在路径和中最大值和最小值的平均值\",{\"1\":{\"90\":1}}],[\"该项目提供了一个优秀\",{\"1\":{\"82\":1}}],[\"该bean仅在当前会话的范围内可见\",{\"1\":{\"65\":1}}],[\"该bean仅在当前请求的范围内可见\",{\"1\":{\"65\":1}}],[\"轻型目录访问协议\",{\"1\":{\"81\":1}}],[\"轻量级锁升级为重量级锁\",{\"1\":{\"139\":1}}],[\"轻量级锁使用cas操作将对象头部的mark\",{\"1\":{\"139\":1}}],[\"轻量级锁\",{\"1\":{\"139\":1}}],[\"轻量级\",{\"1\":{\"61\":1,\"496\":1}}],[\"发现不匹配\",{\"1\":{\"653\":1}}],[\"发现需要删除节点则pre跳过\",{\"1\":{\"634\":1}}],[\"发现需要删除的数后整个数组从该位置整体前移一位\",{\"1\":{\"623\":1}}],[\"发现删除的数后整体向前移一位\",{\"1\":{\"623\":1}}],[\"发现\",{\"1\":{\"597\":1}}],[\"发现安装有问题\",{\"1\":{\"49\":1}}],[\"发出通知\",{\"1\":{\"271\":3}}],[\"发送的一份报文可以含有多类型实体\",{\"1\":{\"769\":1}}],[\"发送多种数据的\",{\"0\":{\"769\":1}}],[\"发送后会进行三次握手\",{\"1\":{\"753\":1}}],[\"发送\",{\"1\":{\"606\":1,\"779\":1}}],[\"发送请求\",{\"1\":{\"606\":1}}],[\"发送http请求的客户端还是通过调用其他包来实现的\",{\"1\":{\"606\":1}}],[\"发送http请求\",{\"1\":{\"596\":1,\"597\":1,\"606\":1}}],[\"发送数据结束时无需断开连接\",{\"1\":{\"482\":1}}],[\"发送消息到\",{\"1\":{\"210\":1}}],[\"发送给\",{\"1\":{\"204\":1}}],[\"发送给服务器\",{\"1\":{\"165\":1}}],[\"发送给客户端保存\",{\"1\":{\"165\":1}}],[\"发送服务器证书\",{\"1\":{\"155\":1}}],[\"发送和接收消息的支持\",{\"1\":{\"81\":1}}],[\"高级\",{\"0\":{\"410\":1}}],[\"高级消息队列协议\",{\"1\":{\"81\":1}}],[\"高效的消息存储和检索\",{\"1\":{\"214\":1}}],[\"高吞吐量的流式数据处理\",{\"1\":{\"213\":1}}],[\"高并发导致程序无法有效地释放已经处理过的对象\",{\"1\":{\"146\":1}}],[\"高\",{\"1\":{\"120\":1}}],[\"高质量的代码生成类库\",{\"1\":{\"72\":1}}],[\"以请求报文的首部字段为参考\",{\"1\":{\"771\":1}}],[\"以判断是否是二叉搜索树为例\",{\"1\":{\"730\":1}}],[\"以字符串形式作为输入\",{\"1\":{\"729\":1}}],[\"以反转链表为例\",{\"1\":{\"729\":1}}],[\"以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点\",{\"1\":{\"716\":1}}],[\"以使isonsyncqueue方法更容易处理\",{\"1\":{\"312\":1}}],[\"以haystack中的每一个字符为起点判断一次\",{\"1\":{\"652\":1}}],[\"以下这些都可以视作\",{\"1\":{\"628\":1}}],[\"以下几种\",{\"1\":{\"606\":1}}],[\"以下是lambda表达式的重要特征\",{\"1\":{\"488\":1}}],[\"以下是spring\",{\"1\":{\"81\":1}}],[\"以远端单环境配置为准\",{\"1\":{\"604\":1}}],[\"以多环境共享文件为准\",{\"1\":{\"604\":1}}],[\"以\",{\"1\":{\"512\":2,\"628\":1,\"715\":1,\"720\":1}}],[\"以包的方式引入映射文件\",{\"1\":{\"509\":1}}],[\"以此类推\",{\"1\":{\"445\":1,\"653\":1}}],[\"以此来减少数据库调用\",{\"1\":{\"116\":1}}],[\"以接收任意类型数据\",{\"1\":{\"431\":1}}],[\"以一个字符为标准分割\",{\"1\":{\"429\":1}}],[\"以简化使用\",{\"1\":{\"312\":1}}],[\"以确保传播继续\",{\"1\":{\"312\":1}}],[\"以确保消息被正确处理\",{\"1\":{\"213\":1}}],[\"以确保数据持久性和一致性\",{\"1\":{\"177\":1}}],[\"以确保数据的保密性和完整性\",{\"1\":{\"155\":1}}],[\"以复用一条\",{\"1\":{\"209\":1}}],[\"以保证即使没有被显式释放\",{\"1\":{\"205\":1}}],[\"以保证数据的持久化\",{\"1\":{\"189\":1}}],[\"以上步骤就会产生一个问题\",{\"1\":{\"602\":1}}],[\"以上操作\",{\"1\":{\"193\":1}}],[\"以上命令的含义\",{\"1\":{\"86\":1}}],[\"以及递推公式\",{\"1\":{\"697\":1}}],[\"以及下标的含义\",{\"1\":{\"692\":1}}],[\"以及\",{\"1\":{\"651\":1}}],[\"以及为什么这样就可以用到联合索引\",{\"0\":{\"175\":1}}],[\"以及这个汽车里面的具体实现\",{\"1\":{\"101\":1}}],[\"以适应应用程序的内存需求\",{\"1\":{\"146\":1}}],[\"以提高执行效率\",{\"1\":{\"128\":1}}],[\"以提高查找效率\",{\"1\":{\"124\":1}}],[\"以我们\",{\"1\":{\"93\":1}}],[\"以快速构建spring\",{\"1\":{\"82\":1}}],[\"以便bean执行一些清理操作\",{\"1\":{\"160\":1}}],[\"以便bean可以执行一些初始化的操作\",{\"1\":{\"160\":1}}],[\"以便在后续的处理中能够使用更加精确的语义来描述这些组件\",{\"1\":{\"69\":1}}],[\"以便\",{\"1\":{\"12\":1}}],[\"名称空间注入\",{\"1\":{\"557\":1}}],[\"名称\",{\"1\":{\"401\":1}}],[\"名\",{\"1\":{\"81\":1}}],[\"做选择\",{\"1\":{\"683\":1,\"684\":1,\"689\":1,\"701\":1}}],[\"做一些释放资源的操作\",{\"1\":{\"406\":1}}],[\"做网络开发\",{\"1\":{\"396\":1}}],[\"做健康检测\",{\"1\":{\"80\":1}}],[\"做过的项目\",{\"1\":{\"0\":1}}],[\"默认是按照声明顺序从1递增\",{\"1\":{\"607\":1}}],[\"默认是覆盖写入\",{\"1\":{\"477\":1}}],[\"默认过滤器\",{\"1\":{\"607\":1}}],[\"默认集成了\",{\"1\":{\"593\":1}}],[\"默认按类型注入\",{\"1\":{\"564\":1}}],[\"默认按两者中精度最高的类型来输出\",{\"1\":{\"427\":1}}],[\"默认情况下\",{\"1\":{\"559\":1}}],[\"默认情况下总会去调用父类的无参构造器\",{\"1\":{\"399\":1}}],[\"默认情况是不设置\",{\"1\":{\"536\":1}}],[\"默认为false\",{\"1\":{\"540\":1}}],[\"默认为true\",{\"1\":{\"535\":1}}],[\"默认为object\",{\"1\":{\"457\":1}}],[\"默认类型为string\",{\"1\":{\"480\":1}}],[\"默认设备\",{\"1\":{\"478\":1}}],[\"默认将里面所有属性都序列化\",{\"1\":{\"478\":1}}],[\"默认object\",{\"1\":{\"458\":1}}],[\"默认10\",{\"1\":{\"442\":1}}],[\"默认名称以\",{\"1\":{\"419\":1}}],[\"默认返回结果是两个对象使用\",{\"1\":{\"492\":1}}],[\"默认返回对象的属性\",{\"1\":{\"421\":1}}],[\"默认返回\",{\"1\":{\"406\":1}}],[\"默认判断对象地址是否相等\",{\"1\":{\"406\":1}}],[\"默认级别\",{\"1\":{\"397\":1}}],[\"默认引入\",{\"1\":{\"396\":1}}],[\"默认退出最近的循环体\",{\"1\":{\"377\":1}}],[\"默认语句块\",{\"1\":{\"372\":1}}],[\"默认编码iso\",{\"1\":{\"335\":1}}],[\"默认执行方式\",{\"1\":{\"248\":1}}],[\"默认不开启\",{\"1\":{\"167\":1}}],[\"默认开启\",{\"1\":{\"167\":1}}],[\"默认端口\",{\"1\":{\"154\":1}}],[\"默认\",{\"1\":{\"134\":1,\"397\":1,\"401\":1,\"501\":1,\"536\":2,\"606\":1}}],[\"默认阈值为\",{\"1\":{\"124\":1}}],[\"默认的就失效\",{\"1\":{\"392\":1}}],[\"默认的异步执行方式\",{\"1\":{\"248\":1}}],[\"默认的隔离级别\",{\"1\":{\"171\":1}}],[\"默认的负载因子是\",{\"1\":{\"124\":1}}],[\"默认的starter\",{\"1\":{\"81\":1}}],[\"默认静态资源处理器\",{\"1\":{\"78\":1}}],[\"默认值是类名首字母小写\",{\"1\":{\"563\":1}}],[\"默认值\",{\"1\":{\"65\":1,\"501\":1}}],[\"重复子问题为不同长度的绳子\",{\"1\":{\"736\":1}}],[\"重点\",{\"1\":{\"711\":2}}],[\"重新插入到队尾\",{\"1\":{\"720\":2}}],[\"重新添加到队列尾部\",{\"1\":{\"658\":1}}],[\"重新连接\",{\"1\":{\"204\":1}}],[\"重置为升序\",{\"1\":{\"628\":1}}],[\"重命名为cluster\",{\"1\":{\"605\":1}}],[\"重试策略\",{\"1\":{\"598\":2}}],[\"重试抢锁等\",{\"1\":{\"258\":1}}],[\"重载overload\",{\"1\":{\"401\":1}}],[\"重载与重写的区别\",{\"1\":{\"401\":1}}],[\"重排序后的代码则可能会出现问题\",{\"1\":{\"292\":1}}],[\"重排序后的指令在单线程中运行时没有问题的\",{\"1\":{\"292\":1}}],[\"重做日志用于记录在事务提交之前对数据所做的修改操作\",{\"1\":{\"180\":1}}],[\"重做日志\",{\"1\":{\"180\":1}}],[\"重定向状态码\",{\"0\":{\"775\":1},\"1\":{\"155\":1}}],[\"重定向则是将原始请求的响应被替换为一个新的响应\",{\"1\":{\"77\":1}}],[\"重量级锁会将线程置于阻塞状态\",{\"1\":{\"139\":1}}],[\"重量级锁\",{\"1\":{\"139\":1}}],[\"重写invoke方法\",{\"1\":{\"419\":1}}],[\"重写tostring方法打印该对象和拼接对象时\",{\"1\":{\"406\":1}}],[\"重写和重载就体现了方法的多态\",{\"1\":{\"402\":1}}],[\"重写override\",{\"1\":{\"401\":1}}],[\"重写run方法\",{\"1\":{\"132\":1,\"466\":2}}],[\"重写\",{\"1\":{\"116\":2,\"492\":2}}],[\"重写的registerbeandefinitions\",{\"1\":{\"83\":1}}],[\"重要的内容\",{\"1\":{\"24\":1}}],[\"转变为路由判断的条件\",{\"1\":{\"607\":1}}],[\"转账\",{\"1\":{\"583\":1}}],[\"转账事务\",{\"0\":{\"583\":1}}],[\"转账分成两步\",{\"1\":{\"580\":1}}],[\"转义特殊字符\",{\"1\":{\"557\":1}}],[\"转换流\",{\"1\":{\"478\":1}}],[\"转换成reader\",{\"1\":{\"478\":1}}],[\"转换成string\",{\"1\":{\"477\":1}}],[\"转换成list\",{\"1\":{\"433\":1}}],[\"转换为图论问题中的查找是否有闭环问题\",{\"1\":{\"717\":1}}],[\"转换为0\",{\"1\":{\"687\":1}}],[\"转换为\",{\"1\":{\"199\":1}}],[\"转换为shared\",{\"1\":{\"3\":1}}],[\"转化为红黑树后\",{\"1\":{\"124\":1}}],[\"转接头\",{\"1\":{\"95\":1}}],[\"转发时需要附加\",{\"1\":{\"780\":1}}],[\"转发指的是在原始请求的基础上将其转发到其他url上\",{\"1\":{\"77\":1}}],[\"转发和重定向的区别\",{\"0\":{\"77\":1}}],[\"核心数据结构\",{\"1\":{\"711\":1}}],[\"核心是基于\",{\"1\":{\"588\":1}}],[\"核心配置文件之\",{\"0\":{\"506\":1,\"507\":1,\"508\":1,\"509\":1}}],[\"核心配置文件\",{\"0\":{\"499\":1,\"505\":1},\"1\":{\"522\":1}}],[\"核心\",{\"1\":{\"402\":1}}],[\"核心机制\",{\"0\":{\"348\":1}}],[\"核心思想是什么\",{\"1\":{\"310\":1}}],[\"核心线程在一段时间内都处于空闲状态\",{\"1\":{\"136\":1}}],[\"核心线程可能会被回收\",{\"1\":{\"136\":1}}],[\"核心线程能否被回收\",{\"0\":{\"136\":1}}],[\"核心线程数\",{\"1\":{\"135\":1}}],[\"核心功能之一\",{\"1\":{\"80\":1}}],[\"核心架构的具体流程步骤如下\",{\"1\":{\"76\":1}}],[\"核心容器\",{\"1\":{\"60\":1}}],[\"再首部字段host中写明域名或ip地址\",{\"1\":{\"762\":1}}],[\"再进行操作\",{\"1\":{\"729\":1}}],[\"再进入该线程的内层方法\",{\"1\":{\"263\":1}}],[\"再使用回溯算法遍历\",{\"1\":{\"718\":1}}],[\"再使用0\",{\"1\":{\"701\":1}}],[\"再\",{\"1\":{\"718\":1}}],[\"再把被围绕的区域淹没\",{\"1\":{\"709\":1}}],[\"再加入左孩子呢\",{\"1\":{\"665\":1}}],[\"再加入左孩子\",{\"1\":{\"665\":1}}],[\"再添加回去\",{\"1\":{\"655\":1}}],[\"再向极小值的两边找极大值\",{\"1\":{\"624\":1}}],[\"再通过一个pre指针来连接新链表\",{\"1\":{\"634\":1}}],[\"再通过负载均衡算法获得服务\",{\"1\":{\"598\":1}}],[\"再通过mapper扫描配置类把扫描到的mapper接口注册为mapperfactorybean\",{\"1\":{\"83\":1}}],[\"再运行主线程\",{\"1\":{\"468\":1}}],[\"再将hash值转换为索引值\",{\"1\":{\"445\":1}}],[\"再将服务端应答返回客户端\",{\"1\":{\"208\":1}}],[\"再根据具体情况把这些方法写出来\",{\"1\":{\"417\":1}}],[\"再从数组中间位置开始比较\",{\"1\":{\"381\":1}}],[\"再从内存缓冲区中读取数据\",{\"1\":{\"55\":1}}],[\"再初始化a\",{\"1\":{\"381\":1}}],[\"再判断\",{\"1\":{\"375\":1}}],[\"再对版本号标志进行检查\",{\"1\":{\"299\":1}}],[\"再次使用同一个\",{\"1\":{\"534\":1}}],[\"再次删除\",{\"1\":{\"196\":1}}],[\"再次淘汰缓存\",{\"1\":{\"196\":1}}],[\"再写数据库\",{\"1\":{\"196\":1}}],[\"再更新数据库\",{\"1\":{\"195\":1}}],[\"再更新缓存\",{\"1\":{\"195\":1}}],[\"再检查当前键值是否过期\",{\"1\":{\"191\":1}}],[\"再生成view视图对象\",{\"1\":{\"76\":1}}],[\"根据浏览器的默认语言来切换\",{\"1\":{\"771\":1}}],[\"根据mac地址发送\",{\"1\":{\"752\":1}}],[\"根据差分数组构造结果数组\",{\"1\":{\"677\":1,\"678\":1}}],[\"根据初始数组构造差分数组\",{\"1\":{\"677\":1,\"678\":1}}],[\"根据注解中的地址\",{\"1\":{\"606\":1}}],[\"根据定义的接口信息\",{\"1\":{\"606\":1}}],[\"根据服务所在区域\",{\"1\":{\"598\":1}}],[\"根据每个服务提供者的响应时间分配一个权重\",{\"1\":{\"598\":1}}],[\"根据expression\",{\"1\":{\"563\":2}}],[\"根据属性名称进行注入\",{\"1\":{\"564\":1}}],[\"根据属性名注入\",{\"1\":{\"561\":1}}],[\"根据属性类型进行自动装配\",{\"1\":{\"564\":1}}],[\"根据属性类型注入\",{\"1\":{\"561\":1,\"564\":1}}],[\"根据数据库的schema再生成一层package\",{\"1\":{\"540\":1}}],[\"根据条件查询员工信息\",{\"1\":{\"527\":1}}],[\"根据条件动态拼接\",{\"1\":{\"526\":1}}],[\"根据id查询\",{\"1\":{\"504\":1}}],[\"根据指定主机名\",{\"1\":{\"483\":2}}],[\"根据指定秒数来获得日期\",{\"1\":{\"436\":1}}],[\"根据\",{\"1\":{\"480\":1}}],[\"根据父目录+子路径构建\",{\"1\":{\"475\":1}}],[\"根据父目录文件+子路径构建\",{\"1\":{\"475\":2}}],[\"根据路径构建一个file对象\",{\"1\":{\"475\":1}}],[\"根据路由键将消息路由到绑定的队列上\",{\"1\":{\"209\":1}}],[\"根据键获取值\",{\"1\":{\"480\":1}}],[\"根据键获取键值\",{\"1\":{\"448\":1}}],[\"根据键删除映射关系\",{\"1\":{\"448\":1}}],[\"根据valueof函数\",{\"1\":{\"428\":1}}],[\"根据上面的valueof函数所示\",{\"1\":{\"428\":1}}],[\"根据上面提供的信息\",{\"1\":{\"419\":1}}],[\"根据不同符号来变化字节长度\",{\"1\":{\"356\":1}}],[\"根据doreleaseshared因为此时的head的ws已经被置为0\",{\"1\":{\"318\":2}}],[\"根据线程号使用jstack\",{\"1\":{\"264\":1}}],[\"根据异常参数进一步处理\",{\"1\":{\"244\":1}}],[\"根据runnable构建执行任务\",{\"1\":{\"239\":2}}],[\"根据supplier构建执行任务\",{\"1\":{\"238\":2}}],[\"根据该分数进行排序\",{\"1\":{\"188\":1}}],[\"根据业务逻辑进行处理\",{\"1\":{\"161\":1}}],[\"根据请求的\",{\"1\":{\"161\":1}}],[\"根据请求的url查找handler\",{\"1\":{\"76\":1}}],[\"根据分析结果\",{\"1\":{\"146\":1}}],[\"根据入度遍历\",{\"1\":{\"91\":1}}],[\"根据公式从上往下计算节点值\",{\"1\":{\"90\":1}}],[\"根据逻辑视图名解析成真正的视图\",{\"1\":{\"76\":1}}],[\"相连\",{\"1\":{\"709\":1}}],[\"相连的\",{\"1\":{\"709\":1}}],[\"相邻的节点没有访问过\",{\"1\":{\"716\":1}}],[\"相邻的房屋装有相互连通的防盗系统\",{\"1\":{\"698\":1}}],[\"相邻\",{\"1\":{\"705\":1}}],[\"相邻节点入度减\",{\"1\":{\"91\":1}}],[\"相加\",{\"1\":{\"624\":1}}],[\"相结合\",{\"1\":{\"593\":1}}],[\"相机停止工作\",{\"1\":{\"417\":1}}],[\"相机开始工作\",{\"1\":{\"417\":1}}],[\"相同的概率\",{\"1\":{\"721\":1}}],[\"相同则不是二分图\",{\"1\":{\"716\":1}}],[\"相同或父子类关系\",{\"1\":{\"401\":1}}],[\"相同\",{\"1\":{\"401\":3}}],[\"相同入度内存相加\",{\"1\":{\"91\":1}}],[\"相同入度的任务同时执行\",{\"1\":{\"91\":1}}],[\"相应的交换器根据接收到的路由键查找匹配的队列\",{\"1\":{\"210\":1}}],[\"相对于rabbitmq\",{\"1\":{\"213\":1}}],[\"相对于其他消息的优先权\",{\"1\":{\"209\":1}}],[\"相对耗时\",{\"1\":{\"124\":1}}],[\"相关方法\",{\"1\":{\"483\":1}}],[\"相关的修改操作首先被写入重做日志中\",{\"1\":{\"180\":1}}],[\"相关信息\",{\"1\":{\"14\":1}}],[\"相比之下\",{\"1\":{\"156\":1}}],[\"相比于使用字符数组存储\",{\"1\":{\"121\":1}}],[\"相当于装满了\",{\"1\":{\"701\":1}}],[\"相当于\",{\"1\":{\"530\":1}}],[\"相当于流的指针在尾端\",{\"1\":{\"477\":1}}],[\"相当于流的指针在首端\",{\"1\":{\"477\":1}}],[\"相当于下方注释的cat类\",{\"1\":{\"418\":1}}],[\"相当于去争抢对象监视器修改对象中的锁标识\",{\"1\":{\"260\":1}}],[\"相当于是从远程获取最新版本并merge到本地\",{\"1\":{\"86\":1}}],[\"相当于是从远程获取最新版本到本地\",{\"1\":{\"86\":1}}],[\"相当于转发器\",{\"1\":{\"76\":1}}],[\"由服务器端进行协商\",{\"1\":{\"771\":1}}],[\"由节点\",{\"1\":{\"716\":1}}],[\"由若干字符\",{\"1\":{\"709\":1}}],[\"由1包围\",{\"1\":{\"708\":1}}],[\"由\",{\"1\":{\"650\":1,\"708\":1}}],[\"由两部分组成\",{\"1\":{\"611\":1}}],[\"由我们自己指定\",{\"1\":{\"607\":1}}],[\"由框架负责根据数据库表\",{\"1\":{\"540\":1}}],[\"由框架负责根据实体类生成数据库表\",{\"1\":{\"540\":1}}],[\"由框架提供\",{\"1\":{\"76\":3}}],[\"由网络层的ip协议和传输层的tcp协议组成\",{\"1\":{\"482\":1}}],[\"由这个代理类实现多个接口\",{\"1\":{\"419\":1}}],[\"由condition使用\",{\"1\":{\"312\":1}}],[\"由addwaiter方法使用\",{\"1\":{\"312\":1}}],[\"由消息头和消息体组成\",{\"1\":{\"209\":1}}],[\"由权威的证书颁发机构\",{\"1\":{\"154\":1}}],[\"由调用线程处理该任务\",{\"1\":{\"134\":1}}],[\"由于cglib由于是采用动态创建子类的方法\",{\"1\":{\"492\":1}}],[\"由于\",{\"1\":{\"492\":1}}],[\"由于代理对象要实现与目标对象一致的接口\",{\"1\":{\"419\":1}}],[\"由于经过了sethead\",{\"1\":{\"318\":1}}],[\"由于共享锁是可以被多个线程获取的\",{\"1\":{\"318\":1}}],[\"由于条件只能是独占的\",{\"1\":{\"312\":1}}],[\"由于超时或中断\",{\"1\":{\"312\":1}}],[\"由于读写速度缓慢\",{\"1\":{\"274\":1}}],[\"由于kafka采用了批量写入和顺序写入的方式\",{\"1\":{\"213\":1}}],[\"由于b+树的叶子节点通过指针连接成有序链表\",{\"1\":{\"172\":1}}],[\"由于b树的节点即存储关键字又存储数据\",{\"1\":{\"172\":1}}],[\"由于其他并发事务的插入或删除操作\",{\"1\":{\"171\":1}}],[\"由于tcp提供的可靠性和保证数据顺序到达的机制\",{\"1\":{\"156\":1}}],[\"由于拉丁字符在编码时只需要占用一个字节\",{\"1\":{\"121\":1}}],[\"由于聚合关联关系建立在抽象层\",{\"1\":{\"113\":1}}],[\"由于需求的变化\",{\"1\":{\"107\":1}}],[\"由于handler涉及到具体的用户业务请求\",{\"1\":{\"76\":1}}],[\"由于在实现上采用了引用计数\",{\"1\":{\"3\":1}}],[\"由它调用其它组件处理用户的请求\",{\"1\":{\"76\":1}}],[\"即范围请求\",{\"1\":{\"770\":1}}],[\"即最久未用的key\",{\"1\":{\"720\":1}}],[\"即最大位\",{\"1\":{\"629\":1}}],[\"即dfs\",{\"1\":{\"716\":1}}],[\"即从中断处恢复下载\",{\"1\":{\"770\":1}}],[\"即从节点\",{\"1\":{\"715\":1}}],[\"即从头结点开始唤醒其后继节点\",{\"1\":{\"317\":1}}],[\"即为根节点\",{\"1\":{\"709\":2}}],[\"即让它们指向同一个根节点\",{\"1\":{\"709\":1}}],[\"即被\",{\"1\":{\"708\":1}}],[\"即每个背包的承重\",{\"1\":{\"701\":1}}],[\"即能否等分\",{\"1\":{\"701\":1}}],[\"即能否等分为两个子集\",{\"1\":{\"689\":1,\"701\":2}}],[\"即继承之前的结果\",{\"1\":{\"700\":1}}],[\"即左括号的数量一定要大于右括号\",{\"1\":{\"690\":1}}],[\"即逐层地\",{\"1\":{\"666\":1}}],[\"即两个\",{\"1\":{\"649\":1}}],[\"即类名不区分大小写\",{\"1\":{\"508\":1}}],[\"即隐性的具有\",{\"1\":{\"491\":1}}],[\"即显示器\",{\"1\":{\"479\":1}}],[\"即当一个线程对内存进行操作时\",{\"1\":{\"470\":1}}],[\"即没有synchronized关键字\",{\"1\":{\"431\":1}}],[\"即没有得到真正结果返回的替代值\",{\"1\":{\"241\":1}}],[\"即父类为public时子类不能是protected\",{\"1\":{\"401\":1}}],[\"即构造器重载\",{\"1\":{\"392\":1}}],[\"即可实现对象创建\",{\"1\":{\"557\":1}}],[\"即可退出线程\",{\"1\":{\"467\":1}}],[\"即可\",{\"1\":{\"360\":1}}],[\"即可执行\",{\"1\":{\"352\":2}}],[\"即可以触发watcher解除阻塞重新去获取锁\",{\"1\":{\"217\":1}}],[\"即可以快速定位到符合条件的数据行\",{\"1\":{\"176\":1}}],[\"即进入acquirequeued中的for\",{\"1\":{\"317\":1}}],[\"即进入到操作系统的等待队列中等待唤醒\",{\"1\":{\"143\":1}}],[\"即其他没有获取到资源的线程会阻塞\",{\"1\":{\"295\":1}}],[\"即复制\",{\"1\":{\"274\":1}}],[\"即cpu的运算速度远比内存的读写速度快\",{\"1\":{\"274\":1}}],[\"即生产者可以一次性发送多条消息\",{\"1\":{\"214\":1}}],[\"即增加服务器数量\",{\"1\":{\"214\":1}}],[\"即淘汰使用频率最低的缓存数据\",{\"1\":{\"192\":1}}],[\"即淘汰最久未被使用的缓存数据\",{\"1\":{\"192\":1}}],[\"即淘汰最早添加的缓存数据\",{\"1\":{\"192\":1}}],[\"即重做日志\",{\"1\":{\"180\":1}}],[\"即在一个事务中两次执行相同查询\",{\"1\":{\"178\":1}}],[\"即在方法内部不能对参数进行赋值操作\",{\"1\":{\"127\":1}}],[\"即根据索引的最左边的几列进行匹配\",{\"1\":{\"176\":1}}],[\"即大部分行都有不同的值\",{\"1\":{\"174\":1}}],[\"即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作\",{\"1\":{\"170\":1}}],[\"即a依赖b\",{\"1\":{\"163\":1}}],[\"即\",{\"1\":{\"161\":1,\"628\":1,\"650\":1}}],[\"即使用同一个对象来start线程\",{\"1\":{\"471\":1}}],[\"即使用默认的443端口\",{\"1\":{\"155\":1}}],[\"即使其他操作已经介入\",{\"1\":{\"312\":1}}],[\"即使丢失一些数据包\",{\"1\":{\"156\":1}}],[\"即使这些线程是空闲的\",{\"1\":{\"135\":1}}],[\"即找不到所需的类\",{\"1\":{\"147\":1}}],[\"即线程成功将节点加入到同步队列的尾部\",{\"1\":{\"143\":1}}],[\"即通过关键字直接修饰方法或代码块\",{\"1\":{\"142\":1}}],[\"即将一个图中连通的部分划分出来\",{\"1\":{\"709\":1}}],[\"即将\",{\"1\":{\"312\":1}}],[\"即将任务返回给调用者进行处理\",{\"1\":{\"134\":1}}],[\"即将模型数据填充至视图中\",{\"1\":{\"76\":1}}],[\"即不能有子类\",{\"1\":{\"127\":1}}],[\"即业务逻辑层\",{\"1\":{\"69\":1}}],[\"也应该在\",{\"1\":{\"716\":1}}],[\"也为根节点\",{\"1\":{\"709\":2}}],[\"也出发一个指针\",{\"1\":{\"640\":1}}],[\"也可做为中转服务器提升传输效率\",{\"1\":{\"778\":1}}],[\"也可from\",{\"1\":{\"616\":1}}],[\"也可根据名称\",{\"1\":{\"564\":1}}],[\"也可以通过编码来提升传输速率\",{\"1\":{\"768\":1}}],[\"也可以通过对象名调用\",{\"1\":{\"411\":1}}],[\"也可以提供更方便的方法来完成输入输出\",{\"1\":{\"478\":1}}],[\"也可以使用自己声明的泛型\",{\"1\":{\"459\":1}}],[\"也可以定义在泛型类中\",{\"1\":{\"459\":1}}],[\"也可以由system\",{\"1\":{\"406\":1}}],[\"也可以用super指定一个\",{\"1\":{\"399\":1}}],[\"也可以根据排名获取元素\",{\"1\":{\"188\":1}}],[\"也可以基于字节流\",{\"1\":{\"55\":1}}],[\"也叫最小并发数策略\",{\"1\":{\"598\":1}}],[\"也叫工作线程当线程的任务执行完或通知方式结束\",{\"1\":{\"468\":1}}],[\"也叫后端控制器\",{\"1\":{\"76\":1}}],[\"也会引起实参的改变\",{\"1\":{\"389\":1}}],[\"也会改变arr1的值\",{\"1\":{\"381\":1}}],[\"也会同时创建一个filterconfig类\",{\"1\":{\"341\":1}}],[\"也会同步这些数据\",{\"1\":{\"204\":1}}],[\"也称为mysql\",{\"1\":{\"183\":1}}],[\"也是最常用的支持事务的引擎\",{\"1\":{\"183\":1}}],[\"也是基于原型链模式\",{\"1\":{\"93\":1}}],[\"也不会对整体体验产生重大影响\",{\"1\":{\"156\":1}}],[\"也就是\",{\"1\":{\"694\":1}}],[\"也就是把原问题转化成\",{\"1\":{\"687\":1}}],[\"也就是left指针所在位置\",{\"1\":{\"649\":1}}],[\"也就是它可以保证你在修改对象引用时的线程安全性\",{\"1\":{\"297\":1}}],[\"也就是接收消息的一方\",{\"1\":{\"209\":1}}],[\"也就是客户端和服务端之间的网络传输延迟\",{\"1\":{\"187\":1}}],[\"也就是撤销操作\",{\"1\":{\"180\":1}}],[\"也就是说两个节点\",{\"1\":{\"716\":1}}],[\"也就是说cas机制不能更新成功\",{\"1\":{\"299\":1}}],[\"也就是说\",{\"1\":{\"175\":1,\"677\":1}}],[\"也就是说明明使用了\",{\"1\":{\"164\":1}}],[\"也就是fifo双向队列\",{\"1\":{\"141\":1,\"312\":1}}],[\"也就是同一个线程可以多次获取同一个锁\",{\"1\":{\"141\":1}}],[\"也就是图中这一款\",{\"1\":{\"95\":1}}],[\"也无需xml配置文件就能完成所有配置工作\",{\"1\":{\"80\":1}}],[\"观察者模式\",{\"1\":{\"73\":1}}],[\"代替\",{\"1\":{\"584\":1}}],[\"代理是一种有转发功能的应用程序\",{\"1\":{\"780\":1}}],[\"代理类字节码\",{\"1\":{\"492\":1}}],[\"代理对象和实际对象都继承了同一个接口\",{\"1\":{\"492\":1}}],[\"代理可以分为\",{\"1\":{\"492\":1}}],[\"代理\",{\"0\":{\"419\":1,\"780\":1},\"1\":{\"492\":1,\"780\":1}}],[\"代理模式\",{\"1\":{\"73\":1}}],[\"代表结束\",{\"1\":{\"718\":1}}],[\"代表已经访问过该节点\",{\"1\":{\"716\":1}}],[\"代表两种不同颜⾊\",{\"1\":{\"716\":1}}],[\"代表可以解锁的数字\",{\"1\":{\"713\":1}}],[\"代表生成括号的对数\",{\"1\":{\"690\":1}}],[\"代表缓存可以存储多少个对象\",{\"1\":{\"536\":1}}],[\"代表当前对象\",{\"1\":{\"393\":1}}],[\"代表了一个特定的应用类型\",{\"1\":{\"81\":1}}],[\"代码方式\",{\"1\":{\"598\":1}}],[\"代码分开\",{\"1\":{\"496\":1}}],[\"代码中application\",{\"1\":{\"605\":1}}],[\"代码中\",{\"1\":{\"496\":1}}],[\"代码可能有异常\",{\"1\":{\"424\":1}}],[\"代码实现\",{\"1\":{\"414\":1}}],[\"代码重用\",{\"1\":{\"123\":1}}],[\"代码量轻便\",{\"1\":{\"61\":1}}],[\"代码演示\",{\"0\":{\"34\":1}}],[\"代码块互斥锁在this\",{\"1\":{\"471\":1}}],[\"代码块\",{\"0\":{\"19\":1,\"413\":1},\"1\":{\"384\":1}}],[\"代码\",{\"1\":{\"18\":1,\"413\":1,\"424\":1,\"458\":1,\"459\":1,\"495\":1}}],[\"单元格是那些水平相邻或垂直相邻的单元格\",{\"1\":{\"705\":1}}],[\"单调栈\",{\"0\":{\"662\":1}}],[\"单调队列\",{\"0\":{\"661\":1},\"1\":{\"661\":1}}],[\"单队列实现\",{\"0\":{\"658\":1}}],[\"单链表\",{\"1\":{\"635\":2}}],[\"单一类型\",{\"1\":{\"631\":1}}],[\"单一职责\",{\"1\":{\"595\":1}}],[\"单指针暴力法\",{\"1\":{\"623\":1}}],[\"单位为字节\",{\"1\":{\"605\":4}}],[\"单位毫秒\",{\"1\":{\"536\":1}}],[\"单个路径的最大连接数\",{\"1\":{\"606\":1}}],[\"单个聚合数据的子配置大小上限\",{\"1\":{\"605\":2}}],[\"单个配置大小上限\",{\"1\":{\"605\":2}}],[\"单个实例\",{\"1\":{\"414\":1}}],[\"单体非集群\",{\"1\":{\"599\":1}}],[\"单体架构\",{\"1\":{\"595\":1}}],[\"单引号内使用\",{\"1\":{\"517\":1}}],[\"单独使用一个取的值为null\",{\"1\":{\"501\":1}}],[\"单字符\",{\"1\":{\"477\":1}}],[\"单字节读取\",{\"1\":{\"477\":1}}],[\"单列\",{\"1\":{\"451\":2}}],[\"单目运行\",{\"1\":{\"367\":1}}],[\"单精度\",{\"1\":{\"358\":1}}],[\"单行注释\",{\"1\":{\"354\":1}}],[\"单播或广播的消息传递\",{\"1\":{\"213\":1}}],[\"单机模式\",{\"1\":{\"212\":2}}],[\"单机\",{\"1\":{\"203\":1}}],[\"单实例类\",{\"1\":{\"99\":1}}],[\"单例设计模式\",{\"0\":{\"414\":1}}],[\"单例类必须给所有其他对象提供这一实例\",{\"1\":{\"98\":1}}],[\"单例类必须自己创建自己的唯一实例\",{\"1\":{\"98\":1}}],[\"单例类只能有一个实例\",{\"1\":{\"98\":1}}],[\"单例模式应用实例\",{\"1\":{\"414\":1}}],[\"单例模式有两种\",{\"1\":{\"414\":1}}],[\"单例模式\",{\"0\":{\"97\":1},\"1\":{\"73\":1,\"98\":1}}],[\"单词中的字母已标出\",{\"1\":{\"705\":1}}],[\"单词必须按照字母顺序\",{\"1\":{\"705\":1}}],[\"单词插入trie\",{\"1\":{\"675\":1}}],[\"单词的压缩编码\",{\"0\":{\"675\":1}}],[\"单词\",{\"1\":{\"22\":1}}],[\"就要像服务器请求从中断处开始的范围内容\",{\"1\":{\"770\":1}}],[\"就量初给化\",{\"1\":{\"718\":1}}],[\"就将这个图称为\",{\"1\":{\"716\":1}}],[\"就将指针指向下一个元素\",{\"1\":{\"439\":1}}],[\"就把与之相邻的陆地都淹掉\",{\"1\":{\"707\":1,\"708\":1,\"709\":1}}],[\"就把他删除\",{\"1\":{\"661\":1}}],[\"就相当于双背包问题\",{\"1\":{\"701\":1}}],[\"就表示子串\",{\"1\":{\"650\":1}}],[\"就表示文件读取完毕\",{\"1\":{\"478\":1}}],[\"就可以退出当前循环\",{\"1\":{\"650\":1}}],[\"就可以移动左指针了\",{\"1\":{\"649\":1}}],[\"就可以了\",{\"1\":{\"643\":1}}],[\"就可以调用类中的方法\",{\"1\":{\"427\":1}}],[\"就反转这\",{\"1\":{\"643\":1}}],[\"就能得到一个更大的数\",{\"1\":{\"628\":1}}],[\"就没有执行下一个查询语句\",{\"1\":{\"524\":1}}],[\"就应该使用\",{\"1\":{\"492\":1}}],[\"就会在请求中包含从服务器接收到\",{\"1\":{\"785\":1}}],[\"就会显示一条连接信息\",{\"1\":{\"485\":1}}],[\"就会输出到\",{\"1\":{\"479\":1}}],[\"就会\",{\"1\":{\"471\":2}}],[\"就会先得到\",{\"1\":{\"471\":2}}],[\"就会报错\",{\"1\":{\"454\":1}}],[\"就会使用垃圾回收机制来销毁该对象\",{\"1\":{\"406\":1}}],[\"就会调用\",{\"1\":{\"161\":1}}],[\"就创建一个新的受保护的独立栈空间\",{\"1\":{\"391\":1}}],[\"就重试\",{\"1\":{\"295\":1}}],[\"就像一般的嵌入式操作系统\",{\"1\":{\"224\":1}}],[\"就有可能产生相同的时间日期\",{\"1\":{\"216\":1}}],[\"就有可能导致数据的错乱和不一致\",{\"1\":{\"171\":1}}],[\"就是遍历二叉树\",{\"1\":{\"667\":1}}],[\"就是求两个链表交点节点的指针\",{\"1\":{\"639\":1}}],[\"就是\",{\"1\":{\"628\":1}}],[\"就是在这个有序容器中排在它后面的那个排列\",{\"1\":{\"628\":1}}],[\"就是将其所有成员以序列或线性顺序排列\",{\"1\":{\"628\":1}}],[\"就是注入属性\",{\"1\":{\"557\":1}}],[\"就是子类有一个和父类相同的方法\",{\"1\":{\"401\":1}}],[\"就是接口\",{\"1\":{\"326\":1}}],[\"就是对线程等待唤醒机制的优化\",{\"1\":{\"270\":1}}],[\"就是demo级别的\",{\"1\":{\"212\":1}}],[\"就是投递消息的一方\",{\"1\":{\"209\":1}}],[\"就是只能为接口创建代理实例\",{\"1\":{\"72\":1}}],[\"就支持主从复制的断点续传\",{\"1\":{\"204\":1}}],[\"就无法再改变\",{\"1\":{\"127\":1}}],[\"就不会从头匹配\",{\"1\":{\"653\":1}}],[\"就不会有这种问题\",{\"1\":{\"5\":1}}],[\"就不需要使用大括号\",{\"1\":{\"488\":1}}],[\"就不计算右边表达式\",{\"1\":{\"364\":1}}],[\"就不能省略了\",{\"1\":{\"129\":1}}],[\"就不可避免地出现多个进程或线程同时操作一个文件的现象\",{\"1\":{\"98\":1}}],[\"就必须用转接头\",{\"1\":{\"95\":1}}],[\"接他们和放他们的位置分别是\",{\"1\":{\"677\":1}}],[\"接雨水\",{\"0\":{\"624\":1}}],[\"接受一个\",{\"1\":{\"489\":1}}],[\"接受2个参数\",{\"1\":{\"489\":1}}],[\"接受生产者发送的消息\",{\"1\":{\"209\":1}}],[\"接着遍历整张图当发现o时让它与它上下左右四个节点相连\",{\"1\":{\"709\":1}}],[\"接着变成b\",{\"1\":{\"299\":1}}],[\"接着cpu对数据进行处理\",{\"1\":{\"274\":1}}],[\"接下来共n行\",{\"1\":{\"730\":1}}],[\"接下来就要说一说怎么计算前缀表\",{\"1\":{\"653\":1}}],[\"接下来其唤醒主要为两个判断逻辑\",{\"1\":{\"318\":1}}],[\"接下来\",{\"1\":{\"163\":1}}],[\"接下来要出现的数据的行数\",{\"1\":{\"55\":1}}],[\"接收到客户端的请求时\",{\"1\":{\"780\":1}}],[\"接收到请求后\",{\"1\":{\"161\":1}}],[\"接收由客户端发送的请求并转发给服务器\",{\"1\":{\"780\":1}}],[\"接收2个int型整数\",{\"1\":{\"489\":1}}],[\"接收一个参数\",{\"1\":{\"489\":1}}],[\"接收其他用户的输入\",{\"1\":{\"409\":1}}],[\"接收的nums为一个int数组\",{\"1\":{\"391\":1}}],[\"接收者看到的还是原始请求的url\",{\"1\":{\"77\":1}}],[\"接收请求\",{\"1\":{\"76\":1}}],[\"接口实现类\",{\"1\":{\"555\":1}}],[\"接口和映射文件所在的包必须一致\",{\"1\":{\"509\":1}}],[\"接口和抽象类的区别\",{\"0\":{\"120\":1},\"1\":{\"120\":1}}],[\"接口<t>\",{\"1\":{\"456\":1}}],[\"接口多态传递\",{\"1\":{\"417\":1}}],[\"接口vs继承\",{\"1\":{\"417\":1}}],[\"接口的网络请求框架\",{\"1\":{\"593\":1}}],[\"接口的子接口\",{\"1\":{\"555\":1}}],[\"接口的名字和映射文件必须一致\",{\"1\":{\"509\":1}}],[\"接口的全类名和\",{\"1\":{\"501\":1}}],[\"接口的传递性让teacher类也实现了ih0接口\",{\"1\":{\"417\":1}}],[\"接口的多态\",{\"1\":{\"417\":1}}],[\"接口的修饰符只能用public或默认\",{\"1\":{\"417\":1}}],[\"接口的类\",{\"1\":{\"132\":1}}],[\"接口不能继承类\",{\"1\":{\"417\":1}}],[\"接口不能被实例化\",{\"1\":{\"417\":1}}],[\"接口不能实例化\",{\"1\":{\"120\":1}}],[\"接口中\",{\"1\":{\"458\":1}}],[\"接口中的方法方法名和映射文件中的\",{\"1\":{\"501\":1}}],[\"接口中的属性是final\",{\"1\":{\"417\":1}}],[\"接口中的抽象方法可以不写abstract\",{\"1\":{\"417\":1}}],[\"接口中的所有方法是public方法\",{\"1\":{\"417\":1}}],[\"接口中的所有成员变量都是public\",{\"1\":{\"120\":1}}],[\"接口中abstract可以省略\",{\"1\":{\"417\":1}}],[\"接口名\",{\"1\":{\"417\":1,\"458\":1}}],[\"接口是行为的抽象\",{\"1\":{\"120\":1}}],[\"接口是负责创建一个相关对象的工厂\",{\"1\":{\"110\":1}}],[\"接口\",{\"0\":{\"417\":1,\"500\":1},\"1\":{\"72\":1,\"116\":2,\"417\":1,\"419\":1,\"492\":2,\"569\":1}}],[\"类全路径\",{\"1\":{\"571\":1}}],[\"类里的\",{\"1\":{\"571\":1}}],[\"类里的哪些方法可以被增强\",{\"1\":{\"570\":1}}],[\"类里的主方法\",{\"1\":{\"352\":2}}],[\"类添加对象注解\",{\"1\":{\"564\":1}}],[\"类似地\",{\"1\":{\"628\":1}}],[\"类似\",{\"1\":{\"557\":1,\"588\":1}}],[\"类似c++中的函数指针\",{\"1\":{\"486\":1}}],[\"类似于date\",{\"1\":{\"436\":1}}],[\"类似于simpledateformat类\",{\"1\":{\"436\":1}}],[\"类似于方法\",{\"1\":{\"413\":1}}],[\"类似于关联数组或字典\",{\"1\":{\"188\":1}}],[\"类似于\",{\"1\":{\"186\":1}}],[\"类似于标准的\",{\"1\":{\"65\":1}}],[\"类和接口\",{\"1\":{\"476\":1}}],[\"类<k\",{\"1\":{\"456\":1}}],[\"类静态方法\",{\"1\":{\"413\":2}}],[\"类静态变量\",{\"1\":{\"411\":1}}],[\"类什么时候被加载\",{\"1\":{\"413\":1}}],[\"类成员\",{\"1\":{\"413\":1}}],[\"类方法可以通过类名调用\",{\"1\":{\"411\":1}}],[\"类方法中无this参数\",{\"1\":{\"411\":1}}],[\"类方法\",{\"1\":{\"411\":1}}],[\"类名保存为\",{\"1\":{\"419\":1}}],[\"类名\",{\"1\":{\"411\":1,\"417\":1,\"457\":1}}],[\"类变量名\",{\"1\":{\"411\":1}}],[\"类变量就叫静态变量\",{\"1\":{\"411\":1}}],[\"类变量\",{\"1\":{\"411\":1}}],[\"类变量和类方法\",{\"0\":{\"411\":1}}],[\"类加载器\",{\"1\":{\"569\":1}}],[\"类加载器的一种工作方式\",{\"1\":{\"147\":1}}],[\"类加载信息\",{\"1\":{\"388\":1}}],[\"类是对象的模板\",{\"1\":{\"384\":1}}],[\"类是独立于其他对象的\",{\"1\":{\"107\":1}}],[\"类与对象的内存分配机制\",{\"0\":{\"388\":1}}],[\"类与对象介绍\",{\"0\":{\"384\":1}}],[\"类与实现\",{\"1\":{\"72\":1}}],[\"类型属性\",{\"1\":{\"564\":1}}],[\"类型可以和返回的类型不一样\",{\"1\":{\"558\":1}}],[\"类型就是你的返回类型\",{\"1\":{\"558\":1}}],[\"类型别名用别名来代替一个复杂的名字\",{\"1\":{\"508\":1}}],[\"类型变量的限定\",{\"1\":{\"461\":1}}],[\"类型不能再指向其他字符串\",{\"1\":{\"429\":1}}],[\"类型\",{\"1\":{\"359\":1,\"382\":2,\"478\":1,\"504\":1,\"558\":1}}],[\"类型安全\",{\"1\":{\"123\":1}}],[\"类设置线程池的属性\",{\"1\":{\"134\":1}}],[\"类来创建线程池\",{\"1\":{\"134\":1}}],[\"类初始化需要消化非常多的资源\",{\"1\":{\"116\":1}}],[\"类的回调方法来实现\",{\"1\":{\"492\":1}}],[\"类的常见方法\",{\"1\":{\"429\":1}}],[\"类的内部创建对象\",{\"1\":{\"414\":2}}],[\"类的五大成员\",{\"1\":{\"384\":1}}],[\"类的说明文档\",{\"1\":{\"354\":1}}],[\"类的多态体现为继承\",{\"1\":{\"120\":1}}],[\"类的\",{\"1\":{\"116\":1}}],[\"类\",{\"1\":{\"111\":1,\"422\":2,\"552\":1,\"575\":2,\"720\":1,\"721\":1}}],[\"类会一步一步构造最终的对象\",{\"1\":{\"107\":1}}],[\"动态规划题\",{\"1\":{\"736\":1}}],[\"动态规划二维dp问题\",{\"1\":{\"696\":1}}],[\"动态规划问题五步曲\",{\"1\":{\"692\":1}}],[\"动态规划\",{\"0\":{\"624\":1,\"691\":1},\"1\":{\"624\":1,\"650\":1,\"701\":1}}],[\"动态\",{\"0\":{\"526\":1}}],[\"动态设置表名\",{\"0\":{\"519\":1}}],[\"动态绑定机制\",{\"1\":{\"404\":1}}],[\"动态初始化方法二\",{\"1\":{\"381\":1}}],[\"动态资源\",{\"1\":{\"323\":1}}],[\"动态修改\",{\"0\":{\"134\":1}}],[\"动态创建\",{\"1\":{\"72\":1,\"159\":1}}],[\"动态将横切逻辑和业务逻辑编制在一起\",{\"1\":{\"72\":1,\"159\":1}}],[\"动态代理代码\",{\"1\":{\"569\":1}}],[\"动态代理限制了只能基于接口设计\",{\"1\":{\"492\":1}}],[\"动态代理是基于接口设计实现的\",{\"1\":{\"492\":1}}],[\"动态代理只需要实现\",{\"1\":{\"492\":1}}],[\"动态代理又分为\",{\"1\":{\"492\":1}}],[\"动态代理介绍\",{\"1\":{\"419\":1}}],[\"动态代理相比较\",{\"1\":{\"72\":1}}],[\"动态代理主要涉及到\",{\"1\":{\"72\":1,\"159\":1}}],[\"动态代理\",{\"0\":{\"569\":1},\"1\":{\"72\":2,\"159\":1,\"492\":2,\"568\":3,\"569\":1}}],[\"创建运行一个nginx容器\",{\"1\":{\"614\":1}}],[\"创建接口代理\",{\"1\":{\"606\":1}}],[\"创建接口实现类的代理对象\",{\"1\":{\"569\":1}}],[\"创建时间\",{\"1\":{\"605\":6}}],[\"创建spring容器\",{\"1\":{\"602\":2}}],[\"创建simpledateformat对象来指定格式\",{\"1\":{\"436\":1}}],[\"创建jdbc对象\",{\"1\":{\"584\":1}}],[\"创建数据库连接池\",{\"1\":{\"584\":1}}],[\"创建事务管理器\",{\"1\":{\"583\":1,\"584\":1}}],[\"创建增强类\",{\"1\":{\"572\":1}}],[\"创建配置类\",{\"1\":{\"565\":1}}],[\"创建到销毁的过程\",{\"1\":{\"560\":1}}],[\"创建userdao属性\",{\"1\":{\"557\":1}}],[\"创建bufferedreader\",{\"1\":{\"478\":2}}],[\"创建方式\",{\"1\":{\"477\":2}}],[\"创建多级目录\",{\"1\":{\"475\":1}}],[\"创建一级目录\",{\"1\":{\"475\":1}}],[\"创建一个volume\",{\"1\":{\"615\":1}}],[\"创建一个接口\",{\"1\":{\"606\":1}}],[\"创建一个接口实现类代理对象\",{\"1\":{\"72\":1,\"568\":1}}],[\"创建一个实体类\",{\"1\":{\"576\":1}}],[\"创建一个\",{\"1\":{\"560\":2}}],[\"创建一个将传给代理类的调用请求处理器\",{\"1\":{\"419\":1}}],[\"创建一个子类对象时\",{\"1\":{\"413\":1}}],[\"创建一个对象时\",{\"1\":{\"413\":1}}],[\"创建一个不确定列数的二维数组\",{\"1\":{\"382\":1}}],[\"创建一个int数组\",{\"1\":{\"381\":1}}],[\"创建一个扫描仪接收键盘输入\",{\"1\":{\"368\":1}}],[\"创建一个线程局部变量\",{\"1\":{\"304\":1}}],[\"创建一个位数组\",{\"1\":{\"194\":1}}],[\"创建新文件\",{\"1\":{\"475\":1}}],[\"创建文件对象相关构造器和方法\",{\"1\":{\"475\":1}}],[\"创建线程的两种方式\",{\"1\":{\"466\":1}}],[\"创建日历类对象\",{\"1\":{\"436\":1}}],[\"创建代理实例\",{\"1\":{\"419\":1}}],[\"创建代理对象\",{\"1\":{\"419\":1,\"569\":1}}],[\"创建代理有一个限制\",{\"1\":{\"72\":1}}],[\"创建被代理的对象\",{\"1\":{\"419\":1}}],[\"创建子类对象实例\",{\"1\":{\"413\":1}}],[\"创建不同的文件夹目录来保存类文件\",{\"1\":{\"396\":1}}],[\"创建对象的类路径\",{\"1\":{\"557\":1}}],[\"创建对象的方式\",{\"1\":{\"130\":1}}],[\"创建对象\",{\"1\":{\"480\":1,\"557\":1}}],[\"创建对象实例时\",{\"1\":{\"413\":1}}],[\"创建对象时默认使用的无参构造\",{\"1\":{\"557\":1}}],[\"创建对象时\",{\"1\":{\"392\":1}}],[\"创建\",{\"0\":{\"499\":1,\"500\":1},\"1\":{\"387\":1,\"436\":1,\"477\":1,\"478\":2,\"575\":2,\"581\":1,\"583\":1}}],[\"创建threadlocalmap\",{\"1\":{\"306\":1,\"307\":1}}],[\"创建节点\",{\"1\":{\"143\":1}}],[\"创建的每一个对象使用==\",{\"1\":{\"130\":1}}],[\"创建的\",{\"1\":{\"130\":1,\"535\":1}}],[\"创建并返回\",{\"1\":{\"130\":1}}],[\"创建和提供实例\",{\"1\":{\"107\":1}}],[\"创建过程在其子类执行\",{\"1\":{\"101\":1}}],[\"创建类\",{\"1\":{\"95\":1,\"558\":1,\"572\":1}}],[\"创建动态代理\",{\"1\":{\"72\":1}}],[\"创建当前类子类的代理对象\",{\"1\":{\"72\":1,\"568\":1}}],[\"创建工厂类\",{\"1\":{\"63\":1,\"555\":1}}],[\"有约束的dfs题\",{\"1\":{\"733\":1}}],[\"有则代表有循环依赖\",{\"1\":{\"718\":1}}],[\"有向无环图\",{\"1\":{\"715\":1}}],[\"有可能将其分成\",{\"1\":{\"689\":1}}],[\"有可能因为系统优化切换原则\",{\"1\":{\"247\":1}}],[\"有几种排列方式\",{\"1\":{\"681\":1}}],[\"有效的\",{\"1\":{\"690\":1}}],[\"有效的括号\",{\"0\":{\"659\":1}}],[\"有效而必须添加的最少括号数\",{\"1\":{\"660\":1}}],[\"有效字符串需满足\",{\"1\":{\"659\":1}}],[\"有效字符对应的数量比目标子串少\",{\"1\":{\"649\":1}}],[\"有多大长度的相同前缀后缀\",{\"1\":{\"653\":2}}],[\"有\",{\"1\":{\"625\":1}}],[\"有哪些负载均衡策略\",{\"1\":{\"598\":1}}],[\"有哪些缓存策略\",{\"0\":{\"167\":1}}],[\"有三个读问题\",{\"1\":{\"582\":1}}],[\"有三种模式\",{\"1\":{\"212\":1}}],[\"有两种类型\",{\"1\":{\"558\":1}}],[\"有两种方式\",{\"1\":{\"419\":1}}],[\"有两个核心部分\",{\"1\":{\"546\":1}}],[\"有客户端连接则会返回socket对象\",{\"1\":{\"485\":1}}],[\"有参构造1\",{\"1\":{\"442\":1}}],[\"有属性\",{\"1\":{\"429\":1}}],[\"有了类的特点\",{\"1\":{\"427\":1}}],[\"有了dispatcherservlet减少了其它组件之间的耦合度\",{\"1\":{\"76\":1}}],[\"有static\",{\"1\":{\"418\":1}}],[\"有类名\",{\"1\":{\"418\":1}}],[\"有静态代码块和普通代码块\",{\"1\":{\"413\":1}}],[\"有异常也可以继续执行\",{\"1\":{\"244\":1}}],[\"有返回值\",{\"0\":{\"238\":1},\"1\":{\"242\":1}}],[\"有返回值的方法\",{\"1\":{\"129\":1}}],[\"有返回值的抽象方法\",{\"1\":{\"129\":1}}],[\"有网络故障\",{\"1\":{\"204\":1}}],[\"有序数组的平方\",{\"0\":{\"629\":1}}],[\"有序集合\",{\"1\":{\"188\":1}}],[\"有序性\",{\"0\":{\"278\":1},\"1\":{\"140\":1,\"273\":1}}],[\"有序性和原子性的规范\",{\"1\":{\"140\":1}}],[\"有没有遇到过oom\",{\"0\":{\"146\":1}}],[\"有的话直接取缓存中的值\",{\"1\":{\"130\":1}}],[\"有一份航班预订表\",{\"1\":{\"678\":1}}],[\"有一个大小为\",{\"1\":{\"661\":1}}],[\"有一个admin目录\",{\"1\":{\"339\":1}}],[\"有一个形参的抽象方法\",{\"1\":{\"129\":1}}],[\"有一些通用的方法\",{\"1\":{\"104\":1}}],[\"有时候面临着\",{\"1\":{\"107\":1}}],[\"有接口情况\",{\"1\":{\"72\":1,\"568\":1}}],[\"有何区别\",{\"0\":{\"69\":1}}],[\"您需要一辆汽车\",{\"1\":{\"101\":1}}],[\"您需要计算从首次登录日期开始至少连续两天登录的玩家的数量\",{\"1\":{\"5\":1}}],[\"您可以使用\",{\"1\":{\"71\":1}}],[\"时=\",{\"1\":{\"436\":1}}],[\"时分秒输出\",{\"1\":{\"436\":1}}],[\"时分秒\",{\"1\":{\"436\":2}}],[\"时间获取元素\",{\"1\":{\"721\":1}}],[\"时间复杂度为\",{\"1\":{\"721\":1}}],[\"时间复杂度跟跳表一样o\",{\"1\":{\"193\":1}}],[\"时间插入\",{\"0\":{\"721\":1}}],[\"时间\",{\"1\":{\"436\":1}}],[\"时间戳\",{\"1\":{\"300\":1}}],[\"时间单位\",{\"1\":{\"135\":1}}],[\"时使用\",{\"1\":{\"177\":1}}],[\"时\",{\"1\":{\"71\":1,\"166\":1,\"478\":3,\"559\":2,\"649\":1}}],[\"下次客户端再发送请求时会自动在请求报文中加入cookie值后发送\",{\"1\":{\"765\":1}}],[\"下\",{\"1\":{\"704\":1,\"708\":1}}],[\"下标i之前\",{\"1\":{\"653\":1}}],[\"下到上\",{\"1\":{\"632\":1}}],[\"下雨之后能接多少雨水\",{\"1\":{\"624\":1}}],[\"下一轮交换\",{\"1\":{\"637\":1}}],[\"下一个排列应该把\",{\"1\":{\"628\":1}}],[\"下一个排列与当前排列紧邻\",{\"1\":{\"628\":1}}],[\"下一个排列\",{\"0\":{\"628\":1},\"1\":{\"628\":3}}],[\"下一个更高温度出现在几天后\",{\"1\":{\"622\":1}}],[\"下一篇\",{\"1\":{\"10\":1}}],[\"下载nacos安装包\",{\"1\":{\"605\":1}}],[\"下载nacos发行版本\",{\"1\":{\"599\":1}}],[\"下划线驼峰替换\",{\"1\":{\"522\":1}}],[\"下午好\",{\"1\":{\"108\":1}}],[\"下面为分割等和子集通用回溯法\",{\"1\":{\"689\":1}}],[\"下面是一个服务器的响应报文\",{\"1\":{\"760\":1}}],[\"下面是一个客户端的请求报文\",{\"1\":{\"760\":1}}],[\"下面是一个鉴权的全局过滤器功能实现\",{\"1\":{\"607\":1}}],[\"下面是它们的简要说明\",{\"1\":{\"607\":1}}],[\"下面是rabbitmq和kafka之间的主要区别\",{\"1\":{\"213\":1}}],[\"下面的条件都不会判断\",{\"1\":{\"530\":1}}],[\"下面的操作不会释放锁\",{\"1\":{\"472\":1}}],[\"下面就是同步代码\",{\"1\":{\"471\":1}}],[\"下面两种情况需要使用throws方法来抛出异常\",{\"1\":{\"425\":1}}],[\"下面3个抽象的方法交给子类去实现\",{\"1\":{\"105\":1}}],[\"下面这个例子是通过\",{\"1\":{\"70\":1}}],[\"会告知服务器\",{\"1\":{\"785\":1}}],[\"会碰到超出数组边界的情况\",{\"1\":{\"704\":1}}],[\"会超时\",{\"1\":{\"701\":1}}],[\"会数组越界\",{\"1\":{\"695\":1}}],[\"会直接影响这一行之后的结果\",{\"1\":{\"687\":1}}],[\"会按照defaultfilter\",{\"1\":{\"607\":1}}],[\"会按照运行的类型动态地调用方法\",{\"1\":{\"404\":1}}],[\"会返回缓存对象的拷贝\",{\"1\":{\"536\":1}}],[\"会给所有调用者返回缓存对象的相同实例\",{\"1\":{\"536\":1}}],[\"会使一级和二级缓存同时失效\",{\"1\":{\"535\":1}}],[\"会使用\",{\"1\":{\"15\":1}}],[\"会话对象\",{\"0\":{\"502\":1}}],[\"会设置它的值\",{\"1\":{\"501\":1}}],[\"会抛异常\",{\"1\":{\"492\":1}}],[\"会很冗余\",{\"1\":{\"492\":1}}],[\"会覆盖原来的内容\",{\"1\":{\"477\":1}}],[\"会封装到hashmap$node对象中\",{\"1\":{\"448\":1}}],[\"会被隐式的调用\",{\"1\":{\"413\":1}}],[\"会重写hashcode方法\",{\"1\":{\"406\":1}}],[\"会优先执行运行类型中的方法\",{\"1\":{\"402\":1}}],[\"会顺序执行语句块到末尾\",{\"1\":{\"372\":1}}],[\"会进行类型转换\",{\"1\":{\"365\":1}}],[\"会把其中的数值型转为字符串\",{\"1\":{\"357\":1}}],[\"会把首节点唤醒\",{\"1\":{\"141\":1,\"312\":1}}],[\"会包装为node挂载到condition条件阻塞队列中\",{\"1\":{\"319\":1}}],[\"会通过setheadandpropagate传递唤醒后续的阻塞节点\",{\"1\":{\"318\":1}}],[\"会通过唤醒操作将同步队列中的等待线程唤醒\",{\"1\":{\"141\":1}}],[\"会首先从内存中取出运算指令\",{\"1\":{\"274\":1}}],[\"会根据生产者的配置丢弃或者退回给生产者\",{\"1\":{\"210\":1}}],[\"会根据具体的实现逻辑将state的值进行修改\",{\"1\":{\"141\":1}}],[\"会有原子性问题\",{\"1\":{\"205\":1}}],[\"会有很多的建造类\",{\"1\":{\"107\":1}}],[\"会在底层关闭\",{\"1\":{\"478\":1}}],[\"会在栈中再开辟一个新的独立空间来执行方法\",{\"1\":{\"389\":1}}],[\"会在内存中常见一个\",{\"1\":{\"204\":1}}],[\"会在cookie或者url参数中传递给服务器\",{\"1\":{\"153\":1}}],[\"会导致\",{\"1\":{\"517\":1}}],[\"会导致短时间大量请求落在数据库上\",{\"1\":{\"197\":1}}],[\"会导致查询速度下降\",{\"1\":{\"173\":1}}],[\"会周期性的随机测试一批设置了过期时间的\",{\"1\":{\"191\":1}}],[\"会浪费一定的事件去移动和请求\",{\"1\":{\"186\":1}}],[\"会从缓存中获取\",{\"1\":{\"534\":1}}],[\"会从\",{\"1\":{\"165\":1}}],[\"会生成目标对象的子类\",{\"1\":{\"159\":1}}],[\"会验证其合法性和真实性\",{\"1\":{\"155\":1}}],[\"会将内存中缓存的写命令发送给\",{\"1\":{\"204\":1}}],[\"会将这个\",{\"1\":{\"204\":1}}],[\"会将脏数据读到缓存\",{\"1\":{\"195\":1}}],[\"会将处理结果封装成一个\",{\"1\":{\"161\":1}}],[\"会将自己的ssl\",{\"1\":{\"155\":1}}],[\"会将其通信协议指定为https\",{\"1\":{\"155\":1}}],[\"会调用aqs的release\",{\"1\":{\"141\":1}}],[\"会调用aqs的acquire\",{\"1\":{\"141\":1}}],[\"会调用reentrantlock的unlock\",{\"1\":{\"141\":1}}],[\"会减少state的高16位\",{\"1\":{\"141\":1}}],[\"会增加state的高16位\",{\"1\":{\"141\":1}}],[\"会先写入本地磁盘\",{\"1\":{\"204\":1}}],[\"会先根据具体的实现逻辑判断当前线程是否能够直接获取锁\",{\"1\":{\"141\":1}}],[\"会先尝试用cas操作将state的高16位减1\",{\"1\":{\"141\":1}}],[\"会先尝试用cas操作将state的高16位增加1\",{\"1\":{\"141\":1}}],[\"会先调用reentrantlock的lock\",{\"1\":{\"141\":1}}],[\"会升级为轻量级锁\",{\"1\":{\"139\":1}}],[\"会检查对象的mark\",{\"1\":{\"139\":1}}],[\"会释放monitor锁\",{\"1\":{\"139\":1}}],[\"会自动生成命名空间id\",{\"1\":{\"599\":1}}],[\"会自动退出\",{\"1\":{\"467\":1}}],[\"会自动释放锁\",{\"1\":{\"261\":1}}],[\"会自动重连\",{\"1\":{\"204\":1}}],[\"会自动获取锁\",{\"1\":{\"142\":1,\"263\":1}}],[\"会自动进行扩容\",{\"1\":{\"124\":1}}],[\"会自动将标注了\",{\"1\":{\"69\":1}}],[\"自治\",{\"1\":{\"595\":1}}],[\"自己还活着\",{\"1\":{\"600\":1}}],[\"自己编写\",{\"1\":{\"496\":1}}],[\"自己的方法\",{\"1\":{\"417\":1}}],[\"自己的属性\",{\"1\":{\"417\":1}}],[\"自由\",{\"1\":{\"436\":1}}],[\"自减\",{\"1\":{\"362\":2}}],[\"自增\",{\"1\":{\"362\":2}}],[\"自身\",{\"1\":{\"211\":1}}],[\"自旋等待\",{\"1\":{\"298\":1}}],[\"自旋是指线程不断地在一个循环内尝试获取锁\",{\"1\":{\"143\":1}}],[\"自旋或阻塞\",{\"1\":{\"143\":1}}],[\"自动装配对应值\",{\"1\":{\"603\":1}}],[\"自动装箱用的valueof函数\",{\"1\":{\"428\":1}}],[\"自动装箱\",{\"1\":{\"427\":1}}],[\"自动化构建部署\",{\"1\":{\"592\":1}}],[\"自动拆箱\",{\"1\":{\"427\":1}}],[\"自动导入对应包\",{\"1\":{\"395\":1}}],[\"自动类型转换\",{\"1\":{\"359\":1}}],[\"自动配置\",{\"1\":{\"80\":1}}],[\"自动扫描时的不同\",{\"1\":{\"69\":1}}],[\"自定义镜像\",{\"0\":{\"616\":1}}],[\"自定义输出日志\",{\"1\":{\"586\":1}}],[\"自定义泛型方法\",{\"0\":{\"459\":1}}],[\"自定义泛型接口\",{\"0\":{\"458\":1}}],[\"自定义泛型类\",{\"0\":{\"457\":1}}],[\"自定义模板\",{\"1\":{\"395\":1}}],[\"自定义的线程池\",{\"1\":{\"249\":1}}],[\"自定义的执行方式\",{\"1\":{\"248\":1}}],[\"自定义线程\",{\"1\":{\"238\":1,\"239\":1}}],[\"自定义它们\",{\"1\":{\"42\":1}}],[\"自定义对齐\",{\"0\":{\"21\":1}}],[\"自定义标题\",{\"1\":{\"18\":5}}],[\"自定义容器\",{\"0\":{\"18\":1}}],[\"如若遍历中没有出现这种情况则代表此图为二分图\",{\"1\":{\"716\":1}}],[\"如图\",{\"1\":{\"639\":1,\"653\":2}}],[\"如bufferedreader\",{\"1\":{\"478\":1}}],[\"如filereader\",{\"1\":{\"478\":1}}],[\"如后继节点被取消\",{\"1\":{\"317\":1}}],[\"如实现类只需实现独占锁\",{\"1\":{\"313\":1}}],[\"如下图\",{\"1\":{\"274\":1}}],[\"如修改或删除\",{\"1\":{\"171\":1}}],[\"如开启和提交事务\",{\"1\":{\"166\":1}}],[\"如返回错误页面或json格式的错误信息\",{\"1\":{\"162\":1}}],[\"如jsp页面\",{\"1\":{\"162\":1}}],[\"如音频和视频流传输\",{\"1\":{\"156\":1}}],[\"如证书颁发机构等\",{\"1\":{\"155\":1}}],[\"如ca认证机构\",{\"1\":{\"155\":1}}],[\"如新生代和老年代\",{\"1\":{\"148\":1}}],[\"如visualvm\",{\"1\":{\"146\":1}}],[\"如最大堆内存\",{\"1\":{\"146\":1}}],[\"如数据库连接\",{\"1\":{\"146\":1}}],[\"如大数据集合\",{\"1\":{\"146\":1}}],[\"如何找到这个环的入口\",{\"1\":{\"640\":1}}],[\"如何修改加载策略\",{\"1\":{\"598\":1}}],[\"如何设置\",{\"1\":{\"559\":1}}],[\"如何释放锁\",{\"1\":{\"472\":1}}],[\"如何访问类变量\",{\"1\":{\"411\":1}}],[\"如何定义类变量\",{\"1\":{\"411\":1}}],[\"如何创建对象\",{\"0\":{\"387\":1}}],[\"如何创建一个线程池\",{\"0\":{\"134\":1},\"1\":{\"134\":1}}],[\"如何向客户端回传数据\",{\"1\":{\"335\":1}}],[\"如何使用aqs\",{\"0\":{\"313\":1}}],[\"如何停止中断运行中的线程\",{\"1\":{\"268\":1}}],[\"如何保证\",{\"0\":{\"212\":1}}],[\"如何保证消息可靠性\",{\"0\":{\"211\":1}}],[\"如何选择合适的持久化方式\",{\"1\":{\"189\":1}}],[\"如何在数据库中实现数据的备份和恢复\",{\"0\":{\"171\":1}}],[\"如何获取异步方法执行的返回结果呢\",{\"1\":{\"164\":1}}],[\"如何排查oom\",{\"1\":{\"146\":1}}],[\"如何排查\",{\"0\":{\"146\":1}}],[\"如何处理runnable任务的异常\",{\"1\":{\"133\":1}}],[\"如何接收这两个线程异常\",{\"0\":{\"133\":1}}],[\"如何解决\",{\"1\":{\"98\":1,\"101\":1,\"104\":1,\"107\":1,\"113\":1,\"116\":1}}],[\"如内部变化复杂\",{\"1\":{\"107\":1}}],[\"如你想使用spring\",{\"1\":{\"81\":1}}],[\"如添加一个spring\",{\"1\":{\"80\":1}}],[\"如\",{\"1\":{\"68\":1,\"73\":1,\"168\":3}}],[\"如果要求的测试用例需要读取二维数组\",{\"1\":{\"728\":1}}],[\"如果要去掉大括号\",{\"1\":{\"129\":1}}],[\"如果插入操作导致关键字数量超过\",{\"1\":{\"720\":1}}],[\"如果关键字\",{\"1\":{\"720\":2}}],[\"如果遍历过程中发现下⼀个即将遍历的节点已经被标记为\",{\"1\":{\"717\":1}}],[\"如果可以\",{\"1\":{\"717\":1}}],[\"如果可以直接获取锁\",{\"1\":{\"141\":1}}],[\"如果已经访问过\",{\"1\":{\"716\":1}}],[\"如果已经加载过\",{\"1\":{\"147\":1}}],[\"如果图是二分图\",{\"1\":{\"716\":1}}],[\"如果能将一个图的节点集合分割成两个独立的子集\",{\"1\":{\"716\":1}}],[\"如果无论如何不能解锁\",{\"1\":{\"713\":1}}],[\"如果超出数组边界\",{\"1\":{\"705\":1,\"734\":1}}],[\"如果超过指定时间依然没获取到服务实例则返回\",{\"1\":{\"598\":1}}],[\"如果打过标记\",{\"1\":{\"704\":1}}],[\"如果把第i个物品装入背包\",{\"1\":{\"700\":1}}],[\"如果两间相邻的房屋在同一晚上被小偷闯入\",{\"1\":{\"697\":1,\"698\":1}}],[\"如果两个元素在水平或垂直方向相邻\",{\"1\":{\"709\":1}}],[\"如果两个单词间有多余的空格\",{\"1\":{\"645\":1}}],[\"如果两个链表没有交点\",{\"1\":{\"639\":1}}],[\"如果我们把\",{\"1\":{\"687\":1}}],[\"如果我们通过静态工厂\",{\"1\":{\"130\":1}}],[\"如果path中已有\",{\"1\":{\"685\":1}}],[\"如果propagate\",{\"1\":{\"318\":2}}],[\"如果他在队列中\",{\"1\":{\"661\":1}}],[\"如果暴力匹配\",{\"1\":{\"653\":1}}],[\"如果右边界越界\",{\"1\":{\"650\":1}}],[\"如果左指针指的是有效字符\",{\"1\":{\"649\":1}}],[\"如果目标子串中包含了该字符\",{\"1\":{\"649\":1}}],[\"如果剩余字符小于\",{\"1\":{\"643\":1}}],[\"如果剩余字符少于\",{\"1\":{\"643\":1}}],[\"如果链表无环\",{\"1\":{\"640\":1}}],[\"如果遇到cura\",{\"1\":{\"639\":1}}],[\"如果index非法\",{\"1\":{\"635\":1}}],[\"如果从第一棵树开始采摘\",{\"1\":{\"631\":2}}],[\"如果数组的所有排列根据其字典顺序从小到大排列在一个容器中\",{\"1\":{\"628\":1}}],[\"如果数据库表没有适当的索引或索引选择不当\",{\"1\":{\"173\":1}}],[\"如果自己就是最高的话\",{\"1\":{\"624\":1}}],[\"如果自旋不成功或超过一定次数\",{\"1\":{\"143\":1}}],[\"如果气温在这之后都不会升高\",{\"1\":{\"622\":1}}],[\"如果获取的服务实例为\",{\"1\":{\"598\":1}}],[\"如果在起点和终点遇到了障碍\",{\"1\":{\"696\":1}}],[\"如果在数值计算中不允许有任何舍入误差\",{\"1\":{\"492\":1}}],[\"如果在高并发的情况下\",{\"1\":{\"198\":1}}],[\"如果主体只有一个表达式返回值则编译器会自动返回值\",{\"1\":{\"488\":1}}],[\"如果主体包含了一个语句\",{\"1\":{\"488\":1}}],[\"如果主从复制过程中\",{\"1\":{\"204\":1}}],[\"如果到文件末尾返回\",{\"1\":{\"477\":1}}],[\"如果读取正常\",{\"1\":{\"477\":1}}],[\"如果添加了其他类\",{\"1\":{\"454\":1}}],[\"如果add了不是dog类型的对象也不会报错\",{\"1\":{\"454\":1}}],[\"如果一台服务器内托管了多个域名\",{\"1\":{\"779\":1}}],[\"如果一条链表的元素个数达到8\",{\"1\":{\"445\":1}}],[\"如果一个类继承了抽象类\",{\"1\":{\"416\":1}}],[\"如果一个操作执行的结果需要对另一个操作可见性\",{\"1\":{\"280\":1}}],[\"如果一个得到锁的线程在执行任务的过程中挂掉\",{\"1\":{\"205\":1}}],[\"如果一个哨兵节点确定主节点不可用\",{\"1\":{\"203\":1}}],[\"如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性\",{\"1\":{\"113\":1}}],[\"如果增删操作多用linkedlist\",{\"1\":{\"443\":1}}],[\"如果改查操作多用arraylist\",{\"1\":{\"443\":1}}],[\"如果字符串的反序与原始字符串相同\",{\"1\":{\"650\":1}}],[\"如果字符串很少修改\",{\"1\":{\"431\":1}}],[\"如果字符串存在大量修改的操作\",{\"1\":{\"431\":1}}],[\"如果异常没有发生\",{\"1\":{\"424\":1}}],[\"如果异常发生了\",{\"1\":{\"424\":1}}],[\"如果继承的超类和接口中有同名默认方法\",{\"1\":{\"417\":1}}],[\"如果同时implements的两个接口有同名default方法\",{\"1\":{\"417\":1}}],[\"如果final修饰的属性是静态的\",{\"1\":{\"415\":1}}],[\"如果只是使用类的静态成员\",{\"1\":{\"413\":1}}],[\"如果指向不同对象\",{\"1\":{\"406\":1}}],[\"如果指向同一个对象\",{\"1\":{\"406\":1}}],[\"如果本类中没有则从父类中继续查找\",{\"1\":{\"400\":2}}],[\"如果子类需要扩展功能\",{\"1\":{\"417\":1}}],[\"如果子类没有则向上面的父类查找\",{\"1\":{\"399\":1}}],[\"如果子类有这个属性\",{\"1\":{\"399\":1}}],[\"如果父类没有提供无参构造器\",{\"1\":{\"399\":1}}],[\"如果case都不满足\",{\"1\":{\"372\":1}}],[\"如果cas操作成功\",{\"1\":{\"143\":1}}],[\"如果条件表达式为true则结果为表达式1结果\",{\"1\":{\"366\":1}}],[\"如果为null则抛出nullpointerexception异常\",{\"1\":{\"312\":1}}],[\"如果节点正在以共享模式等待\",{\"1\":{\"312\":1}}],[\"如果next字段似乎是null\",{\"1\":{\"312\":1}}],[\"如果threadlocalmap为null\",{\"1\":{\"307\":1}}],[\"如果threadlocalmap为空\",{\"1\":{\"306\":1}}],[\"如果值为空则返回初始值\",{\"1\":{\"307\":1}}],[\"如果此时threadlocalmap不为空\",{\"1\":{\"306\":1}}],[\"如果仍然想通过原子类来更新的话\",{\"1\":{\"299\":1}}],[\"如果线程\",{\"1\":{\"471\":2}}],[\"如果线程之间竞争程度小\",{\"1\":{\"299\":1}}],[\"如果线程池中的线程数已经达到了maximumpoolsize限制\",{\"1\":{\"135\":1}}],[\"如果相匹配\",{\"1\":{\"295\":1}}],[\"如果发现共享变量已经被其他线程更新过了\",{\"1\":{\"295\":1}}],[\"如果发现循环依赖\",{\"1\":{\"163\":1}}],[\"如果未被其他线程改变过就将共享变量更新成最新值\",{\"1\":{\"295\":1}}],[\"如果ready为false\",{\"1\":{\"291\":1}}],[\"如果其中一个线程修改了这个共享变量的值\",{\"1\":{\"291\":1}}],[\"如果其中有任何一位为\",{\"1\":{\"194\":1}}],[\"如果操作a先行发生于操作b\",{\"1\":{\"284\":1}}],[\"如果操作失败则不能对数据库有任何影响\",{\"1\":{\"170\":1}}],[\"如果这个格子不是岛屿\",{\"1\":{\"704\":1}}],[\"如果这个数据被其他线程更新\",{\"1\":{\"258\":1}}],[\"如果这个数据在操作过程中没有更新\",{\"1\":{\"258\":1}}],[\"如果这是\",{\"1\":{\"204\":1}}],[\"如果传入自定义线程池\",{\"1\":{\"247\":1}}],[\"如果阶段没有运行完\",{\"1\":{\"242\":1}}],[\"如果想要调用dog的方法需进行强制类型转换\",{\"1\":{\"454\":1}}],[\"如果想要异步获取结果\",{\"1\":{\"234\":1}}],[\"如果想增加一个产品\",{\"1\":{\"101\":1}}],[\"如果需要入栈的数大于栈中最后一个数\",{\"1\":{\"662\":1}}],[\"如果需要保证原子操作\",{\"1\":{\"293\":1}}],[\"如果需要大规模\",{\"1\":{\"213\":1}}],[\"如果需要实时性较高\",{\"1\":{\"213\":1}}],[\"如果需要进行类型转换\",{\"1\":{\"55\":1}}],[\"如果找到\",{\"1\":{\"210\":1}}],[\"如果先加锁再设置超时时间\",{\"1\":{\"205\":1}}],[\"如果先更新缓存成功\",{\"1\":{\"195\":1}}],[\"如果master和slave网络连接断掉了\",{\"1\":{\"204\":1}}],[\"如果monitor锁已被别的线程持有\",{\"1\":{\"139\":1}}],[\"如果monitor锁未被占用\",{\"1\":{\"139\":1}}],[\"如果跟\",{\"1\":{\"204\":1}}],[\"如果多数的哨兵节点都确认主节点不可用\",{\"1\":{\"203\":1}}],[\"如果客户端与服务器之间出现通讯故障并导致网络断开\",{\"1\":{\"201\":1}}],[\"如果单个\",{\"1\":{\"200\":1}}],[\"如果对元素有排序需求\",{\"1\":{\"199\":1}}],[\"如果对抽象方法的实现逻辑只有一行\",{\"1\":{\"129\":1}}],[\"如果缓存在某一个时刻出现大规模的\",{\"1\":{\"198\":1}}],[\"如果所有位都为\",{\"1\":{\"194\":1}}],[\"如果所有的父类加载器都无法完成加载请求\",{\"1\":{\"147\":1}}],[\"如果过期则执行删除并返回\",{\"1\":{\"191\":1}}],[\"如果不在队列中\",{\"1\":{\"661\":1}}],[\"如果不相同\",{\"1\":{\"639\":1}}],[\"如果不希望修改直接回车即可\",{\"1\":{\"408\":1}}],[\"如果不想用默认的父类构造器\",{\"1\":{\"399\":1}}],[\"如果不匹配\",{\"1\":{\"295\":1}}],[\"如果不传入自定义线程池\",{\"1\":{\"247\":1}}],[\"如果不采用给缓存设置过期时间策略\",{\"1\":{\"195\":1}}],[\"如果不考虑\",{\"1\":{\"187\":1}}],[\"如果不存在符合条件的子数组\",{\"1\":{\"630\":1}}],[\"如果不存在下一个更大的排列\",{\"1\":{\"628\":1}}],[\"如果不存在\",{\"1\":{\"163\":1,\"651\":1,\"720\":1}}],[\"如果\",{\"1\":{\"184\":3,\"190\":2,\"204\":1,\"471\":2,\"635\":2,\"640\":2,\"648\":2,\"649\":2,\"660\":1,\"705\":1,\"716\":1}}],[\"如果有环\",{\"1\":{\"640\":1}}],[\"如果有相同的最小连接数\",{\"1\":{\"598\":1}}],[\"如果有多个服务提供者\",{\"1\":{\"597\":1}}],[\"如果有一个外部程序\",{\"1\":{\"485\":1}}],[\"如果有\",{\"1\":{\"439\":1,\"445\":1}}],[\"如果有恶意攻击者不断请求系统中不存在的数据\",{\"1\":{\"197\":1}}],[\"如果有的话\",{\"1\":{\"184\":5}}],[\"如果有则返回\",{\"1\":{\"98\":1}}],[\"如果有则生成\",{\"1\":{\"76\":1}}],[\"如果某个数据行的版本在事务的read\",{\"1\":{\"178\":1}}],[\"如果查询条件只涉及到索引的前缀列\",{\"1\":{\"176\":1}}],[\"如果查询条件只涉及到联合索引的最左边的列\",{\"1\":{\"175\":1}}],[\"如果查询条件只涉及到\",{\"1\":{\"175\":1}}],[\"如果查询条件涉及到联合索引的多个列\",{\"1\":{\"175\":1}}],[\"如果锁竞争过于激烈\",{\"1\":{\"173\":1}}],[\"如果通过验证\",{\"1\":{\"165\":1}}],[\"如果存在大量修改操作\",{\"1\":{\"431\":2}}],[\"如果存在\",{\"1\":{\"163\":1}}],[\"如果验证失败\",{\"1\":{\"155\":1}}],[\"如果加载失败\",{\"1\":{\"147\":1}}],[\"如果加载成功\",{\"1\":{\"147\":1}}],[\"如果当前线程竞争锁失败\",{\"1\":{\"141\":1,\"312\":1}}],[\"如果当前线程池中的线程数量已经达到了corepoolsize限制\",{\"1\":{\"135\":1}}],[\"如果减少后的值大于0\",{\"1\":{\"141\":1}}],[\"如果减少后的值为0\",{\"1\":{\"141\":1}}],[\"如果失败\",{\"1\":{\"141\":1}}],[\"如果成功\",{\"1\":{\"141\":1}}],[\"如果竞争失败\",{\"1\":{\"139\":1}}],[\"如果竞争成功\",{\"1\":{\"139\":1}}],[\"如果是多重范围请求则会在\",{\"1\":{\"770\":1}}],[\"如果是在矩阵中递归\",{\"1\":{\"704\":1}}],[\"如果是新单词的话编码长度增加新单词的长度+1\",{\"1\":{\"675\":1}}],[\"如果是则符合\",{\"1\":{\"607\":1}}],[\"如果是全局配置\",{\"1\":{\"606\":1}}],[\"如果是局部配置\",{\"1\":{\"606\":1}}],[\"如果是无参\",{\"1\":{\"442\":1}}],[\"如果是用做内存数据库\",{\"1\":{\"189\":1}}],[\"如果是数据比较重要\",{\"1\":{\"189\":1}}],[\"如果是\",{\"1\":{\"139\":1}}],[\"如果阻塞队列已满\",{\"1\":{\"135\":1}}],[\"如果修改过java\",{\"1\":{\"130\":1}}],[\"如果使用指定大小的构造器\",{\"1\":{\"441\":1}}],[\"如果使用无参构造器\",{\"1\":{\"441\":1}}],[\"如果使用cas\",{\"1\":{\"299\":1}}],[\"如果使用cms垃圾回收器\",{\"1\":{\"146\":1}}],[\"如果使用executorservice来执行runnable任务\",{\"1\":{\"133\":1}}],[\"如果使用\",{\"1\":{\"130\":1}}],[\"如果没有把第i个物品装入背包\",{\"1\":{\"700\":1}}],[\"如果没有接口\",{\"1\":{\"492\":1}}],[\"如果没有则更新值\",{\"1\":{\"299\":1}}],[\"如果没有则创建\",{\"1\":{\"98\":1}}],[\"如果没有找到\",{\"1\":{\"210\":1}}],[\"如果没有过期则返回正常信息给客户端\",{\"1\":{\"191\":1}}],[\"如果没有适当的并发控制机制\",{\"1\":{\"171\":2}}],[\"如果没有spring怎么开发\",{\"0\":{\"168\":1}}],[\"如果没有加载过\",{\"1\":{\"147\":1}}],[\"如果没有可用许可\",{\"1\":{\"144\":1}}],[\"如果没有\",{\"1\":{\"135\":1,\"445\":1}}],[\"如果没有else\",{\"1\":{\"6\":1}}],[\"如果您使用过现代\",{\"1\":{\"93\":1}}],[\"如果提示没有ifconfig命令的先安装sudo\",{\"1\":{\"49\":1}}],[\"如果你带着自己的设备\",{\"1\":{\"95\":1}}],[\"如果你有过出国旅行的经验\",{\"1\":{\"95\":1}}],[\"如果你不了解它\",{\"1\":{\"14\":1}}],[\"如果你是一个新手\",{\"1\":{\"13\":1}}],[\"如果该判断结果为true\",{\"1\":{\"6\":1}}],[\"用单台虚拟主机实现多个域名\",{\"0\":{\"779\":1}}],[\"用逗号分隔\",{\"1\":{\"729\":1}}],[\"用visited记录已经使用过的密码\",{\"1\":{\"713\":1}}],[\"用set记录deadend\",{\"1\":{\"713\":1}}],[\"用队列实现栈\",{\"0\":{\"656\":1}}],[\"用栈实现队列\",{\"0\":{\"655\":1}}],[\"用另外一个\",{\"1\":{\"649\":1}}],[\"用最小的极大值减去中间区域的值\",{\"1\":{\"624\":1}}],[\"用一个存有多个\",{\"1\":{\"515\":1}}],[\"用一份数据服务所有\",{\"1\":{\"204\":1}}],[\"用\",{\"1\":{\"512\":1,\"649\":1,\"709\":1}}],[\"用cglib合适\",{\"1\":{\"492\":1}}],[\"用loop来控制循环\",{\"1\":{\"467\":1}}],[\"用map的方法get根据key得到对应value\",{\"1\":{\"448\":1}}],[\"用的是valueof\",{\"1\":{\"427\":1}}],[\"用abstract关键字来修饰方法\",{\"1\":{\"416\":1}}],[\"用abstract关键字来修饰类\",{\"1\":{\"416\":1}}],[\"用数组实现\",{\"1\":{\"408\":1}}],[\"用this访问构造器\",{\"1\":{\"393\":1}}],[\"用pair这个内部类实现\",{\"1\":{\"299\":1}}],[\"用原型实例指定创建对象的种类\",{\"1\":{\"116\":1}}],[\"用继承会造成类爆炸问题\",{\"1\":{\"113\":1}}],[\"用于链表构建\",{\"1\":{\"729\":1}}],[\"用于能够生成所有可能的并且\",{\"1\":{\"690\":1}}],[\"用于返回字母异位词的起始索引\",{\"1\":{\"649\":1}}],[\"用于返回对象的属性类型\",{\"1\":{\"406\":1}}],[\"用于管理和监控一个或多个\",{\"1\":{\"593\":1}}],[\"用于管理或操作数组\",{\"1\":{\"433\":1}}],[\"用于\",{\"1\":{\"588\":1}}],[\"用于设置单实例还是多实例\",{\"1\":{\"559\":1}}],[\"用于创建和管理应用程序组件\",{\"1\":{\"545\":1}}],[\"用于创建新线程的工厂\",{\"1\":{\"135\":1}}],[\"用于分步查询\",{\"1\":{\"525\":1}}],[\"用于标识计算机上某个特定的网络程序\",{\"1\":{\"482\":1}}],[\"用于xxx\",{\"1\":{\"450\":1}}],[\"用于访问父类的属性\",{\"1\":{\"400\":1}}],[\"用于结束本次循环\",{\"1\":{\"378\":1}}],[\"用于建立初始头节点或shared标记\",{\"1\":{\"312\":1}}],[\"用于检查waitstatus\",{\"1\":{\"312\":1}}],[\"用于逻辑隔离\",{\"1\":{\"209\":1}}],[\"用于连接到具体broker\",{\"1\":{\"209\":1}}],[\"用于指定这个消息的路由规则\",{\"1\":{\"209\":1}}],[\"用于判断一个元素是否存在于一个集合中\",{\"1\":{\"194\":1}}],[\"用于确认uri的有效性及资源的更新日期时间\",{\"1\":{\"763\":1}}],[\"用于确保事务的持久性和恢复能力\",{\"1\":{\"180\":1}}],[\"用于确定事务可见的数据行版本\",{\"1\":{\"178\":1}}],[\"用于防止其他事务在范围内插入新记录\",{\"1\":{\"178\":1}}],[\"用于回滚操作和读取已提交的旧版本数据\",{\"1\":{\"178\":1}}],[\"用于撤销已提交事务的修改或提供读一致性视图\",{\"1\":{\"177\":1}}],[\"用于崩溃恢复和故障恢复\",{\"1\":{\"177\":1}}],[\"用于定位和优化数据库中的慢查询语句\",{\"1\":{\"177\":1}}],[\"用于排查慢查询和审计查询的使用情况\",{\"1\":{\"177\":1}}],[\"用于故障排查和问题分析\",{\"1\":{\"177\":1}}],[\"用于数据恢复\",{\"1\":{\"177\":1}}],[\"用于存放字符串类容\",{\"1\":{\"429\":1}}],[\"用于存放等待执行的任务的阻塞队列\",{\"1\":{\"135\":1}}],[\"用于存储字段和值的映射关系\",{\"1\":{\"188\":1}}],[\"用于存储单个值\",{\"1\":{\"188\":1}}],[\"用于存储每个\",{\"1\":{\"165\":1}}],[\"用于证明服务器的身份\",{\"1\":{\"155\":1}}],[\"用于网络通信\",{\"1\":{\"152\":1}}],[\"用于保证类的唯一性\",{\"1\":{\"147\":1}}],[\"用于控制同时访问某个资源的线程数量\",{\"1\":{\"144\":1}}],[\"用于刷新变量的值到主内存或者从主内存中读取最新值\",{\"1\":{\"140\":1}}],[\"用于对给定的参数进行条件判断\",{\"1\":{\"129\":1}}],[\"用于对给定的参数进行处理并返回结果\",{\"1\":{\"129\":1}}],[\"用于对给定的参数执行某些操作\",{\"1\":{\"129\":1}}],[\"用于获取结果\",{\"1\":{\"129\":1}}],[\"用于编写和运行单元测试和集成测试的支持\",{\"1\":{\"81\":1}}],[\"用于快速创建restful\",{\"1\":{\"81\":1}}],[\"用于监视和管理配置\",{\"1\":{\"81\":1}}],[\"用于配置web应用\",{\"1\":{\"61\":1}}],[\"用户从浏览器显示的可选项列表中手动选择\",{\"1\":{\"771\":1}}],[\"用户名\",{\"1\":{\"540\":1,\"605\":1}}],[\"用户名=\",{\"1\":{\"480\":1}}],[\"用户id\",{\"1\":{\"303\":1}}],[\"用户线程和守护线程\",{\"1\":{\"468\":1}}],[\"用户线程\",{\"1\":{\"227\":1,\"468\":1}}],[\"用户通过提供用户名和密码进行登录\",{\"1\":{\"165\":1}}],[\"用户登录\",{\"1\":{\"165\":1}}],[\"用户请求到达前端控制器\",{\"1\":{\"76\":1}}],[\"用户发送请求至前端控制器dispatcherservlet\",{\"1\":{\"76\":1}}],[\"用来确定模块的初始化顺序\",{\"1\":{\"718\":1}}],[\"用来判断是否已经出现过该字符\",{\"1\":{\"648\":1}}],[\"用来做外层隔离\",{\"1\":{\"599\":1}}],[\"用来标记一个属性\",{\"1\":{\"501\":1}}],[\"用来存放消息\",{\"1\":{\"209\":1}}],[\"用来解决代码重复的问题\",{\"1\":{\"73\":1}}],[\"用来创建对象的实例\",{\"1\":{\"73\":1}}],[\"用途不同\",{\"1\":{\"69\":1}}],[\"用作另一个\",{\"1\":{\"67\":1}}],[\"921\",{\"0\":{\"660\":1}}],[\"9234567\",{\"1\":{\"436\":1}}],[\"904\",{\"0\":{\"631\":1}}],[\"998\",{\"1\":{\"415\":1}}],[\"9999\",{\"1\":{\"485\":2}}],[\"999\",{\"1\":{\"415\":1}}],[\"977\",{\"0\":{\"629\":1}}],[\"97\",{\"1\":{\"358\":1,\"429\":1}}],[\"9\",{\"0\":{\"67\":1,\"334\":1,\"526\":1,\"527\":1,\"528\":1,\"529\":1,\"530\":1,\"531\":1,\"532\":1,\"565\":1,\"617\":1,\"710\":1},\"1\":{\"130\":1,\"210\":1,\"359\":1,\"376\":1,\"629\":5,\"632\":1,\"667\":2,\"669\":2,\"684\":1,\"713\":5,\"724\":3,\"726\":1}}],[\"当客户端想获得\",{\"1\":{\"785\":1}}],[\"当客户端发送一个http请求时\",{\"1\":{\"162\":1}}],[\"当收到请求时就需要弄清究竟要访问那个域名\",{\"1\":{\"779\":1}}],[\"当元素\",{\"1\":{\"721\":2}}],[\"当没有依赖时结束\",{\"1\":{\"718\":1}}],[\"当遍历到终点时将路径记录下来即可\",{\"1\":{\"715\":1}}],[\"当出现了一个障碍时\",{\"1\":{\"696\":1}}],[\"当出现字符串不匹配时\",{\"1\":{\"653\":1}}],[\"当列表中剩余的元素数小于列表需要的元素数时\",{\"1\":{\"683\":1}}],[\"当且仅当你可以在所有给定的行程中接送所有乘客时\",{\"1\":{\"677\":1}}],[\"当窗口之和大于目标时\",{\"1\":{\"630\":1}}],[\"当过滤器的order值一样时\",{\"1\":{\"607\":1}}],[\"当代理实例方法被调用时\",{\"1\":{\"606\":1}}],[\"当本地和远端单环境配置和多环境配置同时配置了一个属性时\",{\"1\":{\"604\":1}}],[\"当本地和远端共享配置同时配置了一个属性时\",{\"1\":{\"604\":1}}],[\"当配置更新时\",{\"1\":{\"602\":1}}],[\"当集群中存在非临时实例时\",{\"1\":{\"600\":1}}],[\"当某个服务提供方出现问题\",{\"1\":{\"597\":1}}],[\"当某个对象用synchronized修饰时\",{\"1\":{\"471\":1}}],[\"当某个对象没有任何引用时\",{\"1\":{\"406\":1}}],[\"当作分隔符\",{\"1\":{\"531\":1}}],[\"当不需要\",{\"1\":{\"524\":1}}],[\"当不希望某个局部变量被修改时\",{\"1\":{\"415\":1}}],[\"当不希望类的某个属性被改时\",{\"1\":{\"415\":1}}],[\"当不希望类被继承时\",{\"1\":{\"415\":1}}],[\"当不希望父类的某个方法被子类重写时\",{\"1\":{\"415\":1}}],[\"当参数为某个javabean时\",{\"1\":{\"501\":1}}],[\"当返回\",{\"1\":{\"478\":3}}],[\"当返回结果为其他类型时\",{\"1\":{\"164\":1}}],[\"当所有用户线程结束\",{\"1\":{\"468\":1}}],[\"当创建arraylist对象时\",{\"1\":{\"441\":1}}],[\"当创建子类对象时\",{\"1\":{\"399\":1}}],[\"当接口需要增加\",{\"1\":{\"419\":1}}],[\"当需要代理多个类的时候\",{\"1\":{\"419\":1}}],[\"当对象被回收时\",{\"1\":{\"406\":1}}],[\"当对应condition\",{\"1\":{\"319\":1}}],[\"当调用对象属性时\",{\"1\":{\"403\":1}}],[\"当调用对象方法时\",{\"1\":{\"403\":1}}],[\"当调用线程池的execute或submit方法提交一个任务时\",{\"1\":{\"135\":1}}],[\"当子类中有和父类重名的属性\",{\"1\":{\"400\":1}}],[\"当两个类中很多属性和方法都可以共用\",{\"1\":{\"399\":1}}],[\"当两个线程共用一个共享变量时\",{\"1\":{\"291\":1}}],[\"当类很多时\",{\"1\":{\"396\":1}}],[\"当main函数执行到方法时\",{\"1\":{\"389\":1}}],[\"当有多种数据类型进行混合运算时\",{\"1\":{\"359\":1}}],[\"当加号两侧有一方是字符串时\",{\"1\":{\"357\":1}}],[\"当加号左右两侧都是数值型时\",{\"1\":{\"357\":1}}],[\"当做转义字符\",{\"1\":{\"353\":1}}],[\"当持有锁的线程发起condition\",{\"1\":{\"319\":1}}],[\"当把ready改为volatile关键字后就能够感知\",{\"1\":{\"291\":1}}],[\"当采用非公平锁时\",{\"1\":{\"262\":1}}],[\"当用户线程全部结束了\",{\"1\":{\"227\":1}}],[\"当然\",{\"1\":{\"209\":1}}],[\"当然如果不止一行\",{\"1\":{\"129\":1}}],[\"当启动一个slave\",{\"1\":{\"204\":1}}],[\"当选出新的主节点后\",{\"1\":{\"203\":1}}],[\"当主节点不可用时\",{\"1\":{\"203\":1}}],[\"当操作被打断时\",{\"1\":{\"202\":1}}],[\"当内存不足时\",{\"1\":{\"200\":1}}],[\"当要检查一个元素是否存在于布隆过滤器中时\",{\"1\":{\"194\":1}}],[\"当要向布隆过滤器中添加一个元素时\",{\"1\":{\"194\":1}}],[\"当要实例化的类是在运行时刻指定时\",{\"1\":{\"116\":1}}],[\"当redis重启的时候\",{\"1\":{\"189\":1}}],[\"当事务执行select语句时\",{\"1\":{\"178\":1}}],[\"当使用联合索引进行查询时\",{\"1\":{\"176\":1}}],[\"当使用了allowcorethreadtimeout\",{\"1\":{\"136\":1}}],[\"当查询时\",{\"1\":{\"175\":1}}],[\"当数据无法完全加载到内存中时\",{\"1\":{\"173\":1}}],[\"当数据发生变化时\",{\"1\":{\"167\":1}}],[\"当b树的高度比较大时\",{\"1\":{\"172\":1}}],[\"当多个处理器的运算任务都涉及到同一块主内存区域时\",{\"1\":{\"274\":1}}],[\"当多个列组合在一起用于查询时\",{\"1\":{\"174\":1}}],[\"当多个并发事务同时查询或修改同一个表时\",{\"1\":{\"173\":1}}],[\"当多个事务同时读取和修改同一份数据时\",{\"1\":{\"171\":1}}],[\"当多个键对象映射到同一个桶时\",{\"1\":{\"124\":1}}],[\"当异步方法有返回值时\",{\"1\":{\"164\":1}}],[\"当依赖注入完成后\",{\"1\":{\"163\":1}}],[\"当spring创建一个bean时\",{\"1\":{\"163\":1}}],[\"当应用程序关闭或bean不再需要时\",{\"1\":{\"160\":1}}],[\"当遇到oom\",{\"1\":{\"146\":1}}],[\"当计数器为0时\",{\"1\":{\"144\":1}}],[\"当同步状态释放时\",{\"1\":{\"141\":1,\"312\":1}}],[\"当竞争轻量级锁的线程过多或自旋次数达到一定阈值时\",{\"1\":{\"139\":1}}],[\"当第二个线程尝试获取偏向锁失败时\",{\"1\":{\"139\":1}}],[\"当线程完成后\",{\"1\":{\"467\":1}}],[\"当线程进入被synchronized修饰的代码块时\",{\"1\":{\"142\":1}}],[\"当线程退出synchronized块时\",{\"1\":{\"139\":1}}],[\"当线程尝试进入synchronized块时\",{\"1\":{\"139\":1}}],[\"当线程池和阻塞队列都已满\",{\"1\":{\"135\":1}}],[\"当线程池中的线程数量大于corepoolsize时\",{\"1\":{\"135\":1}}],[\"当前区域是海水\",{\"1\":{\"706\":1,\"707\":1,\"708\":1,\"709\":2}}],[\"当前背包承重为w时\",{\"1\":{\"700\":1}}],[\"当前前缀和与前面的某一个前缀和之差\",{\"1\":{\"671\":1}}],[\"当前队列的大小\",{\"1\":{\"666\":1,\"669\":1}}],[\"当前页的起始索引\",{\"1\":{\"542\":1}}],[\"当前页的页码\",{\"1\":{\"542\":1}}],[\"当前日期\",{\"1\":{\"436\":2}}],[\"当前工程的路径\",{\"1\":{\"331\":1}}],[\"当前节点的前置节点被取消时\",{\"1\":{\"312\":1}}],[\"当前节点的值\",{\"1\":{\"90\":1}}],[\"当前节点\",{\"1\":{\"312\":2}}],[\"当前线程暂停\",{\"1\":{\"472\":1}}],[\"当前线程在同步代码块\",{\"1\":{\"472\":3}}],[\"当前线程的同步方法\",{\"1\":{\"472\":1}}],[\"当前线程会被封装成一个node节点加入到同步队列中\",{\"1\":{\"141\":1}}],[\"当前线程池中的线程数大于核心线程数\",{\"1\":{\"136\":1}}],[\"当任务数量暂时过多时\",{\"1\":{\"135\":1}}],[\"当final关键字修饰方法的参数时\",{\"1\":{\"127\":1}}],[\"当final关键字修饰一个类时\",{\"1\":{\"127\":1}}],[\"当final关键字修饰一个方法时\",{\"1\":{\"127\":1}}],[\"当final关键字修饰一个变量时\",{\"1\":{\"127\":1}}],[\"当链表长度为8和数组长度为64再转换时\",{\"1\":{\"124\":1}}],[\"当链表中的元素较多时\",{\"1\":{\"124\":1}}],[\"当链表中的元素较少时\",{\"1\":{\"124\":1}}],[\"当\",{\"1\":{\"124\":1,\"202\":1,\"203\":1,\"651\":2}}],[\"当一个背包能够装满时\",{\"1\":{\"701\":1}}],[\"当一个区域满了后\",{\"1\":{\"148\":1}}],[\"当一个类继承了thread类\",{\"1\":{\"466\":1}}],[\"当一个类被标记为\",{\"1\":{\"166\":1}}],[\"当一个类需要被加载时\",{\"1\":{\"147\":1}}],[\"当一个类的实例只能有几个不同状态组合中的一种时\",{\"1\":{\"116\":1}}],[\"当一个写操作对一个volatile变量进行写操作时\",{\"1\":{\"140\":1}}],[\"当一个线程请求获取锁的同步状态\",{\"1\":{\"262\":1}}],[\"当一个线程执行\",{\"1\":{\"205\":2}}],[\"当一个线程释放锁时\",{\"1\":{\"141\":2}}],[\"当一个线程尝试获取锁时\",{\"1\":{\"141\":2}}],[\"当一个线程修改了某一个共享变量的值\",{\"1\":{\"277\":1}}],[\"当一个线程修改了共享变量的值时\",{\"1\":{\"140\":1}}],[\"当一个线程修改了volatile变量的值时\",{\"1\":{\"140\":1}}],[\"当一个线程访问同步块时\",{\"1\":{\"139\":1}}],[\"当一个变量被声明为volatile时\",{\"1\":{\"128\":1}}],[\"当一个系统应该独立于它的产品创建\",{\"1\":{\"116\":1}}],[\"当一个对象的状态发生改变时\",{\"1\":{\"73\":1}}],[\"当直接创建对象的代价比较大时\",{\"1\":{\"116\":1}}],[\"当您想控制实例数目\",{\"1\":{\"98\":1}}],[\"当您创建多个相同类型的\",{\"1\":{\"71\":1}}],[\"当我们使用spring\",{\"1\":{\"82\":1}}],[\"当我们需要用它的时候还给我\",{\"1\":{\"70\":1}}],[\"当容器关闭时\",{\"1\":{\"66\":1,\"560\":1}}],[\"当涉及到继承时\",{\"1\":{\"53\":1}}],[\"前缀树\",{\"0\":{\"673\":1}}],[\"前缀和map\",{\"1\":{\"672\":1}}],[\"前缀和\",{\"0\":{\"670\":1}}],[\"前缀表\",{\"1\":{\"653\":1}}],[\"前缀表是用来回退的\",{\"1\":{\"653\":1}}],[\"前序遍历是中左右\",{\"1\":{\"665\":1}}],[\"前序遍历\",{\"1\":{\"664\":1,\"667\":1,\"668\":1}}],[\"前指针后移n位\",{\"1\":{\"638\":1}}],[\"前指针\",{\"1\":{\"636\":1}}],[\"前后双指针\",{\"1\":{\"638\":1}}],[\"前后双指针法\",{\"1\":{\"636\":1}}],[\"前后指针\",{\"0\":{\"624\":1}}],[\"前后指针法\",{\"0\":{\"623\":1}}],[\"前添加\",{\"1\":{\"635\":1}}],[\"前置方法增强\",{\"1\":{\"572\":2}}],[\"前置通知\",{\"1\":{\"570\":1}}],[\"前置处理器\",{\"1\":{\"66\":1,\"560\":1}}],[\"前\",{\"1\":{\"362\":2}}],[\"前面的写对后面的读是可见的\",{\"1\":{\"283\":1}}],[\"前一个阶段执行完才能执行下一个阶段\",{\"1\":{\"248\":1}}],[\"前先去布隆过滤器查询\",{\"1\":{\"197\":1}}],[\"前者由编译器发现\",{\"1\":{\"126\":1}}],[\"前者可以在拼接的字符间添加连接符\",{\"1\":{\"7\":1}}],[\"前端为例\",{\"1\":{\"93\":1}}],[\"前端控制器收到请求后自己不进行处理\",{\"1\":{\"76\":1}}],[\"前端控制器dispatcherservlet\",{\"1\":{\"76\":1}}],[\"无向图\",{\"1\":{\"716\":1}}],[\"无重复字符的最长子串\",{\"0\":{\"647\":1}}],[\"无需删除的节点连接上pre\",{\"1\":{\"634\":1}}],[\"无需手动创建运行容器\",{\"1\":{\"617\":1}}],[\"无需其他\",{\"1\":{\"80\":1}}],[\"无\",{\"1\":{\"595\":2}}],[\"无论是消费者还是提供者\",{\"1\":{\"597\":1}}],[\"无论s与t有什么联系\",{\"1\":{\"461\":1}}],[\"无论元数据\",{\"1\":{\"212\":1}}],[\"无序\",{\"1\":{\"444\":1,\"451\":1}}],[\"无序的字符串集合\",{\"1\":{\"188\":1}}],[\"无要求\",{\"1\":{\"401\":2}}],[\"无参数默认非公平锁\",{\"1\":{\"262\":1}}],[\"无参数无返回值\",{\"1\":{\"245\":1,\"251\":1}}],[\"无参数构造\",{\"1\":{\"66\":1,\"560\":1}}],[\"无返回值\",{\"1\":{\"244\":1}}],[\"无返回值有形参的抽象方法\",{\"1\":{\"129\":1}}],[\"无磁盘化复制\",{\"1\":{\"204\":1}}],[\"无阻塞操作\",{\"1\":{\"125\":1}}],[\"无代码生成和xml配置\",{\"1\":{\"80\":1}}],[\"无法完成初始化\",{\"1\":{\"718\":1}}],[\"无法再被旋转\",{\"1\":{\"713\":1}}],[\"无法装满背包\",{\"1\":{\"701\":1}}],[\"无法访问\",{\"1\":{\"599\":1}}],[\"无法替换\",{\"1\":{\"517\":1}}],[\"无法进行代理\",{\"1\":{\"492\":1}}],[\"无法被继承\",{\"1\":{\"492\":1}}],[\"无法定义\",{\"1\":{\"458\":1}}],[\"无法修改属性\",{\"1\":{\"398\":1}}],[\"无法判断获取锁的状态\",{\"1\":{\"261\":1}}],[\"无法分配更多的对象\",{\"1\":{\"146\":1}}],[\"无法继续接受新任务时\",{\"1\":{\"135\":1}}],[\"无法实现的\",{\"1\":{\"70\":1}}],[\"无法复制的unique\",{\"1\":{\"3\":1}}],[\"实体首部字段\",{\"1\":{\"784\":1}}],[\"实体类名\",{\"1\":{\"540\":1}}],[\"实体类\",{\"1\":{\"540\":1}}],[\"实体类字段名\",{\"1\":{\"522\":1}}],[\"实体方法\",{\"1\":{\"105\":1}}],[\"实时应用\",{\"1\":{\"156\":1}}],[\"实现randomizedset\",{\"1\":{\"721\":1}}],[\"实现runnable的区别\",{\"1\":{\"466\":1}}],[\"实现runnable接口方式更加适合多个线程共享一个资源的情况\",{\"1\":{\"466\":1}}],[\"实现runnable接口\",{\"1\":{\"132\":1,\"466\":1}}],[\"实现代码\",{\"1\":{\"709\":1}}],[\"实现远程调用\",{\"1\":{\"597\":1,\"606\":1}}],[\"实现消息互通\",{\"1\":{\"593\":1}}],[\"实现的\",{\"1\":{\"588\":1}}],[\"实现批量操作\",{\"1\":{\"578\":1}}],[\"实现这个接口\",{\"1\":{\"569\":1}}],[\"实现自动装配\",{\"1\":{\"561\":1}}],[\"实现部分映射比较困难\",{\"1\":{\"496\":1}}],[\"实现常难\",{\"1\":{\"496\":1}}],[\"实现方式实现\",{\"1\":{\"492\":1}}],[\"实现泛型数组操作代码\",{\"1\":{\"486\":1}}],[\"实现互斥步骤\",{\"1\":{\"471\":1}}],[\"实现接口里方法\",{\"1\":{\"558\":1}}],[\"实现接口\",{\"1\":{\"558\":1}}],[\"实现接口和实现类\",{\"1\":{\"557\":1}}],[\"实现接口时\",{\"1\":{\"458\":1}}],[\"实现接口方式\",{\"1\":{\"76\":1}}],[\"实现基于文本界面的房屋出租系统\",{\"1\":{\"408\":1}}],[\"实现service方法\",{\"1\":{\"327\":1}}],[\"实现类\",{\"1\":{\"569\":1}}],[\"实现类只需要继承该类\",{\"1\":{\"311\":1}}],[\"实现类支持不同的view类型\",{\"1\":{\"76\":1}}],[\"实现一个自旋锁\",{\"1\":{\"298\":1}}],[\"实现分布式锁\",{\"0\":{\"205\":1}}],[\"实现了一次编译全平台通用\",{\"1\":{\"348\":1}}],[\"实现了高效的顺序写入\",{\"1\":{\"214\":1}}],[\"实现了请求的统一入口和全局的请求处理逻辑\",{\"1\":{\"162\":1}}],[\"实现了线程的安全访问和控制\",{\"1\":{\"144\":1}}],[\"实现了自动化配置\",{\"1\":{\"83\":1}}],[\"实现原理\",{\"0\":{\"140\":1,\"141\":1},\"1\":{\"140\":1,\"144\":2}}],[\"实现模板的效果\",{\"1\":{\"123\":1}}],[\"实现\",{\"0\":{\"651\":1},\"1\":{\"116\":1,\"419\":1,\"492\":1,\"571\":2,\"651\":1,\"720\":1}}],[\"实现克隆操作\",{\"1\":{\"116\":1}}],[\"实现细节对客户透明\",{\"1\":{\"113\":1}}],[\"实现系统可能有多个角度分类\",{\"1\":{\"113\":1}}],[\"实现web和方法级别的安全性\",{\"1\":{\"81\":1}}],[\"实例2\",{\"1\":{\"599\":2}}],[\"实例1\",{\"1\":{\"599\":2}}],[\"实例传递给\",{\"1\":{\"560\":1}}],[\"实例是单实例还是多实例\",{\"1\":{\"559\":1}}],[\"实例无法满足需求\",{\"1\":{\"200\":1}}],[\"实例化当前线程中的threadlocalmap\",{\"1\":{\"306\":1}}],[\"实例化可以通过无参数构造函数\",{\"1\":{\"160\":1}}],[\"实例化\",{\"1\":{\"160\":1}}],[\"实例\",{\"1\":{\"66\":1,\"560\":1}}],[\"实际增强的逻辑部分称为通知\",{\"1\":{\"570\":1}}],[\"实际的方法执行者\",{\"1\":{\"419\":1}}],[\"实际的文章内容\",{\"1\":{\"11\":1}}],[\"实际上就是获得一个监视器对象\",{\"1\":{\"260\":1}}],[\"实际上获得的都是同一个实例\",{\"1\":{\"99\":1}}],[\"实际上\",{\"1\":{\"93\":1}}],[\"实际使用中\",{\"1\":{\"62\":1}}],[\"作者\",{\"1\":{\"730\":1}}],[\"作者设置为\",{\"1\":{\"40\":1}}],[\"作废\",{\"1\":{\"720\":2}}],[\"作为页面的文本标记语言\",{\"1\":{\"746\":1}}],[\"作为容量\",{\"1\":{\"720\":1}}],[\"作为方法区这个类的各种数据访问入口\",{\"1\":{\"419\":1}}],[\"作为统一访\",{\"1\":{\"76\":1}}],[\"作用范围\",{\"1\":{\"401\":1}}],[\"作用范围是多个\",{\"1\":{\"167\":1}}],[\"作用范围是\",{\"1\":{\"167\":1}}],[\"作用是拦截请求\",{\"1\":{\"338\":1}}],[\"作用和功能是什么\",{\"1\":{\"273\":1}}],[\"作用主的对象是\",{\"1\":{\"259\":1}}],[\"作用的对象是\",{\"1\":{\"259\":3}}],[\"作用\",{\"1\":{\"76\":4,\"177\":6,\"501\":2}}],[\"作用对象不同\",{\"1\":{\"70\":1}}],[\"作用域整个类\",{\"1\":{\"418\":1}}],[\"作用域在整个类中\",{\"1\":{\"418\":1}}],[\"作用域仅在定义的局部\",{\"1\":{\"418\":1}}],[\"作用域为整个类体\",{\"1\":{\"391\":1}}],[\"作用域\",{\"0\":{\"559\":1},\"1\":{\"65\":1,\"391\":1}}],[\"它扮演了位于服务器和客户端之间的\",{\"1\":{\"780\":1}}],[\"它记录了模式串与主串\",{\"1\":{\"653\":1}}],[\"它是一个空字符串\",{\"1\":{\"660\":1}}],[\"它是\",{\"1\":{\"649\":2}}],[\"它是遍历服务提供者列表\",{\"1\":{\"598\":1}}],[\"它是从中介者模式\",{\"1\":{\"93\":1}}],[\"它就像自己拥有资源的源服务器一样对请求进行处理\",{\"1\":{\"780\":1}}],[\"它就可以当成线程使用\",{\"1\":{\"466\":1}}],[\"它就相当于mvc模式中的c\",{\"1\":{\"76\":1}}],[\"它不会被用作同步队列节点\",{\"1\":{\"312\":1}}],[\"它有什么作用\",{\"1\":{\"310\":1}}],[\"它修饰的对象有以下几种\",{\"1\":{\"259\":1}}],[\"它采用了索引和位移的方式来管理消息\",{\"1\":{\"214\":1}}],[\"它将消息持久化到磁盘中\",{\"1\":{\"213\":1}}],[\"它将自动提供一些默认的依赖关系\",{\"1\":{\"82\":1}}],[\"它通过主题\",{\"1\":{\"213\":1}}],[\"它通过提供抽象化和实现化之间的桥接结构\",{\"1\":{\"113\":1}}],[\"它总是返回ok\",{\"1\":{\"202\":1}}],[\"它与\",{\"1\":{\"184\":1}}],[\"它使用cas进行修改\",{\"1\":{\"312\":1}}],[\"它使用生产者\",{\"1\":{\"213\":1}}],[\"它使用了写优化和压缩算法来提供高效的存储和查询性能\",{\"1\":{\"183\":1}}],[\"它使用多个节点共同存储和处理数据\",{\"1\":{\"183\":1}}],[\"它提供了acid\",{\"1\":{\"183\":1}}],[\"它提供了一种创建对象的最佳方式之一\",{\"1\":{\"116\":1}}],[\"它提供了一种创建对象的最佳方式\",{\"1\":{\"98\":1,\"101\":1,\"107\":1,\"110\":1}}],[\"它决定了数据在磁盘上的物理存储顺序\",{\"1\":{\"179\":1}}],[\"它允许在事务执行期间保持数据的一致性状态\",{\"1\":{\"178\":1}}],[\"它允许一个或多个线程等待其他线程完成操作后再执行\",{\"1\":{\"144\":1}}],[\"它保证每个查询都使用当前的read\",{\"1\":{\"178\":1}}],[\"它保证了多个线程同时尝试加入队列时的竞争关系\",{\"1\":{\"143\":1}}],[\"它会发送一个psync命令给master\",{\"1\":{\"204\":1}}],[\"它会向其他哨兵节点发送sentinel\",{\"1\":{\"203\":1}}],[\"它会优先使用aof文件来还原数据集\",{\"1\":{\"189\":1}}],[\"它会使用当前的read\",{\"1\":{\"178\":1}}],[\"它会处理请求参数\",{\"1\":{\"161\":1}}],[\"它会引入一定的延迟\",{\"1\":{\"156\":1}}],[\"它能够使得不同类型的处理器能够统一执行\",{\"1\":{\"161\":1}}],[\"它可以被写作\",{\"1\":{\"660\":1}}],[\"它可以被写成\",{\"1\":{\"660\":1}}],[\"它可以用来限制同时访问某个资源的线程数目\",{\"1\":{\"144\":1}}],[\"它可以指向shared\",{\"1\":{\"3\":1}}],[\"它同样要求这些\",{\"1\":{\"116\":1}}],[\"它的实现原理是\",{\"1\":{\"598\":1}}],[\"它的实现类需要将这些方法实现\",{\"1\":{\"108\":1}}],[\"它的各个一维数组长度可以相同也可以不同\",{\"1\":{\"382\":1}}],[\"它的优点是简单\",{\"1\":{\"191\":1}}],[\"它的子类需要实现其他基础方法\",{\"1\":{\"105\":1}}],[\"它的子类可以按需要重写方法实现\",{\"1\":{\"104\":1}}],[\"它也方便我们把程序移植到不同平台\",{\"1\":{\"95\":1}}],[\"它还提供了maven插件的默认配置\",{\"1\":{\"82\":2}}],[\"它为我们的应用程序提供默认配置和完整的依赖树\",{\"1\":{\"82\":1}}],[\"它们分别从\",{\"1\":{\"678\":1}}],[\"它们的执行顺序是由他们在web\",{\"1\":{\"342\":1}}],[\"它们在设计和功能上有一些区别\",{\"1\":{\"213\":1}}],[\"它们之间底层实现方法以及与客户端之间通信的应用协议不一样\",{\"1\":{\"186\":1}}],[\"它们提供类似于\",{\"1\":{\"168\":1}}],[\"它们可以简化数据库访问和操作\",{\"1\":{\"168\":1}}],[\"它们都被spring\",{\"1\":{\"81\":1}}],[\"它们能快速持续的运行\",{\"1\":{\"81\":1}}],[\"它包含了一系列可以集成到应用里面的依赖包\",{\"1\":{\"81\":1}}],[\"它定义了bean的生命周期和可见范围\",{\"1\":{\"65\":1}}],[\"797\",{\"0\":{\"715\":1}}],[\"785\",{\"0\":{\"716\":1}}],[\"78\",{\"0\":{\"686\":1}}],[\"77\",{\"0\":{\"683\":1}}],[\"707\",{\"0\":{\"635\":1}}],[\"704\",{\"0\":{\"620\":1}}],[\"76\",{\"0\":{\"648\":1},\"1\":{\"622\":1}}],[\"76000989482f\",{\"1\":{\"599\":1}}],[\"72\",{\"1\":{\"622\":1}}],[\"71\",{\"1\":{\"622\":1}}],[\"74\",{\"1\":{\"622\":1}}],[\"73\",{\"1\":{\"622\":2}}],[\"739\",{\"0\":{\"622\":1}}],[\"7<\",{\"1\":{\"498\":1,\"540\":2}}],[\"752\",{\"0\":{\"713\":1}}],[\"75\",{\"1\":{\"124\":1,\"445\":1,\"622\":1}}],[\"7\",{\"0\":{\"65\":1,\"254\":1,\"255\":1,\"256\":1,\"264\":1,\"287\":1,\"289\":1,\"290\":1,\"291\":1,\"292\":1,\"293\":1,\"332\":1,\"516\":1,\"517\":1,\"518\":1,\"519\":1,\"520\":1,\"563\":1,\"579\":1,\"580\":1,\"581\":1,\"582\":1,\"583\":1,\"584\":1,\"607\":1,\"615\":1,\"691\":1,\"756\":1,\"764\":1,\"785\":1},\"1\":{\"116\":1,\"210\":1,\"362\":1,\"391\":1,\"477\":1,\"598\":1,\"616\":1,\"617\":1,\"625\":2,\"629\":1,\"630\":1,\"632\":1,\"634\":5,\"661\":9,\"667\":2,\"669\":2,\"677\":1,\"713\":1,\"726\":2}}],[\"注册中心\",{\"0\":{\"597\":1,\"599\":1},\"1\":{\"595\":1}}],[\"注册服务就会垮掉\",{\"1\":{\"207\":1}}],[\"注入配置类\",{\"1\":{\"603\":1}}],[\"注入数据源\",{\"1\":{\"583\":1}}],[\"注入datasource\",{\"1\":{\"575\":1,\"583\":1}}],[\"注入\",{\"1\":{\"575\":4,\"576\":2,\"577\":1,\"583\":2}}],[\"注入方法\",{\"1\":{\"564\":1}}],[\"注入基本类型属性\",{\"1\":{\"564\":1}}],[\"注入bean的类型与类属性类型相同\",{\"1\":{\"561\":1}}],[\"注入bean的id值和类属性名称一样\",{\"1\":{\"561\":1}}],[\"注入对象\",{\"1\":{\"557\":1}}],[\"注入course对象\",{\"1\":{\"557\":1}}],[\"注入集合类型属性\",{\"1\":{\"557\":1}}],[\"注入外部bean\",{\"1\":{\"557\":1}}],[\"注入外部\",{\"1\":{\"557\":1}}],[\"注入其他类型属性\",{\"1\":{\"557\":1}}],[\"注入属性\",{\"1\":{\"557\":5}}],[\"注释文字\",{\"1\":{\"354\":2}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"39\":1}}],[\"注\",{\"1\":{\"130\":1,\"537\":1}}],[\"注意字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串\",{\"1\":{\"653\":1}}],[\"注意在反转之前应当保存之后的节点\",{\"1\":{\"636\":1}}],[\"注意index是从0开始的\",{\"1\":{\"635\":1}}],[\"注意每次螺旋的变化\",{\"1\":{\"632\":1}}],[\"注意如果有多个实现类会报错\",{\"1\":{\"564\":1}}],[\"注意保存时\",{\"1\":{\"480\":1}}],[\"注意细节\",{\"1\":{\"458\":1,\"459\":1}}],[\"注意索引列的大小\",{\"1\":{\"174\":1}}],[\"注意事项\",{\"1\":{\"107\":1,\"113\":1,\"116\":1,\"164\":1,\"441\":1,\"468\":1,\"471\":1,\"478\":1}}],[\"注意\",{\"1\":{\"76\":1,\"98\":1,\"413\":1,\"430\":1,\"443\":1,\"477\":1,\"559\":1,\"648\":1,\"676\":1,\"684\":1,\"700\":1,\"728\":1}}],[\"注解作为前置通知\",{\"1\":{\"572\":1}}],[\"注解作用于方法\",{\"1\":{\"70\":1}}],[\"注解作用于类\",{\"1\":{\"70\":1}}],[\"注解类型\",{\"1\":{\"563\":1,\"564\":1}}],[\"注解不会生效\",{\"1\":{\"164\":1}}],[\"注解或者java配置来完成\",{\"1\":{\"160\":1}}],[\"注解中的属性相当于哪几个注解\",{\"0\":{\"84\":1}}],[\"注解方式等\",{\"1\":{\"76\":1}}],[\"注解进行查找\",{\"1\":{\"76\":1}}],[\"注解和\",{\"1\":{\"71\":1}}],[\"注解有什么用\",{\"0\":{\"71\":1}}],[\"注解使用示例\",{\"1\":{\"70\":2}}],[\"注解来注册\",{\"1\":{\"70\":1}}],[\"注解的自定义性更强\",{\"1\":{\"70\":1}}],[\"注解比\",{\"1\":{\"70\":1}}],[\"注解通常是我们在标有该注解的方法中定义产生这个\",{\"1\":{\"70\":1}}],[\"注解定义要扫描的路径从中找出标识了需要装配的类自动装配到\",{\"1\":{\"70\":1}}],[\"注解\",{\"0\":{\"422\":1},\"1\":{\"68\":1,\"83\":1,\"166\":2,\"422\":1,\"512\":1,\"564\":1}}],[\"注解配置包括\",{\"1\":{\"64\":1}}],[\"允许我们与容器交互\",{\"1\":{\"614\":1}}],[\"允许在请求中携带的头信息\",{\"1\":{\"607\":1}}],[\"允许的跨域请求方式\",{\"1\":{\"607\":1}}],[\"允许哪些网站的跨域请求\",{\"1\":{\"607\":1}}],[\"允许重复\",{\"1\":{\"451\":1}}],[\"允许通过添加注解来自动装配bean之间的依赖关系\",{\"1\":{\"64\":1}}],[\"允许多个该智能指针共享地\",{\"1\":{\"3\":1}}],[\"指明了访问的资源对象\",{\"1\":{\"760\":1}}],[\"指由相同字母重排列形成的字符串\",{\"1\":{\"649\":1}}],[\"指针\",{\"1\":{\"640\":1}}],[\"指针指向前移的数\",{\"1\":{\"623\":1}}],[\"指针从头到尾遍历数组\",{\"1\":{\"623\":1}}],[\"指向\",{\"1\":{\"717\":1}}],[\"指向前一个节点\",{\"1\":{\"636\":1}}],[\"指向后一个节点\",{\"1\":{\"636\":1}}],[\"指向更新\",{\"1\":{\"623\":1}}],[\"指向宿主机文件系统中的某个目录\",{\"1\":{\"615\":1}}],[\"指向shared\",{\"1\":{\"3\":1}}],[\"指定服务器上的文件路径来定位资源\",{\"1\":{\"757\":1}}],[\"指定服务器连接的网络端口号\",{\"1\":{\"757\":1}}],[\"指定用户名和密码作为从服务器获得资源时的登录信息\",{\"1\":{\"757\":1}}],[\"指定文档所在地址\",{\"1\":{\"746\":1}}],[\"指定容器运行时的监听端口\",{\"1\":{\"616\":1}}],[\"指定基础镜像\",{\"1\":{\"616\":1}}],[\"指定对userservice这个服务饥饿加载\",{\"1\":{\"598\":1}}],[\"指定哪种规则的方法上添加事务\",{\"1\":{\"583\":1}}],[\"指定包下的所有类型都有默认的别名\",{\"1\":{\"508\":1}}],[\"指定排序方法\",{\"1\":{\"452\":1}}],[\"指定索引位置插入\",{\"1\":{\"430\":1}}],[\"指定该注解是否会在javadoc上体现\",{\"1\":{\"422\":1}}],[\"指定注解可以在哪些地方使用\",{\"1\":{\"422\":1}}],[\"指定注解的作用范围\",{\"1\":{\"422\":1}}],[\"指定属性来装配bean之间的依赖关系\",{\"1\":{\"64\":1}}],[\"指数位\",{\"1\":{\"358\":1}}],[\"指客户端给服务器发请求\",{\"1\":{\"336\":1}}],[\"指出该消息可能需要持久性存储\",{\"1\":{\"209\":1}}],[\"指令定义集群中的每个容器如何运行\",{\"1\":{\"617\":1}}],[\"指令\",{\"1\":{\"205\":1,\"611\":1}}],[\"指令重排序可能导致线程间操作顺序的错乱\",{\"1\":{\"128\":1}}],[\"指标和其他运行时属性的模块\",{\"1\":{\"81\":1}}],[\"指的是spring中定义bean的作用域\",{\"1\":{\"65\":1}}],[\"yml文件配置如下\",{\"1\":{\"605\":1}}],[\"yml文件中添加规则\",{\"1\":{\"599\":1}}],[\"yml之前\",{\"1\":{\"602\":1}}],[\"yml\",{\"1\":{\"602\":2}}],[\"yml中的nacos地址\",{\"1\":{\"602\":1}}],[\"yml中的\",{\"1\":{\"602\":1}}],[\"yml中\",{\"1\":{\"598\":1}}],[\"ymk是二级目录\",{\"1\":{\"396\":1}}],[\"ymkedu\",{\"1\":{\"248\":1,\"418\":1}}],[\"ymk\",{\"1\":{\"63\":1,\"96\":4,\"99\":3,\"102\":12,\"105\":5,\"108\":5,\"111\":26,\"114\":6,\"117\":10,\"390\":1,\"396\":1,\"445\":1,\"451\":1,\"499\":1,\"501\":1,\"504\":2,\"508\":3,\"509\":1,\"522\":1,\"523\":2,\"524\":4,\"535\":1,\"540\":3,\"552\":1,\"555\":1,\"557\":18,\"559\":4,\"560\":3,\"561\":2,\"563\":3,\"565\":1,\"569\":1,\"571\":2,\"572\":6,\"576\":1,\"583\":3,\"584\":2}}],[\"your\",{\"1\":{\"655\":1,\"657\":1,\"658\":1,\"674\":1}}],[\"yo\",{\"1\":{\"499\":1,\"506\":1,\"540\":1,\"562\":1,\"575\":1,\"583\":1,\"584\":1}}],[\"yield\",{\"1\":{\"468\":2,\"472\":1}}],[\"year\",{\"1\":{\"436\":2,\"445\":4}}],[\"yaml可以做到多环境共享\",{\"1\":{\"604\":1}}],[\"yaml\",{\"1\":{\"599\":1,\"602\":1,\"604\":4}}],[\"yanmingkui\",{\"1\":{\"424\":1,\"457\":1}}],[\"yanghui\",{\"1\":{\"382\":1}}],[\"yahoo\",{\"1\":{\"111\":20}}],[\"yyyy\",{\"1\":{\"436\":2}}],[\"yy\",{\"1\":{\"354\":1}}],[\"y\",{\"1\":{\"105\":1,\"391\":2,\"408\":2,\"428\":2,\"489\":4,\"569\":2,\"709\":4}}],[\"yum\",{\"1\":{\"49\":1,\"616\":1}}],[\"xf\",{\"1\":{\"616\":1}}],[\"xiyouji\",{\"1\":{\"439\":1,\"440\":1}}],[\"x\",{\"1\":{\"376\":1,\"391\":5,\"417\":6,\"428\":2,\"489\":6,\"569\":2,\"607\":2,\"625\":1,\"639\":2,\"640\":2,\"655\":6,\"656\":2,\"657\":3,\"658\":3,\"695\":1,\"696\":1,\"705\":1,\"709\":41,\"711\":4,\"734\":4,\"742\":7,\"760\":1,\"786\":2}}],[\"xxx\",{\"1\":{\"754\":1}}],[\"xx来命名\",{\"1\":{\"415\":1}}],[\"xx\",{\"1\":{\"354\":1,\"415\":1,\"616\":1}}],[\"xms\",{\"1\":{\"146\":1}}],[\"xmx\",{\"1\":{\"146\":1}}],[\"xml自动装配\",{\"0\":{\"561\":1}}],[\"xmlmapper\",{\"1\":{\"540\":1}}],[\"xml中添加依赖\",{\"1\":{\"602\":1}}],[\"xml中获取参数\",{\"1\":{\"504\":1}}],[\"xml中从上到下的配置顺序决定的\",{\"1\":{\"342\":1}}],[\"xml配置servlet的地址\",{\"1\":{\"327\":1}}],[\"xml配置文件的实现方式在xml文件中使用<bean>等标签手动指定依赖关系\",{\"1\":{\"68\":1}}],[\"xml配置文件\",{\"1\":{\"68\":1}}],[\"xml配置文件中定义bean\",{\"1\":{\"62\":1}}],[\"xml文件中直接使用\",{\"1\":{\"82\":1}}],[\"xml文件\",{\"1\":{\"82\":1}}],[\"xmlschema\",{\"1\":{\"63\":1,\"327\":1,\"498\":1,\"540\":1,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1}}],[\"xmlns\",{\"1\":{\"63\":1,\"327\":4,\"498\":1,\"540\":1,\"552\":1,\"555\":1,\"557\":4,\"560\":4,\"561\":2,\"562\":5,\"563\":6,\"583\":4}}],[\"xmlns=\",{\"1\":{\"63\":1,\"327\":1,\"498\":1,\"540\":1,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1}}],[\"xml\",{\"0\":{\"505\":1,\"583\":1},\"1\":{\"63\":2,\"327\":4,\"339\":1,\"495\":1,\"498\":1,\"499\":3,\"501\":2,\"502\":1,\"504\":2,\"509\":2,\"511\":1,\"523\":2,\"540\":3,\"552\":3,\"555\":2,\"557\":11,\"558\":2,\"559\":1,\"560\":3,\"561\":1,\"562\":2,\"563\":3,\"565\":1,\"571\":1,\"576\":1,\"583\":3,\"584\":2,\"586\":2}}],[\"xml解析得到对象名\",{\"1\":{\"63\":1,\"555\":1}}],[\"xml解析\",{\"1\":{\"63\":2,\"555\":1}}],[\"x的\",{\"1\":{\"80\":1}}],[\"xss\",{\"1\":{\"786\":1}}],[\"xsd\",{\"1\":{\"63\":1,\"327\":1,\"498\":2,\"540\":2,\"552\":1,\"555\":1,\"557\":4,\"560\":4,\"561\":2,\"562\":5,\"563\":6,\"583\":4}}],[\"xsi\",{\"1\":{\"63\":1,\"327\":1,\"498\":1,\"540\":1,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1}}],[\"xsi=\",{\"1\":{\"63\":1,\"327\":1,\"498\":1,\"540\":1,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1}}],[\">1\",{\"1\":{\"636\":1}}],[\">null\",{\"1\":{\"636\":2}}],[\">5\",{\"1\":{\"636\":1}}],[\">4\",{\"1\":{\"636\":2}}],[\">3\",{\"1\":{\"636\":2}}],[\">3a\",{\"1\":{\"299\":1}}],[\">2\",{\"1\":{\"636\":2}}],[\">2b\",{\"1\":{\"299\":1}}],[\">路由过滤器>\",{\"1\":{\"607\":1}}],[\">string\",{\"1\":{\"430\":1}}],[\">stringbuffe\",{\"1\":{\"430\":1}}],[\">test\",{\"1\":{\"391\":5}}],[\">=\",{\"1\":{\"363\":1,\"367\":1,\"428\":1,\"622\":1,\"624\":2,\"628\":1,\"630\":2,\"635\":3,\"650\":1,\"675\":1,\"687\":1,\"688\":1,\"705\":2,\"706\":2,\"707\":2,\"708\":2,\"709\":4,\"720\":1,\"734\":2}}],[\">a问题就变成了1a\",{\"1\":{\"299\":1}}],[\">b\",{\"1\":{\"299\":1}}],[\">符号\",{\"1\":{\"129\":1}}],[\">>>\",{\"1\":{\"367\":1}}],[\">>\",{\"1\":{\"105\":1,\"367\":1,\"689\":1,\"701\":1}}],[\">dispatcherservlet\",{\"1\":{\"76\":1}}],[\"><null><\",{\"1\":{\"557\":1}}],[\"><\",{\"1\":{\"63\":1,\"67\":2,\"501\":1,\"522\":4,\"523\":19,\"524\":5,\"525\":12,\"527\":6,\"532\":1,\"552\":1,\"555\":1,\"557\":26,\"560\":3,\"561\":1,\"562\":9,\"563\":1,\"572\":1,\"575\":5,\"583\":8}}],[\">\",{\"1\":{\"63\":3,\"67\":4,\"111\":1,\"114\":1,\"233\":1,\"248\":13,\"249\":5,\"251\":4,\"253\":1,\"256\":4,\"262\":4,\"263\":1,\"268\":6,\"271\":6,\"298\":2,\"304\":1,\"307\":1,\"313\":2,\"318\":1,\"327\":7,\"363\":1,\"366\":3,\"367\":1,\"381\":1,\"391\":1,\"395\":4,\"419\":2,\"430\":1,\"440\":1,\"457\":1,\"458\":1,\"459\":1,\"460\":5,\"477\":1,\"488\":2,\"489\":5,\"490\":1,\"491\":2,\"498\":8,\"499\":13,\"501\":42,\"504\":5,\"506\":12,\"507\":2,\"508\":5,\"509\":7,\"511\":4,\"512\":7,\"517\":3,\"518\":1,\"519\":2,\"520\":1,\"522\":7,\"523\":11,\"524\":5,\"525\":6,\"527\":7,\"528\":4,\"529\":5,\"530\":4,\"531\":6,\"532\":6,\"535\":3,\"536\":1,\"540\":29,\"541\":1,\"552\":3,\"555\":3,\"557\":48,\"560\":8,\"561\":6,\"562\":10,\"563\":12,\"575\":5,\"578\":1,\"583\":22,\"586\":6,\"597\":1,\"599\":1,\"602\":1,\"606\":2,\"607\":2,\"614\":1,\"620\":1,\"622\":1,\"627\":1,\"628\":1,\"630\":1,\"631\":2,\"632\":3,\"635\":1,\"639\":2,\"647\":1,\"648\":1,\"650\":1,\"653\":2,\"658\":1,\"666\":1,\"669\":2,\"675\":1,\"677\":1,\"678\":1,\"687\":1,\"689\":1,\"690\":3,\"694\":2,\"696\":6,\"697\":2,\"698\":3,\"701\":1,\"718\":2,\"730\":1,\"734\":1,\"737\":1,\"740\":1,\"742\":1}}],[\"820\",{\"0\":{\"675\":1}}],[\"8286\",{\"1\":{\"598\":1}}],[\"84\",{\"0\":{\"662\":1}}],[\"8080\",{\"1\":{\"616\":2}}],[\"8080和localhost8081\",{\"1\":{\"607\":1}}],[\"80\",{\"1\":{\"605\":2,\"614\":2,\"615\":2}}],[\"80000\",{\"1\":{\"431\":3}}],[\"8000000\",{\"1\":{\"416\":1}}],[\"86c37ced48c5\",{\"1\":{\"598\":1}}],[\"834\",{\"1\":{\"524\":1}}],[\"8847\",{\"1\":{\"605\":2}}],[\"8846\",{\"1\":{\"605\":2}}],[\"8845\",{\"1\":{\"605\":2}}],[\"8848\",{\"1\":{\"599\":2,\"602\":1,\"607\":1,\"617\":2}}],[\"882\",{\"1\":{\"524\":1}}],[\"888888\",{\"1\":{\"480\":1}}],[\"8859\",{\"1\":{\"335\":1}}],[\"890\",{\"1\":{\"436\":3}}],[\"87\",{\"1\":{\"381\":1,\"404\":1}}],[\"8位\",{\"1\":{\"358\":1}}],[\"8bit\",{\"1\":{\"358\":1,\"476\":1}}],[\"8编码\",{\"1\":{\"356\":1}}],[\"8开始\",{\"1\":{\"204\":1}}],[\"8中出现了default修饰的方法\",{\"1\":{\"120\":1}}],[\"816\",{\"1\":{\"524\":1}}],[\"81\",{\"1\":{\"104\":1}}],[\"8\",{\"0\":{\"66\":1,\"88\":1,\"288\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":1,\"298\":1,\"299\":1,\"300\":1,\"333\":1,\"521\":1,\"522\":1,\"523\":1,\"524\":1,\"525\":1,\"564\":1,\"585\":1,\"586\":1,\"587\":1,\"588\":1,\"616\":1,\"703\":1,\"765\":1,\"786\":1},\"1\":{\"63\":1,\"124\":1,\"210\":1,\"327\":1,\"333\":1,\"335\":1,\"366\":1,\"466\":1,\"477\":4,\"478\":1,\"485\":1,\"498\":1,\"499\":1,\"501\":1,\"504\":1,\"540\":2,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1,\"586\":1,\"605\":1,\"614\":1,\"616\":3,\"625\":4,\"632\":1,\"713\":1,\"724\":1}}],[\"解集\",{\"1\":{\"686\":1}}],[\"解数独等等\",{\"1\":{\"681\":1}}],[\"解压nginx安装包\",{\"1\":{\"605\":1}}],[\"解析响应\",{\"1\":{\"606\":1}}],[\"解析\",{\"1\":{\"419\":1}}],[\"解析格式\",{\"1\":{\"354\":1}}],[\"解释\",{\"1\":{\"624\":1,\"625\":1,\"629\":1,\"630\":1,\"631\":4,\"645\":2,\"647\":1,\"648\":1,\"649\":1,\"650\":1,\"661\":1,\"678\":1,\"687\":1,\"693\":1,\"696\":1,\"697\":1,\"698\":1,\"701\":1,\"702\":1,\"708\":1,\"709\":1,\"716\":1,\"717\":1,\"718\":2,\"720\":1}}],[\"解释型语言\",{\"1\":{\"346\":2}}],[\"解释一下\",{\"1\":{\"6\":1}}],[\"解除阻塞\",{\"1\":{\"270\":1}}],[\"解锁\",{\"1\":{\"205\":1}}],[\"解决字符串拼接痛点\",{\"1\":{\"526\":1}}],[\"解决post请求的乱码问题\",{\"1\":{\"333\":1}}],[\"解决了静态代理中冗余的代理实现类问题\",{\"1\":{\"492\":1}}],[\"解决了什么问题\",{\"0\":{\"295\":1}}],[\"解决了不可重复读的问题\",{\"1\":{\"171\":1}}],[\"解决缓存与数据库一致性问题\",{\"0\":{\"196\":1}}],[\"解决并发事务带来的问题\",{\"1\":{\"171\":1}}],[\"解决跨域问题\",{\"1\":{\"78\":1}}],[\"解法很简单\",{\"1\":{\"715\":1}}],[\"解法\",{\"1\":{\"90\":1,\"91\":1}}],[\"解耦发送消息的功能\",{\"1\":{\"207\":1}}],[\"解耦\",{\"1\":{\"63\":1,\"207\":1,\"555\":1}}],[\"通信过程中\",{\"1\":{\"780\":1}}],[\"通信数据转发程序\",{\"0\":{\"780\":1}}],[\"通信的两端都要有socket\",{\"1\":{\"484\":1}}],[\"通用首部字段\",{\"1\":{\"784\":1}}],[\"通用日志封装\",{\"0\":{\"586\":1}}],[\"通用注解\",{\"1\":{\"69\":1}}],[\"通知客户端保存cookie\",{\"1\":{\"765\":1}}],[\"通知\",{\"1\":{\"570\":1}}],[\"通知方式\",{\"1\":{\"467\":1}}],[\"通俗描述\",{\"1\":{\"567\":1}}],[\"通常使用的网络是在tcp\",{\"1\":{\"747\":1}}],[\"通常用\",{\"1\":{\"694\":1}}],[\"通常用于优化和改进查询性能\",{\"1\":{\"177\":1}}],[\"通常被用来对接入的http请求\",{\"1\":{\"607\":1}}],[\"通常通过构造函数参数或属性访问器方法完成此操作\",{\"1\":{\"545\":1}}],[\"通常称为\",{\"1\":{\"545\":1}}],[\"通常将释放资源的代码放在finally\",{\"1\":{\"424\":1}}],[\"通常都会以轮询地方式去获取结果尽量不要阻塞\",{\"1\":{\"234\":1}}],[\"通常不会是瓶颈\",{\"1\":{\"187\":1}}],[\"通常\",{\"1\":{\"155\":1}}],[\"通常是指在redis\",{\"1\":{\"187\":1}}],[\"通常是先执行远离\",{\"1\":{\"184\":1}}],[\"通常是一个类似于session\",{\"1\":{\"153\":1}}],[\"通常是通过路径扫描来自动侦测以及自动装配到\",{\"1\":{\"70\":1}}],[\"通常在用户关闭浏览器或者一段时间不活动后失效\",{\"1\":{\"153\":1}}],[\"通常无法更改\",{\"1\":{\"152\":1}}],[\"通常只需要在一个类中添加几个注解即可完成bean的定义\",{\"1\":{\"62\":1}}],[\"通过代理服务器把通信内容加密后经网络隧道传输\",{\"1\":{\"763\":1}}],[\"通过请求和响应的交换达成通信\",{\"0\":{\"760\":1}}],[\"通过http协议能够明确区分两端\",{\"1\":{\"759\":1}}],[\"通过hashcode可以直接确定位置\",{\"1\":{\"492\":1}}],[\"通过hash计算可以直接定位某个值存储的位置\",{\"1\":{\"492\":1}}],[\"通过handleradapter对处理器进行执行\",{\"1\":{\"76\":1}}],[\"通过分隔符将其转为字符串数组\",{\"1\":{\"729\":1}}],[\"通过分步查询门以及部门中的员工信息\",{\"1\":{\"525\":1}}],[\"通过分步查询处理一对多映射\",{\"1\":{\"525\":1}}],[\"通过相邻的单元格内的字母构成\",{\"1\":{\"705\":1}}],[\"通过一个快指针和慢指针在一个for循环下完成两个for循环的工作\",{\"1\":{\"623\":1}}],[\"通过一个类的全限定名来获取定义此类的二进制字节流\",{\"1\":{\"419\":1}}],[\"通过restapi\",{\"1\":{\"611\":1}}],[\"通过动态代理创建一个代理实例\",{\"1\":{\"606\":1}}],[\"通过动态装载\",{\"1\":{\"116\":1}}],[\"通过注解给这个属性赋了一个值\",{\"1\":{\"564\":2}}],[\"通过序列化\",{\"1\":{\"536\":1}}],[\"通过同一个\",{\"1\":{\"534\":1,\"535\":1}}],[\"通过包设置别名\",{\"1\":{\"508\":1}}],[\"通过输出流\",{\"1\":{\"485\":1}}],[\"通过socket\",{\"1\":{\"485\":1}}],[\"通过index来遍历\",{\"1\":{\"440\":1}}],[\"通过继承类的方式\",{\"1\":{\"419\":1}}],[\"通过静态代理来实现功能增强\",{\"1\":{\"419\":1}}],[\"通过静态工厂\",{\"0\":{\"130\":1}}],[\"通过java语言编写的\",{\"1\":{\"322\":1}}],[\"通过park方法\",{\"1\":{\"312\":1}}],[\"通过硬件保证了cas的原子性\",{\"1\":{\"295\":1}}],[\"通过这些内存屏障指令\",{\"1\":{\"290\":1}}],[\"通过win+r打开运行\",{\"1\":{\"264\":1}}],[\"通过增加消费者或增加分区等方式\",{\"1\":{\"214\":1}}],[\"通过增加分区和副本等方式将数据分散存储和处理\",{\"1\":{\"214\":1}}],[\"通过路由键将交换器和队列绑定起来\",{\"1\":{\"210\":1}}],[\"通过bindingkey\",{\"1\":{\"209\":1}}],[\"通过绑定将交换器和队列关联起来\",{\"1\":{\"209\":1}}],[\"通过交换信息来达成一致\",{\"1\":{\"203\":1}}],[\"通过使用\",{\"1\":{\"199\":1}}],[\"通过使用volatile关键字\",{\"1\":{\"128\":1}}],[\"通过消息队列通知系统\",{\"1\":{\"196\":1}}],[\"通过追踪每个\",{\"1\":{\"186\":1}}],[\"通过执行explain加上需要分析的sql语句\",{\"1\":{\"182\":1}}],[\"通过非聚簇索引可以快速定位到满足查询条件的数据行\",{\"1\":{\"179\":1}}],[\"通过回滚这些undo日志可以撤销已提交的事务对数据行的修改\",{\"1\":{\"178\":1}}],[\"通过强制事务的串行执行来避免并发问题\",{\"1\":{\"171\":1}}],[\"通过配置文件或注解的方式\",{\"1\":{\"158\":2}}],[\"通过队列和等待\",{\"1\":{\"141\":1}}],[\"通过将任务放入阻塞队列\",{\"1\":{\"135\":1}}],[\"通过thread类的setuncaughtexceptionhandler\",{\"1\":{\"133\":1}}],[\"通过返回future对象来获取异步计算的结果\",{\"1\":{\"133\":1}}],[\"通过实现接口的方式\",{\"1\":{\"419\":1}}],[\"通过实现run\",{\"1\":{\"133\":1}}],[\"通过实现该接口定义横切逻辑\",{\"1\":{\"72\":1,\"159\":1}}],[\"通过创建\",{\"1\":{\"132\":1}}],[\"通过享元模式缓存频繁请求的值来显着提高空间和时间性能\",{\"1\":{\"130\":1}}],[\"通过指定泛型类型参数\",{\"1\":{\"123\":1}}],[\"通过指定应该装配哪\",{\"1\":{\"71\":1}}],[\"通过泛型指定的不同类型来控制形参具体限制的类型\",{\"1\":{\"123\":1}}],[\"通过char\",{\"1\":{\"121\":1}}],[\"通过桥接模式可以使它们在抽象层建立一个关联关系\",{\"1\":{\"113\":1}}],[\"通过新的banner类\",{\"1\":{\"96\":1}}],[\"通过扩展适配器可以对更多类型的处理器进行执行\",{\"1\":{\"76\":1}}],[\"通过构造器创建\",{\"1\":{\"66\":1,\"560\":1}}],[\"通过调用discard\",{\"1\":{\"202\":1}}],[\"通过调用构造函数或者setter方法\",{\"1\":{\"163\":1}}],[\"通过调用\",{\"1\":{\"64\":1}}],[\"通过xml文件配置应用程序上下文\",{\"1\":{\"64\":1}}],[\"通过反射创建对象\",{\"1\":{\"63\":1,\"555\":1}}],[\"通过\",{\"1\":{\"14\":1,\"17\":1,\"116\":2,\"198\":1,\"492\":1,\"525\":1}}],[\"繁琐程度不同\",{\"1\":{\"62\":1}}],[\"只包含正整数\",{\"1\":{\"701\":1}}],[\"只包含一个抽象方法的接口\",{\"1\":{\"129\":1}}],[\"只记录与当前计算相关的前两个结果\",{\"1\":{\"697\":1}}],[\"只保留f\",{\"1\":{\"694\":1}}],[\"只用o\",{\"1\":{\"693\":1}}],[\"只允许使用额外常数空间\",{\"1\":{\"628\":1}}],[\"只允许一个事务请求同一数据\",{\"1\":{\"170\":1}}],[\"只向内移动短板\",{\"1\":{\"625\":1}}],[\"只读缓存\",{\"1\":{\"536\":1}}],[\"只读\",{\"1\":{\"536\":1}}],[\"只是调用了泛型\",{\"1\":{\"459\":1}}],[\"只是用来处理网络数据的读写和协议的解析\",{\"1\":{\"187\":1}}],[\"只维护一个代理类\",{\"1\":{\"419\":1}}],[\"只打印998\",{\"1\":{\"415\":1}}],[\"只会执行一次\",{\"1\":{\"413\":1}}],[\"只会等待\",{\"1\":{\"204\":1}}],[\"只创建必要的索引\",{\"1\":{\"174\":1}}],[\"只能\",{\"1\":{\"677\":1}}],[\"只能判断两个字符串是否放在相同的位置上\",{\"1\":{\"429\":1}}],[\"只能写static\",{\"1\":{\"413\":1}}],[\"只能在构造器中使用\",{\"1\":{\"393\":1}}],[\"只能在自己的工程里跳转\",{\"1\":{\"334\":1}}],[\"只能在init\",{\"1\":{\"327\":1}}],[\"只能在方法内部进行异常处理\",{\"1\":{\"133\":1}}],[\"只能获取一次返回0\",{\"1\":{\"313\":1}}],[\"只能取以下值之一\",{\"1\":{\"312\":1}}],[\"只能通过阻塞或轮询的方式得到任务的结果\",{\"1\":{\"235\":1}}],[\"只能通过\",{\"1\":{\"70\":1}}],[\"只需要连接你遍历数组的两个方向就可以全部连接了\",{\"1\":{\"709\":1}}],[\"只需要在内部节点中进行比较操作\",{\"1\":{\"172\":1}}],[\"只需检查符号即可\",{\"1\":{\"312\":1}}],[\"只需调整节点的指针\",{\"1\":{\"122\":1}}],[\"只需在方法上添加\",{\"1\":{\"62\":1}}],[\"只要使用虚拟主机的功能\",{\"1\":{\"779\":1}}],[\"只要\",{\"1\":{\"650\":1}}],[\"只要让\",{\"1\":{\"643\":1}}],[\"只要符合第一个就只会加上第一个条件\",{\"1\":{\"530\":1}}],[\"只要扩展一个工厂类就可以\",{\"1\":{\"101\":1}}],[\"只要知道其名称就可以了\",{\"1\":{\"101\":1}}],[\"只要加入springboot\",{\"1\":{\"81\":1}}],[\"只有满足下面几点之一\",{\"1\":{\"660\":1}}],[\"只有当输出栈中没有数据时再从输出栈中读取数据\",{\"1\":{\"655\":1}}],[\"只有当\",{\"1\":{\"649\":2}}],[\"只有执行了createnewfile才会创建文件\",{\"1\":{\"475\":1}}],[\"只有加载类或创建对象时隐式调用\",{\"1\":{\"413\":1}}],[\"只有方法体\",{\"1\":{\"413\":1}}],[\"只有public和默认才能修饰类\",{\"1\":{\"397\":1}}],[\"只有全部相等才更新值\",{\"1\":{\"299\":1}}],[\"只有单个线程\",{\"1\":{\"186\":1}}],[\"只有在编译时期无法确定需要实现哪个接口时才有必要使用代理\",{\"1\":{\"419\":1}}],[\"只有在这个线程中才能访问的到\",{\"1\":{\"304\":1}}],[\"只有在每次访问的时候才会检查键值是否过期\",{\"1\":{\"191\":1}}],[\"只有在建筑的后期才有加壁橱加栅栏等差异\",{\"1\":{\"104\":1}}],[\"只有在引用计数归零的时候\",{\"1\":{\"3\":1}}],[\"只有将\",{\"1\":{\"67\":1}}],[\"只有\",{\"1\":{\"5\":1,\"358\":1}}],[\"简洁版\",{\"0\":{\"540\":1}}],[\"简介\",{\"0\":{\"321\":1,\"494\":1,\"593\":1}}],[\"简单的http协议\",{\"0\":{\"758\":1}}],[\"简单题\",{\"1\":{\"707\":1}}],[\"简单来说\",{\"1\":{\"639\":1}}],[\"简单来说就是http请求动态代理\",{\"1\":{\"606\":1}}],[\"简单方便的调用\",{\"1\":{\"593\":1}}],[\"简单\",{\"1\":{\"148\":1}}],[\"简单函数\",{\"1\":{\"6\":1}}],[\"简少了maven的配置\",{\"1\":{\"80\":1}}],[\"简化开发\",{\"1\":{\"549\":1}}],[\"简化配置\",{\"1\":{\"80\":1}}],[\"简化了错误处理策略\",{\"1\":{\"61\":1}}],[\"输⼊\",{\"1\":{\"689\":1}}],[\"输⼊⼀个初始数组\",{\"1\":{\"677\":1,\"678\":1}}],[\"输出描述\",{\"1\":{\"724\":1}}],[\"输出处理\",{\"1\":{\"630\":1}}],[\"输出终端\",{\"1\":{\"614\":1}}],[\"输出修改成到\",{\"1\":{\"479\":1}}],[\"输出数据的位置是\",{\"1\":{\"479\":1}}],[\"输出流\",{\"1\":{\"476\":2}}],[\"输出output\",{\"1\":{\"476\":1}}],[\"输出不是按add顺序来的\",{\"1\":{\"444\":1}}],[\"输出false\",{\"1\":{\"429\":1}}],[\"输出1\",{\"1\":{\"427\":1}}],[\"输出该属性会导致类加载\",{\"1\":{\"415\":1}}],[\"输出都为2\",{\"1\":{\"411\":1}}],[\"输出都为1\",{\"1\":{\"411\":1}}],[\"输出base类型的count\",{\"1\":{\"402\":1}}],[\"输出为meow\",{\"1\":{\"402\":1}}],[\"输出为woo\",{\"1\":{\"402\":1}}],[\"输出为4\",{\"1\":{\"381\":1}}],[\"输出为\",{\"1\":{\"359\":1,\"413\":1,\"418\":1}}],[\"输出为1\",{\"1\":{\"359\":1,\"381\":1}}],[\"输出的是对应的unicode码\",{\"1\":{\"358\":1}}],[\"输出两个则需要四个\",{\"1\":{\"353\":1}}],[\"输出\",{\"1\":{\"89\":1,\"90\":1,\"91\":1,\"413\":1,\"479\":1,\"622\":1,\"624\":1,\"625\":1,\"629\":2,\"630\":1,\"631\":4,\"632\":1,\"634\":3,\"636\":1,\"643\":1,\"645\":3,\"647\":1,\"648\":2,\"649\":1,\"650\":1,\"651\":2,\"659\":2,\"660\":2,\"661\":1,\"667\":3,\"668\":2,\"677\":1,\"678\":1,\"684\":3,\"686\":1,\"687\":1,\"688\":1,\"689\":1,\"690\":2,\"693\":1,\"696\":1,\"697\":1,\"698\":1,\"700\":1,\"701\":1,\"702\":1,\"706\":1,\"708\":1,\"709\":1,\"716\":1,\"717\":1,\"718\":4,\"720\":1,\"724\":1,\"729\":1,\"730\":1}}],[\"输出结果返回一个list<string>\",{\"1\":{\"255\":1}}],[\"输出结果\",{\"1\":{\"55\":2,\"697\":1,\"698\":1,\"718\":1}}],[\"输入给了二维数组信息和约束条件\",{\"1\":{\"733\":1}}],[\"输入描述\",{\"1\":{\"729\":1,\"730\":1}}],[\"输入是一串数字\",{\"1\":{\"729\":1}}],[\"输入例子\",{\"1\":{\"726\":1}}],[\"输入处理\",{\"1\":{\"718\":1}}],[\"输入一个整型数组\",{\"1\":{\"693\":1}}],[\"输入栈和输出栈\",{\"1\":{\"655\":1}}],[\"输入字符串\",{\"1\":{\"646\":1}}],[\"输入字符串可以在前面或者后面包含多余的空格\",{\"1\":{\"645\":1}}],[\"输入字符串以字符数组\",{\"1\":{\"642\":1}}],[\"输入流\",{\"1\":{\"476\":2}}],[\"输入input\",{\"1\":{\"476\":1}}],[\"输入jconsole打开java控制台\",{\"1\":{\"264\":1}}],[\"输入\",{\"1\":{\"89\":1,\"90\":1,\"91\":1,\"523\":1,\"524\":1,\"622\":1,\"624\":1,\"625\":1,\"629\":2,\"630\":1,\"631\":4,\"632\":1,\"634\":3,\"636\":1,\"643\":1,\"645\":3,\"647\":1,\"648\":1,\"649\":1,\"650\":1,\"651\":2,\"659\":2,\"660\":2,\"661\":1,\"667\":3,\"668\":2,\"677\":1,\"678\":1,\"684\":3,\"686\":1,\"687\":1,\"688\":1,\"690\":2,\"693\":1,\"696\":1,\"697\":1,\"698\":1,\"701\":1,\"702\":1,\"706\":1,\"708\":1,\"709\":1,\"716\":1,\"717\":1,\"718\":3,\"720\":1,\"724\":1,\"729\":1,\"730\":2}}],[\"输入上一步得到的ip地址和虚拟机的用户名和密码即可登录\",{\"1\":{\"49\":1}}],[\"后序遍历\",{\"1\":{\"664\":1}}],[\"后指针\",{\"1\":{\"636\":1}}],[\"后台运行容器\",{\"1\":{\"614\":1}}],[\"后置方法增强\",{\"1\":{\"572\":1}}],[\"后置通知\",{\"1\":{\"570\":1}}],[\"后置处理器\",{\"1\":{\"66\":1,\"560\":1}}],[\"后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串\",{\"1\":{\"653\":1}}],[\"后缀l表示这是一个长整型\",{\"1\":{\"358\":1}}],[\"后缀名匹配\",{\"1\":{\"343\":1}}],[\"后继节点\",{\"1\":{\"312\":1}}],[\"后\",{\"1\":{\"203\":1,\"362\":2}}],[\"后删除缓存\",{\"1\":{\"195\":1}}],[\"后更新数据库\",{\"1\":{\"195\":1}}],[\"后的结果集\",{\"1\":{\"184\":1}}],[\"后者可以通过throw和catch来自定义处理\",{\"1\":{\"126\":1}}],[\"后者不能添加会导致拼接的字符串无法表示唯一的对应关系\",{\"1\":{\"7\":1}}],[\"后面的都到达不了\",{\"1\":{\"696\":1}}],[\"后面的每一项数字都是前面两项数字的和\",{\"1\":{\"694\":1}}],[\"后面的所有数\",{\"1\":{\"628\":1}}],[\"后面的子类catch就没意义了\",{\"1\":{\"424\":1}}],[\"后面集合中\",{\"1\":{\"406\":1}}],[\"后面\",{\"1\":{\"91\":1}}],[\"后面出现数的个数\",{\"1\":{\"55\":1}}],[\"第七章\",{\"0\":{\"787\":1}}],[\"第六章\",{\"0\":{\"782\":1}}],[\"第五章\",{\"0\":{\"778\":1}}],[\"第四章\",{\"0\":{\"772\":1}}],[\"第i行三个数val\",{\"1\":{\"730\":1}}],[\"第root个节点时二叉树的根\",{\"1\":{\"730\":1}}],[\"第0个节点就是头结点\",{\"1\":{\"635\":1}}],[\"第\",{\"1\":{\"625\":1,\"677\":2}}],[\"第1行只有一个数字\",{\"1\":{\"718\":1}}],[\"第1\",{\"1\":{\"328\":1}}],[\"第三章\",{\"0\":{\"766\":1}}],[\"第三次调用服务3\",{\"1\":{\"598\":1}}],[\"第三代日期\",{\"1\":{\"436\":1}}],[\"第三代日期类\",{\"1\":{\"436\":1}}],[\"第三种方案也存在问题\",{\"1\":{\"195\":1}}],[\"第三方的\",{\"1\":{\"81\":1}}],[\"第二章\",{\"0\":{\"758\":1}}],[\"第二次调用服务\",{\"1\":{\"598\":1}}],[\"第二次查询会返回额外的行\",{\"1\":{\"178\":1}}],[\"第二代日期类\",{\"1\":{\"436\":1}}],[\"第二种方法\",{\"1\":{\"603\":1}}],[\"第二种方案存在的问题是\",{\"1\":{\"195\":1}}],[\"第二种写法\",{\"1\":{\"557\":1}}],[\"第二种注入方式\",{\"1\":{\"557\":1}}],[\"第二种可能就是采用了相同的过期时间\",{\"1\":{\"198\":1}}],[\"第二行开始每一行第一个数代表\",{\"1\":{\"55\":1}}],[\"第一章\",{\"0\":{\"744\":1}}],[\"第一行两个数n\",{\"1\":{\"730\":1}}],[\"第一行代表\",{\"1\":{\"55\":1}}],[\"第一代日期类\",{\"1\":{\"436\":1}}],[\"第一个servlet程序\",{\"0\":{\"327\":1}}],[\"第一个支持注解的版本\",{\"1\":{\"59\":1}}],[\"第一次访问才会创建loadbalancer\",{\"1\":{\"598\":1}}],[\"第一次调用服务\",{\"1\":{\"598\":1}}],[\"第一次添加时\",{\"1\":{\"445\":1}}],[\"第一次添加则扩容为10\",{\"1\":{\"441\":1}}],[\"第一次102\",{\"1\":{\"442\":1}}],[\"第一次检测\",{\"1\":{\"292\":1}}],[\"第一次连接\",{\"1\":{\"204\":1}}],[\"第一种方法\",{\"1\":{\"603\":1}}],[\"第一种写法\",{\"1\":{\"557\":1}}],[\"第一种注入方式\",{\"1\":{\"557\":1}}],[\"第一种是redis宕机\",{\"1\":{\"198\":1}}],[\"第一种和第二种方案\",{\"1\":{\"195\":1}}],[\"包\",{\"1\":{\"575\":1,\"586\":1}}],[\"包装节点流\",{\"1\":{\"478\":1}}],[\"包装流\",{\"1\":{\"476\":1,\"478\":1}}],[\"包装类和基本数据的转化\",{\"1\":{\"427\":1}}],[\"包装类的分类\",{\"1\":{\"427\":1}}],[\"包装类\",{\"0\":{\"427\":1}}],[\"包的本质\",{\"1\":{\"396\":1}}],[\"包的三大作用\",{\"1\":{\"396\":1}}],[\"包名\",{\"1\":{\"396\":1,\"540\":2}}],[\"包基本语法\",{\"1\":{\"396\":1}}],[\"包package\",{\"0\":{\"396\":1}}],[\"包括i\",{\"1\":{\"653\":2}}],[\"包括int\",{\"1\":{\"55\":1}}],[\"包括相同的字符串\",{\"1\":{\"649\":1}}],[\"包括开始采摘的树\",{\"1\":{\"631\":1}}],[\"包括端口监听和网络连接情况\",{\"1\":{\"485\":1}}],[\"包括null\",{\"1\":{\"443\":1}}],[\"包括索引使用情况\",{\"1\":{\"182\":1}}],[\"包括增删改表数据的语句\",{\"1\":{\"177\":1}}],[\"包括请求的\",{\"1\":{\"161\":1}}],[\"包括大部分常用的英文字符\",{\"1\":{\"121\":1}}],[\"包括\",{\"1\":{\"76\":1,\"177\":1,\"676\":1}}],[\"包中的两个类\",{\"1\":{\"72\":1,\"159\":1}}],[\"包中所有类的一切操作\",{\"1\":{\"57\":1}}],[\"包含在请求报文中的某些首部字段就是判断基准\",{\"1\":{\"771\":1}}],[\"包含在jdk中\",{\"1\":{\"348\":1}}],[\"包含重复的子集\",{\"1\":{\"686\":1}}],[\"包含来自字符串\",{\"1\":{\"648\":1}}],[\"包含一个虚拟头节点\",{\"1\":{\"635\":1}}],[\"包含构建镜像的指令\",{\"1\":{\"616\":1}}],[\"包含操作系统函数库\",{\"1\":{\"609\":1}}],[\"包含3个nacos节点\",{\"1\":{\"605\":1}}],[\"包含了一组死亡数字\",{\"1\":{\"713\":1}}],[\"包含了一系列静态方法\",{\"1\":{\"433\":1}}],[\"包含了filter配置文件的配置信息\",{\"1\":{\"341\":1}}],[\"包含基本数学运算的方法\",{\"1\":{\"432\":1}}],[\"包含基本类型和引用类型\",{\"1\":{\"389\":1}}],[\"包含enum类的一些属性和方法\",{\"1\":{\"421\":1}}],[\"包含世界上所有字符\",{\"1\":{\"356\":1}}],[\"包含英语字符\",{\"1\":{\"356\":1}}],[\"包含的信息\",{\"1\":{\"331\":1}}],[\"包含两个属性\",{\"1\":{\"299\":1}}],[\"包含三个操作数\",{\"1\":{\"295\":1}}],[\"包含响应的数据和视图信息\",{\"1\":{\"161\":1}}],[\"包含自动配置\",{\"1\":{\"81\":1}}],[\"包含\",{\"1\":{\"18\":1,\"678\":1}}],[\"支持httpclient的开关\",{\"1\":{\"606\":1}}],[\"支持连接池\",{\"1\":{\"606\":2}}],[\"支持多个接口\",{\"1\":{\"569\":1}}],[\"支持定制化\",{\"1\":{\"495\":1}}],[\"支持a类以及a类的父类\",{\"1\":{\"460\":1}}],[\"支持a类以及a类的子类\",{\"1\":{\"460\":1}}],[\"支持任意泛型类型\",{\"1\":{\"460\":1}}],[\"支持先唤醒后等待\",{\"1\":{\"271\":1}}],[\"支持事务和消息确认机制\",{\"1\":{\"213\":1}}],[\"支持事务和并发性\",{\"1\":{\"183\":1}}],[\"支持\",{\"1\":{\"81\":1}}],[\"支持响应式编程\",{\"1\":{\"59\":1}}],[\"支持各种类型的数据输入\",{\"1\":{\"55\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"26\":1}}],[\"并保持双方通信连接的应用程序\",{\"1\":{\"780\":1}}],[\"并保存\",{\"1\":{\"203\":1}}],[\"并满足每个函数的\",{\"1\":{\"721\":1}}],[\"并使图中的每一条边的两个节点一个来自\",{\"1\":{\"716\":1}}],[\"并使用选举算法选出新的主节点\",{\"1\":{\"203\":1}}],[\"并使用\",{\"1\":{\"134\":1}}],[\"并查集类\",{\"1\":{\"709\":1}}],[\"并查集模板类\",{\"1\":{\"709\":1}}],[\"并查集的思想就是\",{\"1\":{\"709\":1}}],[\"并查集常用来解决连通性的问题\",{\"1\":{\"709\":1}}],[\"并查集\",{\"0\":{\"679\":1,\"709\":1},\"1\":{\"709\":2}}],[\"并求出两个链表长度的差值\",{\"1\":{\"639\":1}}],[\"并继续采摘\",{\"1\":{\"631\":1}}],[\"并配置\",{\"1\":{\"552\":1}}],[\"并生成对象\",{\"1\":{\"492\":1}}],[\"并写入到\",{\"1\":{\"478\":1}}],[\"并释放锁\",{\"1\":{\"472\":1}}],[\"并不是比较字符串内容\",{\"1\":{\"429\":1}}],[\"并不及时更新到主内存中\",{\"1\":{\"140\":1}}],[\"并利用throw语句抛出一个检查型异常\",{\"1\":{\"425\":1}}],[\"并把注解当作一个修饰后面程序的修饰符\",{\"1\":{\"422\":1}}],[\"并能够打印房屋明细表\",{\"1\":{\"408\":1}}],[\"并用逗号隔开\",{\"1\":{\"373\":1}}],[\"并指定运行该方法\",{\"1\":{\"352\":1}}],[\"并实现dofilter\",{\"1\":{\"339\":1}}],[\"并实现其中的\",{\"1\":{\"132\":1}}],[\"并响应数据给客户端\",{\"1\":{\"326\":1}}],[\"并在\",{\"1\":{\"583\":1}}],[\"并在子类中采用方法拦截的技术拦截所有父类方法的调用\",{\"1\":{\"492\":1}}],[\"并在控制台打印\",{\"1\":{\"489\":1}}],[\"并在多线程的情况\",{\"1\":{\"431\":1}}],[\"并在单线程的情况\",{\"1\":{\"431\":1}}],[\"并在使用后清空\",{\"1\":{\"312\":1}}],[\"并在出队时清空\",{\"1\":{\"312\":2}}],[\"并在方法执行前后进行一些额外的处理\",{\"1\":{\"166\":1}}],[\"并重写指定方法即可实现一套线程同步机制\",{\"1\":{\"311\":1}}],[\"并重写目标对象的方法来实现代理逻辑\",{\"1\":{\"159\":1}}],[\"并存储值\",{\"1\":{\"306\":1}}],[\"并订阅到队列上\",{\"1\":{\"209\":1}}],[\"并动态调整节点分布\",{\"1\":{\"203\":1}}],[\"并放弃执行事务\",{\"1\":{\"202\":1}}],[\"并检查对应位置的位值\",{\"1\":{\"194\":1}}],[\"并进入运行状态\",{\"1\":{\"613\":1}}],[\"并进入自旋状态\",{\"1\":{\"141\":1}}],[\"并进行处理\",{\"1\":{\"191\":1}}],[\"并可以对数据进行计算\",{\"1\":{\"184\":1}}],[\"并可能消耗更多的网络资源\",{\"1\":{\"156\":1}}],[\"并支持行级锁定\",{\"1\":{\"183\":1}}],[\"并确保数据的一致性和完整性\",{\"1\":{\"180\":1}}],[\"并提高索引查询的效率\",{\"1\":{\"174\":1}}],[\"并提供一个访问它的全局访问点\",{\"1\":{\"98\":1}}],[\"并与服务器端存储的\",{\"1\":{\"165\":1}}],[\"并设置\",{\"1\":{\"165\":1}}],[\"并设置相应的线程状态和等待状态\",{\"1\":{\"143\":1}}],[\"并将这些区域里所有的\",{\"1\":{\"709\":1}}],[\"并将这些组件注入需要它们的\",{\"1\":{\"545\":1}}],[\"并将对应位置的位设为\",{\"1\":{\"194\":1}}],[\"并将所有位初始化为\",{\"1\":{\"194\":1}}],[\"并将该\",{\"1\":{\"165\":1}}],[\"并将其他节点设置为从节点\",{\"1\":{\"203\":2}}],[\"并将其发送给服务器\",{\"1\":{\"155\":1}}],[\"并将其与特定的域名关联\",{\"1\":{\"155\":1}}],[\"并将其转换为另一种类型的结果\",{\"1\":{\"129\":1}}],[\"并行发送\",{\"1\":{\"764\":1}}],[\"并行\",{\"1\":{\"224\":1}}],[\"并行通过同时执行多个任务来加速任务的完成\",{\"1\":{\"151\":1}}],[\"并行是指多个任务在同一时刻同时执行\",{\"1\":{\"151\":1}}],[\"并发\",{\"1\":{\"224\":1}}],[\"并发与并行的区别\",{\"0\":{\"224\":1}}],[\"并发更新数据库场景下\",{\"1\":{\"195\":1}}],[\"并发事务中的更新操作可能会相互覆盖\",{\"1\":{\"171\":1}}],[\"并发事务可能导致数据的不一致性\",{\"1\":{\"171\":1}}],[\"并发事务会带来哪些问题\",{\"0\":{\"171\":1},\"1\":{\"171\":1}}],[\"并发通过任务切换来提高系统的吞吐量和性能\",{\"1\":{\"151\":1}}],[\"并发是指多个任务在同一时间段内交替执行\",{\"1\":{\"151\":1}}],[\"并发和并行的区别\",{\"0\":{\"151\":1}}],[\"并发性\",{\"1\":{\"150\":1}}],[\"并发度更高\",{\"1\":{\"125\":1}}],[\"并返回\",{\"1\":{\"721\":2}}],[\"并返回其根节点\",{\"1\":{\"667\":1}}],[\"并返回其长度\",{\"1\":{\"630\":1}}],[\"并返回交换后的链表\",{\"1\":{\"637\":1}}],[\"并返回给调用方\",{\"1\":{\"606\":1}}],[\"并返回他们的差值\",{\"1\":{\"489\":1}}],[\"并返回处理结果\",{\"1\":{\"161\":1}}],[\"并返回加载的类\",{\"1\":{\"147\":1}}],[\"并返回一个布尔值结果\",{\"1\":{\"129\":1}}],[\"并找出潜在的内存泄漏问题\",{\"1\":{\"146\":1}}],[\"并唤醒等待的线程\",{\"1\":{\"144\":2}}],[\"并尝试唤醒同步队列中的等待线程\",{\"1\":{\"141\":1}}],[\"并记录当前线程已经获取锁的次数\",{\"1\":{\"141\":1}}],[\"并允许它们去竞争获取锁\",{\"1\":{\"141\":1}}],[\"并标记为偏向锁\",{\"1\":{\"139\":1}}],[\"并调用其\",{\"1\":{\"132\":1}}],[\"并对其进行操作\",{\"1\":{\"129\":1}}],[\"并希望仅使用属性装配其中一个\",{\"1\":{\"71\":1}}],[\"并且淹没整块岛屿防止重复遍历\",{\"1\":{\"706\":1}}],[\"并且每座岛屿只能由水平方向和\",{\"1\":{\"706\":1}}],[\"并且每个篮子只能装\",{\"1\":{\"631\":1}}],[\"并且返回链表的头结点\",{\"1\":{\"638\":1}}],[\"并且将两个指针向内收缩继续比较\",{\"1\":{\"629\":1}}],[\"并且将每个程序放入一个隔离的容器去运行\",{\"1\":{\"609\":1}}],[\"并且where\",{\"1\":{\"528\":1}}],[\"并且避免了单继承的限制\",{\"1\":{\"466\":1}}],[\"并且构造器是private\",{\"1\":{\"436\":1}}],[\"并且以后不能再修改\",{\"1\":{\"415\":1}}],[\"并且只提供一个取得对象实例的方法\",{\"1\":{\"414\":1}}],[\"并且只有线程自己才可以取消\",{\"1\":{\"312\":1}}],[\"并且因为队列中的线程d为share共享锁\",{\"1\":{\"318\":1}}],[\"并且thread类中维护了一个threadlocalmap的成员变量\",{\"1\":{\"308\":1}}],[\"并且客户端会从事务状态中退出\",{\"1\":{\"202\":1}}],[\"并且它保证在执行事务时\",{\"1\":{\"201\":1}}],[\"并且支持事务\",{\"1\":{\"183\":1}}],[\"并且可能导致性能下降\",{\"1\":{\"174\":1}}],[\"并且可以访问\",{\"1\":{\"399\":1}}],[\"并且可以在集群中进行复制\",{\"1\":{\"213\":1}}],[\"并且可以将异常抛给调用者处理\",{\"1\":{\"133\":1}}],[\"并且可以通过\",{\"1\":{\"132\":1}}],[\"并且能接收从那台服务器发送的响应再转发给客户端\",{\"1\":{\"780\":1}}],[\"并且能被spring扫描到\",{\"1\":{\"164\":1}}],[\"并且能够重用这些横切关注点\",{\"1\":{\"158\":1}}],[\"并且在需要时可以从磁盘加载回内存\",{\"1\":{\"200\":1}}],[\"并且在某些情况下比单列索引更有效\",{\"1\":{\"174\":1}}],[\"并且在使用完毕后需要调用unlock\",{\"1\":{\"142\":1}}],[\"并且在写操作后增加一条store屏障\",{\"1\":{\"140\":1}}],[\"并且其他线程在读取该变量时会从主内存中获取最新值而不是工作内存中的副本\",{\"1\":{\"140\":1}}],[\"并且其还存在一些缓存和正则表达式等开销\",{\"1\":{\"55\":1}}],[\"并且\",{\"1\":{\"138\":1,\"306\":1}}],[\"并且同时满足以下条件时\",{\"1\":{\"136\":1}}],[\"并且会创建一个新的数组来重新分配元素\",{\"1\":{\"124\":1}}],[\"并且通过拷贝这些原型创建新的对象\",{\"1\":{\"116\":1}}],[\"并且是通过使用一个共同的接口来指向新创建的对象\",{\"1\":{\"101\":1}}],[\"并且spring会在应用启动时自动检查bean是否正确\",{\"1\":{\"62\":1}}],[\"并且需要手动指定bean之间的关系\",{\"1\":{\"62\":1}}],[\"并通过threadlocalmap的getentry方法将这个threadlocal作为key来取值\",{\"1\":{\"307\":1}}],[\"并通过指针连接形成有序链表\",{\"1\":{\"172\":1}}],[\"并通过在类上添加\",{\"1\":{\"166\":1}}],[\"并通过配置的异常处理器\",{\"1\":{\"162\":1}}],[\"并通过反射机制调用目标类\",{\"1\":{\"72\":1,\"159\":1}}],[\"并通过\",{\"0\":{\"49\":1},\"1\":{\"132\":1,\"606\":1}}],[\"更小\",{\"1\":{\"628\":1}}],[\"更正式地\",{\"1\":{\"628\":1}}],[\"更积极地移出基于垃圾收集器状态和弱引用规则的对象\",{\"1\":{\"536\":1}}],[\"更改\",{\"1\":{\"522\":1}}],[\"更新dp\",{\"1\":{\"624\":1}}],[\"更新了\",{\"1\":{\"576\":1,\"577\":1}}],[\"更新了混合了\",{\"1\":{\"189\":1}}],[\"更新\",{\"1\":{\"419\":2}}],[\"更新值\",{\"1\":{\"295\":1}}],[\"更新操作\",{\"1\":{\"195\":1}}],[\"更新和删除\",{\"1\":{\"174\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"42\":1}}],[\"更新时间\",{\"1\":{\"10\":1}}],[\"更适合读取大量数据\",{\"1\":{\"55\":1}}],[\"bd\",{\"1\":{\"684\":1}}],[\"bdee\",{\"1\":{\"598\":1}}],[\"blue\",{\"1\":{\"645\":2}}],[\"blocking=\",{\"1\":{\"536\":1}}],[\"blocked\",{\"1\":{\"225\":1,\"469\":1,\"471\":2}}],[\"bloom\",{\"1\":{\"194\":1}}],[\"btree\",{\"1\":{\"605\":2}}],[\"bf\",{\"1\":{\"483\":1,\"684\":1}}],[\"bfs广度优先搜索\",{\"0\":{\"710\":1}}],[\"bfs\",{\"1\":{\"90\":1,\"711\":1}}],[\"bba\",{\"1\":{\"651\":1}}],[\"bb\",{\"1\":{\"458\":1,\"477\":7}}],[\"b2=\",{\"1\":{\"433\":3}}],[\"b2\",{\"1\":{\"359\":1,\"433\":3}}],[\"b1=\",{\"1\":{\"433\":3}}],[\"b1\",{\"1\":{\"359\":6,\"365\":4,\"433\":3}}],[\"b随后进来发现当前线程持有锁\",{\"1\":{\"298\":1}}],[\"begin\",{\"1\":{\"650\":4}}],[\"between\",{\"1\":{\"607\":1}}],[\"betaips\",{\"1\":{\"605\":1}}],[\"beta`\",{\"1\":{\"605\":1}}],[\"beta\",{\"1\":{\"605\":2}}],[\"bestavailablerule\",{\"1\":{\"598\":2}}],[\"be\",{\"1\":{\"491\":1,\"655\":1,\"674\":1,\"684\":1}}],[\"before先行发生原则\",{\"1\":{\"273\":1}}],[\"before\",{\"0\":{\"280\":1},\"1\":{\"251\":3,\"280\":1,\"419\":5,\"572\":4,\"607\":1}}],[\"bean管理xml\",{\"0\":{\"562\":1}}],[\"beanpostprocessor\",{\"1\":{\"560\":2}}],[\"beanname\",{\"1\":{\"560\":4}}],[\"bean7\",{\"1\":{\"560\":1}}],[\"bean5\",{\"1\":{\"559\":1}}],[\"bean=\",{\"1\":{\"557\":2}}],[\"beanfactory\",{\"1\":{\"555\":2}}],[\"beanfactory就是简单工厂模式的体现\",{\"1\":{\"73\":1}}],[\"bean1\",{\"1\":{\"552\":1,\"557\":1,\"576\":1,\"583\":1}}],[\"bean可以响应业务逻辑中的方法调用和其他操作\",{\"1\":{\"160\":1}}],[\"bean就可以被应用程序使用了\",{\"1\":{\"160\":1}}],[\"bean在spring缓存中\",{\"1\":{\"160\":1}}],[\"bean验证api\",{\"1\":{\"81\":1}}],[\"bean默认为单例模式\",{\"1\":{\"73\":1}}],[\"bean有何区别\",{\"0\":{\"70\":1}}],[\"bean的生命周期\",{\"0\":{\"66\":1}}],[\"bean的作用域\",{\"0\":{\"65\":1}}],[\"bean方法声明bean并指定依赖关系\",{\"1\":{\"64\":1}}],[\"bean>\",{\"1\":{\"63\":1,\"67\":2,\"552\":1,\"555\":1,\"557\":15,\"560\":3,\"561\":2,\"562\":2,\"575\":2,\"583\":3}}],[\"beansexception\",{\"1\":{\"560\":2}}],[\"beans>\",{\"1\":{\"63\":1,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1}}],[\"beans\",{\"1\":{\"63\":4,\"552\":4,\"555\":4,\"557\":12,\"560\":8,\"561\":4,\"562\":8,\"563\":8,\"583\":4}}],[\"bean注解能够更加方便地定义bean\",{\"1\":{\"62\":1}}],[\"bean注解即可\",{\"1\":{\"62\":1}}],[\"bean注解时\",{\"1\":{\"62\":3}}],[\"bean注解\",{\"1\":{\"62\":1}}],[\"bean注解注入spring容器和解析xml文件注入的区别如下\",{\"1\":{\"62\":1}}],[\"bean注解注入spring容器和解析xml文件注入有什么区别\",{\"0\":{\"62\":1}}],[\"bean\",{\"0\":{\"160\":1,\"556\":1,\"557\":1,\"558\":1,\"559\":1,\"560\":1,\"561\":1,\"563\":1},\"1\":{\"60\":1,\"65\":1,\"66\":8,\"67\":5,\"70\":12,\"71\":3,\"163\":1,\"545\":4,\"557\":9,\"558\":7,\"559\":4,\"560\":28,\"565\":1,\"584\":3,\"597\":1,\"598\":1,\"606\":1}}],[\"break语句出现在多层嵌套语句块中时\",{\"1\":{\"377\":1}}],[\"break\",{\"0\":{\"377\":1},\"1\":{\"268\":3,\"372\":3,\"377\":2,\"466\":5,\"468\":2,\"469\":1,\"471\":1,\"622\":2,\"630\":1,\"650\":1,\"652\":2,\"696\":2,\"730\":1}}],[\"broker\",{\"1\":{\"210\":1}}],[\"broker服务节点\",{\"1\":{\"209\":1}}],[\"bridge\",{\"1\":{\"113\":2}}],[\"bi\",{\"1\":{\"717\":2}}],[\"bis\",{\"1\":{\"478\":5}}],[\"birthday\",{\"1\":{\"445\":7}}],[\"bigint\",{\"1\":{\"605\":13}}],[\"biginteger适合保存比较大的整型\",{\"1\":{\"435\":1}}],[\"biginteger和bigdecimal类\",{\"0\":{\"435\":1}}],[\"bigdecimal类\",{\"1\":{\"492\":1}}],[\"bigdecimal适合保存精度更高的浮点型\",{\"1\":{\"435\":1}}],[\"bifunction<\",{\"1\":{\"244\":1,\"248\":3}}],[\"bin\",{\"1\":{\"605\":9,\"616\":1}}],[\"binding\",{\"1\":{\"209\":2}}],[\"binarysearch\",{\"1\":{\"433\":2,\"621\":2}}],[\"binary\",{\"1\":{\"177\":1,\"664\":1,\"666\":1,\"667\":1,\"668\":1,\"672\":1,\"699\":1}}],[\"bit\",{\"1\":{\"194\":1}}],[\"bitmap\",{\"1\":{\"188\":1}}],[\"biased\",{\"1\":{\"139\":1}}],[\"b+树的范围查询效率更高\",{\"1\":{\"172\":1}}],[\"b+树的查询效率更高\",{\"1\":{\"172\":1}}],[\"b+树在进行关键字查找时\",{\"1\":{\"172\":1}}],[\"b+树\",{\"1\":{\"172\":1}}],[\"b树的查询效率相对较低\",{\"1\":{\"172\":1}}],[\"b树的每个节点都会存储关键字和对应的数据\",{\"1\":{\"172\":1}}],[\"b树的内部节点存储数据\",{\"1\":{\"172\":1}}],[\"b树的缺点\",{\"1\":{\"172\":1}}],[\"b树\",{\"1\":{\"172\":1}}],[\"b树和b+树\",{\"1\":{\"172\":1}}],[\"b树缺点\",{\"0\":{\"172\":1}}],[\"b不能向这张卡转账\",{\"1\":{\"170\":1}}],[\"b却没收到\",{\"1\":{\"170\":1}}],[\"b有\",{\"0\":{\"166\":1}}],[\"b又依赖a\",{\"1\":{\"163\":1}}],[\"boardsize+1\",{\"1\":{\"709\":1}}],[\"boardsize\",{\"1\":{\"709\":3}}],[\"board\",{\"1\":{\"705\":15,\"709\":39,\"734\":11}}],[\"body\",{\"1\":{\"598\":2}}],[\"body><\",{\"1\":{\"111\":1,\"335\":1}}],[\"bos\",{\"1\":{\"478\":5}}],[\"bob\",{\"1\":{\"443\":1}}],[\"bool\",{\"1\":{\"721\":2}}],[\"boolean>\",{\"1\":{\"689\":1,\"701\":1}}],[\"boolean不参与转换\",{\"1\":{\"359\":1}}],[\"boolean\",{\"1\":{\"55\":1,\"220\":1,\"242\":1,\"268\":1,\"291\":1,\"300\":1,\"312\":1,\"313\":2,\"358\":1,\"406\":2,\"445\":1,\"467\":2,\"471\":2,\"605\":1,\"650\":2,\"655\":3,\"657\":1,\"658\":1,\"659\":1,\"668\":4,\"674\":5,\"675\":1,\"677\":1,\"688\":1,\"689\":3,\"701\":6,\"702\":4,\"704\":1,\"705\":3,\"709\":2,\"716\":6,\"717\":6,\"721\":2,\"730\":2}}],[\"bookings\",{\"1\":{\"678\":8}}],[\"bookdaoimpl\",{\"1\":{\"575\":1,\"576\":2,\"577\":4}}],[\"bookdao\",{\"1\":{\"575\":3,\"576\":5,\"577\":2}}],[\"book2\",{\"1\":{\"559\":2}}],[\"book1\",{\"1\":{\"559\":2}}],[\"booklist\",{\"1\":{\"557\":3}}],[\"bookmapper\",{\"1\":{\"504\":4,\"509\":1}}],[\"bookservice\",{\"1\":{\"575\":1,\"576\":6}}],[\"books\",{\"1\":{\"433\":9}}],[\"book\",{\"1\":{\"300\":5,\"433\":24,\"439\":7,\"440\":9,\"504\":5,\"508\":2,\"557\":11,\"559\":10,\"576\":1,\"577\":3}}],[\"bootstrap\",{\"1\":{\"147\":1}}],[\"boot应用程序变得更加简单快捷\",{\"1\":{\"82\":1}}],[\"boot应用程序提供默认设置和约定的依赖管理\",{\"1\":{\"82\":1}}],[\"boot应用程序\",{\"1\":{\"82\":2}}],[\"boot项目\",{\"1\":{\"82\":1}}],[\"boot中各个启动器的名称和简要功能列表\",{\"1\":{\"81\":1}}],[\"boot官方保留\",{\"1\":{\"81\":1}}],[\"boot官方的启动器都是以spring\",{\"1\":{\"81\":1}}],[\"boot开头命名\",{\"1\":{\"81\":1}}],[\"boot提供一系列端点可以监控服务及应用\",{\"1\":{\"80\":1}}],[\"boot配置过程中无代码生成\",{\"1\":{\"80\":1}}],[\"boot能根据当前类路径下的类\",{\"1\":{\"80\":1}}],[\"boot\",{\"0\":{\"82\":1},\"1\":{\"80\":2,\"81\":37,\"82\":5,\"161\":1,\"593\":4}}],[\"boot只要打成一个可执行的\",{\"1\":{\"80\":1}}],[\"boot而且内嵌了各种servlet容器\",{\"1\":{\"80\":1}}],[\"bucket\",{\"1\":{\"689\":6,\"701\":6}}],[\"bus\",{\"1\":{\"593\":2}}],[\"buildgraph\",{\"1\":{\"717\":2}}],[\"build构建镜像\",{\"1\":{\"613\":1}}],[\"build>\",{\"1\":{\"540\":1}}],[\"build\",{\"1\":{\"502\":1,\"617\":3}}],[\"builder类定义了这一类型的固定方法\",{\"1\":{\"108\":1}}],[\"builder\",{\"1\":{\"107\":3,\"108\":13,\"431\":2}}],[\"buf\",{\"1\":{\"485\":3}}],[\"buff\",{\"1\":{\"477\":3,\"478\":3}}],[\"bufferedoutputstream\",{\"1\":{\"478\":5}}],[\"bufferedinputstream\",{\"1\":{\"478\":4}}],[\"bufferedwrite\",{\"1\":{\"478\":1}}],[\"bufferedwriter\",{\"1\":{\"478\":14}}],[\"bufferedread\",{\"1\":{\"478\":1}}],[\"bufferedreaderandwriter\",{\"1\":{\"478\":1}}],[\"bufferedreaderexample\",{\"1\":{\"55\":1}}],[\"bufferedreader\",{\"1\":{\"55\":3,\"114\":9,\"478\":15,\"730\":3}}],[\"bufferedreader比scanner更快\",{\"1\":{\"55\":1}}],[\"bufferedreader是基于字符流的\",{\"1\":{\"55\":1}}],[\"buffer\",{\"1\":{\"108\":11,\"111\":18,\"431\":2}}],[\"bubblesort\",{\"1\":{\"381\":1}}],[\"b\",{\"1\":{\"95\":1,\"175\":3,\"176\":3,\"195\":1,\"248\":2,\"262\":1,\"298\":1,\"300\":2,\"318\":2,\"362\":4,\"365\":2,\"366\":4,\"395\":1,\"403\":2,\"417\":2,\"419\":1,\"424\":4,\"429\":2,\"439\":2,\"471\":6,\"475\":1,\"477\":1,\"542\":2,\"648\":1,\"660\":2,\"684\":1,\"687\":1,\"688\":2,\"716\":2,\"742\":7}}],[\"bagsolution\",{\"1\":{\"700\":1}}],[\"bab\",{\"1\":{\"650\":1}}],[\"babad\",{\"1\":{\"650\":1}}],[\"bac\",{\"1\":{\"649\":1}}],[\"bacdfeg\",{\"1\":{\"643\":1}}],[\"backtrack\",{\"1\":{\"683\":3,\"684\":3,\"685\":3,\"686\":6,\"687\":4,\"688\":3,\"689\":4,\"690\":4,\"701\":4,\"715\":5,\"716\":3,\"717\":3,\"718\":3}}],[\"backtracking\",{\"1\":{\"682\":2}}],[\"backtracknsum\",{\"1\":{\"627\":2}}],[\"backlog\",{\"1\":{\"204\":1}}],[\"bachargs\",{\"1\":{\"578\":1}}],[\"baidu\",{\"1\":{\"482\":1}}],[\"bash\",{\"1\":{\"614\":2}}],[\"basic\",{\"1\":{\"606\":1}}],[\"basicack\",{\"1\":{\"211\":1}}],[\"baseimage\",{\"1\":{\"616\":1}}],[\"basepackages\",{\"1\":{\"565\":1,\"584\":1}}],[\"base\",{\"1\":{\"402\":5,\"563\":3,\"572\":1,\"583\":1,\"624\":1,\"689\":1,\"701\":1}}],[\"bad\",{\"1\":{\"155\":1,\"776\":1}}],[\"barrier\",{\"1\":{\"140\":2}}],[\"banc\",{\"1\":{\"648\":2}}],[\"bank\",{\"1\":{\"583\":3}}],[\"bankuser\",{\"1\":{\"583\":3}}],[\"bankdaoimpl\",{\"1\":{\"583\":4}}],[\"bankdao\",{\"1\":{\"583\":7}}],[\"bankservice\",{\"1\":{\"583\":6,\"584\":3}}],[\"banner\",{\"1\":{\"96\":3}}],[\"bangalore\",{\"1\":{\"67\":1}}],[\"batchupdate\",{\"1\":{\"578\":1,\"583\":2}}],[\"batchdelete\",{\"1\":{\"518\":2}}],[\"batch批处理框架的支持\",{\"1\":{\"81\":1}}],[\"batch\",{\"1\":{\"81\":1}}],[\"bytype\",{\"1\":{\"561\":1}}],[\"byte范围的指定形式如下\",{\"1\":{\"770\":1}}],[\"byteranges\",{\"1\":{\"769\":1,\"770\":1}}],[\"byte\",{\"1\":{\"121\":1,\"358\":1,\"359\":6,\"365\":1,\"477\":4,\"478\":2,\"485\":2,\"598\":1}}],[\"byname\",{\"1\":{\"561\":2}}],[\"by\",{\"0\":{\"7\":1},\"1\":{\"5\":1,\"7\":1,\"184\":9,\"203\":1}}],[\"oldestkey\",{\"1\":{\"720\":2}}],[\"oldval\",{\"1\":{\"452\":1}}],[\"options\",{\"1\":{\"762\":1,\"763\":1,\"786\":1}}],[\"optional>\",{\"1\":{\"498\":1,\"540\":1}}],[\"openlock\",{\"1\":{\"713\":1}}],[\"openfeign<\",{\"1\":{\"606\":2}}],[\"open=\",{\"1\":{\"531\":1}}],[\"opensession\",{\"1\":{\"502\":1}}],[\"open\",{\"1\":{\"105\":4,\"114\":4,\"531\":1}}],[\"o用于处理数据传输\",{\"1\":{\"476\":1}}],[\"oww\",{\"1\":{\"466\":1}}],[\"owners\",{\"1\":{\"102\":3}}],[\"owner\",{\"1\":{\"102\":12}}],[\"o2\",{\"1\":{\"433\":6,\"451\":2,\"471\":6}}],[\"o1\",{\"1\":{\"433\":6,\"443\":1,\"451\":2,\"471\":6}}],[\"ovload\",{\"1\":{\"391\":2}}],[\"override\",{\"0\":{\"401\":1},\"1\":{\"45\":1,\"96\":2,\"102\":3,\"105\":6,\"108\":8,\"111\":6,\"114\":6,\"117\":2,\"232\":1,\"291\":1,\"313\":2,\"334\":2,\"339\":1,\"404\":2,\"417\":2,\"418\":4,\"419\":1,\"422\":1,\"433\":3,\"439\":1,\"440\":1,\"445\":2,\"451\":1,\"454\":1,\"458\":1,\"466\":5,\"467\":1,\"468\":2,\"469\":1,\"471\":2,\"478\":1,\"557\":1,\"560\":2,\"564\":1,\"569\":1,\"576\":1,\"577\":3,\"583\":4,\"607\":2}}],[\"oopdesc进行对应\",{\"1\":{\"260\":1}}],[\"oop\",{\"1\":{\"260\":1,\"418\":1}}],[\"oom\",{\"1\":{\"126\":1}}],[\"otherwise\",{\"0\":{\"530\":1}}],[\"other\",{\"1\":{\"248\":6,\"418\":1,\"775\":1}}],[\"o多路复用\",{\"1\":{\"186\":1}}],[\"o\",{\"0\":{\"721\":1},\"1\":{\"186\":3,\"187\":4,\"263\":4,\"443\":2,\"445\":5,\"454\":3,\"471\":1,\"709\":17,\"720\":2,\"721\":1}}],[\"onto\",{\"1\":{\"657\":1,\"658\":1}}],[\"oname\",{\"1\":{\"560\":7}}],[\"one\",{\"1\":{\"525\":1}}],[\"oneservice\",{\"1\":{\"70\":1}}],[\"on\",{\"1\":{\"523\":2,\"524\":1,\"525\":2,\"527\":1,\"528\":1,\"529\":1,\"532\":1,\"657\":1,\"658\":1}}],[\"only\",{\"1\":{\"181\":1,\"189\":1,\"414\":2}}],[\"okhttp\",{\"1\":{\"606\":1}}],[\"ok\",{\"1\":{\"155\":1,\"413\":1,\"478\":1,\"716\":4,\"717\":3,\"760\":2,\"774\":1}}],[\"oftype=\",{\"1\":{\"525\":2}}],[\"ofpattern\",{\"1\":{\"436\":1,\"603\":1}}],[\"off\",{\"1\":{\"477\":5}}],[\"offset++\",{\"1\":{\"632\":1}}],[\"offset\",{\"1\":{\"632\":3}}],[\"offset开始继续复制\",{\"1\":{\"204\":1}}],[\"offset就是保存在backlog中的\",{\"1\":{\"204\":1}}],[\"offset还有一个master\",{\"1\":{\"204\":1}}],[\"offer\",{\"0\":{\"693\":1,\"705\":1,\"732\":1,\"735\":1,\"738\":1,\"741\":1},\"1\":{\"91\":2,\"656\":1,\"657\":2,\"658\":2,\"666\":3,\"669\":3,\"711\":2,\"712\":3,\"713\":3}}],[\"of\",{\"1\":{\"146\":1,\"158\":1,\"160\":1,\"436\":3,\"657\":1,\"658\":1}}],[\"obstaclegrid\",{\"1\":{\"696\":9}}],[\"observer\",{\"1\":{\"93\":1}}],[\"objecinpustream提供反序列化功能\",{\"1\":{\"478\":1}}],[\"object>>\",{\"1\":{\"515\":1}}],[\"object>\",{\"1\":{\"514\":1}}],[\"objectoutstream\",{\"1\":{\"478\":1}}],[\"objectoutputstream提供序列化功能\",{\"1\":{\"478\":1}}],[\"objectoutputstream\",{\"1\":{\"478\":13}}],[\"objectinputstream\",{\"1\":{\"478\":13}}],[\"object类的tostring方法\",{\"1\":{\"406\":1}}],[\"object类详解\",{\"0\":{\"406\":1}}],[\"objectlock\",{\"1\":{\"271\":5}}],[\"objectmonitor\",{\"1\":{\"260\":2}}],[\"object在jvm内部都有一个native的c++对象\",{\"1\":{\"260\":1}}],[\"objects\",{\"1\":{\"251\":3,\"445\":3}}],[\"object\",{\"1\":{\"116\":2,\"163\":1,\"263\":2,\"271\":2,\"334\":1,\"339\":1,\"406\":2,\"419\":6,\"427\":1,\"433\":6,\"439\":2,\"442\":1,\"443\":3,\"444\":1,\"445\":1,\"448\":2,\"451\":3,\"454\":1,\"460\":1,\"461\":1,\"471\":6,\"486\":1,\"492\":1,\"560\":4,\"569\":6,\"655\":1,\"674\":1}}],[\"objarrary\",{\"1\":{\"461\":2}}],[\"obj\",{\"1\":{\"406\":5,\"427\":2,\"439\":3,\"486\":1,\"569\":5,\"655\":5,\"674\":4}}],[\"oauth\",{\"1\":{\"81\":2}}],[\"oauth2\",{\"1\":{\"81\":2,\"593\":1}}],[\"or\",{\"1\":{\"491\":1,\"531\":2}}],[\"ordinal\",{\"1\":{\"421\":1}}],[\"order注解来指定order值\",{\"1\":{\"607\":1}}],[\"order值越小\",{\"1\":{\"607\":1}}],[\"ordered\",{\"1\":{\"607\":1}}],[\"ordermapper\",{\"1\":{\"597\":1}}],[\"orderid\",{\"1\":{\"597\":2}}],[\"orderservice\",{\"1\":{\"607\":1,\"617\":1}}],[\"orderservice启动类添加注解开启feign功能\",{\"1\":{\"606\":1}}],[\"orders\",{\"1\":{\"560\":11}}],[\"order\",{\"1\":{\"184\":3,\"597\":6,\"598\":1,\"606\":1,\"607\":2,\"617\":1}}],[\"orm\",{\"1\":{\"168\":2,\"495\":1}}],[\"oriented\",{\"1\":{\"158\":1}}],[\"originaluri\",{\"1\":{\"598\":3}}],[\"original\",{\"1\":{\"429\":1}}],[\"origin\",{\"1\":{\"86\":4}}],[\"org和www\",{\"1\":{\"607\":1}}],[\"org\",{\"1\":{\"63\":4,\"99\":1,\"102\":1,\"117\":1,\"248\":1,\"297\":1,\"327\":4,\"498\":4,\"499\":2,\"501\":2,\"504\":2,\"540\":6,\"551\":1,\"552\":4,\"555\":4,\"557\":15,\"560\":14,\"561\":7,\"562\":17,\"563\":22,\"575\":1,\"583\":15,\"586\":2}}],[\"orz\",{\"1\":{\"55\":1}}],[\"outindex\",{\"1\":{\"715\":10,\"716\":5,\"717\":7,\"718\":5}}],[\"outside\",{\"1\":{\"668\":2}}],[\"outer1\",{\"1\":{\"418\":2}}],[\"outer\",{\"1\":{\"418\":1}}],[\"outputstreamwriter可以将outputstream转换成writer\",{\"1\":{\"478\":1}}],[\"outputstreamwriter\",{\"1\":{\"478\":1}}],[\"outputstream\",{\"1\":{\"476\":1,\"485\":4}}],[\"output\",{\"1\":{\"111\":2}}],[\"out\",{\"1\":{\"55\":4,\"91\":1,\"96\":2,\"99\":3,\"102\":2,\"105\":7,\"108\":1,\"111\":1,\"114\":7,\"117\":4,\"146\":1,\"192\":1,\"232\":2,\"233\":3,\"248\":4,\"249\":4,\"253\":2,\"256\":4,\"262\":1,\"263\":3,\"268\":15,\"271\":12,\"291\":4,\"297\":2,\"298\":3,\"300\":2,\"304\":2,\"313\":4,\"334\":3,\"335\":3,\"351\":1,\"352\":2,\"354\":1,\"358\":2,\"359\":2,\"368\":2,\"376\":2,\"377\":1,\"381\":5,\"382\":3,\"390\":1,\"391\":4,\"396\":1,\"399\":1,\"402\":4,\"403\":2,\"404\":4,\"411\":5,\"413\":10,\"414\":3,\"415\":2,\"416\":1,\"417\":4,\"418\":10,\"419\":8,\"421\":1,\"424\":1,\"427\":1,\"428\":3,\"429\":2,\"430\":3,\"431\":3,\"433\":2,\"436\":22,\"439\":2,\"440\":8,\"443\":9,\"444\":1,\"448\":2,\"451\":1,\"454\":2,\"457\":3,\"459\":4,\"466\":6,\"467\":1,\"468\":7,\"469\":4,\"471\":7,\"475\":7,\"477\":7,\"478\":13,\"479\":8,\"480\":4,\"483\":5,\"485\":5,\"486\":2,\"489\":1,\"490\":1,\"491\":2,\"502\":1,\"512\":1,\"524\":1,\"530\":1,\"552\":1,\"557\":2,\"559\":2,\"560\":5,\"563\":1,\"564\":3,\"565\":3,\"569\":2,\"572\":8,\"576\":3,\"577\":9,\"583\":9,\"586\":1,\"645\":4,\"648\":1,\"718\":1,\"724\":1,\"729\":2,\"730\":1}}],[\"执行linux\",{\"1\":{\"616\":1}}],[\"执行一个命令\",{\"1\":{\"614\":1}}],[\"执行一个方法时\",{\"1\":{\"391\":1}}],[\"执行顺序越靠前\",{\"1\":{\"607\":1}}],[\"执行无参构造\",{\"1\":{\"560\":2}}],[\"执行两条查询语句\",{\"1\":{\"523\":1}}],[\"执行完一个case后\",{\"1\":{\"372\":1}}],[\"执行代码块\",{\"1\":{\"371\":5}}],[\"执行目标资源\",{\"1\":{\"342\":1}}],[\"执行下一个filter过滤器\",{\"1\":{\"342\":1}}],[\"执行下一阶段\",{\"1\":{\"245\":1}}],[\"执行\",{\"1\":{\"328\":1,\"560\":6}}],[\"执行是连续的\",{\"1\":{\"296\":1}}],[\"执行cas操作时\",{\"1\":{\"295\":1}}],[\"执行其他任务\",{\"1\":{\"233\":1}}],[\"执行所有事务块内的命令\",{\"1\":{\"202\":1}}],[\"执行之后\",{\"1\":{\"202\":1}}],[\"执行速度是非常快的\",{\"1\":{\"187\":1}}],[\"执行业务逻辑\",{\"1\":{\"161\":1}}],[\"执行处理器\",{\"1\":{\"161\":1}}],[\"执行任务\",{\"1\":{\"91\":1}}],[\"执行子类的构造函数\",{\"1\":{\"53\":1}}],[\"执行子类的构造代码块\",{\"1\":{\"53\":1}}],[\"执行子类的静态代码块\",{\"1\":{\"53\":1}}],[\"执行父类的构造函数\",{\"1\":{\"53\":1}}],[\"执行父类的构造代码块\",{\"1\":{\"53\":1}}],[\"执行父类的静态代码块\",{\"1\":{\"53\":1}}],[\"内\",{\"1\":{\"716\":2}}],[\"内置数据类型\",{\"0\":{\"358\":1}}],[\"内置java关键字\",{\"1\":{\"261\":1}}],[\"内置策略\",{\"1\":{\"192\":1}}],[\"内部bean\",{\"1\":{\"557\":1}}],[\"内部\",{\"1\":{\"557\":1}}],[\"内部修改定义在域外的局部变量\",{\"1\":{\"491\":1}}],[\"内部类n1\",{\"1\":{\"418\":1}}],[\"内部类的分类\",{\"1\":{\"418\":1}}],[\"内部类\",{\"0\":{\"418\":1},\"1\":{\"384\":1,\"418\":1}}],[\"内部节点能容纳更多的子节点指针\",{\"1\":{\"172\":1}}],[\"内部节点只存储关键字\",{\"1\":{\"172\":1}}],[\"内部节点和叶子节点的结构相同\",{\"1\":{\"172\":1}}],[\"内部的使用接口\",{\"1\":{\"555\":1}}],[\"内部的多次查询可以复用缓存\",{\"1\":{\"167\":1}}],[\"内部的缓存\",{\"1\":{\"167\":1}}],[\"内部实现\",{\"1\":{\"122\":1}}],[\"内存\",{\"1\":{\"348\":1}}],[\"内存位置\",{\"1\":{\"295\":1}}],[\"内存屏障是一类同步屏障指令\",{\"1\":{\"290\":1}}],[\"内存屏障\",{\"0\":{\"290\":1}}],[\"内存是有限的\",{\"1\":{\"203\":1}}],[\"内存不足\",{\"1\":{\"146\":1,\"203\":1}}],[\"内存泄漏是指应用程序中的对象占用了内存\",{\"1\":{\"146\":1}}],[\"内存泄漏\",{\"1\":{\"146\":1}}],[\"内存语义\",{\"1\":{\"138\":1}}],[\"内存溢出\",{\"1\":{\"126\":1}}],[\"内存分配\",{\"0\":{\"91\":1}}],[\"内存分区\",{\"0\":{\"51\":1}}],[\"内容协商技术有以下3种类型\",{\"1\":{\"771\":1}}],[\"内容协商\",{\"0\":{\"771\":1}}],[\"内容\",{\"1\":{\"15\":1,\"605\":1}}],[\"j<ints\",{\"1\":{\"729\":1}}],[\"jkl\",{\"1\":{\"684\":1}}],[\"jndi\",{\"1\":{\"506\":2}}],[\"jconsole监视线程\",{\"1\":{\"466\":1}}],[\"jcp\",{\"1\":{\"327\":3}}],[\"j1\",{\"1\":{\"427\":1}}],[\"j+=res\",{\"1\":{\"622\":1}}],[\"j+1\",{\"1\":{\"381\":3,\"709\":2}}],[\"j++\",{\"1\":{\"55\":4,\"91\":2,\"381\":1,\"382\":2,\"440\":1,\"623\":1,\"624\":1,\"625\":1,\"628\":1,\"630\":1,\"632\":1,\"652\":1,\"653\":2,\"695\":1,\"696\":1,\"700\":1,\"701\":1,\"705\":1,\"706\":1,\"707\":1,\"708\":1,\"709\":5,\"713\":1,\"718\":1,\"727\":1,\"728\":1,\"729\":1,\"737\":1}}],[\"jianshu\",{\"1\":{\"730\":1}}],[\"jimowo\",{\"1\":{\"354\":1}}],[\"jicheng\",{\"1\":{\"96\":4}}],[\"jre\",{\"1\":{\"350\":2}}],[\"jboss\",{\"1\":{\"324\":1}}],[\"john\",{\"1\":{\"248\":1}}],[\"join与get对比\",{\"0\":{\"253\":1}}],[\"join\",{\"1\":{\"184\":2,\"248\":3,\"253\":3,\"256\":1,\"411\":3,\"468\":2,\"523\":2,\"524\":1,\"525\":2,\"527\":1,\"528\":1,\"529\":1,\"532\":1}}],[\"jooq\",{\"1\":{\"81\":2}}],[\"jmxremote\",{\"1\":{\"466\":4}}],[\"jmm规定所有变量都存储在主内存中\",{\"1\":{\"279\":1}}],[\"jmm规定线程间变量值的传递需要通过主内存来完成\",{\"1\":{\"277\":1}}],[\"jmm规范下\",{\"0\":{\"276\":1,\"279\":1,\"280\":1}}],[\"jmm为什么会出现\",{\"1\":{\"273\":1}}],[\"jmm有哪些特性和它的三大特征\",{\"1\":{\"273\":1}}],[\"jmm与volatile之间的关系\",{\"1\":{\"273\":1}}],[\"jmm通过内存屏障来禁止指令重排序\",{\"1\":{\"140\":1}}],[\"jmm通过在线程之间进行内存屏障\",{\"1\":{\"140\":1}}],[\"jmm通过以下机制来实现上述目标\",{\"1\":{\"140\":1}}],[\"jmm保证了对它的读写具有原子性\",{\"1\":{\"140\":1}}],[\"jmm保证对基本数据类型\",{\"1\":{\"140\":1}}],[\"jmm\",{\"1\":{\"140\":1,\"303\":1}}],[\"jmm内存模型\",{\"1\":{\"140\":1}}],[\"jmstemplate\",{\"1\":{\"73\":1}}],[\"jpg\",{\"1\":{\"478\":2}}],[\"jprofiler\",{\"1\":{\"146\":1}}],[\"jp\",{\"1\":{\"111\":6,\"760\":1,\"762\":2}}],[\"jpa\",{\"1\":{\"81\":1,\"496\":1}}],[\"jpa启动器依赖就能使用了\",{\"1\":{\"81\":1}}],[\"jpa访问数据库\",{\"1\":{\"81\":1}}],[\"jpatemplate\",{\"1\":{\"73\":1}}],[\"jul\",{\"1\":{\"760\":1}}],[\"juc是java\",{\"1\":{\"222\":1}}],[\"juc是什么\",{\"0\":{\"222\":1}}],[\"juc并发编程\",{\"0\":{\"218\":1}}],[\"juc的executors\",{\"1\":{\"134\":1}}],[\"jupiter<\",{\"1\":{\"540\":2}}],[\"jupiter\",{\"1\":{\"99\":1,\"102\":1,\"117\":1,\"248\":1,\"297\":1}}],[\"junit是一个java语言的单元测试框架\",{\"1\":{\"462\":1}}],[\"junit测试\",{\"0\":{\"462\":1}}],[\"junit\",{\"1\":{\"99\":1,\"102\":1,\"117\":1,\"248\":1,\"297\":1,\"540\":1}}],[\"jersey\",{\"1\":{\"81\":1}}],[\"jetty等\",{\"1\":{\"80\":1}}],[\"jack\",{\"1\":{\"404\":1,\"408\":1,\"411\":1,\"440\":1,\"451\":1}}],[\"jackson\",{\"1\":{\"81\":1}}],[\"japan\",{\"1\":{\"111\":2}}],[\"jar下载\",{\"1\":{\"551\":1}}],[\"jar\",{\"1\":{\"82\":1,\"551\":2,\"575\":1,\"586\":1,\"616\":10,\"617\":2}}],[\"jar包来自动配置bean\",{\"1\":{\"80\":1}}],[\"jar包就能独立运行\",{\"1\":{\"80\":1}}],[\"java应用启动命令\",{\"1\":{\"616\":2}}],[\"java代码配置\",{\"1\":{\"606\":1}}],[\"javamodelgenerator>\",{\"1\":{\"540\":1}}],[\"javamail发送电子邮件的支持\",{\"1\":{\"81\":1}}],[\"javatype=\",{\"1\":{\"501\":2,\"523\":1,\"527\":1}}],[\"javatype\",{\"1\":{\"501\":1,\"523\":1,\"527\":1}}],[\"java<\",{\"1\":{\"498\":1,\"540\":2}}],[\"java绘图坐标系\",{\"0\":{\"464\":1}}],[\"java不支持泛型类型的数组\",{\"1\":{\"461\":1}}],[\"java是单继承的\",{\"1\":{\"466\":1}}],[\"java是单继承机制\",{\"1\":{\"421\":1}}],[\"java是健壮的\",{\"1\":{\"346\":1}}],[\"java所有类都是object的子类\",{\"1\":{\"399\":1}}],[\"java核心技术卷补充\",{\"0\":{\"461\":1},\"1\":{\"396\":1,\"417\":1,\"429\":1}}],[\"java界面开发\",{\"1\":{\"396\":1}}],[\"java允许将同一个类中多个同名同功能但参数个数不同的方法封装成一个方法\",{\"1\":{\"391\":1}}],[\"java允许同一个类中多个同名方法存在\",{\"1\":{\"391\":1}}],[\"java允许动态创建以下的数组\",{\"1\":{\"382\":1}}],[\"java没有无符号数\",{\"1\":{\"369\":1}}],[\"java运算符\",{\"0\":{\"361\":1}}],[\"java在进行赋值或运算时\",{\"1\":{\"359\":1}}],[\"java变量\",{\"0\":{\"355\":1}}],[\"javadoc\",{\"1\":{\"354\":1}}],[\"java注释\",{\"0\":{\"354\":1}}],[\"java转义字符\",{\"0\":{\"353\":1}}],[\"java开发注意事项\",{\"0\":{\"352\":1}}],[\"java开发工具\",{\"1\":{\"350\":1}}],[\"java快速入门\",{\"0\":{\"351\":1}}],[\"java等\",{\"1\":{\"350\":1}}],[\"javaclientgenerator>\",{\"1\":{\"540\":1}}],[\"javac\",{\"1\":{\"349\":1,\"350\":1}}],[\"java的\",{\"1\":{\"651\":1}}],[\"java的动态绑定机制\",{\"0\":{\"403\":1}}],[\"java的运行机制及运行过程\",{\"0\":{\"347\":1}}],[\"java的重要特点\",{\"0\":{\"346\":1}}],[\"java虚拟机无法解决的严重问题\",{\"1\":{\"424\":1}}],[\"java虚拟机类加载过程主要分为五个阶段\",{\"1\":{\"419\":1}}],[\"java虚拟机在调用main方法\",{\"1\":{\"412\":1}}],[\"java虚拟机给每个对象分配一个this\",{\"1\":{\"393\":1}}],[\"java虚拟机\",{\"1\":{\"346\":1}}],[\"java虚拟机会自动退出\",{\"1\":{\"227\":1}}],[\"javaee\",{\"1\":{\"327\":3}}],[\"javaweb是基于请求和响应开发的\",{\"1\":{\"322\":1}}],[\"javaweb概念\",{\"0\":{\"322\":1}}],[\"javaweb\",{\"0\":{\"320\":1}}],[\"java提供的cas操作类\",{\"1\":{\"295\":1}}],[\"java提供了一个停止线程的协商机制\",{\"1\":{\"267\":1}}],[\"java无法直接操作硬件\",{\"1\":{\"223\":1}}],[\"java会调用本地方法private\",{\"1\":{\"223\":1}}],[\"java默认有几个线程\",{\"0\":{\"223\":1}}],[\"java内存结构分析\",{\"1\":{\"388\":1}}],[\"java内存模型的排序规则会要求java编译器在生成jvm指令时插入特定的内存屏障指令\",{\"1\":{\"290\":1}}],[\"java内存模型java\",{\"0\":{\"275\":1}}],[\"java内存模型jmm\",{\"0\":{\"272\":1}}],[\"java内存模型\",{\"1\":{\"140\":1}}],[\"java内存分区\",{\"1\":{\"51\":1}}],[\"java基础概述\",{\"0\":{\"345\":1}}],[\"java基础\",{\"0\":{\"119\":1,\"344\":1}}],[\"java实现\",{\"0\":{\"96\":1,\"99\":1,\"102\":1,\"105\":1,\"108\":1,\"111\":1,\"114\":1,\"117\":1},\"1\":{\"653\":1}}],[\"java对象的sql查询\",{\"1\":{\"81\":1}}],[\"java8新特性\",{\"1\":{\"588\":1}}],[\"java8tester\",{\"1\":{\"491\":1}}],[\"java8\",{\"1\":{\"59\":1,\"616\":2}}],[\"java5\",{\"1\":{\"59\":1}}],[\"java多线程\",{\"0\":{\"56\":1,\"131\":1}}],[\"java中\",{\"0\":{\"357\":1},\"1\":{\"364\":1,\"424\":1}}],[\"java中实现多线程\",{\"0\":{\"132\":1}}],[\"java中的cas机制只能保证共享变量操作的原子性\",{\"1\":{\"299\":1}}],[\"java中的每个对象都派生自object类\",{\"1\":{\"260\":1}}],[\"java中的继承和多态\",{\"0\":{\"120\":1}}],[\"java中的原子操作\",{\"0\":{\"57\":1}}],[\"java中可以使用bufferedreader和scanner来进行文件或者输入流的读取操作\",{\"1\":{\"55\":1}}],[\"java中bufferedreader与scanner读入的区别\",{\"0\":{\"55\":1}}],[\"java\",{\"0\":{\"51\":1,\"52\":1,\"54\":1,\"348\":1,\"791\":1},\"1\":{\"55\":4,\"57\":1,\"63\":4,\"72\":3,\"91\":4,\"98\":1,\"101\":1,\"102\":2,\"107\":1,\"111\":6,\"114\":2,\"116\":3,\"117\":1,\"130\":1,\"132\":1,\"147\":1,\"159\":1,\"168\":4,\"232\":3,\"233\":3,\"248\":1,\"249\":1,\"253\":1,\"256\":6,\"262\":2,\"268\":10,\"297\":1,\"349\":1,\"350\":1,\"352\":2,\"354\":1,\"368\":2,\"396\":5,\"404\":4,\"409\":4,\"417\":4,\"419\":4,\"433\":2,\"476\":2,\"478\":3,\"482\":1,\"492\":1,\"496\":2,\"500\":1,\"501\":2,\"502\":1,\"504\":1,\"511\":1,\"540\":3,\"555\":4,\"569\":4,\"593\":1,\"616\":11,\"724\":2,\"729\":2,\"730\":4}}],[\"js\",{\"1\":{\"93\":1,\"323\":1}}],[\"jsr\",{\"1\":{\"81\":1}}],[\"jsonp的支持\",{\"1\":{\"81\":1}}],[\"jsonp\",{\"1\":{\"81\":1}}],[\"json处理器的支持\",{\"1\":{\"81\":1}}],[\"json\",{\"1\":{\"81\":1}}],[\"jsp<\",{\"1\":{\"343\":1}}],[\"jsp页面\",{\"1\":{\"323\":1}}],[\"jsp\",{\"1\":{\"76\":1,\"168\":2,\"339\":1}}],[\"jstlview\",{\"1\":{\"76\":1}}],[\"jd\",{\"1\":{\"256\":1,\"607\":2}}],[\"jdbctemplate对象\",{\"1\":{\"575\":1,\"583\":1}}],[\"jdbctemplate\",{\"0\":{\"573\":1,\"574\":1},\"1\":{\"574\":1,\"575\":7,\"576\":4,\"577\":6,\"578\":1,\"583\":7,\"584\":6}}],[\"jdbcconnection>\",{\"1\":{\"540\":1}}],[\"jdbc\",{\"0\":{\"578\":1},\"1\":{\"81\":2,\"168\":3,\"495\":2,\"496\":1,\"499\":3,\"506\":5,\"507\":8,\"540\":2,\"562\":3,\"574\":1,\"575\":3,\"583\":5,\"584\":2}}],[\"jdbc异常\",{\"1\":{\"61\":1}}],[\"jdkproxy\",{\"1\":{\"569\":2}}],[\"jdk方式解决不了\",{\"1\":{\"492\":1}}],[\"jdk的代理是利用反射生成代理类\",{\"1\":{\"492\":1}}],[\"jdk的元注解\",{\"1\":{\"422\":1}}],[\"jdk中用thread\",{\"1\":{\"469\":1}}],[\"jdk8\",{\"1\":{\"616\":2}}],[\"jdk8默认方法中可以使用泛型\",{\"1\":{\"458\":1}}],[\"jdk8加入\",{\"1\":{\"436\":1}}],[\"jdk5以后是自动装箱方式\",{\"1\":{\"427\":1}}],[\"jdk5前是手动装箱和手动拆箱\",{\"1\":{\"427\":1}}],[\"jdk会通过根据传入的参数信息动态地在内存中创建和\",{\"1\":{\"419\":1}}],[\"jdk动态代理之所以只能代理接口是因为代理类本身已经extends了proxy\",{\"1\":{\"492\":1}}],[\"jdk动态代理\",{\"1\":{\"419\":2,\"492\":1}}],[\"jdk7以上的版本\",{\"1\":{\"411\":1}}],[\"jdk基本介绍\",{\"0\":{\"350\":1}}],[\"jdk9及之后的版本使用字节数组\",{\"1\":{\"121\":1}}],[\"jdk9及之后的有什么变化\",{\"0\":{\"121\":1}}],[\"jdk1\",{\"1\":{\"120\":1,\"442\":2,\"616\":1}}],[\"jdk\",{\"0\":{\"569\":1},\"1\":{\"72\":4,\"159\":1,\"300\":4,\"350\":1,\"492\":4,\"568\":1,\"569\":1}}],[\"j\",{\"1\":{\"55\":14,\"91\":6,\"377\":5,\"381\":5,\"382\":15,\"427\":2,\"428\":2,\"440\":4,\"622\":6,\"623\":4,\"624\":7,\"625\":4,\"628\":5,\"629\":7,\"630\":5,\"632\":9,\"650\":14,\"652\":4,\"653\":14,\"677\":6,\"678\":4,\"687\":6,\"688\":4,\"695\":10,\"696\":7,\"700\":7,\"701\":8,\"702\":15,\"704\":1,\"705\":13,\"706\":14,\"707\":14,\"708\":14,\"709\":49,\"713\":12,\"715\":1,\"718\":2,\"727\":2,\"728\":3,\"729\":3,\"734\":10,\"736\":3,\"737\":6}}],[\"jvm系统内部错误\",{\"1\":{\"424\":1}}],[\"jvm是一个虚拟计算机\",{\"1\":{\"348\":1}}],[\"jvm会编译出汇编指令\",{\"1\":{\"296\":1}}],[\"jvm会发出一条lock前缀的指令\",{\"1\":{\"140\":1}}],[\"jvm可一个根据处理器特性对机器指令重排\",{\"1\":{\"278\":1}}],[\"jvm中采用了分代回收的思想\",{\"1\":{\"148\":1}}],[\"jvm垃圾回收机制\",{\"0\":{\"148\":1}}],[\"jvm\",{\"0\":{\"50\":1,\"145\":1,\"147\":1,\"348\":1},\"1\":{\"350\":1}}],[\"在服务器端处理\",{\"1\":{\"771\":1}}],[\"在服务器返回响应给客户端时\",{\"1\":{\"165\":1}}],[\"在http\",{\"1\":{\"769\":1}}],[\"在http通信中\",{\"1\":{\"768\":1}}],[\"在hotspot源码的\",{\"1\":{\"260\":1}}],[\"在报文内加入一个叫set\",{\"1\":{\"765\":1}}],[\"在图中添加⼀条从\",{\"1\":{\"717\":1}}],[\"在选修某些课程之前需要一些先修课程\",{\"1\":{\"717\":1}}],[\"在遍历图的所有节点时\",{\"1\":{\"716\":1}}],[\"在遍历二维列表的过程中\",{\"1\":{\"704\":1}}],[\"在调用find后\",{\"1\":{\"709\":2}}],[\"在计算岛屿数量的基础上\",{\"1\":{\"708\":1}}],[\"在计算机系统中存在一个cpu的运算速度与内存读写速度不匹配的问题\",{\"1\":{\"274\":1}}],[\"在下一行将一串整型数字存入二维数组中\",{\"1\":{\"728\":1}}],[\"在下一个请求时返回它的克隆\",{\"1\":{\"116\":1}}],[\"在下面的\",{\"1\":{\"705\":1}}],[\"在下图中标记为\",{\"1\":{\"695\":1,\"696\":1}}],[\"在每一步的操作上都要取模\",{\"1\":{\"739\":1}}],[\"在每一次操作中\",{\"1\":{\"660\":1}}],[\"在每次进行操作的时候加上一个版本号\",{\"1\":{\"299\":1}}],[\"在把原队列中的数poll到辅助队列中\",{\"1\":{\"657\":1}}],[\"在头节点处定义一个新指针\",{\"1\":{\"640\":1}}],[\"在第\",{\"1\":{\"635\":1}}],[\"在链表的最后插入一个节点\",{\"1\":{\"635\":1}}],[\"在链表最前面插入一个节点\",{\"1\":{\"635\":1}}],[\"在此情况下\",{\"1\":{\"625\":1}}],[\"在baseimage\",{\"1\":{\"616\":1}}],[\"在nacos终端新增配置\",{\"1\":{\"602\":1}}],[\"在nacos控制台中添加命名空间\",{\"1\":{\"599\":1}}],[\"在项目配置中添加命名空间id\",{\"1\":{\"599\":1}}],[\"在项目工程文件中引入\",{\"1\":{\"571\":1}}],[\"在没有区域的环境下\",{\"1\":{\"598\":1}}],[\"在这里更新步数\",{\"1\":{\"711\":1}}],[\"在这里插入图片描述\",{\"1\":{\"597\":1}}],[\"在这种情况下\",{\"1\":{\"624\":1}}],[\"在这个过程中\",{\"1\":{\"419\":1}}],[\"在这个阶段\",{\"1\":{\"160\":1}}],[\"在这个类中\",{\"1\":{\"83\":1}}],[\"在order\",{\"1\":{\"596\":1,\"597\":2,\"598\":1}}],[\"在作为通知方法上面配置通知注解\",{\"1\":{\"572\":1}}],[\"在增强类里面\",{\"1\":{\"572\":1}}],[\"在增强类里创建方法\",{\"1\":{\"572\":1}}],[\"在增强类上面添加注解\",{\"1\":{\"572\":1}}],[\"在类里定义方法\",{\"1\":{\"572\":1}}],[\"在程序主干里添加新功能\",{\"1\":{\"567\":1}}],[\"在需要注入的类上打上注释\",{\"1\":{\"563\":1}}],[\"在需要的时候更新数据库\",{\"1\":{\"116\":1}}],[\"在获取对象时才会创建对象\",{\"1\":{\"555\":1}}],[\"在不触动警报装置的情况下\",{\"1\":{\"698\":1}}],[\"在不修改源代码的情况下\",{\"1\":{\"548\":1}}],[\"在不创建新的类型的情况下\",{\"1\":{\"123\":1}}],[\"在targetpackage的基础上\",{\"1\":{\"540\":1}}],[\"在映射文件配置文件中设置标签<cache\",{\"1\":{\"535\":1}}],[\"在核心配置文件中全局属性\",{\"1\":{\"535\":1}}],[\"在标签内容的前或后去除指定内容\",{\"1\":{\"529\":1}}],[\"在标签内容前或后添加指定内容\",{\"1\":{\"529\":1}}],[\"在各种标签中的id属性必须和接口中的方法名相同\",{\"1\":{\"501\":1}}],[\"在代理对象中指向的是实际对象的实例\",{\"1\":{\"492\":1}}],[\"在代表锁资源的节点被删除\",{\"1\":{\"217\":1}}],[\"在运行时检查对象\",{\"1\":{\"486\":1}}],[\"在运行时分析类的能力\",{\"1\":{\"486\":1}}],[\"在运行期建立和删除原型\",{\"1\":{\"116\":1}}],[\"在本机的9999端口监听\",{\"1\":{\"485\":1}}],[\"在默认情况下\",{\"1\":{\"479\":1}}],[\"在数据量大的情况下\",{\"1\":{\"477\":1}}],[\"在数据库索引中使用较为广泛\",{\"1\":{\"172\":1}}],[\"在给以设置loop的方法\",{\"1\":{\"467\":1}}],[\"在函数上加上\",{\"1\":{\"462\":1}}],[\"在继承接口或实现接口时确定\",{\"1\":{\"458\":1}}],[\"在内存中生成一个代表这个类的\",{\"1\":{\"419\":1}}],[\"在内存里只有一个实例\",{\"1\":{\"98\":1}}],[\"在执行方法之后执行\",{\"1\":{\"419\":1}}],[\"在执行方法之前执行\",{\"1\":{\"419\":1}}],[\"在创建对象实例时\",{\"1\":{\"413\":1}}],[\"在编写代码时\",{\"1\":{\"411\":1}}],[\"在浏览器地址栏中输入地址后敲回车\",{\"1\":{\"332\":1}}],[\"在条件队列中\",{\"1\":{\"319\":1}}],[\"在阻塞队列等待\",{\"1\":{\"318\":1}}],[\"在doacquireshared与独占锁不同的是\",{\"1\":{\"318\":1}}],[\"在dispatcherservlet的控制下handler对具体的用户请求进行处理\",{\"1\":{\"76\":1}}],[\"在前置节点不可能为null的情况下使用\",{\"1\":{\"312\":1}}],[\"在构造函数中初始化\",{\"1\":{\"312\":1}}],[\"在构造时只能指定初始容量\",{\"1\":{\"124\":1}}],[\"在绕过已取消的前置节点时进行调整\",{\"1\":{\"312\":1}}],[\"在入队时分配\",{\"1\":{\"312\":2}}],[\"在失败时进行阻塞\",{\"1\":{\"312\":1}}],[\"在并发量非常高的环境中\",{\"1\":{\"299\":1}}],[\"在线程之间竞争程度大的时候\",{\"1\":{\"299\":1}}],[\"在线游戏和网络广播等场景中经常使用\",{\"1\":{\"156\":1}}],[\"在compareandset中先对当前引用进行检查\",{\"1\":{\"299\":1}}],[\"在countdownlatch内部有一个volatile修饰的int类型变量\",{\"1\":{\"144\":1}}],[\"在重排序时需考虑指令之间的依赖性\",{\"1\":{\"278\":1}}],[\"在多cpu的系统中\",{\"1\":{\"274\":1}}],[\"在多个路由规则中指定给定的路由权重\",{\"1\":{\"607\":1}}],[\"在多个filter过滤器执行的时候\",{\"1\":{\"342\":1}}],[\"在多个\",{\"1\":{\"167\":1}}],[\"在加入高速缓存后\",{\"1\":{\"274\":1}}],[\"在指令执行完毕后\",{\"1\":{\"274\":1}}],[\"在终端中\",{\"1\":{\"264\":1}}],[\"在future结束时自动调用该函数\",{\"1\":{\"235\":1}}],[\"在finalshell\",{\"1\":{\"49\":1}}],[\"在同一时刻\",{\"1\":{\"217\":1}}],[\"在同一个类中\",{\"1\":{\"164\":1}}],[\"在同一个线程再次调用lock\",{\"1\":{\"141\":1}}],[\"在单体项目中jvm中的锁即可完成需要\",{\"1\":{\"216\":1}}],[\"在单线程环境中\",{\"1\":{\"128\":1}}],[\"在哨兵模式下\",{\"1\":{\"203\":1}}],[\"在查询\",{\"1\":{\"197\":1}}],[\"在存储上非常紧凑\",{\"1\":{\"189\":1}}],[\"在网络模型中实现多线程\",{\"1\":{\"187\":1}}],[\"在事务开启之前\",{\"1\":{\"201\":1}}],[\"在事务提交之前\",{\"1\":{\"180\":1}}],[\"在事务回滚或\",{\"1\":{\"177\":1}}],[\"在wal原则中\",{\"1\":{\"180\":1}}],[\"在innodb中使用6字节的数字表示\",{\"1\":{\"178\":1}}],[\"在application\",{\"1\":{\"598\":1}}],[\"在application中配置eureka地址\",{\"1\":{\"597\":1}}],[\"在aof持久化模式下\",{\"1\":{\"181\":1}}],[\"在a取钱的过程结束前\",{\"1\":{\"170\":1}}],[\"在acquire\",{\"1\":{\"141\":1}}],[\"在控制器方法处理完请求后\",{\"1\":{\"162\":1}}],[\"在初始化完成后\",{\"1\":{\"160\":1}}],[\"在属性赋值完成之后\",{\"1\":{\"160\":1}}],[\"在实现的方法中定义返回的\",{\"1\":{\"558\":1}}],[\"在实体类之间表示一对多的关系\",{\"1\":{\"557\":1}}],[\"在实例化之后\",{\"1\":{\"160\":1}}],[\"在实际项目中\",{\"1\":{\"116\":1}}],[\"在实际使用中\",{\"1\":{\"86\":1}}],[\"在spring中\",{\"1\":{\"158\":1}}],[\"在随后的https通信过程中\",{\"1\":{\"155\":1}}],[\"在低竞争的情况下\",{\"1\":{\"142\":1}}],[\"在release\",{\"1\":{\"141\":1}}],[\"在释放锁时\",{\"1\":{\"141\":1}}],[\"在完全释放锁后\",{\"1\":{\"141\":1}}],[\"在unlock\",{\"1\":{\"141\":1}}],[\"在lock\",{\"1\":{\"141\":1}}],[\"在一幅图中找从起点到终点最近的距离\",{\"1\":{\"711\":1}}],[\"在一个类中的调用顺序是\",{\"1\":{\"413\":1}}],[\"在一个线程修改了该变量的值后\",{\"1\":{\"128\":1}}],[\"在一段时间后失效\",{\"1\":{\"153\":1}}],[\"在一定程度上增加了系统的复杂度\",{\"1\":{\"101\":1}}],[\"在将键值对存储到哈希表中时\",{\"1\":{\"124\":1}}],[\"在jvm中执行\",{\"1\":{\"469\":1}}],[\"在juc中\",{\"1\":{\"311\":1}}],[\"在jdk中提供了atomicstampedreference类解决aba问题\",{\"1\":{\"299\":1}}],[\"在jdk9中\",{\"1\":{\"121\":1}}],[\"在jdk9及之前的版本中\",{\"1\":{\"121\":1}}],[\"在jmm中\",{\"1\":{\"280\":1}}],[\"在java8中\",{\"1\":{\"445\":1}}],[\"在java5\",{\"1\":{\"222\":1}}],[\"在java类中指定和注入依赖\",{\"1\":{\"68\":1}}],[\"在\",{\"1\":{\"116\":2,\"184\":1,\"203\":2,\"523\":1,\"545\":1,\"557\":2,\"559\":2,\"564\":2,\"572\":2,\"575\":2,\"628\":1,\"651\":1,\"687\":1,\"716\":1,\"780\":1}}],[\"在有多种可能会变化的情况下\",{\"1\":{\"113\":1}}],[\"在抽象工厂模式中\",{\"1\":{\"110\":1}}],[\"在抽象类实现\",{\"1\":{\"104\":1}}],[\"在造房子的时候\",{\"1\":{\"104\":1}}],[\"在模板模式\",{\"1\":{\"104\":1}}],[\"在工厂模式中\",{\"1\":{\"101\":1}}],[\"在输出的时候就要处理不能两台打印机打印同一个文件\",{\"1\":{\"98\":1}}],[\"在操作一个文件的时候\",{\"1\":{\"98\":1}}],[\"在主程序保持稳定的基础上\",{\"1\":{\"95\":1}}],[\"在mapper接口上添加\",{\"1\":{\"83\":1}}],[\"在系统运行时决定spring容器如何创建和管理bean实例\",{\"1\":{\"65\":1}}],[\"在使用\",{\"1\":{\"62\":1}}],[\"在页面禁用功能与布局\",{\"1\":{\"10\":1}}],[\"禁止驱逐数据\",{\"1\":{\"192\":1}}],[\"禁止指令重排\",{\"1\":{\"140\":1}}],[\"禁止指令重排序\",{\"1\":{\"128\":1}}],[\"禁止开机启动防火墙\",{\"1\":{\"49\":1}}],[\"禁用了如下功能\",{\"1\":{\"10\":1}}],[\"禁用展示\",{\"1\":{\"9\":1,\"33\":1}}],[\"关系\",{\"1\":{\"588\":1}}],[\"关系操作符得到的结果都是true\",{\"1\":{\"130\":1}}],[\"关晓彤\",{\"1\":{\"448\":1}}],[\"关键是如何套用0\",{\"1\":{\"701\":1}}],[\"关键字的作用\",{\"1\":{\"492\":1}}],[\"关键字synchronized来与对象的互斥锁联系\",{\"1\":{\"471\":1}}],[\"关键字\",{\"1\":{\"396\":1}}],[\"关键\",{\"0\":{\"308\":1}}],[\"关键代码\",{\"1\":{\"98\":1,\"101\":1,\"104\":1,\"107\":1,\"113\":1,\"116\":1}}],[\"关闭后\",{\"1\":{\"537\":1}}],[\"关闭或提交之后有效\",{\"1\":{\"535\":1}}],[\"关闭外层的处理流即可\",{\"1\":{\"478\":1}}],[\"关闭外层流即可\",{\"1\":{\"478\":1}}],[\"关闭流对象和socket\",{\"1\":{\"485\":1}}],[\"关闭流和socket\",{\"1\":{\"485\":1}}],[\"关闭流\",{\"1\":{\"478\":1,\"479\":1}}],[\"关闭文件流\",{\"1\":{\"477\":3}}],[\"关闭\",{\"1\":{\"49\":1,\"104\":1,\"114\":1,\"477\":1}}],[\"关闭centos\",{\"1\":{\"49\":1}}],[\"关于这些扩展\",{\"1\":{\"16\":1}}],[\"换到前面后\",{\"1\":{\"628\":1}}],[\"换行符\",{\"1\":{\"353\":1}}],[\"换数据库只需换方言和驱动就可以\",{\"1\":{\"101\":1}}],[\"换成了2207版后安装成功\",{\"1\":{\"49\":1}}],[\"换句话说\",{\"1\":{\"5\":1,\"709\":1}}],[\"found\",{\"1\":{\"775\":1,\"776\":1}}],[\"foreach>\",{\"1\":{\"531\":3}}],[\"foreach\",{\"0\":{\"531\":1},\"1\":{\"531\":1}}],[\"fori模板\",{\"1\":{\"395\":1}}],[\"for循环增强\",{\"1\":{\"439\":1}}],[\"for循环可以有多条初始化语句\",{\"1\":{\"373\":1}}],[\"for循环可以简写成for\",{\"1\":{\"373\":1}}],[\"for循环控制\",{\"0\":{\"373\":1}}],[\"forward\",{\"1\":{\"334\":1,\"339\":1}}],[\"form\",{\"1\":{\"760\":1,\"769\":1}}],[\"formuser\",{\"1\":{\"583\":2}}],[\"form标签\",{\"1\":{\"332\":2}}],[\"formatstr\",{\"1\":{\"430\":2}}],[\"format\",{\"1\":{\"256\":2,\"419\":4,\"429\":1,\"430\":1,\"436\":6,\"603\":1}}],[\"forkjoinpool\",{\"1\":{\"247\":1}}],[\"forbidden\",{\"1\":{\"155\":1,\"776\":1}}],[\"forname\",{\"1\":{\"63\":1,\"111\":1,\"486\":1,\"555\":1}}],[\"for\",{\"1\":{\"55\":8,\"91\":6,\"105\":2,\"108\":1,\"114\":3,\"117\":1,\"262\":3,\"373\":1,\"376\":2,\"377\":2,\"381\":4,\"382\":10,\"391\":1,\"404\":1,\"416\":1,\"430\":1,\"431\":3,\"433\":1,\"439\":2,\"440\":2,\"443\":4,\"444\":2,\"448\":1,\"454\":1,\"468\":1,\"469\":1,\"599\":1,\"622\":2,\"623\":3,\"624\":6,\"625\":2,\"626\":1,\"627\":2,\"628\":2,\"629\":2,\"630\":3,\"631\":1,\"632\":4,\"634\":1,\"635\":7,\"636\":1,\"637\":1,\"638\":1,\"639\":1,\"640\":1,\"643\":1,\"644\":1,\"646\":2,\"647\":1,\"648\":2,\"649\":1,\"650\":3,\"652\":2,\"653\":2,\"659\":1,\"660\":1,\"661\":2,\"662\":1,\"664\":1,\"666\":1,\"667\":1,\"668\":1,\"671\":1,\"672\":1,\"674\":2,\"675\":2,\"677\":4,\"678\":3,\"682\":1,\"683\":1,\"684\":2,\"685\":1,\"686\":3,\"687\":2,\"688\":2,\"689\":2,\"693\":2,\"694\":1,\"695\":2,\"696\":4,\"697\":1,\"698\":1,\"699\":1,\"700\":4,\"701\":7,\"702\":2,\"705\":2,\"706\":2,\"707\":2,\"708\":4,\"709\":14,\"711\":2,\"712\":1,\"713\":3,\"715\":2,\"716\":2,\"717\":4,\"718\":4,\"724\":1,\"727\":2,\"728\":2,\"729\":2,\"730\":2,\"737\":2}}],[\"ftp\",{\"1\":{\"749\":1}}],[\"ftp占用21\",{\"1\":{\"482\":1}}],[\"flatterntowdim\",{\"1\":{\"709\":8}}],[\"flags\",{\"1\":{\"659\":5}}],[\"flag\",{\"1\":{\"471\":7,\"730\":2}}],[\"flip\",{\"1\":{\"477\":1}}],[\"flushinterval\",{\"1\":{\"536\":1}}],[\"flushinterval=\",{\"1\":{\"536\":1}}],[\"flush\",{\"1\":{\"477\":4}}],[\"fly\",{\"1\":{\"459\":1}}],[\"float>\",{\"1\":{\"458\":1}}],[\"float\",{\"1\":{\"55\":1,\"358\":3,\"359\":3,\"458\":1}}],[\"f\",{\"1\":{\"457\":3,\"471\":1,\"475\":1,\"486\":4,\"614\":1,\"694\":8,\"699\":5,\"702\":10}}],[\"fmt\",{\"1\":{\"436\":2}}],[\"f3\",{\"1\":{\"418\":2}}],[\"f2\",{\"1\":{\"418\":2,\"479\":1}}],[\"f1\",{\"1\":{\"418\":1,\"479\":3}}],[\"fn\",{\"1\":{\"243\":1,\"244\":1,\"248\":9}}],[\"feign的作用是把我们的请求转换为http请求\",{\"1\":{\"606\":1}}],[\"feign性能优化\",{\"1\":{\"606\":1}}],[\"feignloglevel\",{\"1\":{\"606\":1}}],[\"feign自定义配置\",{\"1\":{\"606\":1}}],[\"feignclientconfig\",{\"1\":{\"606\":2}}],[\"feignclient\",{\"1\":{\"606\":2}}],[\"feignclient注解来指定远程服务地址和协议\",{\"1\":{\"606\":1}}],[\"feign客户端依赖\",{\"1\":{\"606\":1}}],[\"feign\",{\"1\":{\"592\":1,\"593\":3,\"595\":2,\"606\":2}}],[\"female\",{\"1\":{\"557\":2}}],[\"feature只能处理简单的异步任务\",{\"1\":{\"164\":1}}],[\"fetchtype=\",{\"1\":{\"524\":1}}],[\"fetchtype\",{\"1\":{\"524\":1}}],[\"fetch更安全一些\",{\"1\":{\"86\":1}}],[\"fetch\",{\"1\":{\"86\":3}}],[\"fetch和git\",{\"0\":{\"86\":1}}],[\"functionalinterface\",{\"1\":{\"251\":4}}],[\"function<v\",{\"1\":{\"251\":1}}],[\"function<\",{\"1\":{\"243\":1,\"248\":6,\"251\":2}}],[\"function<t\",{\"1\":{\"129\":1,\"251\":4}}],[\"full=sc\",{\"1\":{\"724\":1}}],[\"full\",{\"1\":{\"204\":2}}],[\"future2\",{\"1\":{\"268\":2}}],[\"future中get\",{\"1\":{\"235\":1}}],[\"futureapidemo\",{\"1\":{\"233\":1}}],[\"futuretask<string>\",{\"1\":{\"233\":2}}],[\"futuretask<>\",{\"1\":{\"232\":1}}],[\"futuretask<integer>\",{\"1\":{\"232\":1}}],[\"futuretask\",{\"1\":{\"232\":4,\"233\":4}}],[\"futuretask使用例子\",{\"0\":{\"232\":1}}],[\"futuretask类的继承实现关系\",{\"0\":{\"231\":1}}],[\"futuretask类\",{\"0\":{\"230\":1}}],[\"future接口对于结果的获取不是很友好\",{\"1\":{\"235\":1}}],[\"future接口的缺点\",{\"1\":{\"235\":1}}],[\"future接口功能\",{\"1\":{\"229\":1}}],[\"future接口\",{\"0\":{\"229\":1}}],[\"future\",{\"1\":{\"132\":3,\"268\":2}}],[\"fast指针每次移动两个节点\",{\"1\":{\"640\":1}}],[\"fast\",{\"1\":{\"640\":8,\"642\":5,\"643\":5}}],[\"fastindex++\",{\"1\":{\"623\":1}}],[\"fastindex\",{\"1\":{\"623\":4}}],[\"father匿名内部类\",{\"1\":{\"418\":2}}],[\"father\",{\"1\":{\"399\":3,\"418\":7}}],[\"fabonachi\",{\"1\":{\"391\":4}}],[\"factorial\",{\"1\":{\"391\":3}}],[\"factory读取并处理\",{\"1\":{\"607\":1}}],[\"factorybean\",{\"0\":{\"558\":1},\"1\":{\"558\":3}}],[\"factory\",{\"1\":{\"101\":1,\"102\":9,\"110\":1,\"111\":42}}],[\"false\",{\"1\":{\"220\":1,\"268\":2,\"358\":1,\"428\":2,\"429\":1,\"445\":1,\"467\":1,\"471\":1,\"501\":1,\"524\":1,\"536\":2,\"563\":2,\"650\":1,\"659\":4,\"668\":4,\"674\":1,\"675\":1,\"677\":3,\"688\":1,\"689\":3,\"701\":6,\"702\":1,\"705\":3,\"716\":4,\"717\":3,\"721\":4,\"730\":2}}],[\"failover命令通知其他redis实例进行主从切换\",{\"1\":{\"203\":1}}],[\"failsafe\",{\"1\":{\"82\":1}}],[\"fairness\",{\"1\":{\"142\":1}}],[\"fib\",{\"1\":{\"694\":1}}],[\"finish\",{\"1\":{\"695\":1,\"696\":1}}],[\"find\",{\"1\":{\"709\":10}}],[\"findtargetsumways\",{\"1\":{\"687\":2}}],[\"findanagrams\",{\"1\":{\"649\":1}}],[\"findbyid\",{\"1\":{\"597\":1,\"606\":1}}],[\"final修饰后就不会导致类加载\",{\"1\":{\"415\":1}}],[\"final修饰的属性在定义时\",{\"1\":{\"415\":1}}],[\"final修饰的属性又叫常量\",{\"1\":{\"415\":1}}],[\"final修饰的\",{\"1\":{\"120\":1}}],[\"finaldetail02\",{\"1\":{\"415\":1}}],[\"final使用细节\",{\"1\":{\"415\":1}}],[\"final关键字\",{\"0\":{\"415\":1}}],[\"final关键字有什么作用\",{\"0\":{\"127\":1}}],[\"finalize方法\",{\"1\":{\"406\":1}}],[\"finally\",{\"1\":{\"220\":1,\"249\":1,\"262\":1,\"271\":2,\"424\":1,\"477\":7,\"478\":6,\"479\":1}}],[\"final\",{\"1\":{\"102\":1,\"105\":1,\"114\":1,\"247\":1,\"263\":1,\"312\":9,\"313\":1,\"415\":2,\"418\":1,\"429\":2,\"491\":5,\"492\":1,\"586\":1,\"598\":4}}],[\"finalshell连接\",{\"0\":{\"49\":1}}],[\"fish\",{\"1\":{\"459\":1}}],[\"fie\",{\"1\":{\"395\":1}}],[\"field\",{\"1\":{\"386\":1,\"486\":1}}],[\"fill\",{\"1\":{\"433\":1}}],[\"filters\",{\"1\":{\"607\":1}}],[\"filters=\",{\"1\":{\"563\":2}}],[\"filter的拦截路径\",{\"0\":{\"343\":1}}],[\"filter的生命周期包含几个方法\",{\"1\":{\"340\":1}}],[\"filter的生命周期\",{\"0\":{\"340\":1}}],[\"filter执行顺序\",{\"1\":{\"342\":1}}],[\"filter>\",{\"1\":{\"339\":1}}],[\"filterchain类\",{\"0\":{\"342\":1}}],[\"filterchain\",{\"1\":{\"339\":1,\"342\":1}}],[\"filterconfig类\",{\"0\":{\"341\":1}}],[\"filterconfig\",{\"1\":{\"339\":1}}],[\"filter使用步骤\",{\"1\":{\"339\":1}}],[\"filter应用\",{\"0\":{\"339\":1}}],[\"filter过滤器的配置文件类\",{\"1\":{\"341\":1}}],[\"filter过滤器也是个接口\",{\"1\":{\"338\":1}}],[\"filter过滤器\",{\"0\":{\"337\":1}}],[\"filter\",{\"1\":{\"194\":1,\"339\":5,\"341\":1,\"563\":2,\"607\":3}}],[\"filecopy\",{\"1\":{\"477\":1}}],[\"filecpy\",{\"1\":{\"477\":1}}],[\"filepath\",{\"1\":{\"477\":8,\"478\":13}}],[\"fileoutputstream拷贝\",{\"1\":{\"477\":1}}],[\"fileoutputstream\",{\"1\":{\"477\":16,\"478\":2,\"480\":1}}],[\"fileoutputstream01\",{\"1\":{\"477\":1}}],[\"fileoutputstream介绍\",{\"1\":{\"477\":1}}],[\"file03\",{\"1\":{\"475\":1}}],[\"file02\",{\"1\":{\"475\":1}}],[\"file01\",{\"1\":{\"475\":1}}],[\"file对象在java程序中只是一个对象\",{\"1\":{\"475\":2}}],[\"filenotfoundexception\",{\"1\":{\"425\":1}}],[\"filename\",{\"1\":{\"111\":3}}],[\"fileinputstream01\",{\"1\":{\"477\":1}}],[\"fileinputstream介绍\",{\"1\":{\"477\":1}}],[\"fileinputstream\",{\"1\":{\"425\":1,\"477\":19,\"478\":4}}],[\"file\",{\"1\":{\"181\":1,\"189\":1,\"475\":37,\"477\":3,\"599\":1,\"602\":1}}],[\"filereader01\",{\"1\":{\"477\":1}}],[\"filereader相关方法\",{\"1\":{\"477\":1}}],[\"filereader\",{\"1\":{\"114\":1,\"477\":15,\"478\":1,\"480\":1}}],[\"filewriter01\",{\"1\":{\"477\":1}}],[\"filewriter使用后\",{\"1\":{\"477\":1}}],[\"filewriter常用方法\",{\"1\":{\"477\":1}}],[\"filewriter\",{\"1\":{\"111\":3,\"477\":16,\"478\":5,\"479\":1}}],[\"firsti\",{\"1\":{\"678\":3}}],[\"firstvalue\",{\"1\":{\"306\":2}}],[\"first\",{\"1\":{\"192\":2}}],[\"firewalld\",{\"1\":{\"49\":2}}],[\"fifo\",{\"1\":{\"167\":1,\"192\":1,\"536\":1}}],[\"fruits\",{\"1\":{\"631\":15}}],[\"freaking\",{\"1\":{\"607\":1}}],[\"frequency\",{\"1\":{\"452\":1}}],[\"frequently\",{\"1\":{\"192\":1}}],[\"freemarker\",{\"1\":{\"76\":1,\"81\":1}}],[\"freemarkerview\",{\"1\":{\"76\":1}}],[\"frame\",{\"1\":{\"786\":1}}],[\"framework\",{\"1\":{\"102\":7,\"117\":6}}],[\"fraction\",{\"1\":{\"5\":1}}],[\"front\",{\"1\":{\"162\":1}}],[\"frontmatter\",{\"1\":{\"10\":1,\"14\":3,\"40\":1,\"42\":1}}],[\"fromi\",{\"1\":{\"677\":2}}],[\"from\",{\"1\":{\"5\":1,\"184\":2,\"436\":1,\"501\":3,\"504\":1,\"511\":2,\"512\":4,\"517\":3,\"518\":1,\"519\":1,\"522\":2,\"523\":3,\"524\":1,\"525\":2,\"527\":1,\"528\":1,\"529\":1,\"530\":1,\"531\":2,\"532\":1,\"577\":1,\"616\":4,\"717\":4}}],[\"安全的\",{\"0\":{\"787\":1}}],[\"安全的在\",{\"1\":{\"18\":1}}],[\"安全框架与其他系统的集成\",{\"1\":{\"545\":1}}],[\"安全\",{\"1\":{\"442\":1}}],[\"安全通信\",{\"1\":{\"155\":1}}],[\"安全性\",{\"1\":{\"154\":1}}],[\"安全性和隔离性\",{\"1\":{\"147\":1}}],[\"安装部分单独打包\",{\"1\":{\"616\":1}}],[\"安装jdk\",{\"1\":{\"616\":1}}],[\"安装docker\",{\"0\":{\"612\":1}}],[\"安装时一开始选用的是centos7\",{\"1\":{\"49\":1}}],[\"安装\",{\"0\":{\"49\":1}}],[\"计算一个数的数位之和\",{\"1\":{\"734\":1}}],[\"计算一段代码的运行时间\",{\"1\":{\"416\":1}}],[\"计算封闭岛屿数量\",{\"1\":{\"708\":1}}],[\"计算当前岛屿的面积\",{\"1\":{\"707\":1}}],[\"计算你\",{\"1\":{\"697\":1,\"698\":1}}],[\"计算\",{\"1\":{\"678\":1}}],[\"计算n个数和\",{\"1\":{\"627\":1}}],[\"计算结果\",{\"1\":{\"624\":1}}],[\"计算结果作为输入参数传给下一个阶段\",{\"1\":{\"243\":1}}],[\"计算答案\",{\"1\":{\"624\":1}}],[\"计算按此排列的柱子\",{\"1\":{\"624\":1}}],[\"计算机运算时都是用补码运算的\",{\"1\":{\"369\":1}}],[\"计算机硬件存储体系\",{\"0\":{\"274\":1}}],[\"计算时会都转换为int类型\",{\"1\":{\"359\":1}}],[\"计算完成\",{\"1\":{\"249\":1}}],[\"计算后调用\",{\"1\":{\"95\":1}}],[\"计算执行所有任务所需要的最小内存\",{\"1\":{\"91\":1}}],[\"计算工作时长\",{\"0\":{\"89\":1}}],[\"计算整型数组的总和\",{\"0\":{\"44\":1}}],[\"计划偷窃沿街的房屋\",{\"1\":{\"698\":1}}],[\"计划\",{\"1\":{\"25\":2}}],[\"一样会过期\",{\"1\":{\"781\":1}}],[\"一串数字\",{\"1\":{\"729\":1}}],[\"一行输出答案\",{\"1\":{\"724\":1}}],[\"一夜之内能够偷窃到的最高金额\",{\"1\":{\"697\":1}}],[\"一共有\",{\"1\":{\"687\":1}}],[\"一层遍历完\",{\"1\":{\"666\":1,\"669\":1}}],[\"一次业务中\",{\"1\":{\"596\":1}}],[\"一次只使用其中一个\",{\"1\":{\"148\":1}}],[\"一种是最大乘积为这两段的乘积j×\",{\"1\":{\"736\":1}}],[\"一种是和\",{\"1\":{\"593\":2}}],[\"一种\",{\"1\":{\"558\":1}}],[\"一种普通\",{\"1\":{\"558\":1}}],[\"一种特殊的线程\",{\"1\":{\"227\":1}}],[\"一对多关系\",{\"1\":{\"557\":1}}],[\"一对多映射\",{\"0\":{\"525\":1}}],[\"一处最长时间不配使用的对象\",{\"1\":{\"536\":1}}],[\"一定要关闭流\",{\"1\":{\"477\":1}}],[\"一边读一边写\",{\"1\":{\"477\":1}}],[\"一组键值对\",{\"1\":{\"451\":1}}],[\"一组对象\",{\"1\":{\"451\":2}}],[\"一\",{\"0\":{\"321\":1,\"345\":1}}],[\"一台\",{\"1\":{\"203\":1,\"778\":1}}],[\"一致性读\",{\"1\":{\"178\":1}}],[\"一致性\",{\"1\":{\"170\":1,\"183\":1,\"580\":1}}],[\"一级缓存的数据会写入二级缓存\",{\"1\":{\"537\":1}}],[\"一级缓存也没有\",{\"1\":{\"537\":1}}],[\"一级缓存失效的情况\",{\"1\":{\"534\":1}}],[\"一级缓存是基于对象引用来实现的\",{\"1\":{\"167\":1}}],[\"一级缓存\",{\"0\":{\"534\":1},\"1\":{\"163\":1,\"167\":1}}],[\"一旦拨轮的数字和列表里的任何一个元素相同\",{\"1\":{\"713\":1}}],[\"一旦你走到某棵树前\",{\"1\":{\"631\":1}}],[\"一旦定义了自己的构造\",{\"1\":{\"392\":1}}],[\"一旦事务执行前有一个键被修改\",{\"1\":{\"202\":1}}],[\"一旦表和连接准备好\",{\"1\":{\"184\":1}}],[\"一旦找到了匹配的处理器\",{\"1\":{\"161\":1}}],[\"一旦被初始化赋值后\",{\"1\":{\"127\":1}}],[\"一起使用\",{\"1\":{\"133\":1}}],[\"一些敏感数据不允许被多个线程同时访问\",{\"1\":{\"470\":1}}],[\"一些基本部件不会变\",{\"1\":{\"107\":1}}],[\"一些方法通用\",{\"1\":{\"104\":1}}],[\"一些设备管理器常常设计为单例模式\",{\"1\":{\"98\":1}}],[\"一些前辈达人总结出来能够更进一步改善代码结构的方式方法\",{\"1\":{\"93\":1}}],[\"一些数组操作\",{\"0\":{\"43\":1}}],[\"一般将编码实体资源进行分块\",{\"1\":{\"768\":1}}],[\"一般可以解决如下几种问题\",{\"1\":{\"681\":1}}],[\"一般由开发人员使用\",{\"1\":{\"555\":1}}],[\"一般用于中断正在休眠线程\",{\"1\":{\"468\":1}}],[\"一般用tostring\",{\"1\":{\"421\":1}}],[\"一般用xx\",{\"1\":{\"415\":1}}],[\"一般存放基本数据类型\",{\"1\":{\"388\":1}}],[\"一般是启动的脚本和参数\",{\"1\":{\"616\":1}}],[\"一般是为工作线程服务的\",{\"1\":{\"468\":1}}],[\"一般是类名\",{\"1\":{\"327\":1}}],[\"一般是和工厂方法模式一起出现\",{\"1\":{\"116\":1}}],[\"一般在多线程并发情况下我们都应该禁止指令重排序的优化\",{\"1\":{\"292\":1}}],[\"一般具有较低的写入延迟\",{\"1\":{\"213\":1}}],[\"一般就是你本地启动了玩玩儿的\",{\"1\":{\"212\":1}}],[\"一般会指定一个bindingkey\",{\"1\":{\"209\":1}}],[\"一般情况下一个broker可以看做一个rabbitmq服务器\",{\"1\":{\"209\":1}}],[\"一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户\",{\"1\":{\"76\":1}}],[\"一般来说\",{\"1\":{\"174\":1}}],[\"一般使用注解\",{\"1\":{\"164\":1}}],[\"一般还会配置一个线程池\",{\"1\":{\"164\":1}}],[\"一般为4kb左右\",{\"1\":{\"153\":1}}],[\"一般一个第三方的应该这样命\",{\"1\":{\"81\":1}}],[\"一并返回给\",{\"1\":{\"76\":1}}],[\"一个报文分为报文首部和报文主体\",{\"1\":{\"768\":1}}],[\"一个来自\",{\"1\":{\"716\":1}}],[\"一个代表四个拨轮的数字的字符串\",{\"1\":{\"713\":1}}],[\"一个机器人位于一个\",{\"1\":{\"695\":1,\"696\":1}}],[\"一个n个数的集合里有多少符合条件的子集\",{\"1\":{\"681\":1}}],[\"一个队列在模拟栈弹出元素的时候只要将队列头部的元素\",{\"1\":{\"658\":1}}],[\"一个栈存数据\",{\"1\":{\"655\":1}}],[\"一个字符不满足个数\",{\"1\":{\"648\":1}}],[\"一个字符串按一定规则有几种切割方式\",{\"1\":{\"681\":1}}],[\"一个字符串\",{\"1\":{\"648\":1}}],[\"一个字符占两个字节\",{\"1\":{\"429\":1}}],[\"一个别人制作好的镜像\",{\"1\":{\"616\":1}}],[\"一个未提交事务读取到另一个提交事务添加数据\",{\"1\":{\"582\":1}}],[\"一个未提交事务读取到另一个未提交事务的数据\",{\"1\":{\"582\":1}}],[\"一个未提交事务读取到另一提交事务修改数据\",{\"1\":{\"582\":1}}],[\"一个人多100\",{\"1\":{\"580\":1}}],[\"一个人少100\",{\"1\":{\"580\":1}}],[\"一个部门里有多个员工\",{\"1\":{\"557\":1}}],[\"一个参数无需定义圆括号\",{\"1\":{\"488\":1}}],[\"一个普通类实现接口就必须将该接口的所有方法都实现\",{\"1\":{\"417\":1}}],[\"一个house对象表示一个房屋信息\",{\"1\":{\"409\":1}}],[\"一个子类只能继承一个父类\",{\"1\":{\"399\":1}}],[\"一个方法最多有一个返回值\",{\"1\":{\"389\":1}}],[\"一个方法调用另外一个有\",{\"1\":{\"164\":1}}],[\"一个回车\",{\"1\":{\"353\":1}}],[\"一个源文件中只能有一个public类\",{\"1\":{\"352\":1}}],[\"一个web工程只有一个servlet对象实例\",{\"1\":{\"331\":1}}],[\"一个版本号和某个值\",{\"1\":{\"299\":1}}],[\"一个unlock操作先行发生于lock之后\",{\"1\":{\"282\":1}}],[\"一个线程不应该由其他线程来中断或停止\",{\"1\":{\"267\":1}}],[\"一个简单的例子\",{\"1\":{\"252\":1}}],[\"一个virtual\",{\"1\":{\"209\":1}}],[\"一个tcp连接可以用多个信道\",{\"1\":{\"209\":1}}],[\"一个消息可投入一个或多个队列\",{\"1\":{\"209\":1}}],[\"一个对象的编译类型和运行类型可以不一致\",{\"1\":{\"402\":1}}],[\"一个对象的初始化完成\",{\"1\":{\"288\":1}}],[\"一个对象需要提供给其他对象访问\",{\"1\":{\"116\":1}}],[\"一个对象需要在一个高代价的数据库操作之后被创建\",{\"1\":{\"116\":1}}],[\"一个对象多个修改者的场景\",{\"1\":{\"116\":1}}],[\"一个类的内部嵌套了一个类\",{\"1\":{\"418\":1}}],[\"一个类可以同时实现多个接口\",{\"1\":{\"417\":1}}],[\"一个类可以定义多个构造器\",{\"1\":{\"392\":1}}],[\"一个类存在两个独立变化的维度\",{\"1\":{\"113\":1}}],[\"一个类应该只关心内部逻辑\",{\"1\":{\"98\":1}}],[\"一个复杂对象\",{\"1\":{\"107\":1}}],[\"一个\",{\"1\":{\"107\":1,\"353\":3}}],[\"一个抽象类公开定义了执行它的方法的方式\",{\"1\":{\"104\":1}}],[\"一个调用者想创建一个对象\",{\"1\":{\"101\":1}}],[\"一个班级只有一个班主任\",{\"1\":{\"98\":1}}],[\"一个全局使用的类频繁地创建与销毁\",{\"1\":{\"98\":1}}],[\"一个符合某一接口的实例\",{\"1\":{\"72\":1,\"159\":1}}],[\"一个拥有\",{\"1\":{\"22\":1}}],[\"一个是直接使用group\",{\"1\":{\"7\":1}}],[\"一个shared\",{\"1\":{\"3\":1}}],[\"一个删除了拷贝构造函数\",{\"1\":{\"3\":1}}],[\"徽章\",{\"1\":{\"41\":1}}],[\"徽章文字\",{\"1\":{\"41\":1}}],[\"但未满足条件\",{\"1\":{\"775\":1}}],[\"但响应报文中不包含实体得主体部分\",{\"1\":{\"774\":1}}],[\"但模块1和3没有依赖关系\",{\"1\":{\"718\":1}}],[\"但如果使用前缀表\",{\"1\":{\"653\":1}}],[\"但大于或等于\",{\"1\":{\"643\":1}}],[\"但水果不符合篮子的水果类型\",{\"1\":{\"631\":1}}],[\"但避免了写\",{\"1\":{\"495\":1}}],[\"但指向该对象的地址不能修改\",{\"1\":{\"492\":1}}],[\"但多个参数需要定义圆括号\",{\"1\":{\"488\":1}}],[\"但线程并没用真正结束\",{\"1\":{\"468\":1}}],[\"但比stringbuffer类要快\",{\"1\":{\"431\":1}}],[\"但可以继承接口\",{\"1\":{\"417\":1}}],[\"但可能存在幻读问题\",{\"1\":{\"178\":1}}],[\"但可能降低并发性能\",{\"1\":{\"171\":1}}],[\"但与方法不同没有方法名\",{\"1\":{\"413\":1}}],[\"但不肯相让\",{\"1\":{\"471\":1}}],[\"但不完全等价于地址\",{\"1\":{\"406\":1}}],[\"但不能访问父类的private属性\",{\"1\":{\"400\":1}}],[\"但编译类型不能改变\",{\"1\":{\"402\":1}}],[\"但要求形参不一致\",{\"1\":{\"391\":1}}],[\"但要求类型相同\",{\"1\":{\"373\":1}}],[\"但建议使用state方法对state变量进行操作以实现同步类\",{\"1\":{\"313\":1}}],[\"但它有助于虚拟机\",{\"1\":{\"312\":1}}],[\"但简化了机制\",{\"1\":{\"312\":1}}],[\"但volatile无法保证原子性\",{\"1\":{\"290\":1}}],[\"但volatile不能保证原子性\",{\"1\":{\"138\":1}}],[\"但读取消息可能会有一定的延迟\",{\"1\":{\"213\":1}}],[\"但仍可能存在幻读的问题\",{\"1\":{\"171\":1}}],[\"但仍可能存在不可重复读和幻读的问题\",{\"1\":{\"171\":1}}],[\"但此时读取到的数据已经发生了改变\",{\"1\":{\"171\":1}}],[\"但此时只是占位符\",{\"1\":{\"163\":1}}],[\"但就没有走多线程\",{\"1\":{\"164\":1}}],[\"但随着时间的推移无法被垃圾回收器释放\",{\"1\":{\"146\":1}}],[\"但在任意给定的时间点只有一个任务在执行\",{\"1\":{\"151\":1}}],[\"但在高竞争环境下\",{\"1\":{\"142\":1}}],[\"但在多线程环境中\",{\"1\":{\"128\":1}}],[\"但返回一个结果\",{\"1\":{\"129\":1}}],[\"但没有返回结果\",{\"1\":{\"129\":1}}],[\"但对于已有的类不一定很容易\",{\"1\":{\"116\":1}}],[\"但调用将以抽象类中定义的方式进行\",{\"1\":{\"104\":1}}],[\"但是使用数组\",{\"1\":{\"721\":1}}],[\"但是查找慢\",{\"1\":{\"720\":1}}],[\"但是查询条件不同\",{\"1\":{\"534\":1}}],[\"但是数据⽆固定顺序\",{\"1\":{\"720\":1}}],[\"但是数据库更新失败\",{\"1\":{\"195\":1}}],[\"但是只有二个map存储的数据完全相同\",{\"1\":{\"649\":1}}],[\"但是只能有一个null\",{\"1\":{\"445\":1}}],[\"但是反转后的字符不能包括\",{\"1\":{\"645\":1}}],[\"但是读取nacos中的配置文件是在读取application\",{\"1\":{\"602\":1}}],[\"但是必须满足两个条件\",{\"1\":{\"509\":1}}],[\"但是cglib在创建代理对象时所花费的时间却比jdk多得多\",{\"1\":{\"492\":1}}],[\"但是允许实现多个接口\",{\"1\":{\"492\":1}}],[\"但是不设终止条件\",{\"1\":{\"686\":1}}],[\"但是不太暴力\",{\"1\":{\"622\":1}}],[\"但是不可被后面的代码修改\",{\"1\":{\"491\":1}}],[\"但是不能保存int变量值\",{\"1\":{\"359\":1}}],[\"但是可能会引发异常\",{\"1\":{\"461\":1}}],[\"但是可以进行计算\",{\"1\":{\"359\":1}}],[\"但是没有synchronized修饰\",{\"1\":{\"441\":1}}],[\"但是这样会产生过多的代理类\",{\"1\":{\"419\":1}}],[\"但是这样就导致代理类过于庞大\",{\"1\":{\"419\":1}}],[\"但是这个代理对象只能拦截从外部类调用的方法\",{\"1\":{\"166\":1}}],[\"但是一个类包含抽象方法则一定要声明为抽象类\",{\"1\":{\"416\":1}}],[\"但是私有属性不能在子类直接访问\",{\"1\":{\"399\":1}}],[\"但是引用类型变量则会产生影响\",{\"1\":{\"391\":1}}],[\"但是引用类型形参传递的是指向内存的地址\",{\"1\":{\"389\":1}}],[\"但是常量在byte范围内就可以赋值\",{\"1\":{\"365\":1}}],[\"但是具体值在byte范围内就可以赋值\",{\"1\":{\"359\":1}}],[\"但是\",{\"1\":{\"312\":1}}],[\"但是实际上这个值确实已经被修改过了\",{\"1\":{\"299\":1}}],[\"但是带来一个问题\",{\"1\":{\"299\":1}}],[\"但是在每次的向后判断过程中有很多重复的判断\",{\"1\":{\"622\":1}}],[\"但是在正式更新数据之前会检查数据是否被其他线程改变过\",{\"1\":{\"295\":1}}],[\"但是在扫描时\",{\"1\":{\"69\":1}}],[\"但是由于另外一个线程在自己的工作内存中已经保留了一份该共享变量的副本\",{\"1\":{\"291\":1}}],[\"但是多线程间可能产生问题\",{\"1\":{\"278\":1}}],[\"但是多个线程同时进行自增操作仍然会产生竞态条件\",{\"1\":{\"128\":1}}],[\"但是指令重排可一个保证单线程的语义一致\",{\"1\":{\"278\":1}}],[\"但是微服务\",{\"1\":{\"216\":1}}],[\"但是如果竞争很大\",{\"1\":{\"299\":1}}],[\"但是如果在多线程中\",{\"1\":{\"292\":1}}],[\"但是如果没有找到对应的offset\",{\"1\":{\"204\":1}}],[\"但是如果查询条件只涉及到\",{\"1\":{\"175\":1}}],[\"但是会周期性地把更新的数据写入磁盘或者把修改操作写成追加的记录文件中\",{\"1\":{\"189\":1}}],[\"但是返回值都是null\",{\"1\":{\"164\":1}}],[\"但是对于存活对象较多的情况\",{\"1\":{\"148\":1}}],[\"但是还没有超过maximumpoolsize限制\",{\"1\":{\"135\":1}}],[\"但是转化红黑树这个过程是耗时的\",{\"1\":{\"124\":1}}],[\"但是将它们组合在一起的算法却相对稳定\",{\"1\":{\"107\":1}}],[\"但是也具有灵活性和可读性\",{\"1\":{\"62\":1}}],[\"但是你需要使用相对链接\",{\"1\":{\"41\":1}}],[\"但无法应对较为复杂的场景\",{\"1\":{\"6\":1}}],[\"标明\",{\"1\":{\"770\":1}}],[\"标准通用标记语言\",{\"1\":{\"746\":1}}],[\"标准输出\",{\"1\":{\"479\":1}}],[\"标准输入输出流\",{\"1\":{\"478\":1}}],[\"标签里的属性\",{\"1\":{\"559\":1}}],[\"标签\",{\"1\":{\"557\":1}}],[\"标签来引用\",{\"1\":{\"532\":1}}],[\"标签表示代码片段\",{\"1\":{\"532\":1}}],[\"标签还会自动删除前面多余的\",{\"1\":{\"528\":1}}],[\"标签会自动判断条件标签是否成立\",{\"1\":{\"528\":1}}],[\"标签为\",{\"1\":{\"40\":1}}],[\"标题和页面信息\",{\"1\":{\"42\":1}}],[\"标记出已经获得资源中的子资源\",{\"1\":{\"757\":1}}],[\"标记接口\",{\"1\":{\"478\":1}}],[\"标记\",{\"0\":{\"24\":1},\"1\":{\"148\":1}}],[\"日志级别\",{\"1\":{\"606\":1}}],[\"日志记录的是最终状态\",{\"1\":{\"181\":1}}],[\"日志记录\",{\"1\":{\"158\":1}}],[\"日志记录和yaml支持等\",{\"1\":{\"81\":1}}],[\"日=\",{\"1\":{\"436\":1}}],[\"日期=\",{\"1\":{\"436\":1}}],[\"日期时间\",{\"1\":{\"436\":1}}],[\"日期\",{\"1\":{\"436\":1}}],[\"日期类\",{\"0\":{\"436\":1}}],[\"日记操作\",{\"1\":{\"338\":1}}],[\"日报\",{\"1\":{\"111\":1}}],[\"日\",{\"1\":{\"40\":1,\"436\":2}}],[\"月=\",{\"1\":{\"436\":2}}],[\"月租\",{\"1\":{\"408\":1}}],[\"月\",{\"1\":{\"40\":1,\"436\":2}}],[\"年=\",{\"1\":{\"436\":1}}],[\"年月日时分秒\",{\"1\":{\"436\":1}}],[\"年月日\",{\"1\":{\"436\":3}}],[\"年\",{\"1\":{\"40\":1,\"436\":2}}],[\"写配置类替代\",{\"1\":{\"584\":1}}],[\"写增强的方法\",{\"1\":{\"569\":1}}],[\"写在main方法中\",{\"1\":{\"379\":1}}],[\"写入数据到数据通道\",{\"1\":{\"485\":1}}],[\"写入字符串的指定部分\",{\"1\":{\"477\":2}}],[\"写入整个字符串\",{\"1\":{\"477\":2}}],[\"写入指定数组的指定部分\",{\"1\":{\"477\":2}}],[\"写入指定数组\",{\"1\":{\"477\":2}}],[\"写入单个字符\",{\"1\":{\"477\":2}}],[\"写入一个字符串\",{\"1\":{\"477\":1}}],[\"写入一个字节\",{\"1\":{\"477\":1}}],[\"写入你不希望显示的警告信息\",{\"1\":{\"422\":1}}],[\"写入\",{\"1\":{\"295\":1}}],[\"写入共享数据时\",{\"1\":{\"295\":1}}],[\"写后读\",{\"1\":{\"281\":1}}],[\"写请求可以删除读请求造成的缓存脏数据\",{\"1\":{\"196\":1}}],[\"写作日期为\",{\"1\":{\"40\":1}}],[\"写一条sql查询语句获取合作过至少三次的演员和导演的\",{\"1\":{\"7\":1}}],[\"↩︎\",{\"1\":{\"38\":1}}],[\"捐赠一杯咖啡\",{\"1\":{\"35\":1}}],[\"向集合中插入该项\",{\"1\":{\"721\":1}}],[\"向该区域的相邻区域发散\",{\"1\":{\"704\":1}}],[\"向下\",{\"1\":{\"696\":4}}],[\"向右\",{\"1\":{\"696\":4}}],[\"向数组中的每个整数前添加\",{\"1\":{\"687\":1}}],[\"向一个方向行驶\",{\"1\":{\"677\":1}}],[\"向后移动一位\",{\"1\":{\"636\":1}}],[\"向docker\",{\"1\":{\"611\":1}}],[\"向外暴露一个静态的公共方法\",{\"1\":{\"414\":2}}],[\"向\",{\"1\":{\"35\":1}}],[\"导致异常结束\",{\"1\":{\"472\":1}}],[\"导致死锁\",{\"1\":{\"471\":1}}],[\"导致主从服务器数据库状态不一致\",{\"1\":{\"203\":1}}],[\"导致数据库压力巨大\",{\"1\":{\"198\":1}}],[\"导致数据的不完整性\",{\"1\":{\"171\":1}}],[\"导致数据的错误处理和错误结果\",{\"1\":{\"171\":1}}],[\"导致数据的丢失\",{\"1\":{\"171\":1}}],[\"导致用户每次请求该数据都要去数据库中查询一遍\",{\"1\":{\"197\":1}}],[\"导致查询性能下降\",{\"1\":{\"173\":1}}],[\"导致前后两次查询的结果集不一致\",{\"1\":{\"171\":1}}],[\"导致前后两次读取的数据不一致\",{\"1\":{\"171\":1}}],[\"导致类的个数增加\",{\"1\":{\"104\":1}}],[\"导演\",{\"1\":{\"107\":1}}],[\"导入依赖库\",{\"1\":{\"552\":1}}],[\"导入了system类的所有静态方法和静态成员\",{\"1\":{\"396\":1}}],[\"导入了mapperscannerregistrar这个类\",{\"1\":{\"83\":1}}],[\"导入文件\",{\"0\":{\"33\":1}}],[\"导航栏\",{\"1\":{\"10\":1,\"42\":1}}],[\"−1\",{\"1\":{\"32\":1}}],[\"ωyω​\",{\"1\":{\"32\":2}}],[\"∂ωr∂r​\",{\"1\":{\"32\":1}}],[\"图结构\",{\"1\":{\"718\":1}}],[\"图也可表示成linkedlist<integer>\",{\"1\":{\"718\":1}}],[\"图的单条路径遍历\",{\"1\":{\"716\":1}}],[\"图的遍历\",{\"1\":{\"716\":1,\"718\":1}}],[\"图的遍历框架\",{\"1\":{\"715\":1}}],[\"图的遍历稍作修改\",{\"1\":{\"707\":1}}],[\"图中共有\",{\"1\":{\"717\":1}}],[\"图中有\",{\"1\":{\"716\":1}}],[\"图中垂直线代表输入数组\",{\"1\":{\"625\":1}}],[\"图\",{\"1\":{\"706\":1,\"707\":1,\"708\":1,\"709\":1}}],[\"图论算法\",{\"0\":{\"714\":1}}],[\"图论\",{\"0\":{\"704\":1}}],[\"图片\",{\"1\":{\"323\":1}}],[\"图片增强\",{\"0\":{\"26\":1}}],[\"图表\",{\"0\":{\"28\":1}}],[\"rightdepth\",{\"1\":{\"669\":3}}],[\"right++\",{\"1\":{\"630\":1,\"647\":1,\"648\":1,\"649\":1}}],[\"right\",{\"1\":{\"620\":5,\"621\":5,\"624\":5,\"625\":6,\"627\":4,\"628\":6,\"630\":6,\"631\":6,\"647\":5,\"648\":8,\"649\":8,\"664\":10,\"666\":6,\"667\":9,\"668\":14,\"669\":3,\"672\":5,\"690\":2,\"699\":8,\"712\":3,\"730\":10}}],[\"ribbon默认采用懒加载\",{\"1\":{\"598\":1}}],[\"ribbon的负载均衡策略是一个叫做irule的接口来定义的\",{\"1\":{\"598\":1}}],[\"ribbon作为服务消费者的负载均衡器\",{\"1\":{\"593\":1}}],[\"ribbon\",{\"0\":{\"598\":1},\"1\":{\"592\":1,\"593\":3,\"598\":10,\"599\":2}}],[\"rpm\",{\"1\":{\"616\":1}}],[\"rm\",{\"1\":{\"615\":1}}],[\"rmi\",{\"1\":{\"613\":1}}],[\"rob1\",{\"1\":{\"698\":3}}],[\"rob\",{\"1\":{\"697\":1,\"698\":1,\"699\":1}}],[\"roles\",{\"1\":{\"605\":1}}],[\"role\",{\"1\":{\"605\":3}}],[\"role`\",{\"1\":{\"605\":1}}],[\"routes\",{\"1\":{\"607\":1}}],[\"route\",{\"1\":{\"606\":1}}],[\"routing\",{\"1\":{\"209\":1}}],[\"roundrobinrule\",{\"1\":{\"598\":2}}],[\"root>\",{\"1\":{\"586\":1}}],[\"root\",{\"1\":{\"499\":1,\"506\":1,\"540\":1,\"562\":1,\"575\":1,\"583\":1,\"584\":1,\"617\":1,\"664\":3,\"666\":3,\"667\":8,\"668\":7,\"669\":4,\"672\":2,\"674\":4,\"675\":3,\"699\":4,\"709\":14,\"712\":3,\"730\":3}}],[\"rose\",{\"1\":{\"404\":1,\"411\":1,\"440\":1}}],[\"r++\",{\"1\":{\"376\":1}}],[\"r+i=1∑r​ωi\",{\"1\":{\"32\":1}}],[\"run创建容器\",{\"1\":{\"613\":1}}],[\"runoob\",{\"1\":{\"491\":1}}],[\"run只是调用线程方法\",{\"1\":{\"468\":1}}],[\"runtimeexception是非检查型异常是可以预测的\",{\"1\":{\"424\":1}}],[\"runtime\",{\"1\":{\"422\":1}}],[\"running\",{\"1\":{\"291\":1}}],[\"runnable使用try\",{\"1\":{\"133\":1}}],[\"runnable接口\",{\"1\":{\"251\":1}}],[\"runnable接口通常用于创建可执行的线程任务\",{\"1\":{\"133\":1}}],[\"runnable接口的run\",{\"1\":{\"133\":1}}],[\"runnable接口没有返回值\",{\"1\":{\"133\":1}}],[\"runnable\",{\"0\":{\"133\":1},\"1\":{\"133\":1,\"225\":1,\"239\":4,\"246\":1,\"247\":1,\"251\":1,\"308\":1,\"466\":4,\"467\":1,\"468\":1,\"469\":1,\"471\":1}}],[\"run\",{\"1\":{\"251\":1,\"291\":1,\"466\":5,\"467\":1,\"468\":3,\"469\":1,\"471\":2,\"614\":1,\"615\":1,\"616\":3}}],[\"runasync\",{\"1\":{\"239\":2,\"268\":4}}],[\"runasync方法\",{\"0\":{\"239\":1}}],[\"rdb方式更适合做数据的备份\",{\"1\":{\"189\":1}}],[\"rdb是内存数据的二进制序列化形式\",{\"1\":{\"189\":1}}],[\"rdb是一次全量备份\",{\"1\":{\"189\":1}}],[\"rdb和aof的区别\",{\"1\":{\"189\":1}}],[\"rdb\",{\"1\":{\"187\":1,\"189\":2,\"200\":1,\"204\":3}}],[\"r>\",{\"1\":{\"129\":1,\"251\":3,\"458\":1,\"459\":2}}],[\"range\",{\"1\":{\"770\":1}}],[\"randomindex\",{\"1\":{\"721\":2}}],[\"randomizedset\",{\"1\":{\"721\":4}}],[\"randomrule\",{\"1\":{\"598\":6}}],[\"randomdisplay\",{\"1\":{\"114\":3}}],[\"random\",{\"1\":{\"114\":3,\"192\":3,\"721\":5}}],[\"rabbitmq在传输消息时通常具有较低的延迟\",{\"1\":{\"213\":1}}],[\"rabbitmq和kafka是两种常用的消息队列系统\",{\"1\":{\"213\":1}}],[\"rabbitmq\",{\"0\":{\"206\":1,\"209\":1,\"212\":1,\"213\":1},\"1\":{\"209\":1,\"210\":1,\"211\":3,\"212\":3,\"213\":5,\"592\":1}}],[\"rawclose\",{\"1\":{\"114\":4}}],[\"rawprint\",{\"1\":{\"114\":4}}],[\"rawopen\",{\"1\":{\"114\":4}}],[\"r\",{\"1\":{\"91\":3,\"114\":2,\"251\":2,\"353\":1,\"376\":4,\"457\":1,\"458\":3,\"459\":7,\"621\":3,\"624\":17,\"690\":7,\"704\":12,\"727\":2,\"728\":2}}],[\"rs和jersey进行restful\",{\"1\":{\"81\":1}}],[\"remoteaddr\",{\"1\":{\"607\":1}}],[\"removelast\",{\"1\":{\"683\":1,\"685\":1,\"686\":2,\"688\":1,\"715\":2,\"718\":1}}],[\"removes\",{\"1\":{\"657\":1,\"658\":1}}],[\"removespace\",{\"1\":{\"645\":4}}],[\"removenthfromend\",{\"1\":{\"638\":1}}],[\"removeelements\",{\"1\":{\"634\":1}}],[\"removeelement\",{\"1\":{\"623\":2}}],[\"removeall\",{\"1\":{\"439\":1}}],[\"remove\",{\"1\":{\"304\":1,\"439\":2,\"440\":3,\"443\":4,\"448\":1,\"631\":1,\"720\":2,\"721\":4}}],[\"refreshscope\",{\"1\":{\"603\":1}}],[\"ref>\",{\"1\":{\"557\":2}}],[\"ref=\",{\"1\":{\"557\":4,\"561\":1,\"575\":1,\"583\":4,\"586\":1}}],[\"refid=\",{\"1\":{\"532\":1}}],[\"reflect\",{\"1\":{\"72\":1,\"159\":1,\"419\":2,\"569\":3}}],[\"reactor\",{\"1\":{\"588\":1}}],[\"reasonable=false\",{\"1\":{\"542\":2}}],[\"real\",{\"1\":{\"492\":1}}],[\"readtimeout\",{\"1\":{\"598\":1}}],[\"readonly\",{\"1\":{\"536\":1}}],[\"readonly=\",{\"1\":{\"536\":1}}],[\"readobject\",{\"1\":{\"478\":1}}],[\"readutf\",{\"1\":{\"478\":1}}],[\"readdouble\",{\"1\":{\"478\":1}}],[\"readdata\",{\"1\":{\"477\":3}}],[\"readchar\",{\"1\":{\"478\":1}}],[\"readboolean\",{\"1\":{\"478\":1}}],[\"readbuff\",{\"1\":{\"477\":6}}],[\"readint\",{\"1\":{\"478\":1}}],[\"readlen\",{\"1\":{\"477\":9,\"478\":3,\"485\":3}}],[\"readline\",{\"1\":{\"55\":2,\"114\":1,\"478\":4,\"730\":2}}],[\"readfile02\",{\"1\":{\"477\":2}}],[\"readfile01\",{\"1\":{\"477\":2}}],[\"ready\",{\"1\":{\"291\":5}}],[\"read\",{\"1\":{\"171\":6,\"178\":5,\"477\":9,\"478\":1,\"485\":1}}],[\"reader\",{\"1\":{\"55\":3,\"476\":1,\"730\":3}}],[\"reversestack\",{\"1\":{\"655\":17}}],[\"reversestr\",{\"1\":{\"643\":1}}],[\"reversestring\",{\"1\":{\"642\":1,\"643\":2,\"645\":5}}],[\"reverseleftwords\",{\"1\":{\"646\":1}}],[\"reverselist\",{\"1\":{\"636\":1}}],[\"reverseeachword\",{\"1\":{\"645\":2}}],[\"reversewords\",{\"1\":{\"645\":5}}],[\"reverse\",{\"1\":{\"452\":1}}],[\"ret\",{\"1\":{\"672\":5}}],[\"retryrule\",{\"1\":{\"598\":1}}],[\"retention\",{\"1\":{\"422\":1}}],[\"returns\",{\"1\":{\"657\":2,\"658\":2}}],[\"returned\",{\"1\":{\"645\":2}}],[\"returnlist\",{\"1\":{\"440\":1}}],[\"return语句不是必须\",{\"1\":{\"389\":1}}],[\"return使用在方法\",{\"1\":{\"379\":1}}],[\"return\",{\"0\":{\"379\":1},\"1\":{\"45\":1,\"63\":2,\"70\":4,\"99\":1,\"102\":5,\"108\":1,\"111\":8,\"117\":2,\"232\":1,\"233\":1,\"247\":1,\"248\":7,\"249\":2,\"251\":4,\"253\":1,\"256\":3,\"260\":1,\"268\":4,\"292\":1,\"307\":4,\"312\":3,\"313\":2,\"389\":1,\"390\":1,\"391\":7,\"403\":6,\"404\":4,\"406\":3,\"414\":3,\"419\":1,\"421\":1,\"428\":2,\"433\":3,\"439\":1,\"440\":4,\"445\":4,\"451\":1,\"454\":1,\"457\":1,\"458\":2,\"472\":1,\"478\":2,\"486\":2,\"525\":2,\"527\":1,\"531\":2,\"555\":2,\"560\":3,\"564\":2,\"569\":1,\"576\":3,\"584\":3,\"597\":2,\"598\":2,\"603\":1,\"606\":1,\"607\":3,\"620\":2,\"621\":4,\"622\":1,\"623\":2,\"624\":5,\"625\":4,\"626\":2,\"627\":3,\"628\":2,\"629\":2,\"630\":2,\"631\":1,\"632\":1,\"634\":2,\"635\":9,\"636\":1,\"637\":2,\"638\":2,\"639\":2,\"640\":2,\"642\":2,\"643\":2,\"644\":1,\"645\":2,\"646\":1,\"647\":1,\"648\":2,\"649\":1,\"650\":2,\"652\":2,\"653\":3,\"655\":6,\"657\":3,\"658\":3,\"659\":5,\"660\":1,\"661\":2,\"662\":3,\"664\":1,\"666\":1,\"667\":2,\"668\":7,\"669\":4,\"671\":1,\"672\":3,\"674\":7,\"675\":2,\"677\":3,\"678\":2,\"682\":1,\"683\":2,\"684\":3,\"685\":2,\"686\":3,\"687\":5,\"688\":5,\"689\":8,\"690\":3,\"693\":2,\"694\":2,\"695\":1,\"696\":2,\"697\":2,\"698\":5,\"699\":2,\"700\":1,\"701\":11,\"702\":4,\"704\":3,\"705\":5,\"706\":3,\"707\":4,\"708\":3,\"709\":13,\"711\":1,\"712\":3,\"713\":4,\"715\":3,\"716\":2,\"717\":4,\"718\":3,\"720\":3,\"721\":5,\"730\":3,\"734\":4,\"737\":1,\"740\":3,\"742\":2}}],[\"recusionmeasure\",{\"1\":{\"391\":3}}],[\"recently\",{\"1\":{\"192\":1}}],[\"reentrylockdemo\",{\"1\":{\"263\":1}}],[\"reentrantlock可能更优\",{\"1\":{\"142\":1}}],[\"reentrantlock提供了更细粒度的控制\",{\"1\":{\"142\":1}}],[\"reentrantlock提供了更多的高级特性\",{\"1\":{\"142\":1}}],[\"reentrantlock支持可重入锁\",{\"1\":{\"141\":1}}],[\"reentrantlock内部通过一个int类型的state来维护当前锁的状态\",{\"1\":{\"141\":1}}],[\"reentrantlock内部使用了一个非公平的aqs\",{\"1\":{\"141\":1}}],[\"reentrantlock实现原理\",{\"1\":{\"141\":1}}],[\"reentrantlock\",{\"0\":{\"141\":1},\"1\":{\"262\":2,\"271\":1}}],[\"required\",{\"1\":{\"583\":1}}],[\"requirenonnull\",{\"1\":{\"251\":3}}],[\"reque\",{\"1\":{\"155\":1}}],[\"requested\",{\"1\":{\"607\":1}}],[\"requestfactory\",{\"1\":{\"598\":1}}],[\"requestdispatcher\",{\"1\":{\"334\":3}}],[\"request\",{\"1\":{\"65\":1,\"333\":1,\"334\":8,\"339\":5,\"598\":4,\"607\":2,\"770\":1,\"776\":1}}],[\"relation`\",{\"1\":{\"605\":1}}],[\"relation\",{\"1\":{\"605\":2}}],[\"reliable\",{\"1\":{\"213\":1}}],[\"release<\",{\"1\":{\"599\":1}}],[\"releases\",{\"1\":{\"599\":1}}],[\"releases>\",{\"1\":{\"498\":2,\"540\":2}}],[\"release流程分析\",{\"0\":{\"317\":1}}],[\"release\",{\"1\":{\"144\":1,\"313\":4,\"551\":1}}],[\"redirect\",{\"1\":{\"775\":1}}],[\"redis集群中会有若干个哨兵节点监控主节点和从节点的状态\",{\"1\":{\"203\":1}}],[\"redis内存不够了怎么办\",{\"0\":{\"200\":1}}],[\"redis中的有序集合支持的核心操作主要支持\",{\"1\":{\"193\":1}}],[\"redis默认是快照rdb的持久化方式\",{\"1\":{\"189\":1}}],[\"redis为了保证效率\",{\"1\":{\"189\":1}}],[\"redisv4\",{\"1\":{\"187\":1}}],[\"redis选择了单线程的\",{\"1\":{\"187\":1}}],[\"redis的set元素过多怎么办\",{\"0\":{\"199\":1}}],[\"redis的持久化策略有两种\",{\"1\":{\"189\":1}}],[\"redis的话\",{\"1\":{\"187\":1}}],[\"redis的aof\",{\"1\":{\"181\":1}}],[\"redis的aof遵守wal原则吗\",{\"0\":{\"181\":1}}],[\"redis将所有写操作追加到aof文件的末尾\",{\"1\":{\"181\":1}}],[\"redis键值数据存储的支持\",{\"1\":{\"81\":1}}],[\"redis\",{\"0\":{\"185\":1,\"186\":1,\"187\":1,\"188\":1,\"189\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":1,\"201\":1,\"202\":1,\"203\":1,\"205\":1},\"1\":{\"81\":1,\"181\":1,\"186\":3,\"187\":3,\"189\":2,\"190\":3,\"191\":2,\"192\":1,\"196\":1,\"197\":2,\"198\":2,\"199\":1,\"200\":5,\"201\":5,\"202\":1,\"203\":5,\"595\":1,\"609\":1}}],[\"redo\",{\"1\":{\"177\":1,\"180\":2}}],[\"repo\",{\"1\":{\"551\":1}}],[\"repositories>\",{\"1\":{\"498\":1,\"540\":1}}],[\"repository>\",{\"1\":{\"498\":1,\"540\":1}}],[\"repository和\",{\"1\":{\"69\":1}}],[\"repository注解类似\",{\"1\":{\"69\":1}}],[\"repository\",{\"0\":{\"69\":1},\"1\":{\"64\":1,\"69\":1,\"498\":2,\"540\":2,\"563\":1,\"564\":1,\"575\":1,\"576\":1,\"577\":1,\"583\":1}}],[\"repos<\",{\"1\":{\"498\":2,\"540\":2}}],[\"replacespace\",{\"1\":{\"644\":1}}],[\"replaceall\",{\"1\":{\"452\":1}}],[\"replace\",{\"1\":{\"429\":1}}],[\"repldiskless\",{\"1\":{\"204\":1}}],[\"repl\",{\"1\":{\"204\":1}}],[\"replica\",{\"1\":{\"204\":1}}],[\"repeatable\",{\"1\":{\"171\":2}}],[\"rejectedexecutionexception\",{\"1\":{\"134\":1}}],[\"register\",{\"1\":{\"117\":3,\"307\":1}}],[\"registerproduct\",{\"1\":{\"102\":3}}],[\"registry\",{\"1\":{\"78\":5}}],[\"res++\",{\"1\":{\"660\":1,\"687\":1,\"706\":1,\"708\":1}}],[\"res中存储需要的左括号数量\",{\"1\":{\"660\":2}}],[\"resmatrix\",{\"1\":{\"632\":7}}],[\"response\",{\"1\":{\"334\":3,\"335\":2,\"339\":3}}],[\"resin\",{\"1\":{\"324\":1}}],[\"resume这些方法都被废弃了\",{\"1\":{\"267\":1}}],[\"resulttype=\",{\"1\":{\"504\":1,\"511\":2,\"512\":4,\"517\":3,\"519\":1,\"522\":1,\"530\":1}}],[\"resulttype\",{\"1\":{\"504\":1}}],[\"resulttype属性指明查询返回的结果集类型\",{\"1\":{\"501\":1}}],[\"resultmap\",{\"1\":{\"522\":1,\"523\":1}}],[\"resultmap=\",{\"1\":{\"501\":2,\"522\":1,\"523\":3,\"525\":2,\"527\":1,\"528\":1,\"529\":1,\"532\":1}}],[\"resultmap>\",{\"1\":{\"501\":1,\"522\":1,\"523\":4,\"524\":1,\"525\":2,\"527\":1}}],[\"result>\",{\"1\":{\"501\":1,\"522\":3,\"523\":13,\"524\":3,\"525\":8,\"527\":4}}],[\"result表示对象的任何一个属性字段\",{\"1\":{\"501\":1}}],[\"result2\",{\"1\":{\"6\":1,\"698\":3}}],[\"result1\",{\"1\":{\"6\":1,\"698\":3}}],[\"result\",{\"1\":{\"5\":1,\"7\":1,\"248\":8,\"307\":2,\"366\":1,\"419\":2,\"677\":2,\"678\":2,\"682\":1,\"683\":3,\"685\":4}}],[\"res\",{\"1\":{\"249\":2,\"424\":1,\"569\":3,\"622\":5,\"624\":11,\"625\":8,\"627\":5,\"629\":7,\"630\":12,\"631\":5,\"647\":4,\"649\":3,\"655\":7,\"660\":2,\"661\":5,\"664\":5,\"666\":3,\"671\":3,\"677\":8,\"678\":5,\"684\":4,\"686\":6,\"687\":2,\"688\":4,\"689\":3,\"690\":8,\"697\":3,\"698\":3,\"701\":3,\"705\":2,\"706\":2,\"707\":4,\"708\":2,\"715\":4,\"740\":5,\"742\":3}}],[\"resynchronization\",{\"1\":{\"204\":2}}],[\"resttemplae结合\",{\"1\":{\"593\":1}}],[\"resttemplate\",{\"1\":{\"73\":1,\"593\":2,\"597\":4,\"606\":1}}],[\"restful\",{\"1\":{\"593\":1}}],[\"rest\",{\"1\":{\"81\":1}}],[\"resources\",{\"1\":{\"502\":1,\"540\":1}}],[\"resource=\",{\"1\":{\"499\":1,\"507\":1,\"509\":2}}],[\"resource\",{\"1\":{\"81\":1,\"564\":4}}],[\"resourcehandlerregistry\",{\"1\":{\"78\":1}}],[\"resource等\",{\"1\":{\"68\":1}}],[\"resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址\",{\"1\":{\"76\":1}}],[\"resolver负责将处理结果生成view视图\",{\"1\":{\"76\":1}}],[\"resolver\",{\"1\":{\"76\":1,\"162\":2}}],[\"reset\",{\"1\":{\"3\":5,\"114\":1}}],[\"r−i​\",{\"1\":{\"32\":1}}],[\"r−i+1\",{\"1\":{\"32\":1}}],[\"rgba\",{\"1\":{\"27\":1}}],[\"l0→ln→l1→ln\",{\"1\":{\"729\":1}}],[\"l0→l1→\",{\"1\":{\"729\":1}}],[\"lc\",{\"1\":{\"659\":4}}],[\"ll\",{\"1\":{\"651\":1}}],[\"l++\",{\"1\":{\"650\":1}}],[\"ls\",{\"1\":{\"615\":1}}],[\"lb\",{\"1\":{\"607\":2}}],[\"lneki92v\",{\"1\":{\"598\":1}}],[\"lt\",{\"1\":{\"557\":2}}],[\"luoguanzhong\",{\"1\":{\"439\":1,\"440\":1}}],[\"ldt\",{\"1\":{\"436\":12}}],[\"ldap\",{\"1\":{\"81\":2}}],[\"l\",{\"1\":{\"395\":1,\"621\":4,\"624\":17,\"650\":7,\"690\":7,\"729\":1}}],[\"l4\",{\"1\":{\"297\":3}}],[\"l查找我们需要排查的线程\",{\"1\":{\"264\":1}}],[\"lfu\",{\"1\":{\"192\":3,\"200\":1}}],[\"lrucache\",{\"1\":{\"720\":17}}],[\"lru缓存\",{\"0\":{\"720\":1}}],[\"lru\",{\"1\":{\"167\":1,\"192\":3,\"200\":1,\"204\":1,\"536\":2,\"720\":2}}],[\"lo++\",{\"1\":{\"627\":2}}],[\"lo\",{\"1\":{\"627\":10}}],[\"load加载压缩包\",{\"1\":{\"613\":1}}],[\"loadbalancer\",{\"1\":{\"598\":9}}],[\"loadbalanced\",{\"1\":{\"597\":1}}],[\"load\",{\"1\":{\"480\":2,\"598\":1}}],[\"loadfactor=0\",{\"1\":{\"445\":1}}],[\"loop\",{\"1\":{\"467\":5,\"632\":2}}],[\"low\",{\"1\":{\"428\":2}}],[\"longestpalindrome\",{\"1\":{\"650\":1}}],[\"longtext\",{\"1\":{\"605\":5}}],[\"longadder\",{\"1\":{\"299\":1}}],[\"long\",{\"1\":{\"256\":2,\"358\":2,\"359\":2,\"416\":4,\"431\":2,\"597\":1,\"606\":1,\"627\":2,\"672\":1,\"740\":1,\"742\":1}}],[\"lombok\",{\"1\":{\"252\":4,\"256\":1,\"297\":2}}],[\"location\",{\"1\":{\"605\":1}}],[\"location=\",{\"1\":{\"562\":1}}],[\"localhost改成服务名称\",{\"1\":{\"617\":1}}],[\"localhost\",{\"1\":{\"483\":2,\"499\":1,\"506\":1,\"507\":1,\"540\":1,\"562\":1,\"575\":1,\"583\":1,\"584\":1,\"599\":2,\"602\":1,\"605\":3,\"607\":1}}],[\"localtime\",{\"1\":{\"436\":4}}],[\"localdatetime2\",{\"1\":{\"436\":2}}],[\"localdatetime\",{\"1\":{\"436\":7,\"603\":1}}],[\"localdate\",{\"1\":{\"436\":4}}],[\"local\",{\"1\":{\"167\":1,\"491\":1,\"616\":1}}],[\"lock锁\",{\"1\":{\"293\":1}}],[\"lock类\",{\"1\":{\"263\":1}}],[\"locksupport类park\",{\"1\":{\"271\":1}}],[\"locksupportdemo\",{\"1\":{\"271\":3}}],[\"locksupport用于创建锁和其他同步类的基本线程阻塞原语\",{\"1\":{\"270\":1}}],[\"locksupport\",{\"0\":{\"269\":1},\"1\":{\"271\":2}}],[\"locks\",{\"1\":{\"262\":2}}],[\"lock\",{\"0\":{\"261\":1},\"1\":{\"178\":1,\"261\":3,\"262\":6,\"271\":9,\"298\":4}}],[\"locking\",{\"1\":{\"139\":3}}],[\"logs\",{\"1\":{\"614\":1}}],[\"loggerfactory\",{\"1\":{\"586\":2}}],[\"loggers>\",{\"1\":{\"586\":1}}],[\"logger\",{\"1\":{\"586\":3,\"606\":2}}],[\"logging\",{\"1\":{\"180\":1,\"181\":1,\"551\":2,\"607\":1}}],[\"log4j2\",{\"1\":{\"586\":6}}],[\"log4jconfiglistener\",{\"1\":{\"586\":1}}],[\"loghandler\",{\"1\":{\"419\":5}}],[\"login\",{\"1\":{\"339\":1}}],[\"logn\",{\"1\":{\"193\":1}}],[\"log\",{\"1\":{\"86\":1,\"177\":7,\"180\":4,\"193\":1,\"214\":1,\"419\":4,\"586\":3}}],[\"logy\",{\"1\":{\"32\":2}}],[\"logo\",{\"1\":{\"27\":2}}],[\"last\",{\"1\":{\"721\":3}}],[\"lasti\",{\"1\":{\"678\":3}}],[\"lastindexof\",{\"1\":{\"429\":1,\"430\":1,\"440\":1}}],[\"largestrectanglearea\",{\"1\":{\"662\":1}}],[\"lazy\",{\"1\":{\"524\":1}}],[\"lazyloadingenabled\",{\"1\":{\"524\":1}}],[\"lambda\",{\"1\":{\"490\":1,\"491\":3}}],[\"lambda表达式不是万能的\",{\"1\":{\"129\":1}}],[\"lambda表达式也可以作为参数传递\",{\"1\":{\"129\":1}}],[\"lambda表达式\",{\"0\":{\"129\":1,\"487\":1}}],[\"label2\",{\"1\":{\"377\":2}}],[\"label1\",{\"1\":{\"377\":1}}],[\"label\",{\"1\":{\"209\":1}}],[\"laver\",{\"1\":{\"208\":1}}],[\"layer\",{\"1\":{\"208\":1,\"616\":1}}],[\"latin\",{\"1\":{\"121\":1}}],[\"lang\",{\"1\":{\"72\":1,\"130\":1,\"159\":1,\"396\":2,\"419\":3,\"501\":2,\"569\":3}}],[\"language\",{\"1\":{\"60\":1,\"771\":2}}],[\"lettercombinations\",{\"1\":{\"684\":1}}],[\"leftdepth\",{\"1\":{\"669\":3}}],[\"left++\",{\"1\":{\"624\":1,\"625\":1,\"626\":1,\"630\":1,\"631\":1,\"647\":1,\"648\":1,\"649\":1}}],[\"left\",{\"1\":{\"523\":2,\"524\":1,\"525\":2,\"527\":1,\"528\":1,\"529\":1,\"532\":1,\"620\":6,\"621\":6,\"624\":4,\"625\":5,\"626\":7,\"627\":4,\"630\":3,\"631\":7,\"647\":3,\"648\":8,\"649\":8,\"659\":5,\"664\":10,\"666\":6,\"667\":9,\"668\":14,\"669\":3,\"672\":5,\"690\":2,\"699\":8,\"712\":3,\"730\":10}}],[\"lenb++\",{\"1\":{\"639\":1}}],[\"lenb\",{\"1\":{\"639\":6}}],[\"lena为其长度\",{\"1\":{\"639\":1}}],[\"lena++\",{\"1\":{\"639\":1}}],[\"lena\",{\"1\":{\"639\":6}}],[\"len\",{\"1\":{\"477\":5,\"650\":8,\"675\":3,\"709\":2}}],[\"lengthoflongestsubstring\",{\"1\":{\"647\":1}}],[\"length之间找到一个比nums\",{\"1\":{\"628\":1}}],[\"length个数据\",{\"1\":{\"477\":1}}],[\"length\",{\"1\":{\"55\":2,\"105\":1,\"114\":1,\"117\":6,\"381\":3,\"382\":7,\"424\":1,\"429\":1,\"430\":1,\"433\":3,\"451\":2,\"475\":3,\"620\":1,\"621\":2,\"622\":3,\"623\":2,\"624\":5,\"625\":4,\"626\":1,\"627\":4,\"628\":5,\"629\":5,\"630\":4,\"631\":1,\"642\":3,\"643\":2,\"645\":4,\"646\":1,\"647\":1,\"648\":4,\"649\":3,\"650\":1,\"652\":5,\"653\":6,\"659\":2,\"660\":1,\"661\":1,\"662\":10,\"671\":1,\"674\":2,\"675\":4,\"677\":7,\"678\":7,\"684\":4,\"685\":3,\"686\":5,\"687\":2,\"688\":2,\"689\":2,\"690\":2,\"693\":3,\"696\":2,\"697\":2,\"698\":3,\"701\":4,\"702\":2,\"704\":2,\"705\":5,\"706\":4,\"707\":4,\"708\":8,\"709\":25,\"715\":4,\"716\":3,\"729\":3,\"734\":2,\"760\":2}}],[\"leaf\",{\"1\":{\"730\":5}}],[\"learnssm\",{\"1\":{\"499\":1,\"501\":1,\"504\":2,\"508\":3,\"509\":1,\"522\":1,\"523\":2,\"524\":4,\"535\":1,\"540\":3}}],[\"learnssm<\",{\"1\":{\"498\":1,\"540\":1}}],[\"learnspring\",{\"1\":{\"63\":1,\"552\":1,\"555\":1,\"557\":15,\"559\":4,\"560\":3,\"561\":2,\"563\":3,\"565\":1,\"571\":2,\"572\":6,\"583\":2,\"584\":1}}],[\"least\",{\"1\":{\"192\":2}}],[\"levelorder\",{\"1\":{\"666\":1,\"669\":1}}],[\"level=\",{\"1\":{\"586\":1}}],[\"level\",{\"1\":{\"167\":1,\"606\":2,\"607\":1}}],[\"leetcode刷题\",{\"0\":{\"618\":1}}],[\"leetcode\",{\"0\":{\"792\":1},\"1\":{\"5\":2}}],[\"lib\",{\"1\":{\"617\":1}}],[\"library\",{\"1\":{\"72\":1}}],[\"like\",{\"1\":{\"517\":3}}],[\"live\",{\"1\":{\"395\":1}}],[\"lisi\",{\"1\":{\"252\":1}}],[\"listnode\",{\"1\":{\"634\":12,\"635\":23,\"636\":11,\"637\":13,\"638\":12,\"639\":9,\"640\":8}}],[\"list集合属性注入使用\",{\"1\":{\"557\":1}}],[\"list集合类的接口是有序的\",{\"1\":{\"440\":1}}],[\"list>\",{\"1\":{\"557\":3}}],[\"list类型注入\",{\"1\":{\"557\":1}}],[\"list=page\",{\"1\":{\"542\":1}}],[\"listen\",{\"1\":{\"605\":1}}],[\"listening表示某个端口在监听\",{\"1\":{\"485\":1}}],[\"listexercise02\",{\"1\":{\"440\":1}}],[\"list2\",{\"1\":{\"460\":1}}],[\"list1\",{\"1\":{\"460\":1}}],[\"list和map等集合的工具类\",{\"1\":{\"452\":1}}],[\"listiterator\",{\"1\":{\"443\":1}}],[\"listiterator<string>\",{\"1\":{\"443\":1}}],[\"list练习\",{\"1\":{\"440\":1}}],[\"list的三种遍历方式\",{\"1\":{\"440\":1}}],[\"list01\",{\"1\":{\"440\":1}}],[\"list接口是collection接口的子接口\",{\"1\":{\"440\":1}}],[\"list接口和常用方法\",{\"0\":{\"440\":1}}],[\"list<linkedlist<integer>>\",{\"1\":{\"718\":2}}],[\"list<list<string>>\",{\"1\":{\"688\":2}}],[\"list<list<integer>>\",{\"1\":{\"627\":3,\"666\":2,\"669\":1,\"683\":2,\"685\":2,\"686\":4,\"715\":2}}],[\"list<integer>\",{\"1\":{\"627\":1,\"649\":2,\"661\":1,\"664\":2,\"666\":1,\"669\":1,\"717\":4,\"721\":1}}],[\"list<object\",{\"1\":{\"578\":1,\"583\":2}}],[\"list<object>\",{\"1\":{\"460\":2}}],[\"list<emp>\",{\"1\":{\"525\":1,\"527\":1,\"531\":1}}],[\"list<map<string\",{\"1\":{\"515\":1}}],[\"list<map>\",{\"0\":{\"515\":1}}],[\"list<user>\",{\"1\":{\"511\":1,\"519\":1}}],[\"list<string>\",{\"1\":{\"256\":2,\"443\":1,\"456\":1,\"684\":2,\"690\":3}}],[\"list<netmall>\",{\"1\":{\"256\":3}}],[\"list<t>\",{\"1\":{\"123\":1}}],[\"list\",{\"1\":{\"188\":1,\"256\":1,\"440\":33,\"443\":12,\"451\":1,\"452\":6,\"460\":4,\"480\":2,\"492\":1,\"515\":1,\"519\":2,\"557\":1,\"627\":3,\"634\":1,\"636\":1,\"637\":1,\"638\":1,\"639\":1,\"640\":1,\"666\":3,\"669\":2,\"718\":3}}],[\"listpage\",{\"1\":{\"111\":3}}],[\"listtray\",{\"1\":{\"111\":3}}],[\"listlink\",{\"1\":{\"111\":3}}],[\"listfactory\",{\"1\":{\"111\":7}}],[\"limit\",{\"1\":{\"184\":2,\"477\":1,\"542\":1}}],[\"li\",{\"1\":{\"111\":1,\"471\":2}}],[\"li>\",{\"1\":{\"111\":1}}],[\"line\",{\"1\":{\"55\":6,\"478\":6}}],[\"linux\",{\"0\":{\"48\":1},\"1\":{\"346\":1}}],[\"linknode\",{\"1\":{\"729\":8}}],[\"linklistinput\",{\"1\":{\"729\":1}}],[\"linklist底层实现了双向链表和双端队列地特点\",{\"1\":{\"443\":1}}],[\"linked\",{\"1\":{\"634\":1,\"636\":1,\"637\":1,\"638\":1,\"639\":1,\"640\":1}}],[\"linkedhashmap<integer\",{\"1\":{\"720\":1}}],[\"linkedhashmap\",{\"1\":{\"451\":1,\"720\":2}}],[\"linkedhashset是hashset的子类\",{\"1\":{\"446\":1}}],[\"linkedhashset\",{\"0\":{\"446\":1},\"1\":{\"451\":1}}],[\"linkedlist<string>\",{\"1\":{\"688\":1}}],[\"linkedlist<integer>\",{\"1\":{\"661\":1,\"683\":1,\"685\":1,\"686\":2,\"715\":1,\"718\":2}}],[\"linkedlist<>\",{\"1\":{\"91\":1,\"443\":1,\"657\":2,\"658\":1,\"661\":1,\"666\":1,\"669\":1,\"683\":1,\"685\":1,\"717\":1,\"718\":2}}],[\"linkedlist遍历\",{\"1\":{\"443\":1}}],[\"linkedlist\",{\"1\":{\"443\":6,\"451\":1,\"492\":1,\"686\":2,\"688\":1,\"712\":1,\"713\":1,\"715\":1,\"717\":1}}],[\"linkedlist01\",{\"1\":{\"443\":1}}],[\"linkedlist增删改查\",{\"1\":{\"443\":1}}],[\"linkedlist的添加和删除\",{\"1\":{\"443\":2}}],[\"linkedlist底层操作机制\",{\"1\":{\"443\":1}}],[\"linkedlist底层结构\",{\"0\":{\"443\":1}}],[\"link标签\",{\"1\":{\"332\":1}}],[\"linkpage\",{\"1\":{\"111\":1}}],[\"link\",{\"1\":{\"27\":1,\"111\":16}}],[\"lightweight\",{\"1\":{\"139\":1}}],[\"light\",{\"1\":{\"27\":1}}],[\"此策略的配置设置如下\",{\"1\":{\"598\":7}}],[\"此后若再次执行相同的查询语句\",{\"1\":{\"535\":1}}],[\"此后就可以使用\",{\"1\":{\"507\":1}}],[\"此处使用该值与字段的其他用途无关\",{\"1\":{\"312\":1}}],[\"此节点的前置节点\",{\"1\":{\"312\":1}}],[\"此节点目前位于条件队列上\",{\"1\":{\"312\":1}}],[\"此节点被取消\",{\"1\":{\"312\":1}}],[\"此时等效于对\",{\"1\":{\"698\":3}}],[\"此时的乘积最大\",{\"1\":{\"739\":1}}],[\"此时的队列中已经包含下一层的节点\",{\"1\":{\"666\":1,\"669\":1}}],[\"此时的hash碰撞概率已经很小接近0\",{\"1\":{\"124\":1}}],[\"此时可以确定出栈柱形对应的最大矩形\",{\"1\":{\"662\":1}}],[\"此时可能读取到的数据是不正确或无效的\",{\"1\":{\"171\":1}}],[\"此时再去弹出元素就是栈的顺序了\",{\"1\":{\"658\":1}}],[\"此时就要从头匹配了\",{\"1\":{\"653\":1}}],[\"此时记录回文长度和起始位置\",{\"1\":{\"650\":1}}],[\"此时我们就可以比较cura和curb是否相同\",{\"1\":{\"639\":1}}],[\"此时arr1和arr2指向的是同一片地址\",{\"1\":{\"381\":1}}],[\"此时有线程c在阻塞队列等待\",{\"1\":{\"318\":1}}],[\"此时有两个线程\",{\"1\":{\"318\":1}}],[\"此时线程b也释放锁\",{\"1\":{\"318\":1}}],[\"此时线程中断标志位被置为1\",{\"1\":{\"267\":1}}],[\"此时doreleaseshared先将head的ws置为0\",{\"1\":{\"318\":2}}],[\"此时状态将设置为0\",{\"1\":{\"312\":1}}],[\"此时需要让主从数据同步到一致的状态\",{\"1\":{\"203\":1}}],[\"此时来了两个请求\",{\"1\":{\"195\":1}}],[\"此时\",{\"1\":{\"139\":2,\"160\":1,\"163\":1,\"630\":1}}],[\"此外\",{\"1\":{\"82\":1,\"214\":1,\"706\":1}}],[\"此页面应当包含\",{\"1\":{\"42\":1}}],[\"此文字有脚注\",{\"1\":{\"23\":1}}],[\"此博客用来记录看过的书\",{\"1\":{\"0\":1}}],[\"脚注\",{\"0\":{\"23\":1}}],[\"我们应该先读取二维数组的长度和宽度存在两个整数中\",{\"1\":{\"728\":1}}],[\"我们应当返回什么值呢\",{\"1\":{\"651\":1}}],[\"我们就不需要\",{\"1\":{\"715\":1}}],[\"我们就不用等待结果\",{\"1\":{\"235\":1}}],[\"我们把首尾被抢的情况分为3种\",{\"1\":{\"698\":1}}],[\"我们保证它是唯一的答案\",{\"1\":{\"648\":1}}],[\"我们寻找的子字符串中该字符数量必须不少于\",{\"1\":{\"648\":1}}],[\"我们求出两个链表的长度\",{\"1\":{\"639\":1}}],[\"我们先不断增加right指针扩大窗口\",{\"1\":{\"630\":1}}],[\"我们需要\",{\"1\":{\"628\":1}}],[\"我们需要根据日期来生成订单号流水\",{\"1\":{\"216\":1}}],[\"我们还希望下一个数\",{\"1\":{\"628\":1}}],[\"我们希望下一个数\",{\"1\":{\"628\":1}}],[\"我们希望对这些接口进行修改\",{\"1\":{\"95\":1}}],[\"我们会进行短路操作以查找一个未取消的前置节点\",{\"1\":{\"312\":1}}],[\"我们后边分析\",{\"1\":{\"306\":1}}],[\"我们在配置文件中写的断言规则只是字符串\",{\"1\":{\"607\":1}}],[\"我们在子线程中通过threadlocal存储了一个10\",{\"1\":{\"304\":1}}],[\"我们在创建对象时不会对客户端暴露创建逻辑\",{\"1\":{\"101\":1}}],[\"我们有以下两种查询条件\",{\"1\":{\"176\":1}}],[\"我们通过下面的实例来演示桥接模式\",{\"1\":{\"113\":1}}],[\"我们明确地计划不同条件下创建不同实例时\",{\"1\":{\"101\":1}}],[\"我们让print实现了满足我们要求的方法\",{\"1\":{\"96\":1}}],[\"我们只要调整适配器里的接口转换代码即可\",{\"1\":{\"95\":1}}],[\"我们可以去修改打印流输出的位置\",{\"1\":{\"479\":1}}],[\"我们可以从尾部向前扫描prev节点进行双重检查\",{\"1\":{\"312\":1}}],[\"我们可以利用这个特性实现分布式锁\",{\"1\":{\"217\":1}}],[\"我们可以缓存该对象\",{\"1\":{\"116\":1}}],[\"我们可以查看更新情况\",{\"1\":{\"86\":1}}],[\"我们可以使用\",{\"1\":{\"70\":1}}],[\"我使用的是vmware\",{\"1\":{\"49\":1}}],[\"我在右对齐\",{\"1\":{\"21\":1}}],[\"我是居中的\",{\"1\":{\"21\":1}}],[\"hz\",{\"1\":{\"599\":1}}],[\"hystrix\",{\"1\":{\"592\":2,\"593\":2,\"595\":1}}],[\"hsp\",{\"1\":{\"478\":2,\"483\":1}}],[\"hh\",{\"1\":{\"436\":2,\"586\":1,\"607\":1}}],[\"h=head\",{\"1\":{\"318\":1}}],[\"h\",{\"1\":{\"318\":5,\"395\":1,\"477\":2}}],[\"hpp文件中\",{\"1\":{\"260\":1}}],[\"home\",{\"1\":{\"616\":1}}],[\"home=$\",{\"1\":{\"616\":1}}],[\"hongloumeng\",{\"1\":{\"439\":1}}],[\"hour\",{\"1\":{\"436\":2}}],[\"houserentapp\",{\"1\":{\"409\":1}}],[\"house\",{\"1\":{\"409\":1}}],[\"houseservice\",{\"1\":{\"409\":1}}],[\"houseview\",{\"1\":{\"409\":1}}],[\"hobby\",{\"1\":{\"399\":1}}],[\"hostname\",{\"1\":{\"598\":1}}],[\"host3address\",{\"1\":{\"483\":2}}],[\"host3name\",{\"1\":{\"483\":2}}],[\"host3\",{\"1\":{\"483\":4}}],[\"host2\",{\"1\":{\"483\":2}}],[\"host不能有同名的exchange或queue\",{\"1\":{\"209\":1}}],[\"host可以有若干个exchange和queue\",{\"1\":{\"209\":1}}],[\"host\",{\"1\":{\"209\":1,\"607\":1,\"760\":1,\"762\":1,\"779\":1}}],[\"hope\",{\"1\":{\"27\":4,\"35\":1,\"40\":1}}],[\"his\",{\"1\":{\"605\":1}}],[\"history\",{\"1\":{\"605\":2}}],[\"high\",{\"1\":{\"428\":1}}],[\"high属性值\",{\"1\":{\"130\":1}}],[\"hi\",{\"1\":{\"413\":6,\"466\":1,\"469\":1,\"627\":12}}],[\"hibernate\",{\"1\":{\"101\":1,\"104\":1,\"168\":1,\"496\":2,\"540\":1}}],[\"h1>\",{\"1\":{\"111\":1,\"335\":1}}],[\"here\",{\"1\":{\"657\":1,\"658\":1}}],[\"heights\",{\"1\":{\"662\":8}}],[\"height\",{\"1\":{\"624\":26,\"625\":14}}],[\"help可以查看命令的帮助\",{\"1\":{\"613\":1}}],[\"hel\",{\"1\":{\"429\":5}}],[\"helloworld<\",{\"1\":{\"498\":1,\"540\":1}}],[\"hello7\",{\"1\":{\"444\":1}}],[\"hello6\",{\"1\":{\"444\":1}}],[\"hello9\",{\"1\":{\"444\":1}}],[\"hello8\",{\"1\":{\"444\":1}}],[\"hello3\",{\"1\":{\"444\":1,\"478\":1}}],[\"hello2\",{\"1\":{\"444\":1,\"478\":1}}],[\"hello5\",{\"1\":{\"444\":1}}],[\"hello4\",{\"1\":{\"444\":1}}],[\"hello1\",{\"1\":{\"444\":1}}],[\"hello0\",{\"1\":{\"444\":1}}],[\"helloabc\",{\"1\":{\"429\":1}}],[\"hello<\",{\"1\":{\"327\":1}}],[\"helloservlet<\",{\"1\":{\"327\":1}}],[\"hello\",{\"1\":{\"96\":1,\"248\":4,\"253\":1,\"268\":3,\"335\":1,\"351\":3,\"352\":2,\"396\":1,\"418\":6,\"429\":3,\"430\":1,\"443\":1,\"444\":1,\"454\":2,\"459\":1,\"466\":3,\"468\":2,\"477\":6,\"478\":2,\"479\":1,\"485\":1,\"490\":1,\"491\":1,\"586\":2,\"645\":2,\"651\":1}}],[\"head方法和get方法的区别在于不返回报文的主体部分\",{\"1\":{\"763\":1}}],[\"headb\",{\"1\":{\"639\":4}}],[\"heada\",{\"1\":{\"639\":4}}],[\"header\",{\"1\":{\"607\":1}}],[\"head\",{\"1\":{\"318\":1,\"634\":8,\"635\":13,\"636\":2,\"637\":4,\"638\":2,\"640\":4,\"648\":4,\"729\":11,\"730\":2,\"763\":1}}],[\"head>\",{\"1\":{\"111\":1}}],[\"heavyweight\",{\"1\":{\"139\":1}}],[\"href=\",{\"1\":{\"111\":1}}],[\"htm\",{\"1\":{\"760\":2,\"762\":2}}],[\"html<\",{\"1\":{\"343\":1}}],[\"html>\",{\"1\":{\"111\":1,\"335\":1}}],[\"html\",{\"1\":{\"111\":1,\"323\":1,\"335\":1,\"551\":1,\"614\":4,\"615\":4,\"746\":1,\"760\":1}}],[\"htmlable\",{\"1\":{\"111\":3}}],[\"htmlbuilder\",{\"1\":{\"108\":1}}],[\"http的内容编码是用在实体上的编码格式\",{\"1\":{\"768\":1}}],[\"http的诞生\",{\"0\":{\"745\":1}}],[\"http在传输时可以按照原数据直接传输\",{\"1\":{\"768\":1}}],[\"http报文结构如下\",{\"1\":{\"767\":1}}],[\"http报文\",{\"0\":{\"767\":1}}],[\"http报文内的http信息\",{\"0\":{\"766\":1}}],[\"http方法\",{\"0\":{\"763\":1}}],[\"http不保存之前状态\",{\"0\":{\"761\":1}}],[\"http用于客户端和服务器端之间的通信\",{\"0\":{\"759\":1}}],[\"http通信的流程\",{\"0\":{\"755\":1}}],[\"http属于它的子集\",{\"1\":{\"747\":1}}],[\"http笔记\",{\"0\":{\"743\":1}}],[\"httpclient<\",{\"1\":{\"606\":1}}],[\"httpclient\",{\"1\":{\"606\":2}}],[\"http客户端feign\",{\"0\":{\"606\":1}}],[\"httprequest\",{\"1\":{\"598\":1}}],[\"http占用80\",{\"1\":{\"482\":1}}],[\"http协议自身不对请求和响应做持久化处理\",{\"1\":{\"761\":1}}],[\"http协议\",{\"1\":{\"482\":1,\"595\":1}}],[\"http状态码\",{\"0\":{\"155\":1},\"1\":{\"155\":1}}],[\"http默认使用80端口进行通信\",{\"1\":{\"154\":1}}],[\"http是明文传输协议\",{\"1\":{\"154\":1}}],[\"http和https的差别\",{\"0\":{\"154\":1}}],[\"http\",{\"0\":{\"778\":1,\"782\":1,\"783\":1,\"784\":1},\"1\":{\"63\":4,\"65\":1,\"161\":1,\"327\":4,\"498\":4,\"499\":1,\"501\":1,\"504\":1,\"540\":5,\"552\":4,\"555\":4,\"557\":15,\"560\":14,\"561\":7,\"562\":17,\"563\":20,\"583\":13,\"593\":1,\"597\":2,\"598\":1,\"605\":2,\"606\":4,\"746\":1,\"749\":1,\"760\":3,\"762\":4,\"769\":1,\"776\":1,\"779\":3,\"780\":3,\"783\":1,\"784\":2,\"785\":1}}],[\"httpstatus\",{\"1\":{\"607\":1}}],[\"httpsession\",{\"1\":{\"339\":1}}],[\"httpservletresponse表示响应信息\",{\"1\":{\"335\":1}}],[\"httpservletresponse类\",{\"0\":{\"335\":1}}],[\"httpservletresponse\",{\"1\":{\"334\":2}}],[\"httpservletrequest表示请求信息\",{\"1\":{\"335\":1}}],[\"httpservletrequest\",{\"1\":{\"334\":2,\"339\":4}}],[\"httpservletrequest类\",{\"0\":{\"333\":1}}],[\"httpservlet\",{\"1\":{\"334\":2}}],[\"https怎么建立连接的\",{\"0\":{\"155\":1},\"1\":{\"155\":1}}],[\"https\",{\"0\":{\"787\":1},\"1\":{\"5\":1,\"27\":2,\"111\":8,\"551\":2,\"598\":1,\"599\":1,\"730\":1}}],[\"hackr\",{\"1\":{\"760\":1,\"762\":2}}],[\"hacker\",{\"1\":{\"486\":1}}],[\"haystackarr\",{\"1\":{\"652\":5}}],[\"haystack\",{\"1\":{\"651\":4,\"652\":2,\"653\":4}}],[\"harry\",{\"1\":{\"486\":10}}],[\"happens\",{\"1\":{\"273\":1}}],[\"handle\",{\"1\":{\"244\":1}}],[\"handle方法\",{\"0\":{\"244\":1}}],[\"handlermapping\",{\"1\":{\"161\":3}}],[\"handlermapping负责根据用户请求找到handler即处理器\",{\"1\":{\"76\":1}}],[\"handler\",{\"1\":{\"76\":1,\"135\":1,\"162\":1,\"607\":1}}],[\"handleradapter\",{\"1\":{\"161\":3}}],[\"handleradapter要求的规则\",{\"1\":{\"76\":1}}],[\"handleradapter将controller执行结果modelandview返回给dispatcherservlet\",{\"1\":{\"76\":1}}],[\"handleradapter经过适配调用具体的处理器\",{\"1\":{\"76\":1}}],[\"having\",{\"1\":{\"184\":3}}],[\"hasword\",{\"1\":{\"674\":3}}],[\"haspreviouspage=false\",{\"1\":{\"542\":1}}],[\"has\",{\"1\":{\"260\":1}}],[\"hasnextpage=true\",{\"1\":{\"542\":1}}],[\"hasnext\",{\"1\":{\"111\":2,\"439\":2,\"443\":1,\"444\":1,\"448\":1,\"724\":1,\"727\":1,\"728\":1}}],[\"hash后再确定索引结果\",{\"1\":{\"445\":1}}],[\"hashset做不到随机在o\",{\"1\":{\"721\":1}}],[\"hashsetexercise02\",{\"1\":{\"445\":1}}],[\"hashset底层是hashmap\",{\"1\":{\"445\":1}}],[\"hashset底层机制说明\",{\"1\":{\"445\":1}}],[\"hashset实际上是hashmap\",{\"1\":{\"445\":1}}],[\"hashset\",{\"0\":{\"445\":1},\"1\":{\"444\":1,\"445\":2,\"451\":1,\"713\":2}}],[\"hashset<>\",{\"1\":{\"91\":1,\"659\":1}}],[\"hashcode\",{\"1\":{\"406\":1,\"421\":1,\"445\":1,\"492\":1}}],[\"hashcode方法\",{\"1\":{\"406\":1}}],[\"hash\",{\"1\":{\"188\":1,\"445\":1}}],[\"hashtable是线程安全的\",{\"1\":{\"449\":1}}],[\"hashtable是dictionary的子类\",{\"1\":{\"124\":1}}],[\"hashtable\",{\"0\":{\"449\":1},\"1\":{\"124\":2}}],[\"hashtable线程安全\",{\"1\":{\"124\":1}}],[\"hashmap<long\",{\"1\":{\"672\":1}}],[\"hashmap<character\",{\"1\":{\"649\":2}}],[\"hashmap<integer\",{\"1\":{\"631\":1,\"671\":1,\"689\":1,\"701\":1,\"721\":1}}],[\"hashmap<>\",{\"1\":{\"102\":1,\"445\":1,\"512\":1,\"649\":2,\"689\":1,\"699\":2,\"701\":1}}],[\"hashmap线程不安全\",{\"1\":{\"449\":1}}],[\"hashmap为什么在链表长度大于8\",{\"1\":{\"124\":1}}],[\"hashmap可以指定初始容量和负载因子\",{\"1\":{\"124\":1}}],[\"hashmap实现了map接口\",{\"1\":{\"124\":1}}],[\"hashmap允许键和值为null\",{\"1\":{\"124\":1}}],[\"hashmap底层是数组+链表+红黑树\",{\"1\":{\"445\":1}}],[\"hashmap底层原理\",{\"1\":{\"124\":1}}],[\"hashmap底层\",{\"0\":{\"124\":1}}],[\"hashmap与hashtable的区别\",{\"0\":{\"124\":1},\"1\":{\"124\":1}}],[\"hashmap的遍历方式有哪几种\",{\"0\":{\"124\":1},\"1\":{\"124\":1}}],[\"hashmap\",{\"1\":{\"102\":1,\"117\":3,\"124\":3,\"186\":2,\"448\":1,\"451\":1,\"626\":1,\"648\":2}}],[\"hateoas\",{\"1\":{\"81\":1}}],[\"h2o\",{\"1\":{\"20\":1}}],[\"上传web表单时使用\",{\"1\":{\"769\":1}}],[\"上预订了\",{\"1\":{\"678\":1}}],[\"上到下\",{\"1\":{\"632\":1}}],[\"上\",{\"1\":{\"631\":1,\"708\":1}}],[\"上海天津\",{\"1\":{\"477\":1}}],[\"上段代码输出为0到5\",{\"1\":{\"391\":1}}],[\"上面表示查询http服务器端支持的http方法种类\",{\"1\":{\"762\":1}}],[\"上面是由数组\",{\"1\":{\"624\":1}}],[\"上面是一个经典的例子\",{\"1\":{\"292\":1}}],[\"上面两个输出都是a\",{\"1\":{\"358\":1}}],[\"上面两个方法如果不指定线程池\",{\"1\":{\"239\":1}}],[\"上面这个例子子线程就感知不到ready的变化\",{\"1\":{\"291\":1}}],[\"上面的代码中objectmonitor这个对象和线程争抢锁的逻辑有密切的关系\",{\"1\":{\"260\":1}}],[\"上面的提交流程中为什么不先创建临时线程而是先放进阻塞队列\",{\"1\":{\"135\":1}}],[\"上述代码就像数组的赋值\",{\"1\":{\"388\":1}}],[\"上述代码首先获取到了当前线程\",{\"1\":{\"306\":1}}],[\"上述都不是\",{\"1\":{\"312\":1}}],[\"上述情况就会导致不一致的情形出现\",{\"1\":{\"195\":1}}],[\"上述命令其实相当于git\",{\"1\":{\"86\":1}}],[\"上一节的工厂抽象类实际上用的就是模板模式\",{\"1\":{\"105\":1}}],[\"上一篇\",{\"1\":{\"10\":1}}],[\"上下角标\",{\"0\":{\"20\":1}}],[\"查出来的数据\",{\"1\":{\"537\":1}}],[\"查找当前树的根节点\",{\"1\":{\"709\":2}}],[\"查找键是否存在\",{\"1\":{\"448\":1}}],[\"查找多个元素是否都存在\",{\"1\":{\"439\":1}}],[\"查找元素是否存在\",{\"1\":{\"439\":1}}],[\"查找房屋\",{\"1\":{\"408\":2}}],[\"查找房源\",{\"1\":{\"408\":2}}],[\"查找\",{\"1\":{\"381\":1,\"452\":1,\"628\":1}}],[\"查找一个数据\",{\"1\":{\"193\":1}}],[\"查找等操作\",{\"1\":{\"188\":1}}],[\"查找处理器\",{\"1\":{\"161\":1}}],[\"查找的效率会比链表高\",{\"1\":{\"124\":1}}],[\"查看容器状态\",{\"1\":{\"614\":1}}],[\"查看容器日志\",{\"1\":{\"614\":1}}],[\"查看本地的镜像\",{\"1\":{\"613\":1}}],[\"查看任意对象的内容\",{\"1\":{\"486\":1}}],[\"查看线程状态\",{\"1\":{\"469\":1}}],[\"查看继承关系\",{\"1\":{\"395\":1}}],[\"查看两数组地址\",{\"1\":{\"381\":1}}],[\"查看transservlet1的章\",{\"1\":{\"334\":1}}],[\"查看源码可以看到\",{\"1\":{\"247\":1}}],[\"查看完整的错误堆栈跟踪和错误信息\",{\"1\":{\"146\":1}}],[\"查看详情\",{\"1\":{\"18\":1,\"19\":1,\"20\":1,\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1}}],[\"查询字符串\",{\"1\":{\"757\":1}}],[\"查询用户\",{\"1\":{\"597\":1}}],[\"查询订单\",{\"1\":{\"597\":1}}],[\"查询订单并且查询其中用户对应的信息\",{\"1\":{\"596\":1}}],[\"查询的数据所转换的实体类型必须实现序列化的接口\",{\"1\":{\"535\":1}}],[\"查询的数据会被缓存\",{\"1\":{\"534\":1}}],[\"查询的结果会被缓存\",{\"1\":{\"535\":1}}],[\"查询同一条数据\",{\"1\":{\"534\":1}}],[\"查询员工信息合集\",{\"1\":{\"525\":1}}],[\"查询结果\",{\"1\":{\"523\":1}}],[\"查询结果格式如下所示\",{\"1\":{\"5\":1}}],[\"查询返回多条数据\",{\"0\":{\"514\":1,\"515\":1}}],[\"查询和修改等操作\",{\"1\":{\"452\":1}}],[\"查询操作\",{\"1\":{\"195\":1}}],[\"查询慢查询日志\",{\"1\":{\"182\":1}}],[\"查询日志\",{\"1\":{\"177\":1}}],[\"查询条件为\",{\"1\":{\"176\":2}}],[\"查询性能会进一步降低\",{\"1\":{\"172\":1}}],[\"查询\",{\"0\":{\"513\":1},\"1\":{\"5\":1,\"419\":2}}],[\"详情容器\",{\"1\":{\"18\":1}}],[\"危险容器\",{\"1\":{\"18\":1}}],[\"警告容器\",{\"1\":{\"18\":1}}],[\"提升传输速率\",{\"0\":{\"768\":1}}],[\"提取list集合类型\",{\"1\":{\"557\":1}}],[\"提取公共代码\",{\"1\":{\"104\":1}}],[\"提交流程\",{\"1\":{\"135\":1}}],[\"提交任务流程\",{\"0\":{\"135\":1}}],[\"提交\",{\"1\":{\"132\":1}}],[\"提高程序的可重用性\",{\"1\":{\"567\":1}}],[\"提高效率\",{\"1\":{\"454\":1}}],[\"提高哈希结构容器的效率\",{\"1\":{\"406\":1}}],[\"提高网络传输和磁盘io的效率\",{\"1\":{\"214\":1}}],[\"提高灵活性\",{\"1\":{\"207\":1}}],[\"提高整体的内存处理能力\",{\"1\":{\"200\":1}}],[\"提高整体的处理能力\",{\"1\":{\"151\":1}}],[\"提高了安全性\",{\"1\":{\"454\":1}}],[\"提高了存储和检索的效率\",{\"1\":{\"214\":1}}],[\"提高了查询效率\",{\"1\":{\"172\":1}}],[\"提高了并发性能\",{\"1\":{\"125\":1}}],[\"提高代码的可维护性和可测试性\",{\"1\":{\"158\":1}}],[\"提高代码的可读性和安全性\",{\"1\":{\"127\":1}}],[\"提高代码的可读性和维护性\",{\"1\":{\"123\":1}}],[\"提高内存利用率\",{\"1\":{\"148\":1}}],[\"提示资源分配\",{\"0\":{\"150\":1}}],[\"提示\",{\"1\":{\"41\":1,\"630\":1}}],[\"提示容器\",{\"1\":{\"18\":1}}],[\"提供域名到ip地址之间的解析服务\",{\"1\":{\"754\":1}}],[\"提供者与消费者\",{\"1\":{\"596\":1}}],[\"提供服务注册和发现功能\",{\"1\":{\"593\":1}}],[\"提供对集合元素进行排序\",{\"1\":{\"452\":1}}],[\"提供\",{\"1\":{\"436\":1,\"555\":1}}],[\"提供一个管理配置的配置管理服务\",{\"1\":{\"602\":1}}],[\"提供一个public的static方法\",{\"1\":{\"414\":1}}],[\"提供一个公共的get方法\",{\"1\":{\"398\":1}}],[\"提供一个公共的set方法\",{\"1\":{\"398\":1}}],[\"提供一个公共方法来获取实例\",{\"1\":{\"99\":1}}],[\"提供操作特定内存数据的方法\",{\"1\":{\"296\":1}}],[\"提供可靠性消息传递\",{\"1\":{\"213\":1}}],[\"提供可靠性同步机制和错误处理\",{\"1\":{\"208\":1}}],[\"提供帧的处理\",{\"1\":{\"208\":1}}],[\"提供的\",{\"1\":{\"430\":1}}],[\"提供的标准数据库连接接口\",{\"1\":{\"168\":1}}],[\"提供的线程池框架可以方便地管理和复用线程资源\",{\"1\":{\"132\":1}}],[\"提供会话级别的安全性\",{\"1\":{\"155\":1}}],[\"提供更多更强大的功能\",{\"1\":{\"555\":1}}],[\"提供更高的安全性\",{\"1\":{\"154\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"17\":1}}],[\"提供新的\",{\"1\":{\"95\":1}}],[\"提供若干个接口\",{\"1\":{\"95\":1}}],[\"提供了熔断器的功能\",{\"1\":{\"593\":1}}],[\"提供了一系列增删改查的方法\",{\"1\":{\"438\":1}}],[\"提供了一套可用于实现锁同步机制的框架\",{\"1\":{\"311\":1}}],[\"提供了一种读和写都是原子性的对象引用变量\",{\"1\":{\"297\":1}}],[\"提供了一些开箱即用的api来实现超媒体驱动的web服务\",{\"1\":{\"81\":1}}],[\"提供了多种内存淘汰策略\",{\"1\":{\"200\":1}}],[\"提供了多种缓存策略\",{\"1\":{\"167\":1}}],[\"提供了实时复制和故障恢复功能\",{\"1\":{\"183\":1}}],[\"提供了spring\",{\"1\":{\"81\":1}}],[\"提供了对spring\",{\"1\":{\"81\":1}}],[\"提供了用于事务管理的通用抽象层\",{\"1\":{\"61\":1}}],[\"提供3种智能指针\",{\"1\":{\"2\":1}}],[\"主键id\",{\"1\":{\"605\":2}}],[\"主线程运行完毕\",{\"1\":{\"468\":1}}],[\"主线程运行中\",{\"1\":{\"468\":1}}],[\"主菜单\",{\"1\":{\"408\":1}}],[\"主动触发垃圾回收机制\",{\"1\":{\"406\":1}}],[\"主方法\",{\"1\":{\"351\":1}}],[\"主从复制的断点续传\",{\"1\":{\"204\":1}}],[\"主从复制的原理\",{\"0\":{\"204\":1}}],[\"主从架构的核心原理\",{\"1\":{\"204\":1}}],[\"主从模式\",{\"1\":{\"203\":1}}],[\"主题包含了一个自定义徽章可以使用\",{\"1\":{\"41\":1}}],[\"主题扩展了更多\",{\"1\":{\"17\":1}}],[\"主题扩展\",{\"0\":{\"17\":1}}],[\"主要需要确定dp数组的含义\",{\"1\":{\"697\":1}}],[\"主要包括\",{\"1\":{\"607\":1}}],[\"主要包含两个方法\",{\"1\":{\"144\":2}}],[\"主要功能是在分布式系统中提供服务链路追踪的解决方案\",{\"1\":{\"593\":1}}],[\"主要功能与配置演示\",{\"0\":{\"8\":1}}],[\"主要方法是append和insert\",{\"1\":{\"431\":1}}],[\"主要的变量就是属性\",{\"1\":{\"391\":1}}],[\"主要传输二进制数据流\",{\"1\":{\"208\":1}}],[\"主要负责客户端命令发送给服务器\",{\"1\":{\"208\":1}}],[\"主要定义了一些客户端调用的命令\",{\"1\":{\"208\":1}}],[\"主要有两种可能\",{\"1\":{\"198\":1}}],[\"主要解决在软件系统中\",{\"1\":{\"107\":1}}],[\"主要解决接口选择的问题\",{\"1\":{\"101\":1}}],[\"主要解决\",{\"1\":{\"98\":1,\"101\":1,\"104\":1,\"107\":1,\"113\":1,\"116\":1}}],[\"主要用于标识服务层组件\",{\"1\":{\"69\":1}}],[\"主要用于标识数据访问组件\",{\"1\":{\"69\":1}}],[\"主要用于标识spring\",{\"1\":{\"69\":1}}],[\"主要从\",{\"1\":{\"12\":1}}],[\"中转时使用arp协议\",{\"1\":{\"752\":1}}],[\"中元素的和为\",{\"1\":{\"687\":1}}],[\"中存在几个子集\",{\"1\":{\"687\":1}}],[\"中存在这样的子串\",{\"1\":{\"648\":1}}],[\"中序遍历\",{\"1\":{\"664\":1}}],[\"中就已经被删除\",{\"1\":{\"661\":1}}],[\"中查找是否出现过一个模式串\",{\"1\":{\"653\":1}}],[\"中该有效字符数量不大于map中该字符数量\",{\"1\":{\"649\":1}}],[\"中该字符数量\",{\"1\":{\"648\":1}}],[\"中包含了目标子串\",{\"1\":{\"649\":1}}],[\"中所有数的和都小于target的情况\",{\"1\":{\"687\":1}}],[\"中所有可能的\",{\"1\":{\"683\":1}}],[\"中所有\",{\"1\":{\"649\":1}}],[\"中重复字符\",{\"1\":{\"648\":1}}],[\"中不存在涵盖\",{\"1\":{\"648\":1}}],[\"中不能加特殊符号\",{\"1\":{\"557\":1}}],[\"中涵盖\",{\"1\":{\"648\":1}}],[\"中间人\",{\"1\":{\"780\":1}}],[\"中间是首部字段\",{\"1\":{\"760\":1}}],[\"中间的是请求首部字段\",{\"1\":{\"760\":1}}],[\"中间会有一个单独的数\",{\"1\":{\"632\":1}}],[\"中间层\",{\"1\":{\"208\":1}}],[\"中注入\",{\"1\":{\"583\":1}}],[\"中定义\",{\"1\":{\"564\":1}}],[\"中可以加\",{\"1\":{\"557\":1}}],[\"中可以使用\",{\"1\":{\"116\":1}}],[\"中加入\",{\"1\":{\"523\":1}}],[\"中文名\",{\"1\":{\"482\":1}}],[\"中级\",{\"0\":{\"394\":1}}],[\"中断需要程序员自己实现\",{\"1\":{\"267\":1}}],[\"中断\",{\"1\":{\"267\":1}}],[\"中断机制\",{\"0\":{\"265\":1}}],[\"中排队等待\",{\"1\":{\"207\":1}}],[\"中任意选择数据淘汰\",{\"1\":{\"192\":1}}],[\"中获取\",{\"1\":{\"165\":1,\"327\":1}}],[\"中直接弃用了new\",{\"1\":{\"130\":1}}],[\"中有缓存\",{\"1\":{\"130\":1}}],[\"中对\",{\"1\":{\"104\":1}}],[\"中\",{\"1\":{\"104\":1,\"153\":1,\"163\":1,\"165\":1,\"197\":1,\"450\":1,\"649\":1}}],[\"中最长的回文子串\",{\"1\":{\"650\":1}}],[\"中最常用的设计模式之一\",{\"1\":{\"101\":1}}],[\"中最简单的设计模式之一\",{\"1\":{\"98\":1}}],[\"中央处理器\",{\"1\":{\"76\":1}}],[\"中新建ssh\",{\"1\":{\"49\":1}}],[\"中设置页面信息\",{\"1\":{\"40\":1}}],[\"中使用\",{\"1\":{\"18\":1}}],[\"中的索引\",{\"1\":{\"721\":1}}],[\"中的所有字母都匹配完\",{\"1\":{\"705\":1}}],[\"中的所有数据到slave\",{\"1\":{\"203\":1}}],[\"中的每个\",{\"1\":{\"716\":1}}],[\"中的每个空格替换成\",{\"1\":{\"644\":1}}],[\"中的每个元素都有一个分数\",{\"1\":{\"199\":1}}],[\"中的jdk\",{\"1\":{\"616\":1}}],[\"中的nginx\",{\"1\":{\"614\":1}}],[\"中的服务名和项目中的地址一致\",{\"1\":{\"617\":1}}],[\"中的服务\",{\"1\":{\"598\":1}}],[\"中的一个组件\",{\"1\":{\"593\":1}}],[\"中的内容\",{\"1\":{\"501\":1}}],[\"中的\",{\"1\":{\"16\":1,\"107\":1,\"116\":1,\"649\":1}}],[\"中很重要的一个概念\",{\"1\":{\"14\":1}}],[\"请将其转换成单链表格式之后\",{\"1\":{\"729\":1}}],[\"请返回\",{\"1\":{\"708\":1}}],[\"请计算需要\",{\"1\":{\"718\":1}}],[\"请计算\",{\"1\":{\"694\":1}}],[\"请你设计并实现一个满足\",{\"1\":{\"720\":1}}],[\"请你设计一个函数\",{\"1\":{\"690\":1}}],[\"请你判断是否可能完成所有课程的学习\",{\"1\":{\"717\":1}}],[\"请你判断是否可以将这个数组分割成两个子集\",{\"1\":{\"701\":1}}],[\"请你计算网格中岛屿的数量\",{\"1\":{\"706\":1}}],[\"请你来实现一个支持\",{\"1\":{\"702\":1}}],[\"请你将\",{\"1\":{\"688\":1}}],[\"请你返回一个长度为\",{\"1\":{\"678\":1}}],[\"请你返回\",{\"1\":{\"676\":1}}],[\"请你找出所有从节点\",{\"1\":{\"715\":1}}],[\"请你找出其中不含有重复字符的\",{\"1\":{\"647\":1}}],[\"请你找出并返回两个单链表相交的起始节点\",{\"1\":{\"639\":1}}],[\"请定义一个函数实现字符串左旋转操作的功能\",{\"1\":{\"646\":1}}],[\"请实现一个函数\",{\"1\":{\"644\":1}}],[\"请在该位置用\",{\"1\":{\"622\":1}}],[\"请输入你要查找的id\",{\"1\":{\"408\":2}}],[\"请选择修改房屋编号\",{\"1\":{\"408\":1}}],[\"请选择房屋编号\",{\"1\":{\"408\":1}}],[\"请选择\",{\"1\":{\"408\":1}}],[\"请求首部字段\",{\"1\":{\"784\":1}}],[\"请求时\",{\"1\":{\"779\":1}}],[\"请求资源的访问被服务器拒绝\",{\"1\":{\"776\":1}}],[\"请求的编码实体资源在尚未传输完成时\",{\"1\":{\"768\":1}}],[\"请求报文和响应报文的结构如下\",{\"1\":{\"767\":1}}],[\"请求被浏览器拦截的问题\",{\"1\":{\"607\":1}}],[\"请求参数转换等\",{\"1\":{\"607\":1}}],[\"请求限流\",{\"1\":{\"607\":1}}],[\"请求到远程服务并获取响应结果\",{\"1\":{\"606\":1}}],[\"请求方式等信息\",{\"1\":{\"606\":1}}],[\"请求方法等信息来确定对应的处理器\",{\"1\":{\"161\":1}}],[\"请求方法\",{\"1\":{\"161\":1}}],[\"请求处理的超时时间\",{\"1\":{\"598\":1}}],[\"请求连接的超时时间\",{\"1\":{\"598\":1}}],[\"请求拦截器中根据服务名称从eureka中拉取服务列表\",{\"1\":{\"598\":1}}],[\"请求重定向\",{\"0\":{\"336\":1}}],[\"请求其他哨兵节点确认主节点的不可用情况\",{\"1\":{\"203\":1}}],[\"请求a将新值写入数据库\",{\"1\":{\"195\":1}}],[\"请求a进行写操作\",{\"1\":{\"195\":1}}],[\"请求b将旧值写入缓存\",{\"1\":{\"195\":1}}],[\"请求b去数据库查询得到旧值\",{\"1\":{\"195\":1}}],[\"请求b查询发现缓存不存在\",{\"1\":{\"195\":1}}],[\"请求\",{\"1\":{\"195\":1,\"776\":1,\"780\":1}}],[\"请求可以继续进行\",{\"1\":{\"192\":1}}],[\"请求分发\",{\"1\":{\"162\":1}}],[\"请求体等信息\",{\"1\":{\"161\":1}}],[\"请求头\",{\"1\":{\"161\":1}}],[\"请给出两者读取以下数据的示例\",{\"1\":{\"55\":1}}],[\"请使用绝对链接\",{\"1\":{\"41\":1}}],[\"请阅读\",{\"1\":{\"16\":1}}],[\"请先阅读\",{\"1\":{\"13\":1}}],[\"语句使用别名\",{\"1\":{\"522\":1}}],[\"语句只需修改映射文件\",{\"1\":{\"496\":1}}],[\"语句需要绕开框架\",{\"1\":{\"496\":1}}],[\"语句块2\",{\"1\":{\"372\":1}}],[\"语句块1\",{\"1\":{\"372\":1}}],[\"语句包含\",{\"1\":{\"184\":3}}],[\"语句首先从\",{\"1\":{\"184\":1}}],[\"语句\",{\"1\":{\"184\":1,\"389\":1,\"496\":1,\"522\":1,\"525\":1,\"526\":1}}],[\"语句的部分\",{\"1\":{\"184\":1}}],[\"语句中\",{\"1\":{\"184\":1}}],[\"语句中的condition是条件判断\",{\"1\":{\"6\":1}}],[\"语音通话\",{\"1\":{\"156\":1}}],[\"语义上的差异\",{\"1\":{\"138\":1}}],[\"语法结构\",{\"1\":{\"571\":1}}],[\"语法不同\",{\"1\":{\"62\":1}}],[\"语法\",{\"0\":{\"32\":1,\"488\":1},\"1\":{\"17\":1,\"366\":1,\"381\":2,\"382\":1,\"402\":2,\"417\":1,\"418\":1,\"462\":1}}],[\"语法进行了扩展\",{\"1\":{\"16\":1}}],[\"语法扩展\",{\"1\":{\"15\":1}}],[\"是原因短语\",{\"1\":{\"760\":1}}],[\"是正着读和反着读都一样的字符串\",{\"1\":{\"688\":1}}],[\"是新单词\",{\"1\":{\"675\":1}}],[\"是有效字符串\",{\"1\":{\"660\":1}}],[\"是空字符串时我们应当返回\",{\"1\":{\"651\":1}}],[\"是空字符串时\",{\"1\":{\"651\":1}}],[\"是回文\",{\"1\":{\"650\":1}}],[\"是第\",{\"1\":{\"631\":1}}],[\"是该条件下的长度最小的子数组\",{\"1\":{\"630\":1}}],[\"是docker\",{\"1\":{\"611\":1}}],[\"是将程序完整的运行环境打包\",{\"1\":{\"610\":1}}],[\"是将光标重新回到当前行开头\",{\"1\":{\"353\":1}}],[\"是否有循环依赖等问题\",{\"1\":{\"718\":1}}],[\"是否在网格中\",{\"1\":{\"704\":1}}],[\"是否需要还原\",{\"1\":{\"704\":1}}],[\"是否是回文串\",{\"1\":{\"650\":1}}],[\"是否更新数据\",{\"1\":{\"648\":1}}],[\"是否允许携带cookie\",{\"1\":{\"607\":1}}],[\"是否存在\",{\"1\":{\"197\":1}}],[\"是作为微服务系统的服务注册与发现组件\",{\"1\":{\"593\":1}}],[\"是作为微服务系统的网关组件\",{\"1\":{\"593\":1}}],[\"是单实例还是多实例\",{\"1\":{\"559\":1}}],[\"是单实例对象\",{\"1\":{\"559\":1}}],[\"是单进程程序\",{\"1\":{\"201\":1}}],[\"是轻量级开源的javaee框架\",{\"1\":{\"546\":1}}],[\"是支持正向工程的\",{\"1\":{\"540\":1}}],[\"是比较他们的值是否相等\",{\"1\":{\"492\":1}}],[\"是中文的\",{\"1\":{\"480\":1}}],[\"是按行读取文件\",{\"1\":{\"478\":2}}],[\"是按照路径匹配\",{\"1\":{\"607\":1}}],[\"是按照\",{\"1\":{\"436\":1}}],[\"是不是一个目录=\",{\"1\":{\"475\":1}}],[\"是不是一个文件=\",{\"1\":{\"475\":1}}],[\"是不同的对象\",{\"1\":{\"99\":1}}],[\"是type的缩写\",{\"1\":{\"456\":1}}],[\"是什么时候\",{\"1\":{\"436\":1}}],[\"是由系统来决定的\",{\"1\":{\"406\":1}}],[\"是cpu或编译器在对内存随机访问的操作中的一个同步点\",{\"1\":{\"290\":1}}],[\"是完全的纯内存操作\",{\"1\":{\"187\":1}}],[\"是为分布式环境设计的高可用性存储引擎\",{\"1\":{\"183\":1}}],[\"是指\",{\"1\":{\"718\":1}}],[\"是指其整数的下一个字典序更大的排列\",{\"1\":{\"628\":1}}],[\"是指对于第\",{\"1\":{\"622\":1}}],[\"是指同一个线程在外层方法获取锁的时候\",{\"1\":{\"263\":1}}],[\"是指在联合索引中\",{\"1\":{\"175\":1}}],[\"是指程序本身可以处理的异常\",{\"1\":{\"126\":1}}],[\"是指程序无法处理的错误\",{\"1\":{\"126\":1}}],[\"是在创建对象时指定的\",{\"1\":{\"457\":1}}],[\"是在同一个\",{\"1\":{\"167\":1}}],[\"是在代理类中执行的\",{\"1\":{\"164\":1}}],[\"是适配器模式的实现\",{\"1\":{\"161\":1}}],[\"是java程序中定义了线程之间共享变量的可见性\",{\"1\":{\"140\":1}}],[\"是对匿名函数的简写形式\",{\"1\":{\"129\":1}}],[\"是一种异步非阻塞框架\",{\"1\":{\"588\":1}}],[\"是一种同步锁\",{\"1\":{\"259\":1}}],[\"是一种空间效率非常高的概率型数据结构\",{\"1\":{\"194\":1}}],[\"是一种数据库事务日志机制\",{\"1\":{\"180\":1}}],[\"是一种并发控制机制\",{\"1\":{\"178\":1}}],[\"是一种模板设计\",{\"1\":{\"120\":1}}],[\"是一个节点数组\",{\"1\":{\"716\":1}}],[\"是一个从节点\",{\"1\":{\"715\":1}}],[\"是一个虚拟目录\",{\"1\":{\"615\":1}}],[\"是一个cs\",{\"1\":{\"611\":1}}],[\"是一个负载均衡组件\",{\"1\":{\"593\":1}}],[\"是一个访问\",{\"1\":{\"593\":1}}],[\"是一个独立的\",{\"1\":{\"571\":1}}],[\"是一个java类\",{\"1\":{\"261\":1}}],[\"是一个前置控制器\",{\"1\":{\"161\":1}}],[\"是一个带有泛型的接口\",{\"1\":{\"132\":1}}],[\"是一个强大的高性能\",{\"1\":{\"72\":1}}],[\"是like\",{\"1\":{\"120\":1}}],[\"是用于创建重复的对象\",{\"1\":{\"116\":1}}],[\"是用于把抽象化与实现化解耦\",{\"1\":{\"113\":1}}],[\"是围绕一个超级工厂创建其他工厂\",{\"1\":{\"110\":1}}],[\"是同一个对象\",{\"1\":{\"99\":1}}],[\"是多进程多线程的\",{\"1\":{\"98\":1}}],[\"是怎么把mapper接口注入容器的\",{\"0\":{\"83\":1}}],[\"是继dispatcherservlet前端控制器的后端控制器\",{\"1\":{\"76\":1}}],[\"是\",{\"1\":{\"14\":1,\"98\":1,\"101\":1,\"120\":1,\"147\":1,\"168\":1,\"478\":1,\"555\":1,\"588\":1,\"593\":1,\"607\":1,\"640\":1}}],[\"是此表的主键\",{\"1\":{\"5\":1}}],[\"还要重写\",{\"1\":{\"492\":1}}],[\"还要确保及时释放使用完毕的资源\",{\"1\":{\"146\":1}}],[\"还可通过使用变量来控制run方法退出的方式停止线程\",{\"1\":{\"467\":1}}],[\"还可以利用js脚本在web页面上自动进行选择\",{\"1\":{\"771\":1}}],[\"还可以设置\",{\"1\":{\"524\":1}}],[\"还可以指定编码格式\",{\"1\":{\"478\":1}}],[\"还可以根据索引获取范围内的元素\",{\"1\":{\"188\":1}}],[\"还可以表示11\",{\"1\":{\"7\":1}}],[\"还是\",{\"1\":{\"212\":1}}],[\"还需要去掉return关键字\",{\"1\":{\"129\":1}}],[\"还不会编写\",{\"1\":{\"13\":1}}],[\"介绍一下\",{\"0\":{\"158\":1}}],[\"介绍一下红黑树\",{\"0\":{\"124\":1}}],[\"介绍\",{\"0\":{\"13\":1,\"270\":1,\"545\":1,\"547\":1,\"548\":1,\"591\":1},\"1\":{\"13\":1,\"14\":1,\"258\":2,\"263\":1,\"391\":2,\"392\":1,\"393\":1,\"398\":1,\"399\":1,\"400\":1,\"401\":1,\"402\":1,\"404\":1,\"405\":1,\"406\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"430\":1,\"431\":1,\"432\":1,\"435\":1,\"440\":1,\"442\":1,\"444\":1,\"445\":1,\"446\":1,\"448\":1,\"449\":1,\"450\":1,\"452\":1,\"460\":1,\"462\":1,\"471\":1,\"478\":1,\"480\":1,\"484\":1,\"486\":1,\"492\":1,\"534\":1,\"535\":1,\"588\":1,\"768\":1}}],[\"介绍页\",{\"0\":{\"0\":1}}],[\"可级联多台代理服务器\",{\"1\":{\"780\":1}}],[\"可用敏感性策略\",{\"1\":{\"598\":1}}],[\"可用性敏感策略\",{\"1\":{\"598\":1}}],[\"可变数组object\",{\"1\":{\"442\":1}}],[\"可变数组\",{\"1\":{\"442\":1}}],[\"可变参数\",{\"1\":{\"391\":1}}],[\"可直接进行doreleaseshared唤醒阻塞节点\",{\"1\":{\"318\":1}}],[\"可只实现tryacquire\",{\"1\":{\"313\":1}}],[\"可释放返回true\",{\"1\":{\"313\":1}}],[\"可获取返回true\",{\"1\":{\"313\":2}}],[\"可根据实际情况选择合适的策略\",{\"1\":{\"200\":1}}],[\"可重入锁种类\",{\"1\":{\"263\":1}}],[\"可重入锁\",{\"0\":{\"263\":1}}],[\"可重入性\",{\"1\":{\"141\":1}}],[\"可重复读\",{\"1\":{\"171\":1}}],[\"可靠性\",{\"1\":{\"156\":1}}],[\"可见性问题是因为多线程的操作都是在各自的工作内存中进行的\",{\"1\":{\"140\":1}}],[\"可见性和有序性\",{\"1\":{\"138\":1}}],[\"可见性\",{\"0\":{\"277\":1},\"1\":{\"128\":1,\"140\":2,\"273\":1}}],[\"可见性保证\",{\"1\":{\"125\":1}}],[\"可乐\",{\"1\":{\"107\":1}}],[\"可选的返回关键字\",{\"1\":{\"488\":1}}],[\"可选的大括号\",{\"1\":{\"488\":1}}],[\"可选的参数圆括号\",{\"1\":{\"488\":1}}],[\"可选类型声明\",{\"1\":{\"488\":1}}],[\"可选\",{\"1\":{\"66\":2,\"559\":1,\"560\":2,\"757\":4}}],[\"可能一个类已经继承了父类\",{\"1\":{\"466\":1}}],[\"可能对业务造成灾难性打击\",{\"1\":{\"203\":1}}],[\"可能瞬间就会导致数据库宕机\",{\"1\":{\"198\":1}}],[\"可能导致查询被阻塞\",{\"1\":{\"173\":1}}],[\"可能需要在每个节点中进行比较操作\",{\"1\":{\"172\":1}}],[\"可能需要同时定义多个xml标签\",{\"1\":{\"62\":1}}],[\"可能会造成精度降低或溢出\",{\"1\":{\"359\":1}}],[\"可能会消耗较高的cpu\",{\"1\":{\"299\":1}}],[\"可能会在编译时对字节码指令进行重排序\",{\"1\":{\"292\":1}}],[\"可能会发现新增或删除了一些记录\",{\"1\":{\"171\":1}}],[\"可能会降低性能\",{\"1\":{\"55\":1}}],[\"可能的优化措施包括减少对象的创建\",{\"1\":{\"146\":1}}],[\"可能是\",{\"1\":{\"5\":1}}],[\"可以形成⼀种新的数据结构\",{\"1\":{\"720\":1}}],[\"可以访问的所有节点的列表\",{\"1\":{\"715\":1}}],[\"可以访问外部类的所有静态成员\",{\"1\":{\"418\":1}}],[\"可以装下的最大价值\",{\"1\":{\"700\":1}}],[\"可以推出\",{\"1\":{\"687\":1}}],[\"可以构造一个\",{\"1\":{\"687\":1}}],[\"可以构造器重载\",{\"1\":{\"392\":1}}],[\"可以利用这些信息避免从头再去做匹配了\",{\"1\":{\"653\":1}}],[\"可以知道一部分之前已经匹配的文本内容\",{\"1\":{\"653\":1}}],[\"可以确定右边界\",{\"1\":{\"650\":1}}],[\"可以采摘\",{\"1\":{\"631\":3}}],[\"可以采摘全部\",{\"1\":{\"631\":1}}],[\"可以接\",{\"1\":{\"624\":1}}],[\"可以接收客户端发送过来的请求\",{\"1\":{\"326\":1}}],[\"可以把自己得业务暴露为接口\",{\"1\":{\"596\":1}}],[\"可以轻松的将分布式应用中连接有消息中间件的多个服务节点连接起来\",{\"1\":{\"593\":1}}],[\"可以从\",{\"1\":{\"593\":1}}],[\"可以简化基于\",{\"1\":{\"557\":1}}],[\"可以简写list<string>\",{\"1\":{\"456\":1}}],[\"可以解决企业开发的复杂性问题\",{\"1\":{\"546\":1}}],[\"可以自定义状态码\",{\"1\":{\"773\":1}}],[\"可以自动删除后面多余的\",{\"1\":{\"529\":1}}],[\"可以自己throw\",{\"1\":{\"126\":1}}],[\"可以很好的保护实际对象的业务逻辑对外暴露\",{\"1\":{\"492\":1}}],[\"可以很好的管理类\",{\"1\":{\"396\":1}}],[\"可以修饰引用\",{\"1\":{\"492\":1}}],[\"可以提供一个lambda表达式\",{\"1\":{\"490\":1}}],[\"可以获得constructor对象\",{\"1\":{\"486\":1}}],[\"可以获取年月日\",{\"1\":{\"436\":1}}],[\"可以获取到查询计划的详细信息\",{\"1\":{\"182\":1}}],[\"可以定义在普通类中\",{\"1\":{\"459\":1}}],[\"可以传入该类型及其子类型\",{\"1\":{\"456\":1}}],[\"可以存放null\",{\"1\":{\"445\":1}}],[\"可以添加任意元素\",{\"1\":{\"443\":1}}],[\"可以添加访问修饰符\",{\"1\":{\"418\":2}}],[\"可以动态保存多个对象\",{\"1\":{\"438\":1}}],[\"可以和date互相转换\",{\"1\":{\"436\":1}}],[\"可以看出模式串与前缀表对应位置的数字表示的就是\",{\"1\":{\"653\":1}}],[\"可以看出\",{\"1\":{\"653\":1}}],[\"可以看出比hashset多了before和after分别指向前一个add和后一个add\",{\"1\":{\"446\":1}}],[\"可以看出stringbuilder效率最高\",{\"1\":{\"431\":1}}],[\"可以看到\",{\"1\":{\"304\":1}}],[\"可以看到下面这段代码\",{\"1\":{\"260\":1}}],[\"可以看到的开关是抽象的\",{\"1\":{\"113\":1}}],[\"可以重写对象的equals方法\",{\"1\":{\"492\":1}}],[\"可以重写该方法\",{\"1\":{\"421\":1}}],[\"可以重载\",{\"1\":{\"431\":1}}],[\"可以抛出多个异常\",{\"1\":{\"425\":1}}],[\"可以得到对应枚举常量\",{\"1\":{\"421\":1}}],[\"可以比较两个枚举常量的大小\",{\"1\":{\"421\":1}}],[\"可以用\",{\"1\":{\"532\":1}}],[\"可以用for\",{\"1\":{\"448\":1}}],[\"可以用final关键字修饰\",{\"1\":{\"415\":1}}],[\"可以用final修饰\",{\"1\":{\"415\":3}}],[\"可以用redis存储\",{\"1\":{\"165\":1}}],[\"可以返回一个cat对象\",{\"1\":{\"414\":1}}],[\"可以返回一个结果\",{\"1\":{\"132\":1}}],[\"可以调用类的静态成员\",{\"1\":{\"412\":1}}],[\"可以调用子类中所有成员\",{\"1\":{\"402\":1}}],[\"可以调用父类中的所有成员\",{\"1\":{\"402\":1}}],[\"可以对进入网关的请求和微服务返回的响应做处理\",{\"1\":{\"607\":1}}],[\"可以对业务逻辑的各个部分进行隔离\",{\"1\":{\"567\":1}}],[\"可以对数据进行验证\",{\"1\":{\"398\":1}}],[\"可以对集合执行添加\",{\"1\":{\"188\":1}}],[\"可以有多条语句\",{\"1\":{\"371\":2}}],[\"可以被javadoc解析\",{\"1\":{\"354\":1}}],[\"可以继续释放线程d\",{\"1\":{\"318\":1}}],[\"可以继续执行临界区代码\",{\"1\":{\"141\":1}}],[\"可以省略null检查\",{\"1\":{\"312\":1}}],[\"可以省略方法体的大括号\",{\"1\":{\"129\":1}}],[\"可以省略方法中的形参类型\",{\"1\":{\"129\":1}}],[\"可以省略方法名\",{\"1\":{\"129\":1}}],[\"可以让任务执行完成后通知监听的一方\",{\"1\":{\"235\":1}}],[\"可以快速地定位和检索消息\",{\"1\":{\"214\":1}}],[\"可以水平扩展系统的处理能力\",{\"1\":{\"214\":1}}],[\"可以选择kafka\",{\"1\":{\"213\":1}}],[\"可以选择rabbitmq\",{\"1\":{\"213\":1}}],[\"可以选择使用\",{\"1\":{\"200\":1}}],[\"可以作为不同权限隔离的手段\",{\"1\":{\"209\":1}}],[\"可以做到\",{\"1\":{\"209\":1}}],[\"可以监控一个或多个键\",{\"1\":{\"202\":1}}],[\"可以为每个子数组设置不同的列数\",{\"1\":{\"382\":1}}],[\"可以为\",{\"1\":{\"202\":1}}],[\"可以设置默认值\",{\"1\":{\"241\":1}}],[\"可以设置超时时间\",{\"1\":{\"233\":1}}],[\"可以设置使用\",{\"1\":{\"200\":1}}],[\"可以设置自己的比较策略\",{\"1\":{\"45\":1}}],[\"可以将上面的dockerfile\",{\"1\":{\"616\":1}}],[\"可以将应用程序需要的远程\",{\"1\":{\"606\":1}}],[\"可以将main方法写在非public类中\",{\"1\":{\"352\":1}}],[\"可以将负载和数据分布到多个服务器上\",{\"1\":{\"214\":1}}],[\"可以将\",{\"1\":{\"199\":1}}],[\"可以将1秒内所造成的缓存脏数据\",{\"1\":{\"196\":1}}],[\"可以将数据同时发送给多个接收者\",{\"1\":{\"156\":1}}],[\"可以表示一系列的开关状态或标记\",{\"1\":{\"188\":1}}],[\"可以是xxx\",{\"1\":{\"757\":1}}],[\"可以是负数\",{\"1\":{\"677\":1,\"678\":1}}],[\"可以是基本数据类型也可以是引用数据类型\",{\"1\":{\"386\":1}}],[\"可以是字符串\",{\"1\":{\"188\":1}}],[\"可以是会话级的\",{\"1\":{\"153\":1}}],[\"可以考虑将数据进行分片或搭建\",{\"1\":{\"200\":1}}],[\"可以考虑创建复合索引\",{\"1\":{\"174\":1}}],[\"可以考虑使用原型模式拷贝多个对象供调用者使用\",{\"1\":{\"116\":1}}],[\"可以进行\",{\"1\":{\"168\":1}}],[\"可以放到二级缓存中\",{\"1\":{\"167\":1}}],[\"可以配置全局的缓存\",{\"1\":{\"167\":1}}],[\"可以更加灵活地控制锁的行为\",{\"1\":{\"142\":1}}],[\"可以实现流量控制\",{\"1\":{\"135\":1}}],[\"可以通过实体类直接获取相对应的属性值\",{\"1\":{\"512\":1}}],[\"可以通过constructor类的newinstance\",{\"1\":{\"486\":1}}],[\"可以通过接口的方式扩展\",{\"1\":{\"417\":1}}],[\"可以通过标签指明要终止于哪一层语句块\",{\"1\":{\"377\":1}}],[\"可以通过httpservletrequest类获得多有请求的信息\",{\"1\":{\"333\":1}}],[\"可以通过浏览器访问的程序\",{\"1\":{\"322\":1}}],[\"可以通过设置合理的过期时间来自动释放内存\",{\"1\":{\"200\":1}}],[\"可以通过将方法b提取到另一个类中\",{\"1\":{\"166\":1}}],[\"可以通过阻塞队列的容量限制来控制任务的接受速率\",{\"1\":{\"135\":1}}],[\"可以通过future对象的get\",{\"1\":{\"133\":1}}],[\"可以通过创建实现\",{\"1\":{\"132\":1}}],[\"可以去掉形参的括号\",{\"1\":{\"129\":1}}],[\"可以禁止编译器和处理器对被修饰变量相关指令的重排序\",{\"1\":{\"128\":1}}],[\"可以按索引访问每个字符\",{\"1\":{\"121\":1}}],[\"可以使用快慢指针法\",{\"1\":{\"640\":1}}],[\"可以使用循环操作\",{\"1\":{\"477\":1}}],[\"可以使用泛型\",{\"1\":{\"457\":1}}],[\"可以使用final修饰符\",{\"1\":{\"418\":2}}],[\"可以使用atomiclong的替代类\",{\"1\":{\"299\":1}}],[\"可以使用命令如\",{\"1\":{\"199\":1}}],[\"可以使用explain关键字来了解mysql优化器的查询执行计划\",{\"1\":{\"182\":1}}],[\"可以使用\",{\"1\":{\"134\":2,\"461\":1}}],[\"可以使用相同的抽象类方法但是不同的桥接实现类\",{\"1\":{\"113\":1}}],[\"可以使用了\",{\"1\":{\"66\":1,\"560\":1}}],[\"可以直接套用图的遍历框架\",{\"1\":{\"715\":1}}],[\"可以直接通过键名获取\",{\"1\":{\"512\":1}}],[\"可以直接使用\",{\"1\":{\"168\":1}}],[\"可以直接进入临界区执行\",{\"1\":{\"141\":1}}],[\"可以直接从工厂里面提货\",{\"1\":{\"101\":1}}],[\"可以直接访问所有成员\",{\"1\":{\"418\":1}}],[\"可以直接访问外部类的所有成员\",{\"1\":{\"418\":2}}],[\"可以直接访问\",{\"1\":{\"98\":1}}],[\"可以大大提升开发效率\",{\"1\":{\"95\":1}}],[\"可以达到平滑升级的效果\",{\"1\":{\"95\":1}}],[\"可以在\",{\"1\":{\"687\":1}}],[\"可以在类声明时通过一个标识表示类中的某个属性的类型\",{\"1\":{\"455\":1}}],[\"可以在网络传输\",{\"1\":{\"429\":1}}],[\"可以在网络传输和磁盘存储上进行有效压缩\",{\"1\":{\"214\":1}}],[\"可以在列表头部或尾部插入\",{\"1\":{\"188\":1}}],[\"可以在我们的pom\",{\"1\":{\"82\":1}}],[\"可以在运行期扩展\",{\"1\":{\"72\":1}}],[\"可以再运行期动态生成新\",{\"1\":{\"72\":1}}],[\"可以根据不同的实现类来注入\",{\"1\":{\"564\":1}}],[\"可以根据分数进行排序和范围查询\",{\"1\":{\"199\":1}}],[\"可以根据分数范围获取元素\",{\"1\":{\"188\":1}}],[\"可以根据服务器的配置进行调整\",{\"1\":{\"153\":1}}],[\"可以根据xml配置\",{\"1\":{\"76\":1}}],[\"可以根据具体情况选择合适的方式来定义bean\",{\"1\":{\"62\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"12\":1}}],[\"你这个学期必须选修\",{\"1\":{\"717\":1}}],[\"你有一个带有四个圆形拨轮的转盘锁\",{\"1\":{\"713\":1}}],[\"你不能先偷窃\",{\"1\":{\"698\":1}}],[\"你不能只是单纯的改变节点内部的值\",{\"1\":{\"637\":1}}],[\"你是一个专业的小偷\",{\"1\":{\"698\":1}}],[\"你需要完成课程\",{\"1\":{\"717\":1}}],[\"你需要先完成课程\",{\"1\":{\"717\":1}}],[\"你需要给出解锁需要的最小旋转次数\",{\"1\":{\"713\":1}}],[\"你需要将⼦数组\",{\"1\":{\"676\":1}}],[\"你需要阅读\",{\"1\":{\"14\":1}}],[\"你将会被给出\",{\"1\":{\"676\":1}}],[\"你将会向右移动到下一棵树\",{\"1\":{\"631\":1}}],[\"你只可以看到在滑动窗口内的\",{\"1\":{\"661\":1}}],[\"你只有\",{\"1\":{\"631\":1}}],[\"你都可以在字符串的任何位置插入一个括号\",{\"1\":{\"660\":1}}],[\"你必须实现类的所有函数\",{\"1\":{\"721\":1}}],[\"你必须从\",{\"1\":{\"631\":1}}],[\"你必须按照要求采摘水果\",{\"1\":{\"631\":1}}],[\"你想要尽可能多地收集水果\",{\"1\":{\"631\":1}}],[\"你正在探访一家农场\",{\"1\":{\"631\":1}}],[\"你好北京~\",{\"1\":{\"477\":1}}],[\"你好\",{\"1\":{\"429\":1}}],[\"你创建的\",{\"1\":{\"212\":1}}],[\"你最擅长的java框架\",{\"0\":{\"158\":1}}],[\"你应该创建和编写\",{\"1\":{\"12\":1}}],[\"你可以假设该网格的四条边均被水包围\",{\"1\":{\"706\":1}}],[\"你可以\",{\"1\":{\"685\":1}}],[\"你可以按\",{\"1\":{\"683\":1,\"686\":1}}],[\"你可以插入一个开始括号为\",{\"1\":{\"660\":1}}],[\"你可以选择任意一棵树开始采摘\",{\"1\":{\"631\":1}}],[\"你可以一站式集成spring及其他技术\",{\"1\":{\"81\":1}}],[\"你可以通过主题选项和页面\",{\"1\":{\"42\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"10\":1}}],[\"你可以将图片和\",{\"1\":{\"41\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"41\":1}}],[\"你可以在\",{\"1\":{\"40\":1}}],[\"你可以标记\",{\"1\":{\"24\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"12\":1}}],[\"文档传递协议\",{\"1\":{\"746\":1}}],[\"文档注释\",{\"1\":{\"354\":2}}],[\"文本串中第六个字符b\",{\"1\":{\"653\":1}}],[\"文本串\",{\"1\":{\"653\":1}}],[\"文本文件\",{\"1\":{\"476\":1,\"616\":1}}],[\"文章标题列表\",{\"1\":{\"42\":1}}],[\"文件是一个文本文件\",{\"1\":{\"617\":1}}],[\"文件是否存在=\",{\"1\":{\"475\":1}}],[\"文件帮助快速部署分布式应用\",{\"1\":{\"617\":1}}],[\"文件后缀名\",{\"1\":{\"599\":1,\"602\":1}}],[\"文件中添加\",{\"1\":{\"557\":1}}],[\"文件拷贝完毕~~~\",{\"1\":{\"478\":1}}],[\"文件末尾返回\",{\"1\":{\"477\":1}}],[\"文件大小\",{\"1\":{\"475\":1}}],[\"文件父级目录=\",{\"1\":{\"475\":1}}],[\"文件绝对路径=\",{\"1\":{\"475\":1}}],[\"文件名字=\",{\"1\":{\"475\":1}}],[\"文件名必须与public类同名\",{\"1\":{\"352\":1}}],[\"文件在程序中是以流的形式来操作的\",{\"1\":{\"474\":1}}],[\"文件流\",{\"0\":{\"474\":1}}],[\"文件等同的字节码\",{\"1\":{\"419\":1}}],[\"文件可以通过jvm\",{\"1\":{\"346\":1}}],[\"文件生成完毕之后\",{\"1\":{\"204\":1}}],[\"文件生成页面\",{\"1\":{\"12\":1}}],[\"文件句柄等\",{\"1\":{\"146\":1}}],[\"文件读写等\",{\"1\":{\"146\":1}}],[\"文件夹的图片\",{\"1\":{\"41\":1}}],[\"文件放置在一起\",{\"1\":{\"41\":1}}],[\"文件\",{\"1\":{\"12\":1,\"63\":1,\"114\":2,\"352\":1,\"555\":1,\"557\":1,\"583\":1,\"584\":2,\"613\":1,\"616\":1}}],[\"文字结尾应该有深蓝色的\",{\"1\":{\"41\":1}}],[\"文字\",{\"1\":{\"11\":2}}],[\"文字段落\",{\"1\":{\"11\":24}}],[\"段落\",{\"1\":{\"11\":2}}],[\"返回结果的http状态码\",{\"0\":{\"772\":1}}],[\"返回结果数组\",{\"1\":{\"677\":1,\"678\":1}}],[\"返回最合适的内容\",{\"0\":{\"771\":1}}],[\"返回可以通过上述方法构造的\",{\"1\":{\"687\":1}}],[\"返回解集\",{\"1\":{\"686\":1}}],[\"返回所有它能表示的字母组合\",{\"1\":{\"684\":1}}],[\"返回答案\",{\"1\":{\"683\":1,\"685\":1}}],[\"返回范围\",{\"1\":{\"683\":1}}],[\"返回计算后的result就行\",{\"1\":{\"678\":1}}],[\"返回该数组所有可能的子集\",{\"1\":{\"686\":1}}],[\"返回该单词增加的编码长度\",{\"1\":{\"675\":1}}],[\"返回该字符值\",{\"1\":{\"477\":1}}],[\"返回它的最大深度\",{\"1\":{\"669\":1}}],[\"返回其\",{\"1\":{\"685\":1}}],[\"返回其节点值的\",{\"1\":{\"666\":1}}],[\"返回其2倍的值\",{\"1\":{\"489\":1}}],[\"返回栈是否为空\",{\"1\":{\"656\":1}}],[\"返回队列是否为空\",{\"1\":{\"655\":1}}],[\"返回队列首部的元素\",{\"1\":{\"655\":1}}],[\"返回这些子串的起始索引\",{\"1\":{\"649\":1}}],[\"返回链表开始入环的第一个节点\",{\"1\":{\"640\":1}}],[\"返回你可以收集的水果的\",{\"1\":{\"631\":1}}],[\"返回满足情况的所有解\",{\"1\":{\"627\":1}}],[\"返回容器可以储存的最大水量\",{\"1\":{\"625\":1}}],[\"返回一个数组\",{\"1\":{\"622\":1}}],[\"返回一个key集合\",{\"1\":{\"448\":1}}],[\"返回异常后方法增强\",{\"1\":{\"572\":1}}],[\"返回后方法增强\",{\"1\":{\"572\":1}}],[\"返回他们的和\",{\"1\":{\"489\":1}}],[\"返回类中的所有构造器\",{\"1\":{\"486\":1}}],[\"返回类中的所有方法\",{\"1\":{\"486\":1}}],[\"返回类中的所有成员变量\",{\"1\":{\"486\":1}}],[\"返回类中的public构造器\",{\"1\":{\"486\":1}}],[\"返回类中的public方法\",{\"1\":{\"486\":1}}],[\"返回类中的public成员变量\",{\"1\":{\"486\":1}}],[\"返回类型\",{\"1\":{\"401\":1,\"459\":1,\"571\":1}}],[\"返回类型可以为任意类型\",{\"1\":{\"389\":1}}],[\"返回类型与当前变量类型相同\",{\"1\":{\"252\":1}}],[\"返回=\",{\"1\":{\"485\":1}}],[\"返回读取到的字符数\",{\"1\":{\"477\":1}}],[\"返回实际读取的字节数\",{\"1\":{\"477\":1}}],[\"返回\",{\"1\":{\"477\":2,\"597\":1,\"629\":1,\"630\":1,\"635\":1,\"639\":1,\"648\":1,\"660\":1,\"661\":1,\"677\":1,\"684\":1,\"688\":1,\"705\":2,\"713\":1,\"716\":2,\"717\":2,\"718\":1,\"720\":5,\"721\":2}}],[\"返回list的大小\",{\"1\":{\"440\":1}}],[\"返回子列\",{\"1\":{\"440\":1}}],[\"返回下一个元素\",{\"1\":{\"439\":1}}],[\"返回表示当前日期时间的\",{\"1\":{\"436\":1}}],[\"返回月时候\",{\"1\":{\"436\":1}}],[\"返回当前时间距离1970\",{\"1\":{\"434\":1}}],[\"返回当前线程的此线程局部变量副本中的值\",{\"1\":{\"304\":1}}],[\"返回字符串形式\",{\"1\":{\"433\":1}}],[\"返回0~1之间一个随机小数\",{\"1\":{\"432\":1}}],[\"返回0说明\",{\"1\":{\"205\":1}}],[\"返回的是所有对象的map集合\",{\"1\":{\"501\":1}}],[\"返回的才是\",{\"1\":{\"430\":1}}],[\"返回的也是一个抽象的产品\",{\"1\":{\"101\":1}}],[\"返回方法的执行结果\",{\"1\":{\"419\":1}}],[\"返回数据类型为void时可以不写return\",{\"1\":{\"389\":1}}],[\"返回数据类型\",{\"1\":{\"389\":1}}],[\"返回前置节点\",{\"1\":{\"312\":1}}],[\"返回此线程局部变量的当前线程的\",{\"1\":{\"304\":1}}],[\"返回1\",{\"1\":{\"205\":1}}],[\"返回空值\",{\"1\":{\"202\":1}}],[\"返回事务块内所有命令的返回值\",{\"1\":{\"202\":1}}],[\"返回值为int\",{\"1\":{\"733\":1}}],[\"返回值为\",{\"1\":{\"489\":1,\"718\":1}}],[\"返回值\",{\"1\":{\"133\":1,\"389\":1,\"704\":1}}],[\"返回http响应等工作\",{\"1\":{\"69\":1}}],[\"返回顶部按钮\",{\"1\":{\"10\":1,\"42\":1}}],[\"返回指针空值\",{\"1\":{\"3\":1}}],[\"页脚\",{\"1\":{\"10\":1,\"42\":1}}],[\"页面是无法显示的\",{\"1\":{\"768\":1}}],[\"页面结构\",{\"0\":{\"42\":1}}],[\"页面内容\",{\"0\":{\"41\":1}}],[\"页面配置\",{\"0\":{\"39\":1},\"1\":{\"40\":1}}],[\"页面引入配置\",{\"1\":{\"14\":1}}],[\"页面信息\",{\"0\":{\"40\":1},\"1\":{\"10\":1}}],[\"页面展示\",{\"1\":{\"9\":1,\"33\":1}}],[\"评论\",{\"1\":{\"10\":1,\"42\":1}}],[\"编程的支持\",{\"1\":{\"549\":1}}],[\"编号\",{\"1\":{\"408\":1}}],[\"编号为\",{\"1\":{\"102\":2}}],[\"编码\",{\"0\":{\"768\":1}}],[\"编码0\",{\"1\":{\"356\":1}}],[\"编码表\",{\"0\":{\"356\":1}}],[\"编译时会检查添加元素的类型\",{\"1\":{\"454\":1}}],[\"编译异常是在编译期间必须处理的异常\",{\"1\":{\"424\":1}}],[\"编译异常\",{\"1\":{\"424\":1}}],[\"编译类型ia\",{\"1\":{\"418\":1}}],[\"编译后用\",{\"1\":{\"352\":2}}],[\"编译后的代码不能被机器直接执行需要通过解释器来执行\",{\"1\":{\"346\":1}}],[\"编译\",{\"1\":{\"349\":1}}],[\"编译运行指令\",{\"0\":{\"349\":1}}],[\"编译生成的\",{\"1\":{\"346\":1}}],[\"编译器可以统一识别参数值\",{\"1\":{\"488\":1}}],[\"编译器可以在编译时检查代码的类型安全性\",{\"1\":{\"123\":1}}],[\"编译器的会把第一个\",{\"1\":{\"353\":1}}],[\"编译器为了优化程序性能\",{\"1\":{\"292\":1}}],[\"编译器和处理器会对指令序列进行重排序\",{\"1\":{\"278\":1}}],[\"编译器和处理器可能会对指令进行重排序\",{\"1\":{\"128\":1}}],[\"编写docker\",{\"1\":{\"617\":1}}],[\"编写\",{\"1\":{\"569\":1,\"576\":1}}],[\"编写完成\",{\"1\":{\"111\":1}}],[\"编写handler时按照handleradapter的要求去做\",{\"1\":{\"76\":1}}],[\"编写一个函数\",{\"1\":{\"642\":1}}],[\"编写一个filter类去实现filter接口\",{\"1\":{\"339\":1}}],[\"编写一个类去实现servlet接口\",{\"1\":{\"327\":1}}],[\"编写一个\",{\"1\":{\"5\":1}}],[\"编辑此页链接\",{\"1\":{\"10\":1}}],[\"贡献者\",{\"1\":{\"10\":1,\"42\":1}}],[\"侧边栏\",{\"1\":{\"10\":1,\"42\":1}}],[\"展示\",{\"0\":{\"12\":1},\"1\":{\"9\":1,\"33\":1}}],[\"和长度i\",{\"1\":{\"736\":1}}],[\"和节点\",{\"1\":{\"716\":1}}],[\"和⼀个正整数\",{\"1\":{\"689\":1}}],[\"和一个字符串单词\",{\"1\":{\"705\":1}}],[\"和一个字符规律\",{\"1\":{\"702\":1}}],[\"和一个数组\",{\"1\":{\"677\":1}}],[\"和一个整数\",{\"1\":{\"643\":1,\"687\":1}}],[\"和为\",{\"0\":{\"671\":1}}],[\"和栈中保持一样元素的队列\",{\"1\":{\"657\":1}}],[\"和数字2\",{\"1\":{\"646\":1}}],[\"和curb\",{\"1\":{\"639\":1}}],[\"和char之间不会相互转化\",{\"1\":{\"359\":1}}],[\"和dockerhub\",{\"1\":{\"611\":1}}],[\"和虚拟机的区别\",{\"0\":{\"610\":1}}],[\"和完整的相关库产品组合还提供\",{\"1\":{\"545\":1}}],[\"和调用普通代码块\",{\"1\":{\"413\":1}}],[\"和this\",{\"1\":{\"399\":1}}],[\"和对数据的操作\",{\"1\":{\"398\":1}}],[\"和局部变量\",{\"1\":{\"391\":1}}],[\"和unpark\",{\"1\":{\"271\":1}}],[\"和kafka\",{\"0\":{\"213\":1}}],[\"和标签\",{\"1\":{\"209\":1}}],[\"和请求\",{\"1\":{\"195\":1}}],[\"和回滚日志\",{\"1\":{\"180\":1}}],[\"和weak\",{\"1\":{\"167\":1}}],[\"和aop\",{\"1\":{\"158\":1}}],[\"和await\",{\"1\":{\"144\":1}}],[\"和永久代大小\",{\"1\":{\"146\":1}}],[\"和releaseshared分析\",{\"0\":{\"318\":1}}],[\"和release\",{\"1\":{\"144\":1}}],[\"和超时\",{\"1\":{\"142\":1}}],[\"和stringbuilder的区别\",{\"1\":{\"120\":1}}],[\"和继承banner并实现print接口的printbanner类\",{\"1\":{\"96\":1}}],[\"和\",{\"0\":{\"261\":1,\"479\":1},\"1\":{\"13\":1,\"40\":1,\"72\":2,\"84\":1,\"86\":1,\"99\":2,\"132\":1,\"134\":1,\"159\":1,\"168\":1,\"175\":2,\"189\":1,\"358\":1,\"436\":1,\"456\":1,\"478\":4,\"492\":4,\"496\":1,\"564\":2,\"572\":1,\"576\":1,\"583\":1,\"625\":1,\"628\":5,\"636\":1,\"639\":2,\"640\":2,\"648\":1,\"649\":1,\"650\":1,\"653\":1,\"660\":1,\"676\":1,\"677\":1,\"678\":1,\"683\":1,\"687\":1,\"694\":1,\"696\":1,\"701\":1,\"702\":1,\"706\":1,\"708\":1,\"709\":1,\"716\":3,\"720\":2}}],[\"和11\",{\"1\":{\"7\":1}}],[\"和普通的concat\",{\"1\":{\"7\":1}}],[\"来标记\",{\"1\":{\"768\":1}}],[\"来比较\",{\"1\":{\"739\":1}}],[\"来表示\",{\"1\":{\"696\":1}}],[\"来表示链表尾连接到链表中的位置\",{\"1\":{\"640\":1}}],[\"来代替\",{\"1\":{\"622\":1}}],[\"来完成动态代理的实现\",{\"1\":{\"492\":1}}],[\"来获取时间\",{\"1\":{\"436\":1}}],[\"来获取属性的值\",{\"1\":{\"398\":1}}],[\"来获取指定范围内的元素\",{\"1\":{\"199\":1}}],[\"来对属性进行判断赋值\",{\"1\":{\"398\":1}}],[\"来开启线程\",{\"1\":{\"223\":1}}],[\"来开启异步调用\",{\"1\":{\"164\":1}}],[\"来提高整体吞吐量\",{\"1\":{\"214\":1}}],[\"来不及显式地释放锁\",{\"1\":{\"205\":1}}],[\"来加锁\",{\"1\":{\"205\":1}}],[\"来说\",{\"1\":{\"187\":1}}],[\"来管理多个\",{\"1\":{\"186\":1}}],[\"来分配的\",{\"1\":{\"178\":1}}],[\"来分组\",{\"1\":{\"7\":1}}],[\"来选择合适的方式进行异常处理\",{\"1\":{\"162\":1}}],[\"来执行该处理器\",{\"1\":{\"161\":1}}],[\"来查找适合处理当前请求的处理器\",{\"1\":{\"161\":1}}],[\"来进行线程的控制和同步\",{\"1\":{\"144\":1}}],[\"来处理在runnable中抛出的异常\",{\"1\":{\"133\":1}}],[\"来创建和维护所有组件\",{\"1\":{\"545\":1}}],[\"来创建\",{\"0\":{\"130\":1},\"1\":{\"130\":1}}],[\"来存储\",{\"1\":{\"121\":1}}],[\"来画出不同颜色的圆\",{\"1\":{\"113\":1}}],[\"来实现锁的功能\",{\"1\":{\"141\":1}}],[\"来实现可见性\",{\"1\":{\"140\":1}}],[\"来实现同步\",{\"1\":{\"139\":1}}],[\"来实现二者的解耦\",{\"1\":{\"113\":1}}],[\"来实现\",{\"1\":{\"70\":1}}],[\"来解析\",{\"1\":{\"15\":1}}],[\"来源\",{\"1\":{\"5\":1}}],[\"因特网互联协议\",{\"1\":{\"482\":1}}],[\"因为实际上这些区域在图上不是真正的连在一起所以我们需要一个虚拟的根节点\",{\"1\":{\"709\":1}}],[\"因为这座岛屿完全被水域包围\",{\"1\":{\"708\":1}}],[\"因为这样出栈的时候才是中左右的顺序\",{\"1\":{\"665\":1}}],[\"因为他们是相邻的\",{\"1\":{\"698\":1}}],[\"因为是从左上往右下移动\",{\"1\":{\"696\":1}}],[\"因为顺序更新\",{\"1\":{\"687\":1}}],[\"因为新的一行只与上一行的数相关\",{\"1\":{\"687\":1}}],[\"因为新生代中的对象生命周期短暂\",{\"1\":{\"148\":1}}],[\"因为queue1中的元素和栈中的保持一致\",{\"1\":{\"657\":1}}],[\"因为无重复字符的最长子串是\",{\"1\":{\"647\":1}}],[\"因为无需频繁创建对象\",{\"1\":{\"492\":1}}],[\"因为要找的也就是每2\",{\"1\":{\"643\":1}}],[\"因为要等更多slave重新连按过来\",{\"1\":{\"204\":1}}],[\"因为最大平方值肯定是出现再最两边数的平方\",{\"1\":{\"629\":1}}],[\"因为最后的值还是a\",{\"1\":{\"299\":1}}],[\"因为一旦有重复元素\",{\"1\":{\"620\":1}}],[\"因为一般的系统调用系统函数的时候\",{\"1\":{\"186\":1}}],[\"因为二级缓存中可能会有其他\",{\"1\":{\"537\":1}}],[\"因为浮点类型采用二进制系统表示\",{\"1\":{\"492\":1}}],[\"因为浮点数默认是double类型\",{\"1\":{\"358\":1}}],[\"因为equals是通过hashcode来比较的\",{\"1\":{\"492\":1}}],[\"因为接口中的类默认是静态类型\",{\"1\":{\"458\":1}}],[\"因为其父类的char\",{\"1\":{\"430\":1}}],[\"因为定义str1时\",{\"1\":{\"429\":1}}],[\"因为==比对的是是不是同一个类变量\",{\"1\":{\"428\":1}}],[\"因为隐式的继承了enum类\",{\"1\":{\"421\":1}}],[\"因为有默认值\",{\"1\":{\"391\":1}}],[\"因为\",{\"1\":{\"365\":1,\"436\":1,\"478\":1,\"479\":1,\"628\":1}}],[\"因为130超过byte的最大值127所以造成了溢出\",{\"1\":{\"359\":1}}],[\"因为1\",{\"1\":{\"359\":1}}],[\"因为条件队列只在持有独占模式时访问\",{\"1\":{\"312\":1}}],[\"因为头节点永远不会被取消\",{\"1\":{\"312\":1}}],[\"因为每一个线程访问threadlocal实例时\",{\"1\":{\"303\":1}}],[\"因为每次读取一个节点时需要读取更多的数据\",{\"1\":{\"172\":1}}],[\"因为建立和销毁\",{\"1\":{\"209\":1}}],[\"因为第一种方案存在问题是\",{\"1\":{\"195\":1}}],[\"因为多个元素可能映射到位数组上相同的位\",{\"1\":{\"194\":2}}],[\"因为aof文件保存的数据集通常比rdb文件所保存的数据集更完整\",{\"1\":{\"189\":1}}],[\"因为大多数请求不会是\",{\"1\":{\"187\":1}}],[\"因为在通信过程中\",{\"1\":{\"156\":1}}],[\"因为在这些应用中\",{\"1\":{\"156\":1}}],[\"因为在merge前\",{\"1\":{\"86\":1}}],[\"因为老年代中的对象生命周期较长\",{\"1\":{\"148\":1}}],[\"因为它不能表示成为1\",{\"1\":{\"492\":1}}],[\"因为它提供了更细粒度的控制和高级特性\",{\"1\":{\"142\":1}}],[\"因为它读取字符时直接将字符存入内存缓冲区\",{\"1\":{\"55\":1}}],[\"因为synchronized是jvm层面的内置特性\",{\"1\":{\"142\":1}}],[\"因为底层数组的连续存储特性\",{\"1\":{\"122\":1}}],[\"因为数组的长度是固定的\",{\"1\":{\"122\":1}}],[\"因为需要根据\",{\"1\":{\"7\":1}}],[\"因此id\",{\"1\":{\"709\":2}}],[\"因此只需要\",{\"1\":{\"628\":1}}],[\"因此程序可以在任何linux\",{\"1\":{\"609\":1}}],[\"因此优化feign性能的步骤主要包括\",{\"1\":{\"606\":1}}],[\"因此可以看出\",{\"1\":{\"299\":1}}],[\"因此可以借助于\",{\"1\":{\"15\":1}}],[\"因此它无法感知该变量的值已经被修改\",{\"1\":{\"291\":1}}],[\"因此在单线程的情况下使用\",{\"1\":{\"431\":1}}],[\"因此在首个阻塞节点被唤醒后\",{\"1\":{\"318\":1}}],[\"因此在获得数据的时候会先加锁\",{\"1\":{\"258\":1}}],[\"因此在查找某个关键字时\",{\"1\":{\"172\":1}}],[\"因此这部分操作通常不会是性能瓶颈\",{\"1\":{\"187\":1}}],[\"因此事务的操作如果成功就必须要完全应用到数据库\",{\"1\":{\"170\":1}}],[\"因此传输速度更快\",{\"1\":{\"156\":1}}],[\"因此对数据传输的可靠性没有严格要求\",{\"1\":{\"156\":1}}],[\"因此每次使用该变量时都要直接从主内存中获取最新的值\",{\"1\":{\"138\":1}}],[\"因此\",{\"1\":{\"12\":1,\"179\":1,\"187\":1,\"201\":1,\"292\":1,\"312\":1,\"678\":1}}],[\"因此该右值对象即刻失去了对指针的\",{\"1\":{\"3\":1}}],[\"次可以初始化一个或多个块\",{\"1\":{\"718\":1}}],[\"次旅行有\",{\"1\":{\"677\":1}}],[\"次操作后的数组\",{\"1\":{\"676\":1}}],[\"次序规则\",{\"0\":{\"281\":1}}],[\"次\",{\"1\":{\"7\":1,\"431\":2}}],[\"他需要函数式接口的支持\",{\"1\":{\"129\":1}}],[\"他的写法是使用一个\",{\"1\":{\"129\":1}}],[\"他们恰好合作了\",{\"1\":{\"7\":1}}],[\"他在某一天使用某个设备注销之前登录并玩了很多游戏\",{\"1\":{\"5\":1}}],[\"表中第\",{\"1\":{\"678\":1}}],[\"表名称\",{\"1\":{\"605\":7}}],[\"表明该对象在任一时刻只能由一个线程访问\",{\"1\":{\"471\":1}}],[\"表明这个构造器如果正常运行会产生一个fileinputstream对象\",{\"1\":{\"425\":1}}],[\"表达式的局部变量可以不用声明为\",{\"1\":{\"491\":1}}],[\"表达式只能引用标记了\",{\"1\":{\"491\":1}}],[\"表达式实例\",{\"0\":{\"489\":1}}],[\"表达式中的返回值必须是byte\",{\"1\":{\"372\":1}}],[\"表达式2\",{\"1\":{\"366\":1}}],[\"表达式1\",{\"1\":{\"366\":1}}],[\"表达式\",{\"1\":{\"365\":1,\"372\":2,\"687\":2}}],[\"表扫描方式等\",{\"1\":{\"182\":1}}],[\"表示当客户端发送附带条件的请求时\",{\"1\":{\"775\":1}}],[\"表示当前对象\",{\"1\":{\"400\":1}}],[\"表示当前线程还持有锁\",{\"1\":{\"141\":1}}],[\"表示当前线程已经完全释放了锁\",{\"1\":{\"141\":1}}],[\"表示当前线程获取到锁\",{\"1\":{\"141\":1}}],[\"表示由于请求的资源存在着另一个\",{\"1\":{\"775\":1}}],[\"表示请求的资源已被分配了新的uri\",{\"1\":{\"775\":2}}],[\"表示请求已正确处理\",{\"1\":{\"774\":1}}],[\"表示请求处理结果的状态码\",{\"1\":{\"760\":1}}],[\"表示客户端发来得请求在服务器端被正常处理了\",{\"1\":{\"774\":1}}],[\"表示http协议的版本号\",{\"1\":{\"760\":2}}],[\"表示方法\",{\"1\":{\"760\":1}}],[\"表示它最近使用过\",{\"1\":{\"720\":2}}],[\"表示模块的序号\",{\"1\":{\"718\":1}}],[\"表示模块总数n\",{\"1\":{\"718\":1}}],[\"表示待遍历的图\",{\"1\":{\"718\":1}}],[\"表示如果要学习课程\",{\"1\":{\"717\":1}}],[\"表示对范围请求的正确处理\",{\"1\":{\"774\":1}}],[\"表示对于前i个物品\",{\"1\":{\"700\":1}}],[\"表示对其修饰的部分进行加锁\",{\"1\":{\"138\":1}}],[\"表示截取的记号\",{\"1\":{\"688\":1}}],[\"表示表中剩余元素数\",{\"1\":{\"683\":1}}],[\"表示剩余需要的元素数\",{\"1\":{\"683\":1}}],[\"表示递归的深度\",{\"1\":{\"683\":1}}],[\"表示宽度\",{\"1\":{\"683\":1}}],[\"表示第\",{\"1\":{\"677\":1}}],[\"表示本层元素的大小\",{\"1\":{\"666\":1,\"669\":1}}],[\"表示\",{\"1\":{\"631\":1,\"650\":1,\"694\":1,\"717\":1}}],[\"表示为蓝色部分\",{\"1\":{\"625\":1}}],[\"表示的高度图\",{\"1\":{\"624\":1}}],[\"表示多实例\",{\"1\":{\"559\":1}}],[\"表示单实例\",{\"1\":{\"559\":1}}],[\"表示循环的内容以什么结束\",{\"1\":{\"531\":1}}],[\"表示循环的内容以什么开始\",{\"1\":{\"531\":1}}],[\"表示不使用数据库连接池\",{\"1\":{\"506\":1}}],[\"表示使用上下文中的数据源\",{\"1\":{\"506\":1}}],[\"表示使用数据库连接池\",{\"1\":{\"506\":1}}],[\"表示使用原生的事务管理方式\",{\"1\":{\"506\":1}}],[\"表示放置该bean对象的属性值\",{\"1\":{\"501\":1}}],[\"表示形式\",{\"1\":{\"482\":1}}],[\"表示以第i个数结尾的最大连续数组和\",{\"1\":{\"693\":1}}],[\"表示以覆盖的方式写入\",{\"1\":{\"478\":1}}],[\"表示以追加的方式写入\",{\"1\":{\"478\":1}}],[\"表示文件读取完毕\",{\"1\":{\"478\":2}}],[\"表示整个方法为同步方法\",{\"1\":{\"470\":1}}],[\"表示可匹配零个或多个\",{\"1\":{\"702\":1}}],[\"表示可以有多个泛型成员\",{\"1\":{\"457\":1}}],[\"表示可用的许可数量\",{\"1\":{\"144\":1}}],[\"表示存放到arraylist集合中的元素是dog类型\",{\"1\":{\"454\":1}}],[\"表示存在多个共享锁可以获取\",{\"1\":{\"318\":1}}],[\"表示存在竞争\",{\"1\":{\"139\":1}}],[\"表示某个程序元素\",{\"1\":{\"422\":1}}],[\"表示重写父类方法\",{\"1\":{\"422\":1}}],[\"表示判断对象的值是否相等\",{\"1\":{\"406\":2}}],[\"表示跳出所在方法\",{\"1\":{\"379\":1}}],[\"表示接收下一个数\",{\"1\":{\"368\":1}}],[\"表示servlet的上下文\",{\"1\":{\"331\":1}}],[\"表示仅当前节点可被唤醒\",{\"1\":{\"318\":1}}],[\"表示下一个acquireshared操作应该无条件地传播\",{\"1\":{\"312\":1}}],[\"表示线程正在等待条件\",{\"1\":{\"312\":1}}],[\"表示线程已取消\",{\"1\":{\"312\":1}}],[\"表示后继节点的线程需要唤醒\",{\"1\":{\"312\":1}}],[\"表示节点正在以独占模式等待的标记\",{\"1\":{\"312\":1}}],[\"表示节点正在以共享模式等待的标记\",{\"1\":{\"312\":1}}],[\"表示一批独立的交换器\",{\"1\":{\"209\":1}}],[\"表示一个受spring容器管理的组件\",{\"1\":{\"69\":1}}],[\"表示消息队列服务器实体\",{\"1\":{\"209\":1}}],[\"表示jvm中的内存不足\",{\"1\":{\"146\":1}}],[\"表示计数器的值\",{\"1\":{\"144\":1}}],[\"表示有其他线程持有锁\",{\"1\":{\"141\":1}}],[\"表示该变量在多线程环境下可能被其他线程修改\",{\"1\":{\"138\":1}}],[\"表示参数是只读的\",{\"1\":{\"127\":1}}],[\"表示每天的温度\",{\"1\":{\"622\":1}}],[\"表示每个http会话都将创建一个新的bean实例\",{\"1\":{\"65\":1}}],[\"表示每个http请求都将创建一个新的bean实例\",{\"1\":{\"65\":1}}],[\"表示每次调用时都会创建一个新的bean实例\",{\"1\":{\"65\":1}}],[\"表示在整个应用程序上下文中只存在一个共享的bean实例\",{\"1\":{\"65\":1}}],[\"表\",{\"1\":{\"7\":2}}],[\"合作过至少三次的演员和导演\",{\"1\":{\"7\":1}}],[\"其总和都相等\",{\"1\":{\"689\":1}}],[\"其余字符保持原样\",{\"1\":{\"643\":1}}],[\"其余exception是不可预测的异常\",{\"1\":{\"424\":1}}],[\"其作用是将输入的字符串反转过来\",{\"1\":{\"642\":1}}],[\"其作用的范围是\",{\"1\":{\"259\":4}}],[\"其元素按升序排列\",{\"1\":{\"628\":1}}],[\"其原理是通过字节码技术为一个类创建子类\",{\"1\":{\"492\":1}}],[\"其次\",{\"1\":{\"267\":1}}],[\"其拥有独立的权限系统\",{\"1\":{\"209\":1}}],[\"其后所有待执行的语占都将不会被服务器执行\",{\"1\":{\"201\":1}}],[\"其后的命令仍然会被继续执行\",{\"1\":{\"201\":1}}],[\"其核心网络模型使用的是单线程\",{\"1\":{\"187\":1}}],[\"其值不能再被修改\",{\"1\":{\"127\":1}}],[\"其通常由各个部分的子对象用一定的算法构成\",{\"1\":{\"107\":1}}],[\"其实在遍历字符串的过程中\",{\"1\":{\"643\":1}}],[\"其实也是调用迭代器方法\",{\"1\":{\"439\":1}}],[\"其实还有一个不那么文邹邹的翻译\",{\"1\":{\"95\":1}}],[\"其实我们日常开发中已经在享受设计模式带来的便利性和高效率了\",{\"1\":{\"93\":1}}],[\"其实是通过mapperfactorybean内部的getobject\",{\"1\":{\"83\":1}}],[\"其他首部字段\",{\"0\":{\"786\":1}}],[\"其他因为编程错误或偶然的外在因素导致的一般性问题\",{\"1\":{\"424\":1}}],[\"其他类\",{\"1\":{\"418\":1}}],[\"其他位取反\",{\"1\":{\"369\":1}}],[\"其他需要此bean的组件就可以通过singletonobjects缓存获取到该bean的实例\",{\"1\":{\"163\":1}}],[\"其他线程调用了该线程的suspend\",{\"1\":{\"472\":1}}],[\"其他线程都不可以对这个内存地址进行操作\",{\"1\":{\"470\":1}}],[\"其他线程能够立即知道\",{\"1\":{\"277\":1}}],[\"其他线程能够立即看到最新的值\",{\"1\":{\"128\":1}}],[\"其他线程会死等\",{\"1\":{\"261\":1}}],[\"其他线程可能无法立即看到这个修改\",{\"1\":{\"140\":1}}],[\"其他线程需要等待锁释放\",{\"1\":{\"138\":1}}],[\"其他步骤在子类实现\",{\"1\":{\"104\":1}}],[\"其他三个注解是\",{\"1\":{\"69\":1}}],[\"其他的shared\",{\"1\":{\"3\":1}}],[\"其中每一块都会由一个16进制数来标记块的大小\",{\"1\":{\"768\":1}}],[\"其中每个节点都有一个介于\",{\"1\":{\"716\":1}}],[\"其中right递增\",{\"1\":{\"631\":1}}],[\"其中加载阶段需要完成以下3件事情\",{\"1\":{\"419\":1}}],[\"其中字母占一个字节\",{\"1\":{\"356\":1}}],[\"其中node节点的结构如下\",{\"1\":{\"312\":1}}],[\"其中包含路由键\",{\"1\":{\"210\":1}}],[\"其中一些支持事务的存储引擎包括\",{\"1\":{\"183\":1}}],[\"其中一个事务的修改结果可能会被另一个事务的覆盖\",{\"1\":{\"171\":1}}],[\"其中\",{\"1\":{\"68\":1,\"69\":1,\"113\":1,\"456\":1,\"622\":1,\"631\":1,\"660\":2,\"676\":1,\"694\":1,\"705\":1,\"716\":1,\"717\":1}}],[\"其语法结构如下\",{\"1\":{\"6\":1}}],[\"对一份10\",{\"1\":{\"770\":1}}],[\"对一个class对象使用getconstrouctor\",{\"1\":{\"486\":1}}],[\"对一个volatile变量的写操作先行发生于后面对这个变量的读操作\",{\"1\":{\"283\":1}}],[\"对一个volatile变量进行自增操作\",{\"1\":{\"128\":1}}],[\"对服务器自身发送请求\",{\"1\":{\"762\":1}}],[\"对称二叉树\",{\"0\":{\"668\":1}}],[\"对称密钥\",{\"1\":{\"155\":1}}],[\"对业务功能对系统进行拆分\",{\"1\":{\"595\":1}}],[\"对扫描加上过滤\",{\"1\":{\"563\":2}}],[\"对string类型字段调用trim\",{\"1\":{\"540\":1}}],[\"对集合进行遍历时\",{\"1\":{\"447\":1}}],[\"对这两类进行计算\",{\"1\":{\"435\":1}}],[\"对某个类只能存在一个对象实例\",{\"1\":{\"414\":1}}],[\"对比\",{\"1\":{\"406\":1}}],[\"对计算结果进行消费\",{\"1\":{\"244\":1}}],[\"对计算结果进行处理\",{\"1\":{\"242\":1}}],[\"对所有\",{\"1\":{\"202\":1}}],[\"对数据的操作也简单\",{\"1\":{\"186\":1}}],[\"对应26个字母\",{\"1\":{\"674\":1}}],[\"对应的\",{\"1\":{\"649\":1}}],[\"对应的用户信息和其他需要保存的数据\",{\"1\":{\"165\":1}}],[\"对应上方三步\",{\"1\":{\"637\":1}}],[\"对应数据库表\",{\"1\":{\"576\":1}}],[\"对应不同的一级缓存\",{\"1\":{\"534\":1}}],[\"对应\",{\"1\":{\"477\":1,\"522\":1}}],[\"对应用程序进行实时监测和分析\",{\"1\":{\"146\":1}}],[\"对带有volatile关键字修饰的变量的写操作会立即刷新到主内存中\",{\"1\":{\"138\":1}}],[\"对我们之后开发会有很大的帮助\",{\"1\":{\"93\":1}}],[\"对于本题而言\",{\"1\":{\"651\":1}}],[\"对于final方法\",{\"1\":{\"492\":1}}],[\"对于引用数据类型\",{\"1\":{\"492\":1}}],[\"对于引用型变量只是把变量的地址传递\",{\"1\":{\"388\":1}}],[\"对于8种基本数据类型\",{\"1\":{\"492\":1}}],[\"对于只有一个抽象方法得接口\",{\"1\":{\"490\":1}}],[\"对于条件节点\",{\"1\":{\"312\":1}}],[\"对于普通同步节点\",{\"1\":{\"312\":1}}],[\"对于原子操作\",{\"1\":{\"293\":1}}],[\"对于真正的异步处理我们希望可以通过传入回调函数\",{\"1\":{\"235\":1}}],[\"对于不再需要的键值对\",{\"1\":{\"200\":1}}],[\"对于一个链表\",{\"1\":{\"729\":1}}],[\"对于一个线程内代码的执行并不一定是从上到下有序执行\",{\"1\":{\"278\":1}}],[\"对于一个\",{\"1\":{\"187\":1}}],[\"对于一个联合索引\",{\"1\":{\"175\":1}}],[\"对于一致性读操作\",{\"1\":{\"178\":1}}],[\"对于经常被查询的数据\",{\"1\":{\"167\":1}}],[\"对于共享锁来说\",{\"1\":{\"141\":1}}],[\"对于独占锁来说\",{\"1\":{\"141\":1}}],[\"对于volatile修饰的变量\",{\"1\":{\"140\":1}}],[\"对于相同的键对象\",{\"1\":{\"124\":1}}],[\"对于arraylist\",{\"1\":{\"122\":1}}],[\"对于拉丁字符\",{\"1\":{\"121\":1}}],[\"对于两个独立变化的维度\",{\"1\":{\"113\":1}}],[\"对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统\",{\"1\":{\"113\":1}}],[\"对于浏览器来说几乎不可能\",{\"1\":{\"95\":1}}],[\"对于\",{\"1\":{\"41\":1,\"648\":1,\"716\":1}}],[\"对于月末的日期的加减会有问题\",{\"1\":{\"5\":1}}],[\"对是\",{\"1\":{\"7\":1}}],[\"对\",{\"1\":{\"7\":1,\"16\":1,\"430\":1,\"571\":1}}],[\"对象类型数组的注入\",{\"1\":{\"557\":1}}],[\"对象流介绍\",{\"1\":{\"478\":1}}],[\"对象流\",{\"1\":{\"478\":1}}],[\"对象互斥锁\",{\"1\":{\"471\":1}}],[\"对象锁\",{\"1\":{\"471\":6}}],[\"对象来进行格式化\",{\"1\":{\"436\":1}}],[\"对象来获取返回值\",{\"1\":{\"132\":1}}],[\"对象内存布局\",{\"0\":{\"385\":1}}],[\"对象是类的实例\",{\"1\":{\"384\":1}}],[\"对象的地址\",{\"1\":{\"483\":1}}],[\"对象的主机名\",{\"1\":{\"483\":1}}],[\"对象的监视权\",{\"1\":{\"471\":2}}],[\"对象的多态\",{\"1\":{\"402\":1}}],[\"对象的原子操作类\",{\"0\":{\"297\":1}}],[\"对象的mark\",{\"1\":{\"139\":1}}],[\"对象终结规则\",{\"0\":{\"288\":1}}],[\"对象关系映射\",{\"1\":{\"168\":1}}],[\"对象获取任务的返回结果\",{\"1\":{\"132\":1}}],[\"对象值在\",{\"1\":{\"130\":1}}],[\"对象有什么好处\",{\"0\":{\"130\":1}}],[\"对象已经获取到了\",{\"1\":{\"66\":1,\"560\":1}}],[\"对象创建\",{\"1\":{\"63\":1,\"552\":1,\"555\":1,\"564\":1}}],[\"对象\",{\"1\":{\"3\":1,\"130\":1,\"132\":1,\"161\":1,\"297\":1,\"389\":1,\"419\":1,\"430\":1,\"436\":2,\"470\":1,\"477\":1,\"478\":2,\"489\":1,\"495\":1,\"572\":1,\"575\":2,\"721\":1}}],[\"对象进行构造\",{\"1\":{\"3\":1}}],[\"gnu\",{\"1\":{\"768\":1}}],[\"ghi\",{\"1\":{\"684\":1}}],[\"gzip\",{\"1\":{\"768\":1}}],[\"gz\",{\"1\":{\"616\":2}}],[\"g\",{\"1\":{\"614\":2,\"699\":7}}],[\"gmt\",{\"1\":{\"605\":2,\"760\":1}}],[\"gmw\",{\"1\":{\"111\":3}}],[\"gs\",{\"1\":{\"490\":2}}],[\"girlfriend\",{\"1\":{\"414\":9}}],[\"github\",{\"1\":{\"599\":1,\"606\":1}}],[\"github的release下载页\",{\"1\":{\"599\":1}}],[\"git\",{\"0\":{\"85\":1,\"86\":1},\"1\":{\"86\":8,\"593\":1}}],[\"gcc\",{\"1\":{\"616\":1}}],[\"gc\",{\"1\":{\"406\":1,\"434\":1}}],[\"gc线程\",{\"1\":{\"223\":1}}],[\"glashfish\",{\"1\":{\"324\":1}}],[\"globalcors\",{\"1\":{\"607\":1}}],[\"globalfilter的顺序执行\",{\"1\":{\"607\":1}}],[\"globalfilter通过实现ordered接口\",{\"1\":{\"607\":1}}],[\"globalfilter\",{\"1\":{\"607\":1}}],[\"global\",{\"1\":{\"65\":1}}],[\"good\",{\"1\":{\"645\":2}}],[\"goodsprice\",{\"1\":{\"430\":5}}],[\"goodsname\",{\"1\":{\"430\":3}}],[\"goods\",{\"1\":{\"430\":2}}],[\"google\",{\"1\":{\"111\":4,\"168\":1}}],[\"gossip\",{\"1\":{\"203\":1}}],[\"gatewayfilterchain\",{\"1\":{\"607\":1}}],[\"gatewayfilter通过配置文件定义\",{\"1\":{\"607\":1}}],[\"gateway有11种断言工厂\",{\"1\":{\"607\":1}}],[\"gateway\",{\"1\":{\"607\":5,\"617\":2}}],[\"gap\",{\"1\":{\"178\":1,\"639\":2}}],[\"game\",{\"1\":{\"5\":1}}],[\"games\",{\"1\":{\"5\":8}}],[\"guice\",{\"1\":{\"168\":1}}],[\"graph\",{\"1\":{\"715\":16,\"716\":16,\"717\":10}}],[\"grandpa\",{\"1\":{\"399\":3}}],[\"greetservice1\",{\"1\":{\"491\":2}}],[\"greetingservice\",{\"1\":{\"490\":2,\"491\":2}}],[\"greetings\",{\"1\":{\"108\":1}}],[\"grid\",{\"1\":{\"91\":4,\"704\":11,\"706\":16,\"707\":15,\"708\":25,\"709\":21}}],[\"groovy\",{\"1\":{\"81\":1}}],[\"groupid>\",{\"1\":{\"498\":5,\"540\":11,\"597\":1,\"599\":2,\"602\":1,\"606\":2}}],[\"group\",{\"0\":{\"7\":1},\"1\":{\"5\":1,\"184\":6,\"214\":1,\"220\":2,\"605\":7}}],[\"gender\",{\"1\":{\"522\":4,\"523\":3,\"524\":1,\"525\":2,\"527\":2,\"528\":1,\"529\":1,\"530\":1,\"532\":2,\"557\":6}}],[\"generic01\",{\"1\":{\"457\":1}}],[\"generateparenthesis\",{\"1\":{\"690\":1}}],[\"generatematrix\",{\"1\":{\"632\":1}}],[\"generateclassfile\",{\"1\":{\"419\":1}}],[\"generatorconfiguration>\",{\"1\":{\"540\":1}}],[\"generatorconfiguration\",{\"1\":{\"540\":1}}],[\"generatorconfig\",{\"1\":{\"540\":1}}],[\"generator<\",{\"1\":{\"540\":3}}],[\"generator\",{\"1\":{\"540\":6}}],[\"generational\",{\"1\":{\"148\":1}}],[\"generation\",{\"1\":{\"72\":1}}],[\"general\",{\"1\":{\"177\":1}}],[\"geii\",{\"1\":{\"403\":3}}],[\"getrandom\",{\"1\":{\"721\":2}}],[\"getresponse\",{\"1\":{\"607\":2}}],[\"getresourceasstream\",{\"1\":{\"502\":1}}],[\"getrequest\",{\"1\":{\"607\":1}}],[\"getrequestdispatcher\",{\"1\":{\"334\":1,\"339\":1}}],[\"getreference\",{\"1\":{\"300\":2}}],[\"getlast\",{\"1\":{\"661\":1}}],[\"getlogger\",{\"1\":{\"586\":1}}],[\"getlocalhost\",{\"1\":{\"483\":2,\"485\":1}}],[\"getqueryparams\",{\"1\":{\"607\":1}}],[\"geturi\",{\"1\":{\"598\":1}}],[\"getuserstatus\",{\"1\":{\"576\":2,\"577\":2}}],[\"getusername\",{\"1\":{\"576\":3,\"577\":3}}],[\"getuserid\",{\"1\":{\"576\":2,\"577\":3,\"597\":1,\"598\":1,\"606\":1}}],[\"getuserdao\",{\"1\":{\"564\":2,\"565\":1}}],[\"getuserfromtable\",{\"1\":{\"519\":3}}],[\"getuserbylike\",{\"1\":{\"517\":3}}],[\"getuserbyusername\",{\"1\":{\"511\":3}}],[\"getuserbyidtomap\",{\"1\":{\"514\":1,\"515\":1}}],[\"getuserbyid\",{\"1\":{\"504\":3}}],[\"getjdbctemplate\",{\"1\":{\"584\":1}}],[\"getemplistbychoose\",{\"1\":{\"530\":2}}],[\"getemplistbycondition\",{\"1\":{\"527\":2,\"528\":1,\"529\":1,\"532\":1}}],[\"getemplistbyid\",{\"1\":{\"525\":1}}],[\"getempname\",{\"1\":{\"524\":1}}],[\"getempanddeptbystep\",{\"1\":{\"523\":1,\"524\":4}}],[\"getempanddeptbyid\",{\"1\":{\"523\":1}}],[\"getempbyid\",{\"1\":{\"522\":3}}],[\"getentry\",{\"1\":{\"307\":1}}],[\"getconstrouctors\",{\"1\":{\"486\":1}}],[\"getclassloader\",{\"1\":{\"419\":1,\"569\":1}}],[\"getclass\",{\"1\":{\"406\":1,\"418\":2,\"419\":3,\"445\":2,\"457\":1,\"459\":4,\"485\":2,\"486\":2}}],[\"getfirst\",{\"1\":{\"607\":1,\"661\":2}}],[\"getfields\",{\"1\":{\"486\":1}}],[\"getforobject\",{\"1\":{\"597\":1,\"606\":1}}],[\"getfactory\",{\"1\":{\"111\":2}}],[\"gethost\",{\"1\":{\"598\":1}}],[\"gethostaddress\",{\"1\":{\"483\":3}}],[\"gethostname\",{\"1\":{\"483\":3}}],[\"gethour\",{\"1\":{\"436\":1}}],[\"getheader方法获得头\",{\"1\":{\"333\":1}}],[\"getdateformat\",{\"1\":{\"603\":1}}],[\"getdatasourcetransactionmanager\",{\"1\":{\"584\":1}}],[\"getdayofmonth\",{\"1\":{\"436\":1}}],[\"getdruiddatasource\",{\"1\":{\"584\":1}}],[\"getdepth\",{\"1\":{\"669\":4}}],[\"getdeptandempbystep\",{\"1\":{\"525\":2}}],[\"getdeptandempbyid\",{\"1\":{\"525\":1}}],[\"getdeptbyid\",{\"1\":{\"523\":2,\"524\":1}}],[\"getdeclaredfield\",{\"1\":{\"486\":1}}],[\"getdeclaredfields\",{\"1\":{\"486\":1}}],[\"getdeclaredconstrouctors\",{\"1\":{\"486\":1}}],[\"getdeclaredmethods\",{\"1\":{\"486\":1}}],[\"getdeclaringclass\",{\"1\":{\"421\":1}}],[\"getdesc\",{\"1\":{\"421\":1}}],[\"getyear\",{\"1\":{\"436\":1}}],[\"getwriter\",{\"1\":{\"335\":1}}],[\"getordefault\",{\"1\":{\"631\":1,\"649\":2,\"671\":1,\"672\":2,\"699\":8}}],[\"getorder\",{\"1\":{\"607\":1}}],[\"getoname\",{\"1\":{\"560\":2}}],[\"getoutputstream\",{\"1\":{\"335\":1,\"485\":1}}],[\"getowners\",{\"1\":{\"102\":1}}],[\"getowner\",{\"1\":{\"102\":2}}],[\"getabsolutepath\",{\"1\":{\"475\":3}}],[\"getauthor\",{\"1\":{\"440\":1}}],[\"getage\",{\"1\":{\"404\":1}}],[\"getattribute\",{\"1\":{\"334\":1,\"339\":1}}],[\"getadd\",{\"1\":{\"63\":3,\"555\":3}}],[\"getparent\",{\"1\":{\"475\":3}}],[\"getparameter\",{\"1\":{\"334\":2}}],[\"getparametervalues获得一个参数的数组\",{\"1\":{\"333\":1}}],[\"getparameter方法获得对应参数\",{\"1\":{\"333\":1}}],[\"getproperty\",{\"1\":{\"480\":3}}],[\"getproperties\",{\"1\":{\"419\":1}}],[\"getpriority\",{\"1\":{\"468\":1}}],[\"getpricebycompletablefuture\",{\"1\":{\"256\":2}}],[\"getprice\",{\"1\":{\"256\":2,\"433\":5,\"440\":3}}],[\"getmethod\",{\"1\":{\"486\":2}}],[\"getmethods\",{\"1\":{\"486\":1}}],[\"getmessage\",{\"1\":{\"249\":1}}],[\"getminute\",{\"1\":{\"436\":1}}],[\"getmonthvalue\",{\"1\":{\"436\":1}}],[\"getmonth\",{\"1\":{\"436\":1}}],[\"getmapping\",{\"1\":{\"603\":1,\"606\":1}}],[\"getmapper\",{\"1\":{\"502\":1,\"512\":1,\"524\":1,\"530\":1}}],[\"getmap\",{\"1\":{\"306\":1,\"307\":2}}],[\"getsqlsession\",{\"1\":{\"512\":1,\"524\":1,\"530\":1}}],[\"getstate\",{\"1\":{\"469\":4}}],[\"getstamp\",{\"1\":{\"300\":4}}],[\"getsalary\",{\"1\":{\"404\":1,\"486\":2}}],[\"getscore\",{\"1\":{\"404\":1}}],[\"getsecond\",{\"1\":{\"436\":1}}],[\"getsession\",{\"1\":{\"339\":1}}],[\"getservletcontext\",{\"1\":{\"330\":1}}],[\"getservletname\",{\"1\":{\"330\":1}}],[\"getservice\",{\"1\":{\"70\":1}}],[\"getnext\",{\"1\":{\"653\":2}}],[\"getnetmallname\",{\"1\":{\"256\":2}}],[\"getnow\",{\"1\":{\"241\":1}}],[\"getnow方法\",{\"0\":{\"241\":1}}],[\"getname\",{\"1\":{\"233\":3,\"249\":1,\"262\":1,\"268\":12,\"271\":12,\"298\":3,\"304\":2,\"313\":4,\"404\":1,\"406\":1,\"414\":1,\"433\":3,\"440\":1,\"468\":3,\"469\":3,\"471\":4,\"475\":3,\"478\":1,\"486\":3,\"565\":1,\"569\":1,\"583\":1}}],[\"get方法依然是先获取到当前线程\",{\"1\":{\"307\":1}}],[\"get方法会引起阻塞\",{\"1\":{\"233\":2}}],[\"get方法\",{\"0\":{\"233\":1,\"240\":1,\"307\":1}}],[\"get\",{\"1\":{\"117\":1,\"129\":1,\"161\":1,\"232\":1,\"233\":1,\"240\":1,\"248\":1,\"251\":1,\"253\":1,\"268\":1,\"297\":1,\"298\":1,\"304\":3,\"307\":1,\"332\":1,\"436\":12,\"440\":3,\"443\":1,\"448\":3,\"458\":2,\"486\":1,\"607\":1,\"626\":1,\"631\":2,\"635\":2,\"648\":6,\"649\":5,\"657\":1,\"658\":1,\"661\":1,\"671\":1,\"672\":1,\"689\":1,\"701\":1,\"718\":4,\"720\":16,\"721\":3,\"760\":2,\"762\":2,\"763\":1,\"775\":2}}],[\"getbalance\",{\"1\":{\"583\":1}}],[\"getbean\",{\"1\":{\"552\":1,\"557\":1,\"559\":2,\"560\":1,\"565\":1,\"576\":1,\"583\":1,\"584\":1}}],[\"getbyname\",{\"1\":{\"483\":4}}],[\"getbytes\",{\"1\":{\"105\":1,\"114\":1,\"117\":1,\"477\":1,\"479\":1,\"485\":1}}],[\"getbuffer\",{\"1\":{\"108\":2}}],[\"getintersectionnode\",{\"1\":{\"639\":1}}],[\"getinterfaces\",{\"1\":{\"419\":1}}],[\"getinputstream\",{\"1\":{\"485\":2}}],[\"getinitparameternames\",{\"1\":{\"330\":1}}],[\"getinitparameter\",{\"1\":{\"330\":1}}],[\"getinstance\",{\"1\":{\"99\":3,\"292\":1,\"414\":6,\"436\":1}}],[\"getid\",{\"1\":{\"102\":2,\"583\":2}}],[\"ai\",{\"1\":{\"717\":2}}],[\"ainstance\",{\"1\":{\"461\":1}}],[\"af\",{\"1\":{\"684\":1}}],[\"afterthrow\",{\"1\":{\"572\":1}}],[\"afterthrowing\",{\"1\":{\"572\":1}}],[\"afterreturn\",{\"1\":{\"572\":1}}],[\"afterreturning\",{\"1\":{\"572\":1}}],[\"after\",{\"1\":{\"251\":6,\"419\":5,\"572\":2,\"607\":1}}],[\"ae\",{\"1\":{\"684\":1}}],[\"a58b\",{\"1\":{\"599\":1}}],[\"avg=sc\",{\"1\":{\"724\":1}}],[\"available\",{\"1\":{\"599\":1}}],[\"availabilityfilteringrule\",{\"1\":{\"598\":2}}],[\"avi\",{\"1\":{\"478\":2}}],[\"aggr`\",{\"1\":{\"605\":1}}],[\"aggr\",{\"1\":{\"605\":5}}],[\"aggressivelazyloading\",{\"1\":{\"524\":1}}],[\"age=37\",{\"1\":{\"760\":1}}],[\"age=\",{\"1\":{\"454\":1}}],[\"age\",{\"1\":{\"297\":1,\"368\":3,\"390\":6,\"392\":4,\"399\":1,\"404\":14,\"454\":5,\"522\":4,\"523\":3,\"524\":1,\"525\":2,\"527\":2,\"528\":1,\"529\":1,\"530\":1,\"532\":2}}],[\"a3\",{\"1\":{\"478\":1}}],[\"a<t>\",{\"1\":{\"461\":1}}],[\"a>\",{\"1\":{\"460\":2}}],[\"a><\",{\"1\":{\"111\":1}}],[\"amazonaws\",{\"1\":{\"598\":1}}],[\"amount\",{\"1\":{\"583\":11}}],[\"amethod\",{\"1\":{\"461\":1}}],[\"amy\",{\"1\":{\"443\":1}}],[\"amqp\",{\"0\":{\"208\":1},\"1\":{\"81\":1,\"209\":1}}],[\"a的静态代码块被执行\",{\"1\":{\"415\":1}}],[\"aab\",{\"1\":{\"688\":1}}],[\"aabaaf\",{\"1\":{\"653\":1}}],[\"aabaabaafa\",{\"1\":{\"653\":1}}],[\"aaaaa\",{\"1\":{\"651\":1}}],[\"aa的普通代码块2被执行\",{\"1\":{\"413\":2}}],[\"aa的普通代码块1被执行\",{\"1\":{\"413\":3}}],[\"aa的静态代码块2被执行\",{\"1\":{\"413\":2}}],[\"aa的静态代码块1被执行\",{\"1\":{\"413\":4}}],[\"aa的构造器\",{\"1\":{\"413\":2}}],[\"aa\",{\"1\":{\"413\":7,\"688\":1}}],[\"awesome\",{\"1\":{\"607\":1}}],[\"awt\",{\"1\":{\"396\":1}}],[\"await调用后\",{\"1\":{\"319\":1}}],[\"await\",{\"1\":{\"144\":2,\"271\":1}}],[\"alpine\",{\"1\":{\"616\":2}}],[\"alive\",{\"1\":{\"760\":1}}],[\"alibaba\",{\"1\":{\"562\":2,\"575\":1,\"583\":1,\"599\":6,\"602\":2}}],[\"alias=\",{\"1\":{\"499\":1,\"508\":2}}],[\"aliyun\",{\"1\":{\"498\":2,\"540\":2}}],[\"alt\",{\"1\":{\"395\":5}}],[\"allpathssourcetarget\",{\"1\":{\"715\":1}}],[\"allowcredentials\",{\"1\":{\"607\":1}}],[\"allowedheaders\",{\"1\":{\"607\":1}}],[\"allowedmethods\",{\"1\":{\"607\":1}}],[\"allowedorigins\",{\"1\":{\"607\":1}}],[\"allargsconstructor\",{\"1\":{\"252\":2,\"256\":1,\"297\":2,\"300\":1}}],[\"allkeys\",{\"1\":{\"192\":3}}],[\"adj\",{\"1\":{\"711\":1}}],[\"ad\",{\"1\":{\"684\":1}}],[\"adobecodebanc\",{\"1\":{\"648\":2}}],[\"advisor>\",{\"1\":{\"583\":1}}],[\"advisor\",{\"1\":{\"583\":1}}],[\"advice>\",{\"1\":{\"583\":1}}],[\"advice\",{\"1\":{\"583\":2}}],[\"admin功能弱\",{\"1\":{\"595\":1}}],[\"admin\",{\"1\":{\"339\":1,\"343\":1,\"501\":1,\"512\":2,\"593\":3,\"605\":1,\"607\":2}}],[\"adminfilter<\",{\"1\":{\"339\":1}}],[\"adminfilter\",{\"1\":{\"339\":1}}],[\"addlast\",{\"1\":{\"661\":1,\"662\":2}}],[\"addattail\",{\"1\":{\"635\":2}}],[\"addatindex\",{\"1\":{\"635\":6}}],[\"addathead\",{\"1\":{\"635\":2}}],[\"addall\",{\"1\":{\"439\":1,\"440\":2}}],[\"add方法\",{\"1\":{\"576\":1,\"577\":1}}],[\"adduser\",{\"1\":{\"576\":2}}],[\"addr\",{\"1\":{\"599\":2,\"602\":1,\"605\":1,\"607\":1}}],[\"addrequestheader=truth\",{\"1\":{\"607\":1}}],[\"addremain方法\",{\"1\":{\"583\":1}}],[\"addremain\",{\"1\":{\"583\":3}}],[\"addresourcehandlers\",{\"1\":{\"78\":1}}],[\"address>\",{\"1\":{\"111\":1}}],[\"address\",{\"1\":{\"67\":1,\"501\":1,\"520\":1}}],[\"addr命令\",{\"1\":{\"203\":1}}],[\"addwaiter\",{\"1\":{\"141\":1,\"312\":1}}],[\"addviewcontrollers\",{\"1\":{\"78\":1}}],[\"addinterceptors\",{\"1\":{\"78\":1}}],[\"addcorsmappings\",{\"1\":{\"78\":1}}],[\"add\",{\"1\":{\"5\":1,\"63\":2,\"91\":1,\"111\":16,\"220\":1,\"391\":1,\"435\":1,\"439\":4,\"440\":9,\"443\":4,\"444\":1,\"445\":2,\"451\":3,\"454\":7,\"552\":1,\"555\":2,\"557\":2,\"563\":2,\"564\":8,\"565\":1,\"569\":3,\"571\":2,\"572\":7,\"576\":3,\"577\":2,\"627\":3,\"648\":3,\"649\":1,\"659\":3,\"661\":1,\"664\":3,\"666\":2,\"669\":1,\"682\":1,\"683\":2,\"684\":1,\"685\":2,\"686\":4,\"688\":2,\"690\":1,\"711\":2,\"713\":4,\"715\":5,\"717\":1,\"718\":3,\"721\":1,\"729\":1}}],[\"a标签\",{\"1\":{\"332\":1}}],[\"a线程先进来调用lock方法锁5秒钟\",{\"1\":{\"298\":1}}],[\"auc\",{\"1\":{\"248\":1}}],[\"autoreconnect=true\",{\"1\":{\"605\":1}}],[\"auto\",{\"1\":{\"605\":9}}],[\"autoproxy>\",{\"1\":{\"572\":1}}],[\"autoproxy><\",{\"1\":{\"572\":1}}],[\"autowire=\",{\"1\":{\"561\":1}}],[\"autowire\",{\"1\":{\"561\":2}}],[\"autowired\",{\"1\":{\"68\":1,\"71\":1,\"564\":4,\"575\":2,\"576\":2,\"577\":1,\"583\":2,\"603\":2}}],[\"auth\",{\"1\":{\"607\":2}}],[\"authenticate=false\",{\"1\":{\"466\":1}}],[\"authorization\",{\"1\":{\"607\":3}}],[\"authorizefilter\",{\"1\":{\"607\":1}}],[\"author=\",{\"1\":{\"439\":1,\"440\":1}}],[\"author\",{\"1\":{\"111\":10,\"354\":1,\"439\":5,\"440\":9}}],[\"autumn\",{\"1\":{\"421\":2}}],[\"aof可以保证数据的不丢失\",{\"1\":{\"189\":1}}],[\"aof日志是连续的增量备份\",{\"1\":{\"189\":1}}],[\"aof\",{\"1\":{\"181\":1,\"187\":1,\"189\":2,\"200\":1}}],[\"aop=\",{\"1\":{\"583\":1}}],[\"aopano\",{\"1\":{\"572\":6}}],[\"aop通过代理模式实现\",{\"1\":{\"158\":1}}],[\"aop通过在不修改原有代码的情况下\",{\"1\":{\"158\":1}}],[\"aop和aspectj的集成支持\",{\"1\":{\"81\":1}}],[\"aop底层原理\",{\"0\":{\"72\":1}}],[\"aop\",{\"0\":{\"548\":1,\"566\":1,\"567\":1,\"568\":1,\"570\":1,\"571\":1,\"572\":1},\"1\":{\"61\":1,\"72\":1,\"81\":1,\"158\":1,\"168\":2,\"546\":1,\"549\":1,\"563\":1,\"567\":2,\"568\":1,\"571\":4,\"572\":1,\"583\":6}}],[\"ahead\",{\"1\":{\"180\":1,\"181\":1}}],[\"a方法调用b方法\",{\"0\":{\"166\":1}}],[\"a上面没有\",{\"0\":{\"166\":1}}],[\"answer\",{\"1\":{\"622\":2,\"678\":4}}],[\"an\",{\"1\":{\"491\":1}}],[\"an可以查看当前主机网络情况\",{\"1\":{\"485\":1}}],[\"anguoyanyi\",{\"1\":{\"440\":1}}],[\"annotationconfigapplicationcontext\",{\"1\":{\"565\":1,\"584\":1}}],[\"annotation\",{\"1\":{\"422\":1,\"563\":2,\"564\":1}}],[\"anonymousinner$1\",{\"1\":{\"418\":1}}],[\"anonymousinner\",{\"1\":{\"418\":1}}],[\"animal\",{\"1\":{\"402\":11,\"466\":2}}],[\"andthen\",{\"1\":{\"251\":2}}],[\"and\",{\"1\":{\"143\":1,\"148\":1,\"202\":1,\"295\":1,\"512\":4,\"527\":5,\"528\":6,\"529\":7,\"530\":1,\"532\":6,\"655\":1,\"657\":1,\"658\":1,\"674\":1}}],[\"analysis\",{\"1\":{\"5\":1}}],[\"aqs分析\",{\"0\":{\"314\":1}}],[\"aqsdemo\",{\"1\":{\"313\":1}}],[\"aqs内部封装了队列维护逻辑\",{\"1\":{\"313\":1}}],[\"aqs原理\",{\"0\":{\"312\":1}}],[\"aqs根据资源互斥级别提供了独占和共享两种资源访问模式\",{\"1\":{\"311\":1}}],[\"aqs通过一个fifo队列维护线程同步状态\",{\"1\":{\"311\":1}}],[\"aqs\",{\"1\":{\"311\":1}}],[\"aqs简介\",{\"0\":{\"311\":1}}],[\"aqs除了锁框架外还提供什么能力\",{\"1\":{\"310\":1}}],[\"aqs在java中有哪些实现类\",{\"1\":{\"310\":1}}],[\"aqs提供的是公平锁还是非公平锁\",{\"1\":{\"310\":1}}],[\"aqs独占锁和共享锁的原理\",{\"1\":{\"310\":1}}],[\"aqs队列同步器\",{\"0\":{\"309\":1}}],[\"aqs队列为空时线程加入队列发生什么\",{\"0\":{\"143\":1}}],[\"aqs使用一个volatile修饰的int类型变量state来表示当前的同步状态\",{\"1\":{\"141\":1}}],[\"aqs是juc同步框架的基石\",{\"1\":{\"311\":1}}],[\"aqs是依赖内部的同步队列实现\",{\"1\":{\"141\":1,\"312\":1}}],[\"aqs是一个用于构建锁和同步器的框架\",{\"1\":{\"141\":1}}],[\"aqs实现原理\",{\"0\":{\"141\":1},\"1\":{\"141\":1}}],[\"ab\",{\"1\":{\"660\":1,\"702\":1}}],[\"abs\",{\"1\":{\"432\":1}}],[\"abstract只能修饰类和方法\",{\"1\":{\"416\":1}}],[\"abstractqueuedsynchronizer\",{\"0\":{\"309\":1},\"1\":{\"141\":1,\"144\":1,\"311\":1,\"313\":1}}],[\"abstractdisplay\",{\"1\":{\"105\":5}}],[\"abstract\",{\"1\":{\"96\":2,\"102\":5,\"105\":4,\"110\":1,\"111\":8,\"117\":2,\"251\":1,\"416\":2}}],[\"abcced\",{\"1\":{\"705\":1}}],[\"abcabcbb\",{\"1\":{\"647\":1}}],[\"abcdefg\",{\"1\":{\"643\":1,\"646\":1}}],[\"abc\",{\"1\":{\"429\":2,\"647\":5,\"648\":2,\"649\":3,\"684\":3}}],[\"aba\",{\"1\":{\"650\":1}}],[\"abademo\",{\"1\":{\"300\":1}}],[\"aba问题\",{\"1\":{\"299\":2}}],[\"aboolean\",{\"1\":{\"268\":3}}],[\"abortpolicy\",{\"1\":{\"134\":1}}],[\"acm输入输出\",{\"0\":{\"722\":1}}],[\"acid\",{\"1\":{\"580\":1}}],[\"account=\",{\"1\":{\"501\":1}}],[\"account\",{\"1\":{\"501\":3}}],[\"accessors\",{\"1\":{\"252\":2}}],[\"accept\",{\"1\":{\"129\":1,\"251\":3,\"485\":1,\"771\":4}}],[\"ack\",{\"1\":{\"210\":1}}],[\"acquireshared和releaseshared整体流程与独占锁类似\",{\"1\":{\"318\":1}}],[\"acquireshared\",{\"0\":{\"318\":1}}],[\"acquirequeue分析\",{\"0\":{\"316\":1}}],[\"acquire分析\",{\"0\":{\"315\":1}}],[\"acquire方法首先必须表明它们需要一个信号量\",{\"1\":{\"312\":1}}],[\"acquire\",{\"1\":{\"144\":3,\"313\":4}}],[\"active\",{\"1\":{\"602\":1,\"604\":1}}],[\"activity\",{\"1\":{\"5\":9}}],[\"action\",{\"1\":{\"245\":1,\"246\":1,\"247\":2}}],[\"actuator\",{\"1\":{\"81\":1}}],[\"actordirector\",{\"1\":{\"7\":1}}],[\"actor\",{\"1\":{\"7\":4}}],[\"apache\",{\"1\":{\"498\":3,\"540\":3,\"606\":1}}],[\"apinote\",{\"1\":{\"381\":1,\"627\":1}}],[\"api与调用\",{\"0\":{\"304\":1}}],[\"api\",{\"1\":{\"99\":1,\"102\":1,\"117\":1,\"248\":1,\"297\":1,\"549\":1,\"588\":1,\"593\":1,\"606\":1}}],[\"api进行数据库访问的支持\",{\"1\":{\"81\":1}}],[\"app>\",{\"1\":{\"327\":1}}],[\"app\",{\"1\":{\"327\":2,\"605\":3,\"616\":4}}],[\"applytoeitherasync\",{\"1\":{\"248\":2}}],[\"applytoeither\",{\"1\":{\"248\":3}}],[\"apply\",{\"1\":{\"129\":1,\"251\":5}}],[\"applicationcontext\",{\"1\":{\"552\":1,\"555\":2,\"557\":1,\"559\":1,\"560\":1,\"565\":1,\"576\":1,\"583\":1,\"584\":1}}],[\"applicationlistener\",{\"1\":{\"73\":1}}],[\"application\",{\"1\":{\"64\":1,\"602\":1,\"604\":3,\"607\":1,\"760\":1}}],[\"appenders>\",{\"1\":{\"586\":1}}],[\"append\",{\"1\":{\"108\":9,\"111\":14,\"181\":1,\"189\":1,\"430\":3,\"431\":2,\"644\":2,\"645\":1,\"646\":2,\"684\":1,\"690\":2}}],[\"appconfig\",{\"1\":{\"70\":1}}],[\"as\",{\"1\":{\"655\":1,\"674\":1}}],[\"asc\",{\"1\":{\"605\":2}}],[\"ascii码\",{\"1\":{\"356\":1}}],[\"association>\",{\"1\":{\"523\":2,\"524\":1,\"527\":1}}],[\"association\",{\"1\":{\"523\":4,\"524\":2,\"527\":1}}],[\"assert\",{\"1\":{\"260\":1,\"477\":2,\"598\":1,\"677\":1,\"678\":1}}],[\"asyncpool的源码\",{\"1\":{\"247\":1}}],[\"asyncpool\",{\"1\":{\"247\":2}}],[\"async的返回值只能为void或者future及其子类\",{\"1\":{\"164\":1}}],[\"async注解的方法\",{\"1\":{\"164\":2}}],[\"async注解\",{\"1\":{\"164\":1}}],[\"async注解会在以下几个场景失效\",{\"1\":{\"164\":1}}],[\"aspectj注解\",{\"0\":{\"572\":1}}],[\"aspectj\",{\"1\":{\"168\":1,\"571\":3,\"572\":2}}],[\"aspect\",{\"1\":{\"158\":1,\"572\":2}}],[\"asm\",{\"1\":{\"72\":1}}],[\"aservice\",{\"1\":{\"70\":1}}],[\"aslist\",{\"1\":{\"46\":2,\"256\":1,\"433\":1,\"627\":1}}],[\"attributes>\",{\"1\":{\"583\":2}}],[\"attrs\",{\"0\":{\"22\":1}}],[\"athread运行\",{\"1\":{\"467\":1}}],[\"athread\",{\"1\":{\"467\":6}}],[\"atomicstampedreference<>\",{\"1\":{\"300\":1}}],[\"atomicstampedreference<book>\",{\"1\":{\"300\":1}}],[\"atomicstampedreference版本号\",{\"1\":{\"300\":1}}],[\"atomicdemo\",{\"1\":{\"297\":1}}],[\"atomicreference<thread>\",{\"1\":{\"298\":1}}],[\"atomicreference<>\",{\"1\":{\"297\":1,\"298\":1}}],[\"atomicreference<user>\",{\"1\":{\"297\":1}}],[\"atomicreference\",{\"1\":{\"297\":5,\"298\":3}}],[\"atomicreference是作用是对\",{\"1\":{\"297\":1}}],[\"atomicreference和atomicinteger非常类似\",{\"1\":{\"297\":1}}],[\"atomicreference类\",{\"0\":{\"297\":1}}],[\"atomicboolean\",{\"1\":{\"268\":3}}],[\"atomicity\",{\"1\":{\"170\":1}}],[\"atomic包中的原子操作类\",{\"1\":{\"128\":1}}],[\"atomic\",{\"1\":{\"57\":1,\"268\":3,\"297\":1}}],[\"around\",{\"1\":{\"572\":2}}],[\"artifactid>\",{\"1\":{\"498\":5,\"540\":11,\"597\":1,\"599\":2,\"602\":1,\"606\":2}}],[\"artemis进行消息传递的支持\",{\"1\":{\"81\":1}}],[\"artemis\",{\"1\":{\"81\":1}}],[\"arithmeticexception\",{\"1\":{\"424\":1}}],[\"arithmeticexception数学运算异常\",{\"1\":{\"424\":1}}],[\"arr\",{\"1\":{\"382\":3,\"433\":5,\"621\":8,\"628\":5,\"661\":3,\"729\":3}}],[\"arrtri\",{\"1\":{\"382\":11}}],[\"arrsort\",{\"1\":{\"381\":10}}],[\"arr2\",{\"1\":{\"381\":5,\"382\":6}}],[\"arr1\",{\"1\":{\"381\":8,\"382\":1}}],[\"arraydeque<>\",{\"1\":{\"662\":1}}],[\"array>\",{\"1\":{\"557\":1}}],[\"arrayoffset\",{\"1\":{\"477\":1}}],[\"arraycopy\",{\"1\":{\"434\":1,\"662\":1}}],[\"arrayindexoutofboundsexception数组下标越界异常\",{\"1\":{\"424\":1}}],[\"arrayassign\",{\"1\":{\"381\":2}}],[\"arraylist<integer>\",{\"1\":{\"718\":1,\"721\":1}}],[\"arraylist<object>\",{\"1\":{\"460\":1}}],[\"arraylist<string>\",{\"1\":{\"456\":1,\"460\":1}}],[\"arraylist<dog>\",{\"1\":{\"454\":2}}],[\"arraylist<>\",{\"1\":{\"111\":2,\"456\":1,\"627\":2,\"649\":1,\"661\":1,\"683\":1,\"685\":2,\"690\":1,\"718\":2}}],[\"arraylist02\",{\"1\":{\"454\":1}}],[\"arraylist01\",{\"1\":{\"454\":1}}],[\"arraylist和linkedlist比较\",{\"1\":{\"443\":1}}],[\"arraylist和linkedlist区别\",{\"0\":{\"122\":1}}],[\"arraylist中有一个object数组\",{\"1\":{\"441\":1}}],[\"arraylist底层操作机制和源码分析\",{\"1\":{\"441\":1}}],[\"arraylist底层结构和源码分析\",{\"0\":{\"441\":1}}],[\"arraylist基本等同于vector\",{\"1\":{\"441\":1}}],[\"arraylist是由数组来实现数据存储的\",{\"1\":{\"441\":1}}],[\"arraylist是基于数组实现的动态数组\",{\"1\":{\"122\":1}}],[\"arraylist可以加入null\",{\"1\":{\"441\":1}}],[\"arraylist可以通过索引直接访问元素\",{\"1\":{\"122\":1}}],[\"arraylist\",{\"1\":{\"111\":4,\"439\":1,\"440\":6,\"442\":1,\"451\":1,\"454\":12,\"460\":2,\"492\":1,\"664\":1,\"666\":2,\"669\":1,\"683\":1,\"684\":1,\"686\":4,\"688\":2,\"715\":3}}],[\"array\",{\"1\":{\"44\":1,\"45\":1,\"46\":3,\"123\":1,\"194\":1,\"424\":2,\"461\":1,\"477\":1}}],[\"arraysexercise\",{\"1\":{\"433\":1}}],[\"arrays类\",{\"0\":{\"433\":1}}],[\"arrays\",{\"1\":{\"44\":1,\"45\":1,\"46\":2,\"256\":2,\"433\":8,\"569\":2,\"627\":1,\"628\":2,\"675\":1,\"687\":4,\"724\":1}}],[\"arrary\",{\"1\":{\"44\":1,\"45\":1}}],[\"arg>\",{\"1\":{\"557\":2}}],[\"arg1\",{\"1\":{\"512\":2}}],[\"arg0\",{\"1\":{\"512\":2}}],[\"arg\",{\"1\":{\"313\":2,\"557\":2}}],[\"args\",{\"1\":{\"55\":2,\"91\":1,\"96\":1,\"99\":1,\"105\":1,\"108\":1,\"111\":1,\"232\":1,\"233\":1,\"249\":1,\"252\":1,\"253\":1,\"256\":1,\"262\":1,\"263\":1,\"268\":3,\"271\":3,\"291\":1,\"300\":1,\"304\":1,\"313\":1,\"351\":2,\"352\":2,\"354\":1,\"368\":1,\"376\":1,\"377\":1,\"381\":3,\"382\":3,\"390\":1,\"391\":3,\"399\":1,\"402\":3,\"403\":1,\"404\":1,\"411\":1,\"412\":1,\"413\":2,\"414\":2,\"415\":1,\"416\":1,\"417\":4,\"418\":1,\"419\":4,\"421\":1,\"427\":3,\"428\":1,\"429\":1,\"430\":2,\"431\":1,\"433\":1,\"436\":3,\"439\":1,\"440\":2,\"443\":1,\"444\":1,\"445\":1,\"448\":1,\"451\":1,\"454\":2,\"457\":1,\"466\":4,\"467\":1,\"468\":2,\"469\":1,\"471\":2,\"477\":1,\"478\":1,\"480\":1,\"483\":1,\"485\":2,\"486\":1,\"491\":1,\"569\":4,\"583\":2,\"586\":1,\"648\":1,\"677\":1,\"718\":1,\"724\":1,\"729\":1,\"730\":1}}],[\"a\",{\"1\":{\"18\":1,\"95\":3,\"120\":2,\"175\":3,\"176\":3,\"195\":1,\"232\":1,\"248\":2,\"262\":1,\"298\":1,\"299\":1,\"318\":2,\"358\":1,\"362\":4,\"365\":4,\"366\":4,\"381\":2,\"403\":6,\"413\":2,\"415\":2,\"417\":3,\"419\":1,\"424\":4,\"429\":4,\"461\":1,\"468\":5,\"471\":6,\"475\":1,\"477\":3,\"478\":3,\"523\":1,\"542\":2,\"598\":1,\"645\":2,\"648\":1,\"660\":4,\"664\":1,\"666\":1,\"667\":1,\"668\":1,\"672\":1,\"674\":5,\"675\":1,\"676\":1,\"684\":1,\"687\":4,\"688\":2,\"699\":1,\"716\":2}}],[\"力扣\",{\"1\":{\"5\":1}}],[\"的平均时间复杂度运行的数据结构\",{\"1\":{\"720\":1}}],[\"的平均时间复杂度运行\",{\"1\":{\"720\":1}}],[\"的次数\",{\"1\":{\"718\":1}}],[\"的有向边\",{\"1\":{\"717\":1}}],[\"的有效期\",{\"1\":{\"165\":1}}],[\"的邻接节点组成\",{\"1\":{\"716\":1}}],[\"的路径并输出\",{\"1\":{\"715\":1}}],[\"的矩阵\",{\"1\":{\"709\":1}}],[\"的矩阵中包含单词\",{\"1\":{\"705\":1}}],[\"的岛\",{\"1\":{\"708\":1}}],[\"的正则表达式匹配\",{\"1\":{\"702\":1}}],[\"的房屋进行打家劫舍1问题\",{\"1\":{\"698\":3}}],[\"的值\",{\"1\":{\"694\":1}}],[\"的值为\",{\"1\":{\"559\":2}}],[\"的空间存储前一个dp\",{\"1\":{\"693\":1}}],[\"的和最大\",{\"1\":{\"693\":1}}],[\"的和的形式\",{\"1\":{\"492\":1}}],[\"的不同\",{\"1\":{\"687\":1}}],[\"的数\",{\"1\":{\"687\":1}}],[\"的数和分配\",{\"1\":{\"687\":1}}],[\"的数目\",{\"1\":{\"687\":1,\"708\":1}}],[\"的数组\",{\"1\":{\"676\":1,\"678\":1}}],[\"的数据行\",{\"1\":{\"176\":1}}],[\"的子数组\",{\"0\":{\"671\":1}}],[\"的子串都是回文串\",{\"1\":{\"650\":1}}],[\"的子串是\",{\"1\":{\"649\":2}}],[\"的子串\",{\"1\":{\"649\":1}}],[\"的滑动窗口从数组的最左侧移动到数组的最右侧\",{\"1\":{\"661\":1}}],[\"的异位词\",{\"1\":{\"649\":2}}],[\"的长度\",{\"1\":{\"647\":1}}],[\"的长度最小的连续\",{\"1\":{\"630\":1}}],[\"的字符串\",{\"1\":{\"659\":1,\"684\":1}}],[\"的字符串中\",{\"1\":{\"653\":2}}],[\"的字符\",{\"1\":{\"645\":1}}],[\"的形式给出\",{\"1\":{\"642\":1}}],[\"的所有节点\",{\"1\":{\"634\":1}}],[\"的水果\",{\"1\":{\"631\":1}}],[\"的要求\",{\"1\":{\"628\":1}}],[\"的定义\",{\"1\":{\"628\":1}}],[\"的下一个排列\",{\"1\":{\"628\":2}}],[\"的下一个排列是\",{\"1\":{\"628\":3}}],[\"的排列\",{\"1\":{\"628\":1}}],[\"的最大值为\",{\"1\":{\"625\":1}}],[\"的整数数组\",{\"1\":{\"625\":1}}],[\"的柱子的高度图\",{\"1\":{\"624\":1}}],[\"的shell\",{\"1\":{\"616\":1}}],[\"的基础上添加安装包\",{\"1\":{\"616\":1}}],[\"的内容\",{\"1\":{\"614\":1}}],[\"的性能和服务的可用性来选择服务实例\",{\"1\":{\"598\":1}}],[\"的事件处理机制和消息中间件消息的发送和接收整合起来\",{\"1\":{\"593\":1}}],[\"的事务是总是带有隔离性的\",{\"1\":{\"201\":1}}],[\"的事务严格意义上来说是不具备原子性的\",{\"1\":{\"201\":1}}],[\"的相关\",{\"1\":{\"588\":1}}],[\"的后置处理器\",{\"1\":{\"560\":1}}],[\"的一种实现\",{\"1\":{\"554\":1}}],[\"的一级缓存是\",{\"1\":{\"534\":1}}],[\"的开发难度\",{\"1\":{\"549\":1}}],[\"的生命周期\",{\"1\":{\"545\":1,\"560\":1}}],[\"的模式\",{\"1\":{\"545\":1}}],[\"的核心原理是基于接口注解和动态代理实现远程调用\",{\"1\":{\"606\":1}}],[\"的核心是一个\",{\"1\":{\"545\":1}}],[\"的核心组件\",{\"1\":{\"161\":1}}],[\"的配置文件写在一个单独的文件中\",{\"1\":{\"507\":1}}],[\"的配置数据\",{\"1\":{\"212\":1}}],[\"的代理实现类对象\",{\"1\":{\"502\":1,\"512\":1}}],[\"的代码\",{\"1\":{\"72\":1,\"159\":1}}],[\"的集合类\",{\"1\":{\"492\":1}}],[\"的判断结果\",{\"1\":{\"492\":1}}],[\"的语义\",{\"1\":{\"491\":1}}],[\"的外层局部变量\",{\"1\":{\"491\":1}}],[\"的指定部分转换成string\",{\"1\":{\"477\":1}}],[\"的执行时间\",{\"1\":{\"431\":3}}],[\"的左边只能是变量\",{\"1\":{\"365\":1}}],[\"的类型\",{\"1\":{\"359\":1}}],[\"的filter\",{\"1\":{\"341\":1}}],[\"的区别在于\",{\"1\":{\"364\":1}}],[\"的区别\",{\"0\":{\"261\":1},\"1\":{\"253\":1,\"492\":1}}],[\"的方法会超时\",{\"1\":{\"742\":1}}],[\"的方法创建一个对象\",{\"1\":{\"116\":1}}],[\"的方式\",{\"1\":{\"547\":1}}],[\"的方式来访问\",{\"1\":{\"507\":1}}],[\"的方式进行消息消费\",{\"1\":{\"214\":1}}],[\"的高可用模式\",{\"1\":{\"212\":1}}],[\"的全局角度\",{\"1\":{\"209\":1}}],[\"的时候\",{\"1\":{\"204\":1,\"212\":1}}],[\"的哈希槽\",{\"1\":{\"203\":1}}],[\"的连接\",{\"1\":{\"203\":1}}],[\"的风险与问题\",{\"1\":{\"203\":1}}],[\"的监控\",{\"1\":{\"202\":1}}],[\"的持久化功能将部分数据存储到磁盘中\",{\"1\":{\"200\":1}}],[\"的分页查询功能\",{\"1\":{\"199\":1}}],[\"的缓存淘汰策略\",{\"0\":{\"192\":1}}],[\"的过期删除策略就是\",{\"1\":{\"191\":1}}],[\"的过程\",{\"1\":{\"63\":1,\"555\":1}}],[\"的扩容方式\",{\"0\":{\"190\":1}}],[\"的命令都是原子操作\",{\"1\":{\"186\":1}}],[\"的优势就是查找和操作的时间复杂度是o\",{\"1\":{\"186\":1}}],[\"的依赖注入功能\",{\"1\":{\"168\":1}}],[\"的标准技术\",{\"1\":{\"168\":1}}],[\"的设置\",{\"1\":{\"165\":1}}],[\"的设计正是对享元模式的应用\",{\"1\":{\"130\":1}}],[\"的角色\",{\"1\":{\"162\":1}}],[\"的读写操作具有原子性\",{\"1\":{\"140\":1}}],[\"的大小必须为素数\",{\"1\":{\"124\":1}}],[\"的元素数量超过负载因子与当前容量的乘积时\",{\"1\":{\"124\":1}}],[\"的关系\",{\"1\":{\"120\":2}}],[\"的用法\",{\"1\":{\"113\":1}}],[\"的创建工作\",{\"1\":{\"107\":1}}],[\"的接口\",{\"1\":{\"95\":1}}],[\"的实现\",{\"1\":{\"93\":1}}],[\"的节点入队列\",{\"1\":{\"91\":1}}],[\"的支持\",{\"1\":{\"81\":2,\"104\":1}}],[\"的属性时\",{\"1\":{\"67\":1}}],[\"的属性设置值和对其他\",{\"1\":{\"66\":1,\"560\":1}}],[\"的初始化方法\",{\"1\":{\"66\":1,\"560\":1}}],[\"的引用\",{\"1\":{\"66\":1,\"560\":1}}],[\"的构成\",{\"0\":{\"60\":1}}],[\"的\",{\"1\":{\"22\":1,\"40\":1,\"65\":1,\"70\":1,\"72\":1,\"102\":2,\"134\":1,\"181\":1,\"205\":1,\"419\":1,\"501\":1,\"514\":1,\"515\":1,\"524\":1,\"531\":1,\"648\":1,\"649\":1,\"678\":1,\"701\":1,\"709\":1}}],[\"的玩家在第一天登录后才重新登录\",{\"1\":{\"5\":1}}],[\"的unique\",{\"1\":{\"3\":1}}],[\"为起点遍历图\",{\"1\":{\"715\":1}}],[\"为使结果字符串\",{\"1\":{\"660\":1}}],[\"为例\",{\"1\":{\"628\":1}}],[\"为保证服务的安全\",{\"1\":{\"593\":1}}],[\"为用户提供最终价值\",{\"1\":{\"591\":1}}],[\"为当前配置文件中的所有\",{\"1\":{\"560\":1}}],[\"为传入的参数起名\",{\"1\":{\"512\":1}}],[\"为占位符\",{\"1\":{\"501\":1}}],[\"为啥有时会出现\",{\"1\":{\"492\":1}}],[\"为程序提供更为强大的读写功能\",{\"1\":{\"478\":1}}],[\"为threadlocal设置初始值\",{\"1\":{\"307\":1}}],[\"为其他线程服务比如gc垃圾回收线程\",{\"1\":{\"227\":1}}],[\"为何\",{\"0\":{\"193\":1}}],[\"为什么要先加入\",{\"1\":{\"665\":1}}],[\"为什么需要网关\",{\"1\":{\"607\":1}}],[\"为什么需要泛型\",{\"1\":{\"454\":1}}],[\"为什么重写\",{\"1\":{\"492\":1}}],[\"为什么默认非公平\",{\"1\":{\"262\":1}}],[\"为什么会有公平锁\",{\"1\":{\"262\":1}}],[\"为什么任何一个对象都可以变成一个锁\",{\"1\":{\"260\":1}}],[\"为什么kafka吞吐量高\",{\"0\":{\"214\":1}}],[\"为什么使用消息队列\",{\"0\":{\"207\":1}}],[\"为什么采用单线程\",{\"0\":{\"187\":1}}],[\"为什么能处理高并发\",{\"0\":{\"186\":1}}],[\"为什么快\",{\"0\":{\"186\":1}}],[\"为什么有可见性问题\",{\"0\":{\"140\":1}}],[\"为什么\",{\"0\":{\"140\":1}}],[\"为什么不先创建临时线程而是先放进阻塞队列\",{\"0\":{\"135\":1}}],[\"为什么选择红黑树这种数据结构\",{\"0\":{\"124\":1}}],[\"为什么是8和64没答出来\",{\"0\":{\"124\":1}}],[\"为了保存状态引入了cookie技术\",{\"1\":{\"761\":1}}],[\"为了换行读取可以使用nextline\",{\"1\":{\"728\":1}}],[\"为了表示给定链表中的环\",{\"1\":{\"640\":1}}],[\"为了方便举例\",{\"1\":{\"639\":1}}],[\"为了满足这个要求\",{\"1\":{\"628\":1}}],[\"为了简化\",{\"1\":{\"563\":1}}],[\"为了让某个类时可序列化的\",{\"1\":{\"478\":1}}],[\"为了让生成的代理类与目标对象\",{\"1\":{\"419\":1}}],[\"为了垃圾回收的目的\",{\"1\":{\"312\":2}}],[\"为了避免竞争\",{\"1\":{\"312\":1}}],[\"为了避免创建一个与产品类层次平行的工厂类层次时\",{\"1\":{\"116\":1}}],[\"为了提高版本兼容性\",{\"1\":{\"478\":1}}],[\"为了提高效率\",{\"1\":{\"140\":1}}],[\"为了提升性能\",{\"1\":{\"278\":1}}],[\"为了解决下载过程中的网络中断问题\",{\"1\":{\"770\":1}}],[\"为了解决静态代理中\",{\"1\":{\"492\":1}}],[\"为了解决这个问题\",{\"1\":{\"299\":1}}],[\"为了解决这一问题\",{\"1\":{\"274\":1}}],[\"为了解决缓存一致性问题\",{\"1\":{\"274\":1}}],[\"为了解决幻读问题\",{\"1\":{\"178\":1}}],[\"为了建立https连接\",{\"1\":{\"154\":1}}],[\"为了丰富文档写作\",{\"1\":{\"16\":1}}],[\"为spring\",{\"1\":{\"82\":1}}],[\"为jee6提供支持\",{\"1\":{\"59\":1}}],[\"为每个\",{\"1\":{\"14\":1}}],[\"为\",{\"0\":{\"785\":1},\"1\":{\"5\":1,\"66\":1,\"91\":1,\"471\":2,\"560\":1,\"693\":1}}],[\"这题的宽度为两层需要两层for\",{\"1\":{\"684\":1}}],[\"这题要返回下标\",{\"1\":{\"626\":1}}],[\"这与c语言的\",{\"1\":{\"651\":1}}],[\"这五棵树\",{\"1\":{\"631\":1}}],[\"这四棵树\",{\"1\":{\"631\":1}}],[\"这三棵树\",{\"1\":{\"631\":1}}],[\"这道题目的前提是数组为有序数组\",{\"1\":{\"620\":1}}],[\"这条url被ribbon实现的请求拦截器拦截\",{\"1\":{\"598\":1}}],[\"这里判断是否达到终点\",{\"1\":{\"711\":1}}],[\"这里有\",{\"1\":{\"678\":1}}],[\"这里需要使用map来当作窗口\",{\"1\":{\"648\":1}}],[\"这里同学们要注意\",{\"1\":{\"639\":1}}],[\"这里负载均衡器可以使用nginx\",{\"1\":{\"605\":1}}],[\"这里获得\",{\"1\":{\"471\":2}}],[\"这里使用\",{\"1\":{\"471\":1}}],[\"这里不能直接用start\",{\"1\":{\"466\":1}}],[\"这里为什么要\",{\"1\":{\"436\":1}}],[\"这里截取hello的前3位与\",{\"1\":{\"429\":1}}],[\"这里创建的是一个自定义的日志处理器\",{\"1\":{\"419\":1}}],[\"这里的userserviceimpl只实现了一个接口userservice\",{\"1\":{\"419\":1}}],[\"这里才实际调用真实主题角色的方法\",{\"1\":{\"419\":2}}],[\"这里返回的是son的name\",{\"1\":{\"399\":1}}],[\"这里我们注意到threadlocalmap的key是当前的threadlocal\",{\"1\":{\"306\":1}}],[\"这里配置视图解析器\",{\"1\":{\"78\":1}}],[\"这使得它可以通过横向扩展\",{\"1\":{\"214\":1}}],[\"这使得编写spring\",{\"1\":{\"82\":1}}],[\"这把锁也要在一段时间后自动释放\",{\"1\":{\"205\":1}}],[\"这块资源将会永远被锁住\",{\"1\":{\"205\":1}}],[\"这么做\",{\"1\":{\"196\":1}}],[\"这两个指针每次只走一个节点\",{\"1\":{\"640\":1}}],[\"这两个计算都是正确的\",{\"1\":{\"359\":1,\"365\":1}}],[\"这两棵树\",{\"1\":{\"631\":2}}],[\"这两步和原来一样\",{\"1\":{\"196\":1}}],[\"这两种类型的类可被结构化改变而互不影响\",{\"1\":{\"113\":1}}],[\"这也是zookeeper分布式锁较其他分布式锁方案的一大优势\",{\"1\":{\"217\":1}}],[\"这也是默认策略\",{\"1\":{\"192\":1}}],[\"这也是spring4\",{\"1\":{\"80\":1}}],[\"这一问题就是缓存一致性问题\",{\"1\":{\"274\":1}}],[\"这一步非常关键\",{\"1\":{\"635\":1}}],[\"这一步执行的是选择和处理列的操作\",{\"1\":{\"184\":1}}],[\"这一步筛选出满足条件的数据行\",{\"1\":{\"184\":1}}],[\"这一步将数据从多个表连接起来\",{\"1\":{\"184\":1}}],[\"这一步涉及从表中获取相关的数据\",{\"1\":{\"184\":1}}],[\"这一切都是借助于条件注解完成的\",{\"1\":{\"80\":1}}],[\"这意味着第一个房屋和最后一个房屋是紧挨着的\",{\"1\":{\"698\":1}}],[\"这意味着通过某个线程通过threadlocal存储的数据\",{\"1\":{\"304\":1}}],[\"这意味着\",{\"1\":{\"181\":1}}],[\"这意味着一个节点的大小是相对较大的\",{\"1\":{\"172\":1}}],[\"这会增加查询的时间复杂度\",{\"1\":{\"172\":1}}],[\"这解决了脏读的问题\",{\"1\":{\"171\":1}}],[\"这可以解决脏读\",{\"1\":{\"171\":1}}],[\"这可以通过xml配置文件\",{\"1\":{\"160\":1}}],[\"这可能导致脏读\",{\"1\":{\"171\":1}}],[\"这时最大乘积就有两种选择\",{\"1\":{\"736\":1}}],[\"这时上一个方法就无法使用了\",{\"1\":{\"466\":1}}],[\"这时候就需要继承\",{\"1\":{\"399\":1}}],[\"这时队列中的消息会被平摊\",{\"1\":{\"209\":1}}],[\"这时需要异步调用的方法带有返回值completablefuture\",{\"1\":{\"164\":1}}],[\"这时\",{\"1\":{\"163\":1}}],[\"这时会根据指定的拒绝策略来处理无法接受的任务\",{\"1\":{\"135\":1}}],[\"这在流媒体服务\",{\"1\":{\"156\":1}}],[\"这在验证share\",{\"1\":{\"3\":1}}],[\"这样传输过程中可以让浏览器逐步显示页面\",{\"1\":{\"768\":1}}],[\"这样时间复杂度就变成了log2n\",{\"1\":{\"742\":1}}],[\"这样插入和删除查找下标时可以直接通过map来查找\",{\"1\":{\"721\":1}}],[\"这样辅助队列中的数就模拟了栈中的出栈顺序\",{\"1\":{\"657\":1}}],[\"这样写\",{\"1\":{\"643\":1}}],[\"这样才满足\",{\"1\":{\"628\":2}}],[\"这样在任意系统中就可以运行这个程序\",{\"1\":{\"610\":1}}],[\"这样对外暴露的是代理对象而真正调用的是\",{\"1\":{\"492\":1}}],[\"这样比如比较两集合时不通过hashcode来比较只能遍历依次比较\",{\"1\":{\"492\":1}}],[\"这样我们取出的元素也是dog类型而不是object\",{\"1\":{\"454\":1}}],[\"这样就确定了状态转移方程\",{\"1\":{\"736\":1}}],[\"这样就把问题转换为了数组操作\",{\"1\":{\"677\":1}}],[\"这样就可以保证遍历的时候按add顺序遍历\",{\"1\":{\"446\":1}}],[\"这样就会比较耗费cpu\",{\"1\":{\"299\":1}}],[\"这样不断寻找\",{\"1\":{\"381\":1}}],[\"这样\",{\"1\":{\"235\":1}}],[\"这样即使在系统发生故障或崩溃时\",{\"1\":{\"180\":1}}],[\"这样可以释放内存\",{\"1\":{\"200\":1}}],[\"这样可以更加高效地处理大量的元素\",{\"1\":{\"199\":1}}],[\"这样可以减少索引占用的存储空间\",{\"1\":{\"174\":1}}],[\"这样可以消除内存碎片\",{\"1\":{\"148\":1}}],[\"这样可以提高单线程访问临界区的性能\",{\"1\":{\"139\":1}}],[\"这样可以避免内存被长时间占用\",{\"1\":{\"200\":1}}],[\"这样可以避免在方法内部意外修改参数的值\",{\"1\":{\"127\":1}}],[\"这样可以避免了线程之间的阻塞和等待\",{\"1\":{\"125\":1}}],[\"这样可以直接阻止其他类对该类的继承\",{\"1\":{\"127\":1}}],[\"这样可以防止子类修改父类的行为\",{\"1\":{\"127\":1}}],[\"这样可以确保常量的值在使用过程中不会被意外修改\",{\"1\":{\"127\":1}}],[\"这样可以节省一半的空间\",{\"1\":{\"121\":1}}],[\"这样适配器才可以去正确执行handler\",{\"1\":{\"76\":1}}],[\"这对于全新的类不是很难\",{\"1\":{\"116\":1}}],[\"这个图可能不是连通图\",{\"1\":{\"716\":1}}],[\"这个锁将会被永久锁定\",{\"1\":{\"713\":1}}],[\"这个地方所有的房屋都\",{\"1\":{\"698\":1}}],[\"这个规则是由org\",{\"1\":{\"607\":1}}],[\"这个过程中事务时如何进行管理的\",{\"1\":{\"582\":1}}],[\"这个目录下的资源必须是用户登录后才允许访问\",{\"1\":{\"339\":1}}],[\"这个方法在下面展示\",{\"1\":{\"220\":1}}],[\"这个操作称为快照读\",{\"1\":{\"178\":1}}],[\"这个版本号是基于事务id\",{\"1\":{\"178\":1}}],[\"这个查询无法利用索引进行快速定位\",{\"1\":{\"176\":1}}],[\"这个查询可以利用索引的最左前缀\",{\"1\":{\"176\":1}}],[\"这个代理对象会拦截所有对该类的方法调用\",{\"1\":{\"166\":1}}],[\"这个密钥只在当前会话中使用\",{\"1\":{\"155\":1}}],[\"这个证书包含了服务器的公钥以及其相关信息\",{\"1\":{\"155\":1}}],[\"这个证书用于验证服务器身份并确保通信的安全性\",{\"1\":{\"154\":1}}],[\"这个屏障会强制刷新处理器缓存\",{\"1\":{\"140\":1}}],[\"这个值将会立即被写入主内存\",{\"1\":{\"140\":1}}],[\"这个资源包括数据\",{\"1\":{\"116\":1}}],[\"这个复杂对象的各个部分经常面临着剧烈的变化\",{\"1\":{\"107\":1}}],[\"这个类实现的接口\",{\"1\":{\"569\":1}}],[\"这个类实现了spring提供的importbeandefinitionregistrar接口\",{\"1\":{\"83\":1}}],[\"这个类就是抽象方法\",{\"1\":{\"416\":1}}],[\"这个类就是抽象类\",{\"1\":{\"416\":1}}],[\"这个类的所有对象\",{\"1\":{\"259\":2}}],[\"这个类提供了一种访问其唯一的对象的方式\",{\"1\":{\"98\":1}}],[\"这就意味着\",{\"1\":{\"640\":1}}],[\"这就实现了服务的自动注册\",{\"1\":{\"597\":1}}],[\"这就是内容协商机制\",{\"1\":{\"771\":1}}],[\"这就是说不能在\",{\"1\":{\"491\":1}}],[\"这就是一个顶层的逻辑骨架\",{\"1\":{\"104\":1}}],[\"这就需要用到条件表达式了\",{\"1\":{\"6\":1}}],[\"这并不是什么好事\",{\"1\":{\"101\":1}}],[\"这种技术叫分块传输编码\",{\"1\":{\"768\":1}}],[\"这种断言工厂有10多个\",{\"1\":{\"607\":1}}],[\"这种现象\",{\"1\":{\"492\":1}}],[\"这种接口称为函数式接口\",{\"1\":{\"490\":1}}],[\"这种迭代器实现了add方法\",{\"1\":{\"443\":1}}],[\"这种高效的存储和检索机制使得kafka能够应对高吞吐量的数据流\",{\"1\":{\"214\":1}}],[\"这种集群式消费模型使得多个消费者可以并行地处理消息\",{\"1\":{\"214\":1}}],[\"这种顺序写入的方式相对于随机写入可以获得更好的磁盘性能\",{\"1\":{\"214\":1}}],[\"这种情况下cas机制会一直重试\",{\"1\":{\"299\":1}}],[\"这种情况下\",{\"1\":{\"171\":3}}],[\"这种算法的特点是高效\",{\"1\":{\"148\":1}}],[\"这种模式\",{\"1\":{\"212\":1}}],[\"这种模式是实现了一个原型接口\",{\"1\":{\"116\":1}}],[\"这种模式涉及到一个作为桥接的接口\",{\"1\":{\"113\":1}}],[\"这种模式涉及到一个单一的类\",{\"1\":{\"98\":1}}],[\"这种类型的设计模式属于结构型模式\",{\"1\":{\"113\":1}}],[\"这种类型的设计模式属于行为型模式\",{\"1\":{\"104\":1}}],[\"这种类型的设计模式属于创建型模式\",{\"1\":{\"98\":1,\"101\":1,\"107\":1,\"110\":1,\"116\":1}}],[\"这些应用程序可以将请求转发给通信线路上的下一站服务器\",{\"1\":{\"780\":1}}],[\"这些位置是从汽车的初始位置向东的公里数\",{\"1\":{\"677\":1}}],[\"这些树用一个整数数组\",{\"1\":{\"631\":1}}],[\"这些字符串会被predicate\",{\"1\":{\"607\":1}}],[\"这些方法称为连接点\",{\"1\":{\"570\":1}}],[\"这些组件\",{\"1\":{\"545\":1}}],[\"这些变量与正常的变量不同\",{\"1\":{\"303\":1}}],[\"这些属性包括routing\",{\"1\":{\"209\":1}}],[\"这些动作都是通过信道完成\",{\"1\":{\"209\":1}}],[\"这些命令不会立即被执行\",{\"1\":{\"202\":1}}],[\"这些工具可以提供更详细的内存使用情况\",{\"1\":{\"146\":1}}],[\"这些功能可以通过spring\",{\"1\":{\"82\":1}}],[\"这些默认设置和约定包括常用的插件及其配置\",{\"1\":{\"82\":1}}],[\"这些错误只能在程序运行时才能被检查出来\",{\"1\":{\"62\":1}}],[\"这是可能的\",{\"1\":{\"717\":1}}],[\"这是为什么\",{\"1\":{\"302\":1}}],[\"这是一道一维动态规划题\",{\"1\":{\"697\":1}}],[\"这是一个在面试中很好的问题\",{\"1\":{\"651\":1}}],[\"这是一个原子操作\",{\"1\":{\"143\":1}}],[\"这是一种适用于老年代的垃圾回收算法\",{\"1\":{\"148\":1}}],[\"这是一种适用于新生代的垃圾回收算法\",{\"1\":{\"148\":1}}],[\"这是因为联合索引的数据结构是按照索引的列顺序进行排序和存储的\",{\"1\":{\"175\":1}}],[\"这是因为处理器会对内存进行缓存\",{\"1\":{\"140\":1}}],[\"这是因为当链表长度过长时\",{\"1\":{\"124\":1}}],[\"这是适配器模式的应用\",{\"1\":{\"76\":1}}],[\"这是某个类的实例\",{\"1\":{\"70\":1}}],[\"这是脚注内容\",{\"1\":{\"38\":1}}],[\"这张表显示了某些游戏的玩家的活动情况\",{\"1\":{\"5\":1}}],[\"|=\",{\"1\":{\"689\":1,\"701\":1}}],[\"||\",{\"1\":{\"318\":3,\"364\":2,\"367\":1,\"382\":1,\"391\":1,\"445\":1,\"621\":1,\"627\":1,\"635\":4,\"642\":1,\"645\":1,\"659\":2,\"674\":2,\"687\":1,\"696\":1,\"701\":1,\"702\":1,\"705\":7,\"706\":3,\"707\":3,\"708\":3,\"709\":11,\"730\":1,\"734\":5}}],[\"|\",{\"1\":{\"5\":49,\"7\":38,\"105\":2,\"114\":2,\"364\":1,\"367\":1,\"506\":3}}],[\"+1\",{\"1\":{\"687\":4}}],[\"+2\",{\"1\":{\"687\":1}}],[\"+o1\",{\"1\":{\"443\":1}}],[\"+next\",{\"1\":{\"443\":1}}],[\"+7\",{\"1\":{\"362\":1}}],[\"+=\",{\"1\":{\"91\":1,\"359\":2,\"365\":5,\"391\":1,\"416\":1,\"624\":5,\"630\":2,\"643\":2,\"662\":1,\"671\":2,\"672\":3,\"675\":1,\"677\":1,\"678\":1,\"689\":2,\"693\":1,\"701\":3,\"713\":1,\"734\":1}}],[\"++j\",{\"1\":{\"702\":1}}],[\"++i\",{\"1\":{\"702\":1}}],[\"++right\",{\"1\":{\"631\":1}}],[\"++count\",{\"1\":{\"466\":2}}],[\"++++\",{\"1\":{\"362\":1}}],[\"++\",{\"1\":{\"91\":1,\"362\":2,\"367\":1,\"377\":1,\"381\":1,\"411\":1,\"647\":1}}],[\"+\",{\"0\":{\"357\":1},\"1\":{\"5\":30,\"7\":21,\"55\":4,\"63\":2,\"96\":4,\"102\":6,\"105\":4,\"108\":6,\"111\":15,\"114\":5,\"117\":5,\"124\":1,\"233\":3,\"248\":7,\"249\":3,\"256\":7,\"262\":5,\"268\":12,\"271\":12,\"291\":1,\"298\":3,\"300\":7,\"304\":4,\"313\":4,\"334\":2,\"335\":2,\"350\":2,\"358\":2,\"359\":2,\"360\":2,\"362\":5,\"365\":4,\"367\":1,\"368\":5,\"369\":1,\"376\":5,\"377\":1,\"382\":3,\"390\":2,\"391\":1,\"395\":11,\"403\":4,\"404\":4,\"406\":4,\"411\":1,\"415\":1,\"416\":1,\"417\":1,\"418\":4,\"428\":1,\"429\":1,\"431\":4,\"436\":33,\"439\":11,\"440\":10,\"443\":5,\"444\":2,\"448\":4,\"451\":1,\"454\":4,\"466\":9,\"468\":2,\"469\":7,\"471\":8,\"475\":7,\"477\":2,\"478\":1,\"480\":2,\"485\":2,\"489\":1,\"490\":1,\"491\":2,\"569\":4,\"576\":3,\"577\":9,\"583\":15,\"597\":1,\"598\":2,\"606\":1,\"620\":2,\"621\":3,\"622\":1,\"623\":1,\"624\":1,\"625\":1,\"627\":3,\"630\":3,\"631\":2,\"643\":1,\"645\":14,\"647\":1,\"648\":4,\"649\":3,\"650\":6,\"652\":2,\"653\":1,\"660\":1,\"661\":1,\"662\":2,\"669\":1,\"671\":1,\"672\":1,\"675\":1,\"677\":3,\"678\":3,\"683\":3,\"684\":1,\"686\":3,\"687\":27,\"688\":2,\"689\":2,\"693\":1,\"694\":3,\"695\":1,\"696\":1,\"697\":4,\"698\":5,\"699\":3,\"700\":4,\"701\":4,\"702\":2,\"704\":2,\"705\":6,\"706\":2,\"707\":6,\"708\":2,\"709\":6,\"718\":1,\"729\":1,\"730\":2,\"734\":7,\"737\":2}}],[\"4be070789f7a\",{\"1\":{\"730\":1}}],[\"4=4\",{\"1\":{\"720\":1}}],[\"416\",{\"0\":{\"701\":1}}],[\"46\",{\"0\":{\"685\":1}}],[\"45\",{\"1\":{\"678\":3}}],[\"494\",{\"0\":{\"687\":1}}],[\"49\",{\"1\":{\"625\":2,\"629\":1}}],[\"42\",{\"0\":{\"624\":1,\"693\":1}}],[\"4762\",{\"1\":{\"598\":1}}],[\"4f83df68\",{\"1\":{\"559\":1}}],[\"437\",{\"0\":{\"672\":1}}],[\"438\",{\"0\":{\"649\":1}}],[\"43\",{\"1\":{\"433\":1,\"724\":1}}],[\"48\",{\"1\":{\"399\":1}}],[\"401\",{\"1\":{\"776\":1}}],[\"409b\",{\"1\":{\"599\":1}}],[\"4096\",{\"1\":{\"114\":1}}],[\"40\",{\"1\":{\"262\":3}}],[\"404\",{\"1\":{\"155\":1,\"776\":1}}],[\"403\",{\"1\":{\"155\":1,\"776\":1}}],[\"40000001\",{\"1\":{\"492\":1}}],[\"400\",{\"1\":{\"155\":1,\"776\":1}}],[\"4xx\",{\"0\":{\"776\":1},\"1\":{\"155\":1}}],[\"4大函数式接口\",{\"1\":{\"129\":1}}],[\"4种\",{\"1\":{\"124\":1}}],[\"4\",{\"0\":{\"62\":1,\"78\":1,\"83\":1,\"225\":1,\"234\":1,\"235\":1,\"261\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"276\":1,\"277\":1,\"278\":1,\"284\":1,\"293\":1,\"298\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":1,\"313\":1,\"318\":1,\"329\":1,\"341\":1,\"501\":1,\"505\":1,\"506\":1,\"507\":1,\"508\":1,\"509\":2,\"520\":1,\"525\":1,\"530\":1,\"537\":1,\"556\":1,\"557\":1,\"558\":1,\"559\":1,\"560\":2,\"561\":1,\"562\":1,\"563\":1,\"564\":1,\"565\":1,\"570\":1,\"577\":1,\"583\":1,\"598\":1,\"604\":1,\"612\":1,\"654\":1,\"718\":1,\"730\":1,\"751\":1,\"762\":1,\"769\":1,\"773\":1,\"774\":1,\"775\":1,\"776\":2,\"777\":1},\"1\":{\"5\":2,\"7\":1,\"55\":1,\"59\":1,\"76\":1,\"116\":2,\"117\":1,\"189\":1,\"210\":1,\"245\":1,\"259\":1,\"327\":2,\"377\":1,\"381\":1,\"391\":1,\"400\":1,\"404\":1,\"419\":1,\"433\":2,\"466\":1,\"471\":2,\"477\":2,\"480\":1,\"489\":1,\"492\":1,\"495\":1,\"498\":3,\"518\":1,\"540\":5,\"542\":1,\"560\":1,\"595\":1,\"597\":1,\"598\":1,\"607\":1,\"622\":1,\"625\":2,\"628\":3,\"629\":2,\"630\":2,\"631\":3,\"632\":1,\"634\":2,\"655\":1,\"667\":2,\"668\":2,\"677\":1,\"678\":1,\"689\":4,\"693\":3,\"697\":2,\"704\":1,\"713\":2,\"718\":4,\"720\":8,\"729\":2,\"730\":3,\"740\":1,\"784\":1}}],[\"3项www构建技术\",{\"0\":{\"746\":1}}],[\"380\",{\"0\":{\"721\":1}}],[\"3=3\",{\"1\":{\"720\":2}}],[\"3次\",{\"1\":{\"718\":1}}],[\"3×4\",{\"1\":{\"705\":1}}],[\"3x3\",{\"1\":{\"696\":1}}],[\"3xx\",{\"0\":{\"775\":1},\"1\":{\"155\":1}}],[\"32\",{\"1\":{\"605\":5}}],[\"32位\",{\"1\":{\"358\":2}}],[\"362\",{\"1\":{\"760\":1}}],[\"36\",{\"1\":{\"586\":1}}],[\"31\",{\"0\":{\"628\":1},\"1\":{\"445\":1}}],[\"344\",{\"0\":{\"642\":1}}],[\"34\",{\"1\":{\"439\":1}}],[\"3456\",{\"1\":{\"436\":3}}],[\"3层\",{\"1\":{\"263\":2}}],[\"307\",{\"1\":{\"775\":1}}],[\"304\",{\"1\":{\"775\":1}}],[\"302\",{\"1\":{\"775\":1}}],[\"301\",{\"1\":{\"775\":1}}],[\"30<\",{\"1\":{\"498\":1,\"540\":2}}],[\"3000\",{\"1\":{\"248\":3,\"408\":1}}],[\"30\",{\"0\":{\"88\":1},\"1\":{\"205\":1,\"262\":1,\"433\":1}}],[\"303\",{\"1\":{\"81\":1,\"775\":1}}],[\"337\",{\"0\":{\"699\":1}}],[\"3306\",{\"1\":{\"499\":1,\"506\":1,\"507\":1,\"540\":1,\"562\":1,\"575\":1,\"583\":1,\"584\":1,\"605\":1}}],[\"33\",{\"0\":{\"621\":1},\"1\":{\"5\":2}}],[\"3\",{\"0\":{\"7\":1,\"46\":1,\"61\":1,\"77\":1,\"82\":1,\"91\":1,\"224\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"234\":1,\"249\":1,\"253\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":2,\"261\":1,\"262\":1,\"263\":1,\"264\":1,\"275\":1,\"283\":1,\"292\":1,\"297\":1,\"304\":1,\"308\":1,\"312\":1,\"317\":1,\"324\":1,\"328\":1,\"338\":1,\"339\":1,\"340\":2,\"341\":1,\"342\":1,\"343\":1,\"500\":1,\"503\":1,\"504\":1,\"508\":1,\"519\":1,\"524\":1,\"529\":1,\"536\":1,\"549\":1,\"553\":1,\"554\":1,\"555\":1,\"559\":1,\"569\":1,\"576\":1,\"582\":1,\"597\":1,\"608\":1,\"609\":1,\"610\":1,\"611\":2,\"612\":1,\"613\":1,\"614\":1,\"615\":1,\"616\":1,\"617\":1,\"641\":1,\"647\":1,\"729\":1,\"747\":1,\"761\":1,\"767\":1,\"768\":2,\"769\":1,\"770\":1,\"771\":1,\"775\":1,\"781\":1},\"1\":{\"5\":7,\"7\":2,\"55\":2,\"59\":1,\"70\":1,\"76\":1,\"90\":1,\"98\":2,\"101\":1,\"104\":2,\"113\":2,\"116\":2,\"196\":1,\"210\":1,\"244\":1,\"249\":1,\"259\":1,\"268\":2,\"299\":1,\"312\":1,\"318\":4,\"362\":6,\"365\":1,\"366\":1,\"381\":2,\"382\":4,\"391\":1,\"399\":1,\"400\":1,\"404\":1,\"419\":1,\"429\":2,\"430\":1,\"433\":1,\"440\":2,\"445\":2,\"448\":1,\"471\":2,\"475\":1,\"477\":2,\"479\":1,\"480\":1,\"489\":1,\"492\":1,\"495\":1,\"499\":2,\"501\":3,\"504\":2,\"518\":1,\"540\":1,\"542\":1,\"552\":1,\"557\":1,\"559\":1,\"560\":3,\"583\":1,\"595\":1,\"597\":1,\"598\":2,\"607\":1,\"617\":1,\"624\":2,\"625\":2,\"628\":12,\"629\":3,\"630\":3,\"631\":11,\"632\":2,\"634\":3,\"645\":3,\"647\":2,\"650\":1,\"655\":1,\"660\":1,\"661\":26,\"667\":5,\"668\":4,\"669\":3,\"674\":1,\"677\":2,\"678\":3,\"684\":1,\"686\":6,\"687\":7,\"689\":4,\"690\":1,\"693\":1,\"697\":4,\"698\":3,\"702\":1,\"704\":1,\"713\":1,\"716\":2,\"718\":8,\"720\":8,\"726\":1,\"729\":2,\"730\":3,\"737\":1,\"740\":3}}],[\"63\",{\"0\":{\"696\":1}}],[\"62\",{\"0\":{\"695\":1}}],[\"64\",{\"1\":{\"605\":5}}],[\"64位\",{\"1\":{\"358\":2}}],[\"6185f2c8\",{\"1\":{\"599\":1}}],[\"60\",{\"1\":{\"466\":1}}],[\"6000\",{\"1\":{\"404\":1,\"486\":1}}],[\"695\",{\"0\":{\"707\":1}}],[\"698\",{\"0\":{\"689\":1}}],[\"69\",{\"1\":{\"381\":1,\"622\":1}}],[\"6个字节来表示字符\",{\"1\":{\"356\":1}}],[\"65536个字符\",{\"1\":{\"356\":1}}],[\"6版本之后成为可用的存储引擎\",{\"1\":{\"183\":1}}],[\"6\",{\"0\":{\"64\":1,\"227\":1,\"250\":1,\"251\":1,\"252\":1,\"253\":1,\"263\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"278\":1,\"279\":1,\"280\":2,\"281\":2,\"282\":2,\"283\":2,\"284\":2,\"285\":2,\"286\":3,\"287\":2,\"288\":2,\"300\":1,\"319\":1,\"331\":1,\"343\":1,\"513\":1,\"514\":1,\"515\":1,\"532\":1,\"562\":1,\"572\":1,\"573\":1,\"574\":1,\"575\":1,\"576\":1,\"577\":1,\"578\":1,\"600\":1,\"606\":1,\"614\":1,\"680\":1,\"755\":1,\"771\":1,\"783\":1,\"784\":1,\"785\":1,\"786\":1},\"1\":{\"5\":2,\"7\":1,\"76\":1,\"116\":1,\"187\":2,\"210\":1,\"362\":2,\"381\":1,\"408\":1,\"439\":1,\"477\":1,\"492\":1,\"598\":1,\"616\":1,\"624\":2,\"625\":2,\"628\":2,\"632\":1,\"634\":3,\"649\":2,\"661\":9,\"667\":2,\"693\":2,\"713\":1,\"730\":2}}],[\"5xx\",{\"0\":{\"777\":1}}],[\"55\",{\"1\":{\"678\":3}}],[\"55183b20\",{\"1\":{\"559\":3}}],[\"541\",{\"0\":{\"643\":1}}],[\"59\",{\"0\":{\"632\":1}}],[\"5level\",{\"1\":{\"586\":1}}],[\"560\",{\"0\":{\"671\":1}}],[\"56\",{\"1\":{\"524\":3}}],[\"5倍扩容\",{\"1\":{\"442\":1}}],[\"5倍如果是无参1\",{\"1\":{\"442\":1}}],[\"5倍\",{\"1\":{\"441\":2}}],[\"503\",{\"1\":{\"777\":1}}],[\"509\",{\"0\":{\"694\":1}}],[\"5001~10\",{\"1\":{\"770\":1}}],[\"500\",{\"1\":{\"469\":1,\"605\":1,\"777\":1}}],[\"50000\",{\"1\":{\"486\":1}}],[\"5000\",{\"1\":{\"291\":1,\"408\":2,\"598\":1}}],[\"50\",{\"1\":{\"433\":1,\"466\":2,\"468\":2,\"471\":1,\"605\":8,\"606\":1,\"760\":1}}],[\"53\",{\"1\":{\"381\":1}}],[\"5\",{\"0\":{\"63\":1,\"84\":1,\"226\":1,\"236\":1,\"237\":1,\"248\":1,\"249\":1,\"262\":1,\"269\":1,\"270\":1,\"271\":1,\"279\":1,\"285\":1,\"299\":1,\"314\":1,\"315\":1,\"316\":1,\"317\":1,\"318\":1,\"330\":1,\"342\":1,\"502\":1,\"510\":1,\"511\":1,\"512\":1,\"531\":1,\"538\":1,\"561\":1,\"566\":1,\"567\":1,\"568\":1,\"569\":1,\"570\":1,\"571\":2,\"572\":1,\"578\":1,\"584\":1,\"599\":1,\"605\":1,\"613\":1,\"650\":1,\"663\":1,\"754\":1,\"763\":1,\"770\":1,\"777\":1,\"779\":1,\"780\":1,\"781\":1},\"1\":{\"5\":4,\"7\":1,\"59\":2,\"76\":1,\"105\":1,\"116\":1,\"183\":1,\"210\":1,\"233\":1,\"246\":1,\"268\":2,\"298\":1,\"313\":1,\"358\":1,\"362\":1,\"366\":1,\"391\":3,\"404\":1,\"419\":1,\"424\":1,\"439\":1,\"440\":2,\"454\":2,\"477\":1,\"489\":3,\"491\":1,\"498\":1,\"540\":1,\"542\":1,\"560\":2,\"598\":1,\"599\":1,\"607\":3,\"616\":1,\"617\":1,\"625\":2,\"628\":4,\"631\":1,\"632\":1,\"634\":2,\"636\":1,\"661\":11,\"677\":1,\"678\":3,\"687\":2,\"689\":2,\"693\":1,\"701\":4,\"713\":1,\"718\":5,\"724\":2,\"726\":1,\"729\":2,\"730\":4}}],[\"000字节内的资源\",{\"1\":{\"770\":1}}],[\"000字节大小的资源可以只请求\",{\"1\":{\"770\":1}}],[\"0000\",{\"1\":{\"713\":3}}],[\"05\",{\"0\":{\"644\":1}}],[\"04\",{\"1\":{\"616\":1}}],[\"0=\",{\"1\":{\"605\":2}}],[\"0=jdbc\",{\"1\":{\"605\":1}}],[\"0表示使用默认值\",{\"1\":{\"605\":7}}],[\"0~1之间\",{\"1\":{\"599\":1}}],[\"0~1024已经被占用\",{\"1\":{\"482\":1}}],[\"092b6cbe\",{\"1\":{\"598\":1}}],[\"0<\",{\"1\":{\"498\":1,\"540\":3}}],[\"0l\",{\"1\":{\"431\":2,\"672\":1}}],[\"0的反码\",{\"1\":{\"369\":1}}],[\"0添加\",{\"1\":{\"222\":1}}],[\"0引入多线程i\",{\"1\":{\"187\":1}}],[\"0之前\",{\"1\":{\"187\":1}}],[\"0资源服务器的支持\",{\"1\":{\"81\":1}}],[\"0客户端的支持\",{\"1\":{\"81\":1}}],[\"07\",{\"1\":{\"5\":2,\"639\":2}}],[\"0\",{\"0\":{\"590\":1},\"1\":{\"5\":5,\"7\":1,\"27\":1,\"55\":10,\"59\":3,\"63\":1,\"91\":11,\"102\":1,\"105\":2,\"114\":4,\"117\":1,\"124\":1,\"187\":2,\"189\":1,\"194\":2,\"220\":1,\"256\":1,\"262\":4,\"304\":1,\"312\":1,\"313\":2,\"318\":5,\"327\":3,\"354\":1,\"377\":2,\"381\":6,\"382\":9,\"390\":1,\"391\":3,\"392\":1,\"404\":1,\"411\":1,\"416\":1,\"417\":1,\"424\":1,\"427\":2,\"429\":2,\"430\":1,\"431\":3,\"433\":1,\"436\":1,\"440\":1,\"442\":1,\"443\":2,\"444\":1,\"461\":1,\"466\":5,\"468\":3,\"469\":1,\"471\":1,\"477\":13,\"478\":2,\"485\":2,\"492\":3,\"498\":10,\"499\":2,\"501\":2,\"504\":2,\"540\":14,\"552\":1,\"555\":1,\"557\":4,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":2,\"586\":1,\"597\":2,\"605\":26,\"616\":1,\"620\":1,\"621\":1,\"622\":6,\"623\":3,\"624\":23,\"625\":9,\"626\":1,\"628\":1,\"629\":7,\"630\":11,\"631\":8,\"632\":4,\"635\":16,\"637\":1,\"638\":2,\"639\":3,\"640\":1,\"642\":2,\"643\":1,\"645\":3,\"646\":1,\"647\":3,\"648\":5,\"649\":8,\"650\":3,\"651\":1,\"652\":2,\"653\":9,\"659\":2,\"660\":4,\"661\":2,\"662\":9,\"666\":2,\"669\":4,\"671\":5,\"672\":5,\"674\":2,\"675\":3,\"676\":1,\"677\":7,\"678\":7,\"684\":2,\"685\":1,\"686\":5,\"687\":8,\"688\":1,\"689\":11,\"690\":4,\"693\":7,\"694\":8,\"695\":13,\"696\":19,\"697\":9,\"698\":11,\"699\":8,\"700\":7,\"701\":18,\"702\":4,\"704\":3,\"705\":8,\"706\":21,\"707\":11,\"708\":29,\"709\":33,\"711\":2,\"712\":3,\"713\":8,\"715\":6,\"716\":5,\"717\":8,\"718\":5,\"724\":3,\"726\":1,\"727\":1,\"728\":1,\"729\":3,\"730\":12,\"734\":8,\"737\":2,\"742\":5,\"768\":1}}],[\"06\",{\"1\":{\"5\":2,\"524\":3,\"760\":1}}],[\"0245\",{\"1\":{\"478\":1}}],[\"02\",{\"1\":{\"5\":4}}],[\"01\",{\"1\":{\"5\":2}}],[\"03\",{\"1\":{\"5\":8}}],[\"2→\",{\"1\":{\"729\":1}}],[\"2=2\",{\"1\":{\"720\":1}}],[\"213\",{\"0\":{\"698\":1}}],[\"26\",{\"0\":{\"718\":1},\"1\":{\"674\":1,\"675\":1}}],[\"26号华为机考第二题\",{\"1\":{\"55\":1}}],[\"28\",{\"0\":{\"651\":1}}],[\"2k\",{\"1\":{\"643\":3}}],[\"27\",{\"0\":{\"623\":1}}],[\"2b8\",{\"1\":{\"499\":1,\"506\":1,\"507\":1,\"540\":1}}],[\"2大接口\",{\"1\":{\"492\":1}}],[\"2^n\",{\"1\":{\"492\":1}}],[\"24\",{\"0\":{\"637\":1},\"1\":{\"381\":1,\"404\":1,\"637\":1}}],[\"2在创建时就会调用\",{\"1\":{\"340\":1}}],[\"2步只有在第一次创建实例时会调用\",{\"1\":{\"328\":1}}],[\"239\",{\"0\":{\"661\":1}}],[\"232\",{\"0\":{\"655\":1}}],[\"23df\",{\"1\":{\"599\":1}}],[\"23\",{\"1\":{\"297\":1,\"390\":1,\"404\":1,\"445\":1,\"684\":1}}],[\"230\",{\"1\":{\"27\":1}}],[\"2层\",{\"1\":{\"263\":2}}],[\"2f\",{\"1\":{\"256\":2}}],[\"2xx\",{\"0\":{\"774\":1},\"1\":{\"155\":1}}],[\"204\",{\"1\":{\"774\":1}}],[\"207\",{\"0\":{\"717\":1}}],[\"206\",{\"0\":{\"636\":1},\"1\":{\"770\":1,\"774\":1}}],[\"203\",{\"0\":{\"634\":1}}],[\"209\",{\"0\":{\"630\":1}}],[\"20\",{\"0\":{\"659\":1},\"1\":{\"402\":1,\"403\":2,\"404\":1,\"468\":2,\"501\":1,\"530\":1,\"569\":1,\"605\":12,\"644\":3,\"669\":2,\"678\":3}}],[\"20000\",{\"1\":{\"404\":1,\"431\":3}}],[\"2000\",{\"1\":{\"248\":2,\"408\":1,\"598\":1}}],[\"200\",{\"0\":{\"706\":1},\"1\":{\"155\":1,\"606\":1,\"760\":2,\"774\":1}}],[\"2001\",{\"1\":{\"63\":1,\"327\":1,\"498\":1,\"540\":1,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1}}],[\"2009\",{\"1\":{\"59\":1}}],[\"2009的版本\",{\"1\":{\"49\":1}}],[\"2007\",{\"1\":{\"59\":1}}],[\"20221018105613706\",{\"1\":{\"586\":1}}],[\"20221016160326239\",{\"1\":{\"582\":1}}],[\"20221104140010926\",{\"1\":{\"522\":1}}],[\"2022\",{\"1\":{\"524\":3}}],[\"20220613163853802\",{\"1\":{\"786\":1}}],[\"20220613163753679\",{\"1\":{\"786\":1}}],[\"20220613163715233\",{\"1\":{\"786\":1}}],[\"20220613163630941\",{\"1\":{\"786\":1}}],[\"20220613163248334\",{\"1\":{\"785\":1}}],[\"20220613162920590\",{\"1\":{\"785\":1}}],[\"20220613161217832\",{\"1\":{\"784\":1}}],[\"20220613161119615\",{\"1\":{\"783\":1}}],[\"20220613160632816\",{\"1\":{\"783\":1}}],[\"20220607162710737\",{\"1\":{\"781\":1}}],[\"20220607162623180\",{\"1\":{\"781\":1}}],[\"20220607161416653\",{\"1\":{\"781\":1}}],[\"20220607154559474\",{\"1\":{\"780\":1}}],[\"20220607153136712\",{\"1\":{\"780\":1}}],[\"20220607150540596\",{\"1\":{\"780\":1}}],[\"20220607102537456\",{\"1\":{\"779\":1}}],[\"20220607101723849\",{\"1\":{\"779\":1}}],[\"20220606153504993\",{\"1\":{\"776\":1}}],[\"20220606153105058\",{\"1\":{\"775\":1}}],[\"20220606105946593\",{\"1\":{\"775\":1}}],[\"20220606105657052\",{\"1\":{\"775\":1}}],[\"20220606105546497\",{\"1\":{\"775\":1}}],[\"20220606105213896\",{\"1\":{\"774\":1}}],[\"20220606104655840\",{\"1\":{\"773\":1}}],[\"20220606104624138\",{\"1\":{\"773\":1}}],[\"20220601151351231\",{\"1\":{\"770\":1}}],[\"20220601151244206\",{\"1\":{\"770\":1}}],[\"20220601090527855\",{\"1\":{\"768\":1}}],[\"20220601083542688\",{\"1\":{\"767\":1}}],[\"20220601083458070\",{\"1\":{\"767\":1}}],[\"20220530220734131\",{\"1\":{\"765\":1}}],[\"20220530220602402\",{\"1\":{\"765\":1}}],[\"20220530220550805\",{\"1\":{\"765\":1}}],[\"20220530214941450\",{\"1\":{\"763\":1}}],[\"20220530214816605\",{\"1\":{\"763\":1}}],[\"20220530214737632\",{\"1\":{\"763\":1}}],[\"20220530214406072\",{\"1\":{\"763\":1}}],[\"20220530214336582\",{\"1\":{\"763\":1}}],[\"20220530214320409\",{\"1\":{\"763\":1}}],[\"20220530214309518\",{\"1\":{\"763\":1}}],[\"20220530215006775\",{\"1\":{\"763\":1}}],[\"20220424164952584\",{\"1\":{\"757\":1}}],[\"20220424164647288\",{\"1\":{\"755\":1}}],[\"20220424163837296\",{\"1\":{\"753\":1}}],[\"20220424161516323\",{\"1\":{\"750\":1}}],[\"20220424161324998\",{\"1\":{\"750\":1}}],[\"20220424153500110\",{\"1\":{\"748\":1}}],[\"20220929205623323\",{\"1\":{\"571\":1}}],[\"20220914215416375\",{\"1\":{\"562\":1}}],[\"20220906170932519\",{\"1\":{\"555\":1}}],[\"20220905151848479\",{\"1\":{\"552\":1}}],[\"20220902165619031\",{\"1\":{\"339\":1}}],[\"20220829160037207\",{\"1\":{\"329\":1}}],[\"20230721135022502\",{\"1\":{\"611\":1}}],[\"20230724151325568\",{\"1\":{\"51\":1}}],[\"20230710214419984\",{\"1\":{\"312\":1}}],[\"20230605144910144\",{\"1\":{\"264\":1}}],[\"20230526173657051\",{\"1\":{\"237\":1}}],[\"20230526102154164\",{\"1\":{\"231\":1}}],[\"20230823113257933\",{\"1\":{\"209\":1}}],[\"20230413095523029\",{\"1\":{\"114\":1}}],[\"20230413093716561\",{\"1\":{\"111\":1}}],[\"20230413202903759\",{\"1\":{\"60\":1}}],[\"2020\",{\"1\":{\"40\":1}}],[\"2012\",{\"1\":{\"760\":1}}],[\"201911032247\",{\"1\":{\"483\":1}}],[\"2013\",{\"1\":{\"59\":1}}],[\"2018\",{\"1\":{\"5\":2}}],[\"2017\",{\"1\":{\"5\":2}}],[\"2016\",{\"1\":{\"5\":6}}],[\"256\",{\"1\":{\"605\":2}}],[\"255\",{\"1\":{\"605\":10}}],[\"253\",{\"1\":{\"27\":1}}],[\"25\",{\"1\":{\"5\":2,\"617\":1,\"678\":11}}],[\"2\",{\"0\":{\"6\":1,\"45\":1,\"60\":1,\"76\":1,\"81\":1,\"90\":1,\"221\":1,\"222\":1,\"223\":2,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"230\":1,\"231\":1,\"232\":2,\"233\":1,\"234\":1,\"235\":1,\"236\":1,\"237\":1,\"248\":2,\"249\":1,\"250\":1,\"251\":1,\"252\":2,\"253\":1,\"254\":1,\"255\":1,\"256\":2,\"259\":1,\"268\":1,\"271\":1,\"274\":1,\"278\":1,\"282\":1,\"291\":1,\"296\":1,\"303\":1,\"307\":1,\"311\":1,\"316\":1,\"323\":1,\"326\":1,\"327\":2,\"328\":1,\"329\":1,\"330\":1,\"331\":1,\"332\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"339\":1,\"496\":1,\"497\":1,\"498\":1,\"499\":2,\"500\":1,\"501\":1,\"502\":1,\"507\":1,\"512\":1,\"515\":1,\"518\":1,\"523\":1,\"528\":1,\"535\":1,\"541\":1,\"546\":1,\"547\":1,\"548\":2,\"550\":1,\"551\":1,\"552\":2,\"555\":1,\"558\":1,\"568\":1,\"575\":1,\"581\":1,\"587\":1,\"588\":1,\"596\":1,\"601\":1,\"602\":1,\"603\":2,\"604\":1,\"605\":1,\"606\":1,\"607\":1,\"610\":1,\"633\":1,\"725\":1,\"727\":1,\"728\":2,\"745\":1,\"759\":1,\"760\":2,\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"765\":1,\"774\":1,\"780\":1,\"784\":1},\"1\":{\"5\":6,\"6\":1,\"7\":5,\"11\":14,\"25\":1,\"55\":1,\"59\":1,\"70\":1,\"76\":1,\"81\":2,\"83\":1,\"90\":1,\"98\":3,\"101\":2,\"104\":2,\"107\":4,\"113\":2,\"116\":6,\"176\":2,\"187\":1,\"196\":1,\"204\":1,\"210\":1,\"217\":1,\"242\":1,\"252\":1,\"256\":1,\"259\":1,\"299\":1,\"312\":1,\"318\":2,\"362\":6,\"365\":1,\"377\":1,\"381\":2,\"382\":4,\"391\":3,\"399\":1,\"400\":1,\"403\":1,\"404\":1,\"408\":3,\"414\":1,\"419\":1,\"427\":1,\"430\":2,\"433\":1,\"436\":2,\"439\":1,\"440\":1,\"442\":1,\"448\":1,\"454\":2,\"471\":2,\"475\":1,\"477\":2,\"478\":3,\"479\":1,\"480\":1,\"489\":2,\"491\":1,\"495\":1,\"501\":2,\"509\":1,\"540\":1,\"542\":1,\"552\":1,\"557\":4,\"559\":1,\"560\":3,\"583\":1,\"595\":1,\"597\":4,\"598\":3,\"599\":3,\"606\":3,\"607\":2,\"617\":1,\"620\":1,\"621\":1,\"622\":2,\"624\":7,\"625\":2,\"627\":2,\"628\":12,\"629\":2,\"630\":3,\"631\":18,\"632\":5,\"634\":3,\"635\":1,\"639\":2,\"643\":4,\"645\":3,\"650\":2,\"651\":2,\"655\":1,\"659\":2,\"660\":1,\"662\":2,\"667\":5,\"668\":5,\"674\":1,\"677\":4,\"678\":6,\"684\":3,\"686\":5,\"687\":6,\"689\":8,\"690\":2,\"693\":3,\"694\":4,\"696\":2,\"697\":4,\"698\":9,\"701\":8,\"702\":1,\"704\":2,\"708\":1,\"713\":1,\"716\":3,\"717\":2,\"718\":4,\"720\":9,\"724\":1,\"729\":2,\"730\":3,\"737\":2,\"740\":2,\"742\":2}}],[\"226\",{\"0\":{\"667\":1}}],[\"225\",{\"0\":{\"656\":1}}],[\"22\",{\"0\":{\"690\":1},\"1\":{\"3\":10,\"297\":1,\"440\":1}}],[\"vs\",{\"1\":{\"466\":1}}],[\"v不带表值\",{\"1\":{\"456\":1}}],[\"vector\",{\"1\":{\"442\":1}}],[\"vector和arraylist比较\",{\"1\":{\"442\":1}}],[\"vector是线程同步的\",{\"1\":{\"442\":1}}],[\"vector底层也是一个对象数组\",{\"1\":{\"442\":1}}],[\"vector底层结构和源码剖析\",{\"0\":{\"442\":1}}],[\"version>\",{\"1\":{\"498\":4,\"540\":10,\"599\":1}}],[\"version=\",{\"1\":{\"63\":1,\"327\":2,\"498\":1,\"499\":1,\"501\":1,\"504\":1,\"540\":2,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1,\"586\":1}}],[\"version\",{\"1\":{\"59\":1,\"178\":1,\"354\":1,\"617\":1}}],[\"v类型的数据结构\",{\"1\":{\"308\":1}}],[\"v的集合\",{\"1\":{\"306\":1}}],[\"v\",{\"1\":{\"249\":2,\"251\":4,\"448\":1,\"480\":2,\"615\":2,\"716\":5}}],[\"v>\",{\"1\":{\"248\":6,\"251\":2,\"456\":1}}],[\"vhost\",{\"1\":{\"209\":2}}],[\"via\",{\"1\":{\"780\":1}}],[\"visited\",{\"1\":{\"711\":4,\"713\":6,\"715\":1,\"716\":5,\"717\":4}}],[\"virtulhead\",{\"1\":{\"637\":3,\"638\":4}}],[\"virtual\",{\"1\":{\"209\":1}}],[\"view来确定可见的数据行版本\",{\"1\":{\"178\":1}}],[\"view来获取数据\",{\"1\":{\"178\":1}}],[\"view之后\",{\"1\":{\"178\":1}}],[\"view找到符合条件的最新版本数据行\",{\"1\":{\"178\":1}}],[\"view包含事务启动时系统中有效的活跃事务列表和已提交事务列表\",{\"1\":{\"178\":1}}],[\"viewcontrollerregistry\",{\"1\":{\"78\":1}}],[\"viewresolverregistry\",{\"1\":{\"78\":1}}],[\"viewreslover解析后返回具体view\",{\"1\":{\"76\":1}}],[\"view是一个接口\",{\"1\":{\"76\":1}}],[\"view\",{\"1\":{\"76\":3,\"162\":1,\"178\":2}}],[\"vm\",{\"1\":{\"186\":1}}],[\"vmware\",{\"0\":{\"49\":1}}],[\"volumes\",{\"1\":{\"617\":1}}],[\"volume\",{\"1\":{\"615\":2}}],[\"volatile不能保证原子性\",{\"0\":{\"293\":1}}],[\"volatile保证有序性\",{\"0\":{\"292\":1}}],[\"volatile保证可见性\",{\"0\":{\"291\":1}}],[\"volatiledemo\",{\"1\":{\"291\":1}}],[\"volatile实现了java内存模型中的可见性和有序性\",{\"1\":{\"290\":1}}],[\"volatile与jmm\",{\"0\":{\"289\":1}}],[\"volatile变量规则\",{\"0\":{\"283\":1}}],[\"volatile\",{\"0\":{\"140\":1},\"1\":{\"192\":4,\"268\":2,\"292\":1,\"312\":4}}],[\"volatile作用\",{\"0\":{\"140\":1},\"1\":{\"140\":1}}],[\"volatile和sychronized的区别\",{\"0\":{\"138\":1}}],[\"volatile关键字是无能为力的\",{\"1\":{\"293\":1}}],[\"volatile关键字保证了一个线程对volatile变量的写操作对其他线程可见\",{\"1\":{\"140\":1}}],[\"volatile关键字保证了多线程环境下的可见性\",{\"1\":{\"128\":1}}],[\"volatile关键字在java中用于确保共享变量的可见性和禁止指令重排\",{\"1\":{\"140\":1}}],[\"volatile关键字提供了禁止指令重排序和保证可见性的功能\",{\"1\":{\"138\":1}}],[\"volatile关键字用于修饰变量\",{\"1\":{\"138\":1}}],[\"volatile关键字不能保证操作的原子性\",{\"1\":{\"128\":1}}],[\"volatile关键字可以防止指令重排序优化\",{\"1\":{\"128\":1}}],[\"volatile关键字有什么作用\",{\"0\":{\"128\":1}}],[\"volatile等\",{\"1\":{\"125\":1}}],[\"void\",{\"1\":{\"3\":1,\"55\":2,\"78\":7,\"91\":1,\"96\":7,\"99\":1,\"102\":5,\"105\":12,\"108\":14,\"111\":4,\"114\":16,\"117\":6,\"123\":1,\"220\":2,\"223\":1,\"232\":1,\"233\":1,\"248\":4,\"249\":1,\"251\":2,\"252\":1,\"253\":1,\"256\":1,\"262\":2,\"263\":1,\"268\":3,\"271\":3,\"291\":2,\"297\":1,\"298\":3,\"300\":1,\"304\":3,\"306\":2,\"313\":1,\"334\":2,\"339\":3,\"351\":2,\"352\":2,\"354\":1,\"368\":1,\"376\":1,\"377\":1,\"381\":3,\"382\":3,\"390\":2,\"391\":5,\"399\":1,\"402\":6,\"403\":1,\"404\":8,\"411\":2,\"412\":1,\"413\":4,\"414\":3,\"415\":1,\"416\":4,\"417\":10,\"418\":10,\"419\":16,\"421\":2,\"427\":3,\"428\":1,\"429\":1,\"430\":2,\"431\":1,\"433\":1,\"436\":3,\"439\":1,\"440\":5,\"443\":1,\"444\":1,\"445\":1,\"448\":1,\"451\":1,\"454\":3,\"457\":2,\"459\":3,\"466\":9,\"467\":3,\"468\":4,\"469\":2,\"470\":1,\"471\":7,\"475\":5,\"477\":8,\"478\":6,\"479\":4,\"480\":1,\"483\":1,\"485\":2,\"486\":3,\"490\":2,\"491\":2,\"502\":1,\"512\":1,\"524\":1,\"530\":1,\"552\":1,\"557\":9,\"559\":1,\"560\":4,\"563\":1,\"564\":3,\"565\":1,\"569\":1,\"572\":7,\"576\":7,\"577\":6,\"583\":11,\"584\":1,\"586\":1,\"628\":1,\"635\":8,\"642\":1,\"643\":1,\"645\":2,\"648\":3,\"653\":1,\"655\":2,\"657\":1,\"658\":1,\"661\":2,\"664\":3,\"667\":1,\"674\":1,\"677\":2,\"678\":1,\"682\":1,\"683\":1,\"684\":1,\"685\":1,\"686\":2,\"687\":1,\"688\":1,\"690\":1,\"699\":1,\"704\":1,\"706\":1,\"708\":1,\"709\":6,\"715\":2,\"716\":1,\"717\":1,\"718\":2,\"720\":3,\"724\":1,\"729\":1,\"730\":1}}],[\"vuex\",{\"1\":{\"93\":1}}],[\"vue\",{\"0\":{\"37\":1}}],[\"vuepress\",{\"0\":{\"16\":1},\"1\":{\"12\":2,\"14\":2,\"15\":1,\"16\":2,\"17\":1,\"41\":1}}],[\"var\",{\"1\":{\"617\":1}}],[\"varchar\",{\"1\":{\"605\":54}}],[\"var3\",{\"1\":{\"477\":5}}],[\"var2\",{\"1\":{\"477\":5}}],[\"var1\",{\"1\":{\"330\":1,\"477\":4}}],[\"variable\",{\"1\":{\"18\":1,\"491\":1}}],[\"val存入数组\",{\"1\":{\"730\":1}}],[\"val=val\",{\"1\":{\"635\":1}}],[\"val\",{\"1\":{\"623\":4,\"634\":14,\"635\":20,\"636\":7,\"637\":7,\"638\":7,\"639\":2,\"640\":2,\"664\":10,\"666\":8,\"667\":7,\"668\":9,\"669\":1,\"672\":8,\"674\":4,\"675\":1,\"677\":6,\"678\":4,\"699\":8,\"700\":3,\"720\":2,\"721\":12,\"729\":6,\"730\":8}}],[\"valid++\",{\"1\":{\"648\":1,\"649\":1}}],[\"valid\",{\"1\":{\"598\":1,\"648\":3,\"649\":4}}],[\"validation\",{\"1\":{\"81\":1}}],[\"value不能为null\",{\"1\":{\"450\":1}}],[\"value不是final类型\",{\"1\":{\"430\":1}}],[\"value可以重复\",{\"1\":{\"448\":1}}],[\"value>jimowo<\",{\"1\":{\"327\":1}}],[\"value>123456<\",{\"1\":{\"327\":1}}],[\"value>\",{\"1\":{\"327\":3,\"557\":14}}],[\"value>yanmingkui<\",{\"1\":{\"327\":1}}],[\"valueifabsent\",{\"1\":{\"241\":1}}],[\"value这里设置为test\",{\"1\":{\"205\":1}}],[\"valueof\",{\"0\":{\"130\":1},\"1\":{\"130\":4,\"421\":1,\"427\":1,\"428\":1,\"431\":2,\"491\":1}}],[\"value\",{\"1\":{\"124\":1,\"205\":1,\"242\":1,\"260\":2,\"304\":5,\"306\":3,\"307\":5,\"334\":2,\"406\":1,\"429\":1,\"448\":1,\"480\":1,\"507\":1,\"563\":1,\"564\":9,\"572\":5,\"583\":1,\"606\":1,\"616\":1,\"630\":4,\"648\":2,\"649\":1,\"720\":6,\"730\":1}}],[\"value=\",{\"1\":{\"67\":2,\"499\":4,\"506\":4,\"522\":1,\"524\":2,\"540\":4,\"557\":17,\"560\":2,\"562\":8,\"575\":4,\"583\":4}}],[\"values\",{\"1\":{\"5\":5,\"124\":1,\"448\":2,\"501\":2,\"520\":1,\"531\":1,\"576\":1,\"577\":1,\"605\":2}}],[\"tue\",{\"1\":{\"760\":1}}],[\"tuv\",{\"1\":{\"684\":1}}],[\"t比s长的情况\",{\"1\":{\"648\":1}}],[\"tmpnode\",{\"1\":{\"639\":2}}],[\"tmplen\",{\"1\":{\"639\":2}}],[\"tmp\",{\"1\":{\"616\":5}}],[\"txconfig\",{\"1\":{\"584\":2}}],[\"txadvice\",{\"1\":{\"583\":2}}],[\"tx\",{\"1\":{\"583\":6}}],[\"tx=\",{\"1\":{\"583\":1}}],[\"txt\",{\"1\":{\"114\":2,\"323\":1,\"475\":4,\"477\":8,\"478\":3,\"479\":4}}],[\"txtdisplayimpl\",{\"1\":{\"114\":2}}],[\"twosum\",{\"1\":{\"626\":1}}],[\"two\",{\"1\":{\"525\":1}}],[\"twodemensionarr\",{\"1\":{\"382\":2}}],[\"tja>af96\",{\"1\":{\"499\":1,\"506\":1,\"507\":1,\"540\":1,\"562\":1,\"575\":1,\"583\":1,\"584\":1}}],[\"t价格\",{\"1\":{\"430\":1}}],[\"tcdemo\",{\"1\":{\"327\":1,\"339\":1}}],[\"tcp网络通信编程\",{\"0\":{\"485\":1}}],[\"tcp和udp\",{\"1\":{\"482\":1}}],[\"tcp和udp区别\",{\"0\":{\"156\":1},\"1\":{\"156\":1}}],[\"tcp\",{\"0\":{\"747\":1,\"748\":1,\"749\":1,\"750\":1},\"1\":{\"209\":2,\"482\":2,\"749\":2}}],[\"tcp保证数据包按发送顺序到达目标设备\",{\"1\":{\"156\":1}}],[\"tcp提供可靠的数据传输\",{\"1\":{\"156\":1}}],[\"tcp通过在通信双方之间建立可靠的连接来传输数据\",{\"1\":{\"156\":1}}],[\"tcp是面向连接的协议\",{\"1\":{\"156\":1}}],[\"tail开始\",{\"1\":{\"635\":1}}],[\"tail\",{\"1\":{\"635\":4}}],[\"tar\",{\"1\":{\"616\":3}}],[\"targetsum\",{\"1\":{\"672\":2}}],[\"target=\",{\"1\":{\"586\":1}}],[\"targetproject\",{\"1\":{\"540\":2}}],[\"targetproject=\",{\"1\":{\"540\":3}}],[\"targetpackage\",{\"1\":{\"540\":2}}],[\"targetpackage=\",{\"1\":{\"540\":3}}],[\"targetruntime=\",{\"1\":{\"540\":1,\"541\":1}}],[\"target>\",{\"1\":{\"498\":1,\"540\":1}}],[\"target>8<\",{\"1\":{\"498\":1,\"540\":1}}],[\"target\",{\"1\":{\"419\":12,\"422\":1,\"620\":3,\"621\":8,\"626\":3,\"627\":5,\"630\":5,\"687\":17,\"689\":7,\"701\":12,\"711\":1,\"713\":3}}],[\"tags\",{\"1\":{\"605\":2}}],[\"tag`\",{\"1\":{\"605\":1}}],[\"tag\",{\"1\":{\"605\":6}}],[\"taobao\",{\"1\":{\"256\":1,\"607\":2}}],[\"table>\",{\"1\":{\"540\":2}}],[\"tablename=\",{\"1\":{\"540\":2}}],[\"tablename\",{\"1\":{\"519\":3,\"540\":1}}],[\"table数组扩容到16\",{\"1\":{\"445\":1}}],[\"table\",{\"1\":{\"5\":4,\"461\":2,\"605\":12,\"692\":1}}],[\"t>\",{\"1\":{\"245\":1,\"248\":3,\"251\":3}}],[\"ttl\",{\"1\":{\"192\":1}}],[\"tls证书发送给客户端\",{\"1\":{\"155\":1}}],[\"tls证书\",{\"1\":{\"155\":2}}],[\"tls协议对通信内容进行加密\",{\"1\":{\"154\":1}}],[\"tyh\",{\"1\":{\"102\":1}}],[\"type`\",{\"1\":{\"605\":3}}],[\"type>\",{\"1\":{\"599\":1}}],[\"typealiases\",{\"0\":{\"508\":1}}],[\"typealiases>\",{\"1\":{\"499\":1,\"508\":1}}],[\"type=\",{\"1\":{\"499\":3,\"501\":1,\"506\":4,\"508\":2,\"522\":1,\"523\":4,\"524\":1,\"525\":2,\"527\":1,\"536\":1,\"540\":1,\"563\":2}}],[\"type\",{\"1\":{\"5\":1,\"501\":1,\"506\":2,\"605\":1,\"607\":1,\"760\":2,\"769\":1,\"770\":1}}],[\"tenant\",{\"1\":{\"605\":12}}],[\"teacher\",{\"1\":{\"404\":5,\"417\":3}}],[\"temporary\",{\"1\":{\"775\":1}}],[\"temperatures\",{\"1\":{\"622\":8}}],[\"temp2\",{\"1\":{\"440\":3,\"695\":6}}],[\"temp1\",{\"1\":{\"440\":3,\"637\":2,\"695\":6}}],[\"temp\",{\"1\":{\"381\":3,\"628\":2,\"634\":7,\"636\":5,\"637\":2,\"642\":3,\"643\":3,\"645\":2,\"666\":7,\"667\":3,\"669\":7,\"688\":2}}],[\"template01\",{\"1\":{\"416\":1}}],[\"template\",{\"1\":{\"104\":1,\"416\":2}}],[\"templates\",{\"1\":{\"81\":1,\"395\":1}}],[\"terminatingthreadlocal<\",{\"1\":{\"307\":1}}],[\"terminatingthreadlocal\",{\"1\":{\"307\":2}}],[\"terminated\",{\"1\":{\"225\":1,\"469\":2}}],[\"testtransfer2\",{\"1\":{\"584\":1}}],[\"testtransfer\",{\"1\":{\"583\":1}}],[\"testtemp\",{\"1\":{\"416\":2}}],[\"testjdbc\",{\"1\":{\"576\":1}}],[\"testservice03\",{\"1\":{\"565\":1}}],[\"testspringdemo\",{\"1\":{\"565\":1}}],[\"testspring5\",{\"1\":{\"552\":1,\"559\":1}}],[\"testspinlockdemo\",{\"1\":{\"298\":1}}],[\"testbook\",{\"1\":{\"576\":1,\"583\":1,\"584\":1}}],[\"testbook1\",{\"1\":{\"557\":1}}],[\"testbean7\",{\"1\":{\"560\":1}}],[\"testbean5\",{\"1\":{\"559\":1}}],[\"testadd\",{\"1\":{\"552\":1}}],[\"testatomicreference\",{\"1\":{\"297\":1}}],[\"testgetempbychoose\",{\"1\":{\"530\":1}}],[\"testgetempanddeptbystep\",{\"1\":{\"524\":1}}],[\"test=\",{\"1\":{\"527\":3,\"528\":3,\"529\":3,\"530\":3,\"532\":3}}],[\"testcheckloginbymap\",{\"1\":{\"512\":1}}],[\"testinsertuser\",{\"1\":{\"502\":1}}],[\"testidcard\",{\"1\":{\"102\":1}}],[\"test1\",{\"1\":{\"499\":1,\"506\":1,\"507\":1,\"540\":1,\"562\":1,\"575\":1,\"583\":1,\"584\":1}}],[\"testlambda\",{\"1\":{\"490\":1}}],[\"test可以直接运行\",{\"1\":{\"462\":1}}],[\"testmsgbox\",{\"1\":{\"117\":1}}],[\"test\",{\"1\":{\"81\":1,\"99\":1,\"102\":2,\"117\":2,\"129\":1,\"248\":5,\"297\":2,\"298\":1,\"391\":4,\"404\":2,\"475\":5,\"477\":6,\"478\":5,\"479\":5,\"502\":2,\"512\":1,\"524\":1,\"530\":1,\"552\":1,\"557\":1,\"559\":1,\"560\":1,\"565\":1,\"576\":1,\"583\":1,\"584\":1}}],[\"textbuilder和htmlbuilder都可以被director类调用\",{\"1\":{\"108\":1}}],[\"textbuilder\",{\"1\":{\"108\":6}}],[\"text\",{\"1\":{\"91\":1,\"335\":1,\"431\":3,\"605\":5,\"760\":1}}],[\"tex\",{\"0\":{\"32\":1}}],[\"treeinput\",{\"1\":{\"730\":1}}],[\"treeify\",{\"1\":{\"124\":1}}],[\"treesize\",{\"1\":{\"709\":10}}],[\"treeset\",{\"0\":{\"447\":1},\"1\":{\"451\":9}}],[\"treenode\",{\"1\":{\"664\":12,\"666\":11,\"667\":12,\"668\":11,\"669\":5,\"672\":10,\"699\":10,\"712\":2,\"730\":9}}],[\"tree\",{\"1\":{\"664\":1,\"666\":1,\"667\":1,\"668\":1,\"672\":1,\"699\":1,\"730\":9}}],[\"treemap\",{\"1\":{\"451\":1}}],[\"treemap01\",{\"1\":{\"451\":1}}],[\"trip\",{\"1\":{\"677\":9}}],[\"trips\",{\"1\":{\"677\":4}}],[\"triple\",{\"1\":{\"99\":1}}],[\"trienode\",{\"1\":{\"675\":8}}],[\"trie\",{\"1\":{\"674\":5,\"675\":6}}],[\"trimstrings\",{\"1\":{\"540\":1}}],[\"trim>\",{\"1\":{\"529\":1,\"532\":1}}],[\"trim\",{\"0\":{\"529\":1},\"1\":{\"429\":1,\"529\":1}}],[\"true\",{\"1\":{\"136\":1,\"220\":1,\"227\":1,\"252\":1,\"262\":1,\"268\":5,\"291\":1,\"358\":1,\"363\":1,\"419\":1,\"427\":1,\"428\":1,\"429\":1,\"440\":2,\"445\":1,\"466\":5,\"467\":1,\"468\":4,\"469\":1,\"471\":2,\"477\":2,\"478\":2,\"486\":1,\"501\":1,\"502\":1,\"520\":1,\"522\":1,\"524\":1,\"535\":1,\"536\":1,\"540\":4,\"598\":1,\"605\":1,\"606\":1,\"607\":1,\"650\":3,\"659\":3,\"668\":3,\"674\":3,\"675\":1,\"677\":2,\"688\":1,\"689\":3,\"701\":4,\"702\":3,\"705\":3,\"716\":4,\"717\":6,\"721\":4,\"730\":2}}],[\"truncate\",{\"1\":{\"5\":1}}],[\"tryrelease可自行设定逻辑\",{\"1\":{\"313\":1}}],[\"tryrelease或tryacquireshared\",{\"1\":{\"313\":1}}],[\"tryreleaseshared\",{\"1\":{\"313\":2}}],[\"tryrelease\",{\"1\":{\"313\":2}}],[\"tryacquireshared获取失败后以node\",{\"1\":{\"318\":1}}],[\"tryacquireshared\",{\"1\":{\"313\":1}}],[\"tryacquire\",{\"1\":{\"313\":2}}],[\"try\",{\"1\":{\"111\":2,\"114\":3,\"117\":1,\"220\":2,\"233\":1,\"248\":7,\"249\":2,\"256\":1,\"262\":1,\"268\":3,\"271\":3,\"298\":3,\"304\":2,\"313\":2,\"424\":3,\"466\":7,\"467\":2,\"468\":5,\"469\":2,\"471\":1,\"475\":3,\"477\":14,\"478\":12,\"479\":3,\"480\":2,\"483\":3,\"485\":2,\"486\":1}}],[\"trace\",{\"1\":{\"763\":1}}],[\"traversal\",{\"1\":{\"664\":1}}],[\"travel\",{\"1\":{\"399\":1}}],[\"trap\",{\"1\":{\"624\":3}}],[\"transfer\",{\"1\":{\"583\":3,\"584\":1,\"768\":1}}],[\"transferserviceimpl\",{\"1\":{\"70\":1}}],[\"transferservice\",{\"1\":{\"70\":2}}],[\"transservlet2\",{\"1\":{\"334\":4}}],[\"transservlet1\",{\"1\":{\"334\":3}}],[\"transportlaver\",{\"1\":{\"208\":1}}],[\"transactionmanager\",{\"1\":{\"506\":1,\"583\":1,\"584\":3}}],[\"transactional\",{\"1\":{\"166\":2}}],[\"transaction\",{\"0\":{\"166\":2},\"1\":{\"177\":1,\"178\":1}}],[\"traysearch\",{\"1\":{\"111\":4}}],[\"traynews\",{\"1\":{\"111\":4}}],[\"trayyahoo\",{\"1\":{\"111\":8}}],[\"tray\",{\"1\":{\"111\":15}}],[\"that\",{\"1\":{\"657\":1,\"658\":1}}],[\"thirddate\",{\"1\":{\"436\":1}}],[\"this用于区分全局变量和局部变量\",{\"1\":{\"393\":1}}],[\"this只能在类定义的方法中使用\",{\"1\":{\"393\":1}}],[\"this关键字可以用来访问本类的属性\",{\"1\":{\"393\":1}}],[\"this关键字\",{\"0\":{\"393\":1}}],[\"this\",{\"1\":{\"67\":1,\"96\":1,\"102\":2,\"105\":3,\"108\":1,\"111\":9,\"114\":5,\"117\":1,\"220\":2,\"262\":1,\"306\":2,\"307\":4,\"312\":4,\"390\":2,\"392\":3,\"393\":1,\"400\":1,\"404\":8,\"406\":1,\"411\":1,\"414\":3,\"418\":2,\"419\":2,\"421\":3,\"433\":2,\"439\":3,\"440\":6,\"445\":7,\"454\":2,\"457\":1,\"467\":1,\"471\":2,\"477\":10,\"478\":2,\"486\":4,\"557\":6,\"560\":1,\"569\":1,\"576\":3,\"598\":1,\"634\":3,\"635\":8,\"636\":3,\"637\":3,\"638\":3,\"655\":1,\"664\":4,\"666\":4,\"667\":4,\"668\":4,\"672\":4,\"674\":1,\"699\":4,\"720\":2,\"729\":1,\"730\":1}}],[\"throwable\",{\"1\":{\"220\":1,\"244\":1,\"419\":1,\"569\":1,\"572\":1}}],[\"throw\",{\"1\":{\"220\":1,\"312\":1}}],[\"throws\",{\"1\":{\"55\":1,\"232\":2,\"233\":1,\"248\":1,\"291\":1,\"312\":1,\"313\":1,\"334\":2,\"339\":2,\"419\":2,\"425\":1,\"477\":1,\"502\":1,\"512\":1,\"560\":2,\"569\":1,\"572\":1,\"598\":1,\"730\":1}}],[\"threaddaemon\",{\"1\":{\"468\":1}}],[\"threadyield\",{\"1\":{\"468\":1}}],[\"threadstop\",{\"1\":{\"467\":1}}],[\"threadstate\",{\"1\":{\"469\":1}}],[\"threadstatus\",{\"1\":{\"220\":1}}],[\"threadstartfailed\",{\"1\":{\"220\":1}}],[\"threadshop\",{\"1\":{\"466\":1,\"471\":1}}],[\"thread03\",{\"1\":{\"466\":1}}],[\"thread02\",{\"1\":{\"466\":1}}],[\"thread01\",{\"1\":{\"466\":1}}],[\"threadlocals\",{\"1\":{\"306\":1,\"308\":1}}],[\"threadlocalmap是一个存储k\",{\"1\":{\"306\":1,\"308\":1}}],[\"threadlocalmap\",{\"0\":{\"308\":1},\"1\":{\"306\":2,\"307\":3,\"308\":1}}],[\"threadlocal<>\",{\"1\":{\"304\":1}}],[\"threadlocal<integer>\",{\"1\":{\"304\":1}}],[\"threadlocal<s>\",{\"1\":{\"304\":1}}],[\"threadlocal的实现原理\",{\"0\":{\"305\":1}}],[\"threadlocal的目的是希望将状态\",{\"1\":{\"303\":1}}],[\"threadlocal的key是弱引用\",{\"1\":{\"302\":1}}],[\"threadlocal提供线程局部变量\",{\"1\":{\"303\":1}}],[\"threadlocal是什么\",{\"0\":{\"303\":1}}],[\"threadlocal中最后为什么要加remove方法\",{\"1\":{\"302\":1}}],[\"threadlocal中threadlocalmap的数据结构和关系\",{\"1\":{\"302\":1}}],[\"threadlocal内存泄露问题你知道吗\",{\"1\":{\"302\":1}}],[\"threadlocal\",{\"0\":{\"301\":1},\"1\":{\"304\":4,\"308\":1}}],[\"threadlocalrandom\",{\"1\":{\"249\":1,\"256\":2}}],[\"thread对象的start\",{\"1\":{\"285\":1}}],[\"thread2\",{\"1\":{\"268\":1,\"466\":2}}],[\"thread1\",{\"1\":{\"263\":1,\"268\":1,\"466\":2}}],[\"threadpool\",{\"1\":{\"249\":3}}],[\"threadpoolexecutor\",{\"1\":{\"134\":5}}],[\"threadpertaskexecutor\",{\"1\":{\"247\":1}}],[\"thread\",{\"1\":{\"232\":1,\"233\":4,\"248\":7,\"249\":1,\"262\":5,\"263\":1,\"267\":2,\"268\":19,\"271\":19,\"291\":4,\"298\":13,\"304\":6,\"306\":3,\"307\":4,\"308\":1,\"312\":10,\"313\":6,\"466\":24,\"467\":3,\"468\":13,\"469\":4,\"471\":10}}],[\"threadfactory\",{\"1\":{\"135\":1}}],[\"threshold\",{\"1\":{\"124\":1}}],[\"thymeleaf模板等\",{\"1\":{\"162\":1}}],[\"thymeleaf\",{\"1\":{\"81\":1}}],[\"the\",{\"1\":{\"645\":2,\"657\":4,\"658\":4}}],[\"there\",{\"1\":{\"27\":2}}],[\"thencombine作业\",{\"1\":{\"248\":1}}],[\"thencombineasync\",{\"1\":{\"248\":2}}],[\"thencombine\",{\"1\":{\"248\":6}}],[\"thenrunasync\",{\"1\":{\"247\":1}}],[\"thenrunasync方法\",{\"0\":{\"247\":1}}],[\"thenrun\",{\"1\":{\"246\":1}}],[\"thenrun方法\",{\"0\":{\"246\":1}}],[\"thenaccept\",{\"1\":{\"245\":1}}],[\"thenaccept方法\",{\"0\":{\"245\":1}}],[\"thenapplyasync\",{\"1\":{\"248\":2}}],[\"thenapply\",{\"1\":{\"243\":1,\"248\":3}}],[\"thenapply方法\",{\"0\":{\"243\":1}}],[\"then\",{\"1\":{\"6\":3,\"248\":1}}],[\"toi\",{\"1\":{\"677\":2}}],[\"toinstant\",{\"1\":{\"436\":1}}],[\"top\",{\"1\":{\"656\":1,\"657\":3,\"658\":3}}],[\"topic\",{\"1\":{\"213\":1}}],[\"toadd\",{\"1\":{\"635\":3}}],[\"touser\",{\"1\":{\"583\":2}}],[\"touppercase\",{\"1\":{\"429\":1}}],[\"totalfruit\",{\"1\":{\"631\":1}}],[\"total=20\",{\"1\":{\"542\":3}}],[\"totalpage\",{\"1\":{\"542\":1}}],[\"total\",{\"1\":{\"524\":1,\"607\":1}}],[\"tolowercase\",{\"1\":{\"429\":1}}],[\"tolist\",{\"1\":{\"256\":3}}],[\"tohexstring\",{\"1\":{\"406\":1}}],[\"tom\",{\"1\":{\"248\":1,\"430\":1}}],[\"tomcat每次创建filter的时候\",{\"1\":{\"341\":1}}],[\"tomcat\",{\"1\":{\"80\":1,\"324\":1,\"588\":1}}],[\"to\",{\"1\":{\"190\":1,\"614\":1,\"717\":4}}],[\"tostring方法\",{\"1\":{\"406\":1}}],[\"tostring\",{\"1\":{\"111\":2,\"297\":1,\"406\":1,\"421\":1,\"430\":4,\"433\":2,\"439\":1,\"440\":1,\"454\":1,\"478\":1,\"569\":1,\"644\":1,\"645\":1,\"646\":1,\"684\":1,\"690\":1,\"729\":1}}],[\"todo\",{\"1\":{\"63\":1,\"555\":1}}],[\"tools\",{\"1\":{\"49\":1}}],[\"tochararray\",{\"1\":{\"477\":2,\"643\":1,\"644\":1,\"646\":1,\"649\":1,\"650\":1,\"652\":2,\"684\":1,\"705\":1,\"713\":2}}],[\"toc\",{\"1\":{\"42\":1}}],[\"t2\",{\"1\":{\"45\":2,\"271\":3,\"313\":1,\"466\":5}}],[\"t1\",{\"1\":{\"45\":2,\"233\":1,\"271\":6,\"313\":1,\"466\":5}}],[\"t\",{\"1\":{\"45\":2,\"123\":1,\"129\":6,\"233\":3,\"240\":1,\"241\":2,\"242\":1,\"243\":1,\"244\":1,\"248\":9,\"251\":14,\"271\":12,\"298\":3,\"300\":3,\"304\":3,\"306\":7,\"307\":11,\"353\":1,\"376\":1,\"391\":15,\"456\":1,\"459\":3,\"461\":4,\"466\":4,\"468\":3,\"469\":12,\"471\":2,\"475\":2,\"586\":1,\"648\":11}}],[\"tiger\",{\"1\":{\"466\":7}}],[\"ticketsnum\",{\"1\":{\"466\":3,\"471\":3}}],[\"ticketnum\",{\"1\":{\"262\":4}}],[\"ticket\",{\"1\":{\"262\":7}}],[\"timed\",{\"1\":{\"225\":1,\"469\":1}}],[\"timeout\",{\"1\":{\"142\":1}}],[\"timeunit\",{\"1\":{\"135\":1,\"233\":2,\"249\":1,\"256\":2,\"268\":6,\"298\":3,\"313\":2}}],[\"times++\",{\"1\":{\"466\":2}}],[\"times\",{\"1\":{\"114\":5,\"466\":4}}],[\"timestamp\",{\"1\":{\"7\":1,\"605\":12}}],[\"time\",{\"1\":{\"91\":3,\"419\":4,\"724\":1}}],[\"title><\",{\"1\":{\"111\":1}}],[\"title\",{\"1\":{\"27\":1,\"108\":4,\"111\":12}}],[\"dnt\",{\"1\":{\"786\":1}}],[\"dns把它转成ip地址\",{\"1\":{\"754\":1}}],[\"dns是http一样位于应用层的协议\",{\"1\":{\"754\":1}}],[\"dns\",{\"1\":{\"156\":1}}],[\"dns解析\",{\"1\":{\"156\":1}}],[\"df\",{\"1\":{\"677\":3,\"678\":3}}],[\"dfs搜索框架\",{\"0\":{\"704\":1}}],[\"dfs深度优先搜索\",{\"0\":{\"703\":1}}],[\"dfs\",{\"1\":{\"672\":4,\"699\":4,\"704\":5,\"705\":6,\"706\":6,\"707\":6,\"708\":10,\"709\":6,\"734\":6}}],[\"dfs+\",{\"1\":{\"672\":1}}],[\"dptable\",{\"1\":{\"694\":9,\"695\":7,\"696\":8,\"697\":11,\"698\":11}}],[\"dp数组初始化\",{\"1\":{\"702\":1}}],[\"dp数组只用2格空间\",{\"1\":{\"697\":1}}],[\"dp数组\",{\"1\":{\"695\":1,\"696\":1}}],[\"dp数组如何初始化\",{\"1\":{\"692\":1}}],[\"dp数组空间优化\",{\"1\":{\"624\":1}}],[\"dp\",{\"1\":{\"650\":9,\"687\":6,\"692\":1,\"693\":16,\"697\":2,\"700\":14,\"701\":9,\"736\":1,\"737\":6}}],[\"d部署\",{\"1\":{\"617\":1}}],[\"dummy\",{\"1\":{\"634\":3}}],[\"dubbo协议\",{\"1\":{\"595\":1}}],[\"dubbo\",{\"1\":{\"595\":3}}],[\"durability\",{\"1\":{\"170\":1}}],[\"druiddatasource\",{\"1\":{\"562\":2,\"575\":1,\"583\":1,\"584\":3}}],[\"druid\",{\"1\":{\"562\":2,\"575\":1,\"583\":1}}],[\"driverclass\",{\"1\":{\"562\":1}}],[\"driverclassname\",{\"1\":{\"562\":2,\"575\":1,\"583\":1}}],[\"driverclass=\",{\"1\":{\"540\":1}}],[\"driver=com\",{\"1\":{\"507\":1}}],[\"driver\",{\"1\":{\"499\":2,\"506\":2,\"507\":1,\"540\":1,\"562\":1,\"575\":1,\"583\":1,\"584\":1}}],[\"dynamicsqlmapper\",{\"1\":{\"530\":2}}],[\"dynamicbind\",{\"1\":{\"403\":1}}],[\"dtd\",{\"1\":{\"499\":3,\"501\":3,\"504\":3,\"540\":3}}],[\"dcom\",{\"1\":{\"466\":4}}],[\"dd\",{\"1\":{\"436\":2,\"607\":1}}],[\"d2\",{\"1\":{\"436\":3}}],[\"d1\",{\"1\":{\"436\":3}}],[\"d\",{\"1\":{\"318\":1,\"354\":1,\"395\":1,\"542\":2,\"586\":1,\"614\":2,\"615\":1,\"617\":1}}],[\"db2tables\",{\"1\":{\"540\":1,\"541\":1}}],[\"db\",{\"1\":{\"187\":1,\"192\":1,\"605\":4}}],[\"dot\",{\"1\":{\"716\":5,\"717\":2}}],[\"dotindex\",{\"1\":{\"430\":2}}],[\"does\",{\"1\":{\"598\":1}}],[\"dockercompose\",{\"0\":{\"617\":1}}],[\"dockerfile\",{\"0\":{\"616\":1},\"1\":{\"616\":1}}],[\"dockerhub\",{\"1\":{\"611\":1}}],[\"docker如何解决上述问题\",{\"1\":{\"609\":1}}],[\"docker\",{\"0\":{\"608\":1,\"610\":1,\"611\":1,\"613\":1},\"1\":{\"609\":1,\"610\":1,\"611\":5,\"613\":10,\"614\":6,\"615\":2,\"616\":3}}],[\"doctype\",{\"1\":{\"499\":1,\"501\":1,\"504\":1,\"540\":1}}],[\"documented\",{\"1\":{\"422\":1}}],[\"do\",{\"0\":{\"375\":1},\"1\":{\"375\":1}}],[\"dog\",{\"1\":{\"352\":4,\"402\":6,\"417\":2,\"418\":3,\"454\":10,\"478\":3}}],[\"doget\",{\"1\":{\"334\":2}}],[\"dofilter方法\",{\"1\":{\"340\":1}}],[\"dofilter\",{\"1\":{\"339\":2,\"342\":1}}],[\"down\",{\"1\":{\"203\":1,\"713\":4}}],[\"domainobjectname=\",{\"1\":{\"540\":2}}],[\"domainobjectname\",{\"1\":{\"540\":1}}],[\"dom\",{\"1\":{\"93\":1}}],[\"double>\",{\"1\":{\"458\":1}}],[\"double类型强制转换为int类型\",{\"1\":{\"359\":1}}],[\"doublechecklock\",{\"1\":{\"292\":6}}],[\"double\",{\"1\":{\"55\":1,\"256\":1,\"358\":4,\"359\":2,\"368\":1,\"427\":1,\"439\":2,\"440\":4,\"445\":2,\"486\":6,\"583\":5,\"742\":3}}],[\"digit\",{\"1\":{\"684\":2}}],[\"digits\",{\"1\":{\"684\":11}}],[\"diff\",{\"1\":{\"677\":11,\"678\":11}}],[\"difference\",{\"1\":{\"677\":4,\"678\":4}}],[\"did`\",{\"1\":{\"605\":1}}],[\"di\",{\"1\":{\"545\":1,\"557\":1}}],[\"divide\",{\"1\":{\"435\":1}}],[\"dict\",{\"1\":{\"192\":1}}],[\"dir\",{\"1\":{\"616\":3}}],[\"dir=\",{\"1\":{\"616\":1}}],[\"dirty\",{\"1\":{\"171\":1}}],[\"director类独立于builder类和它的两个实现\",{\"1\":{\"108\":1}}],[\"director\",{\"1\":{\"7\":5,\"108\":6}}],[\"discovery\",{\"1\":{\"599\":2,\"602\":1}}],[\"discovery<\",{\"1\":{\"599\":1}}],[\"discardoldestpolicy\",{\"1\":{\"134\":1}}],[\"discardpolicy\",{\"1\":{\"134\":1}}],[\"diskless\",{\"1\":{\"204\":1}}],[\"display的子类countdisplay和randomdisplay用来实现不同的显示效果\",{\"1\":{\"114\":1}}],[\"displayimpl的实现类stringdisplayimpl和txtdisplayimpl是用来显示不同类型\",{\"1\":{\"114\":1}}],[\"displayimpl\",{\"1\":{\"114\":7}}],[\"display\",{\"1\":{\"105\":3,\"114\":5}}],[\"dispatcherservlet还负责处理请求过程中可能产生的异常\",{\"1\":{\"162\":1}}],[\"dispatcherservlet会根据配置的视图解析器\",{\"1\":{\"162\":1}}],[\"dispatcherservlet接收到该请求并根据配置的url映射规则\",{\"1\":{\"162\":1}}],[\"dispatcherservlet充当了前端控制器\",{\"1\":{\"162\":1}}],[\"dispatcherservlet是干嘛的\",{\"0\":{\"162\":1}}],[\"dispatcherservlet是整个流程控制的中心\",{\"1\":{\"76\":1}}],[\"dispatcherservlet的存在降低了组件之间的耦合性\",{\"1\":{\"76\":1}}],[\"dispatcherservlet响应用户\",{\"1\":{\"76\":1}}],[\"dispatcherservlet根据view进行渲染视图\",{\"1\":{\"76\":1}}],[\"dispatcherservlet将modelandview传给viewreslover视图解析器\",{\"1\":{\"76\":1}}],[\"dispatcherservlet调用handleradapter处理器适配器\",{\"1\":{\"76\":1}}],[\"dispatcherservlet\",{\"1\":{\"76\":1,\"161\":6}}],[\"dispatcherservlet收到请求调用handlermapping处理器映射器\",{\"1\":{\"76\":1}}],[\"disable\",{\"1\":{\"49\":1}}],[\"deads\",{\"1\":{\"713\":3}}],[\"deadends\",{\"1\":{\"713\":3}}],[\"deadlockdemo\",{\"1\":{\"471\":6}}],[\"deadlock\",{\"1\":{\"471\":1}}],[\"deque<integer>\",{\"1\":{\"662\":1}}],[\"detectcycle\",{\"1\":{\"640\":1}}],[\"detail\",{\"1\":{\"551\":1}}],[\"debug\",{\"1\":{\"524\":3,\"607\":1}}],[\"dev\",{\"1\":{\"602\":1,\"604\":1}}],[\"dev环境\",{\"1\":{\"599\":1}}],[\"development\",{\"1\":{\"499\":2,\"506\":2}}],[\"device\",{\"1\":{\"5\":8}}],[\"deflate\",{\"1\":{\"768\":1}}],[\"def\",{\"1\":{\"684\":1}}],[\"definition\",{\"1\":{\"634\":1,\"636\":1,\"637\":1,\"638\":1,\"639\":1,\"640\":1,\"664\":1,\"666\":1,\"667\":1,\"668\":1,\"672\":1,\"699\":1}}],[\"defined\",{\"1\":{\"491\":1}}],[\"defaultfeignconfiguration\",{\"1\":{\"606\":1}}],[\"defaultconfiguration\",{\"1\":{\"606\":1}}],[\"defaultzone\",{\"1\":{\"597\":1}}],[\"default=\",{\"1\":{\"499\":1,\"506\":1}}],[\"default方法冲突\",{\"1\":{\"417\":1}}],[\"default可有可无\",{\"1\":{\"372\":1}}],[\"default\",{\"1\":{\"251\":3,\"372\":1,\"458\":1,\"506\":1,\"563\":2,\"605\":66,\"607\":1}}],[\"defaultservlethandlerconfigurer\",{\"1\":{\"78\":1}}],[\"department\",{\"1\":{\"561\":1}}],[\"depth++\",{\"1\":{\"669\":1}}],[\"depth\",{\"1\":{\"669\":4,\"686\":6}}],[\"dept=null\",{\"1\":{\"530\":2}}],[\"dept=dept\",{\"1\":{\"523\":1}}],[\"deptstepmap\",{\"1\":{\"525\":1}}],[\"deptassmap\",{\"1\":{\"525\":3}}],[\"deptmap\",{\"1\":{\"523\":2}}],[\"deptmapper\",{\"1\":{\"523\":3,\"524\":1}}],[\"deptname=\",{\"1\":{\"523\":1}}],[\"deptname\",{\"1\":{\"523\":3,\"525\":2,\"527\":1}}],[\"deptid=null\",{\"1\":{\"542\":8}}],[\"deptid=1\",{\"1\":{\"523\":1}}],[\"deptid\",{\"1\":{\"523\":3,\"525\":4,\"527\":1}}],[\"dept\",{\"1\":{\"523\":25,\"524\":8,\"525\":17,\"527\":8,\"528\":4,\"529\":4,\"532\":5,\"540\":2,\"557\":15,\"561\":3}}],[\"dependencies<\",{\"1\":{\"599\":1}}],[\"dependencies>\",{\"1\":{\"498\":1,\"540\":2}}],[\"dependency>\",{\"1\":{\"498\":4,\"540\":9,\"597\":1,\"599\":2,\"602\":1,\"606\":3}}],[\"dependency\",{\"1\":{\"160\":1,\"718\":4}}],[\"deprecated\",{\"1\":{\"422\":1}}],[\"demo\",{\"0\":{\"256\":1},\"1\":{\"298\":5,\"475\":1,\"616\":2}}],[\"delivery\",{\"1\":{\"209\":1,\"213\":1}}],[\"del\",{\"1\":{\"204\":1,\"205\":2}}],[\"delay\",{\"1\":{\"204\":1}}],[\"deletecharat\",{\"1\":{\"684\":1,\"690\":2}}],[\"deleteatindex\",{\"1\":{\"635\":2}}],[\"delete方法\",{\"1\":{\"577\":1}}],[\"deletemoreemp\",{\"1\":{\"531\":3}}],[\"delete>\",{\"1\":{\"501\":1,\"518\":1,\"531\":2}}],[\"deleteuser\",{\"1\":{\"501\":1}}],[\"delete\",{\"1\":{\"177\":1,\"430\":1,\"475\":1,\"501\":1,\"518\":1,\"531\":2,\"577\":3,\"763\":1}}],[\"delegation\",{\"1\":{\"147\":1}}],[\"destfilepath\",{\"1\":{\"478\":5}}],[\"destroy\",{\"1\":{\"339\":1,\"560\":2}}],[\"destruction\",{\"1\":{\"160\":1}}],[\"destory方法\",{\"1\":{\"340\":1}}],[\"destory\",{\"1\":{\"328\":1,\"560\":3}}],[\"desc`\",{\"1\":{\"605\":2}}],[\"desc\",{\"1\":{\"27\":1,\"421\":8,\"605\":1}}],[\"decochar\",{\"1\":{\"117\":7}}],[\"dag\",{\"1\":{\"715\":1}}],[\"da取最大值\",{\"1\":{\"697\":1}}],[\"dailytemperatures\",{\"1\":{\"622\":1}}],[\"dao\",{\"1\":{\"557\":1,\"564\":3,\"575\":3,\"576\":2,\"581\":1,\"583\":3}}],[\"david\",{\"1\":{\"404\":1,\"486\":1}}],[\"dangdang\",{\"1\":{\"256\":1}}],[\"datum\",{\"1\":{\"605\":1}}],[\"dat\",{\"1\":{\"478\":2}}],[\"datagrouptenanttag`\",{\"1\":{\"605\":1}}],[\"datagrouptenantdatum`\",{\"1\":{\"605\":1}}],[\"datagrouptenant`\",{\"1\":{\"605\":2}}],[\"datasourcetransactionmanager\",{\"1\":{\"583\":1,\"584\":3}}],[\"datasource\",{\"1\":{\"506\":1,\"562\":2,\"575\":4,\"583\":6,\"584\":12,\"605\":1}}],[\"datasource>\",{\"1\":{\"499\":1,\"506\":1}}],[\"database\",{\"0\":{\"789\":1},\"1\":{\"168\":1,\"189\":1}}],[\"dataline\",{\"1\":{\"114\":3}}],[\"data概念\",{\"1\":{\"81\":1}}],[\"data\",{\"1\":{\"81\":9,\"252\":2,\"256\":1,\"297\":2,\"300\":1,\"477\":3,\"478\":2,\"603\":1,\"605\":5,\"617\":1,\"657\":1,\"658\":1,\"769\":1}}],[\"datetime\",{\"1\":{\"605\":13}}],[\"datetimeformatter\",{\"1\":{\"436\":8,\"603\":1}}],[\"datetimeformatter格式日期类\",{\"1\":{\"436\":1}}],[\"dateformat\",{\"1\":{\"603\":1,\"607\":1}}],[\"date01\",{\"1\":{\"436\":1}}],[\"date+1\",{\"1\":{\"5\":2}}],[\"date\",{\"1\":{\"5\":14,\"419\":5,\"436\":9,\"760\":1}}],[\"date数据类型的加减\",{\"0\":{\"5\":1}}],[\"day\",{\"1\":{\"5\":1,\"436\":3,\"445\":4}}],[\"则保持tcp连接状态\",{\"1\":{\"764\":1}}],[\"则应该\",{\"1\":{\"720\":1}}],[\"则向缓存中插入该组\",{\"1\":{\"720\":1}}],[\"则变更其数据值\",{\"1\":{\"720\":1}}],[\"则输出\",{\"1\":{\"718\":1}}],[\"则必须先\",{\"1\":{\"718\":1}}],[\"则必须在子类中用super去指定使用父类哪个构造器完成对父类的初始化工作\",{\"1\":{\"399\":1}}],[\"则\",{\"1\":{\"717\":1}}],[\"则称它们是\",{\"1\":{\"709\":1}}],[\"则跳过\",{\"1\":{\"685\":1}}],[\"则该字符串称为回文字符串\",{\"1\":{\"650\":1}}],[\"则反转前\",{\"1\":{\"643\":1}}],[\"则将剩余字符全部反转\",{\"1\":{\"643\":1}}],[\"则将类添加到自己的命名空间中\",{\"1\":{\"147\":1}}],[\"则在该链表中没有环\",{\"1\":{\"640\":1}}],[\"则在指定的时间之内不断地进行重试来获取服务\",{\"1\":{\"598\":1}}],[\"则找到交点\",{\"1\":{\"639\":1}}],[\"则节点指针相等\",{\"1\":{\"639\":1}}],[\"则说明是新插入的节点为链表的尾结点\",{\"1\":{\"635\":1}}],[\"则只能采摘\",{\"1\":{\"631\":2}}],[\"则少100的操作也会失败\",{\"1\":{\"580\":1}}],[\"则查询数据库\",{\"1\":{\"537\":1}}],[\"则先执行完插队的线程\",{\"1\":{\"468\":1}}],[\"则元素必须实现comparable接口\",{\"1\":{\"447\":1}}],[\"则初始elementdata容量为指定大小\",{\"1\":{\"441\":1}}],[\"则初始elementdata容量为0\",{\"1\":{\"441\":1}}],[\"则使用map来存储窗内数据\",{\"1\":{\"631\":1}}],[\"则使用string\",{\"1\":{\"431\":1}}],[\"则使用stringbuffer或stringbuilder\",{\"1\":{\"431\":1}}],[\"则使用cas操作将mark\",{\"1\":{\"139\":1}}],[\"则顺序执行try代码块\",{\"1\":{\"424\":1}}],[\"则异常后面的代码不会执行\",{\"1\":{\"424\":1}}],[\"则它必须实现抽象类的所有抽象方法\",{\"1\":{\"416\":1}}],[\"则jvm就认为该对象是一个垃圾对象\",{\"1\":{\"406\":1}}],[\"则实例会有默认值\",{\"1\":{\"386\":1}}],[\"则做拼接运算\",{\"1\":{\"357\":1}}],[\"则做加法运算\",{\"1\":{\"357\":1}}],[\"则有两种情况\",{\"1\":{\"318\":1}}],[\"则转为从尾部开始找阻塞的节点将其唤醒\",{\"1\":{\"317\":1}}],[\"则返回关键字的值\",{\"1\":{\"720\":1}}],[\"则返回\",{\"1\":{\"640\":1,\"651\":1}}],[\"则返回空字符串\",{\"1\":{\"648\":1}}],[\"则返回空\",{\"1\":{\"635\":1}}],[\"则返回该信息\",{\"1\":{\"399\":1}}],[\"则返回true\",{\"1\":{\"312\":1}}],[\"则返回null\",{\"1\":{\"6\":1}}],[\"则会使用父类的父类\",{\"1\":{\"400\":1}}],[\"则会退出程序\",{\"1\":{\"379\":1}}],[\"则会进default默认语句块\",{\"1\":{\"372\":1}}],[\"则会通过setinitialvalue方法返回了一个null值\",{\"1\":{\"307\":1}}],[\"则会抛出\",{\"1\":{\"147\":1}}],[\"则子线程中可以取到这个值\",{\"1\":{\"304\":1}}],[\"则死循环\",{\"1\":{\"291\":1}}],[\"则根据不同的实现方式执行不同的操作\",{\"1\":{\"258\":1}}],[\"则第一阶段用自定义线程池\",{\"1\":{\"247\":1}}],[\"则打断运行过程把value值作为阶段的结果\",{\"1\":{\"242\":1}}],[\"则默认使用forkjoinpool\",{\"1\":{\"239\":1}}],[\"则肯定会造成数据不一致\",{\"1\":{\"195\":1}}],[\"则表示该元素可能存在于布隆过滤器中\",{\"1\":{\"194\":1}}],[\"则生成一个唯一的\",{\"1\":{\"165\":1}}],[\"则继续下一步\",{\"1\":{\"163\":1}}],[\"则委托父类加载器\",{\"1\":{\"147\":1}}],[\"则线程会阻塞等待\",{\"1\":{\"144\":1}}],[\"则直接返回已加载的类\",{\"1\":{\"147\":1}}],[\"则直接返回\",{\"1\":{\"141\":1}}],[\"则当前线程修改的数据成功写入\",{\"1\":{\"258\":1}}],[\"则当前线程会被阻塞\",{\"1\":{\"139\":1}}],[\"则当前线程获取到锁并执行临界区代码\",{\"1\":{\"139\":1}}],[\"则创建一个新线程来处理该任务\",{\"1\":{\"135\":1}}],[\"则采用这种模式\",{\"1\":{\"116\":1}}],[\"则可以得出操作a先行发生于操作c\",{\"1\":{\"284\":1}}],[\"则可以确定该元素一定不存在于布隆过滤器中\",{\"1\":{\"194\":1}}],[\"则可以使用原型模式\",{\"1\":{\"116\":1}}],[\"则可以通过\",{\"1\":{\"72\":1}}],[\"则可返回其指向内存的\",{\"1\":{\"3\":1}}],[\"则需重新编译\",{\"1\":{\"496\":1}}],[\"则需要使用synchronized关键字\",{\"1\":{\"293\":1}}],[\"则需要使用特定的标签以及属性来定义bean\",{\"1\":{\"62\":1}}],[\"则需在spring\",{\"1\":{\"62\":1}}],[\"则是当左侧表达式为false时\",{\"1\":{\"364\":1}}],[\"则是\",{\"1\":{\"3\":1}}],[\"p3p\",{\"1\":{\"786\":1}}],[\"pqrs\",{\"1\":{\"684\":1}}],[\"pt\",{\"1\":{\"583\":2}}],[\"ptr智能指针的有效性上会很有作用\",{\"1\":{\"3\":1}}],[\"ptr成员lock\",{\"1\":{\"3\":1}}],[\"ptr指针指向的对象内存\",{\"1\":{\"3\":1}}],[\"ptr指针放弃了\",{\"1\":{\"3\":1}}],[\"ptr的使用更为复杂一点\",{\"1\":{\"3\":1}}],[\"ptr这个类模板\",{\"1\":{\"3\":1}}],[\"ptr才会真正释放所占有的堆内存的空间\",{\"1\":{\"3\":1}}],[\"ptr对对象内存的引用并不会受到影响\",{\"1\":{\"3\":1}}],[\"ptr不同的是\",{\"1\":{\"3\":1}}],[\"ptr类型的指针对象共享所指对象的内存\",{\"1\":{\"3\":1}}],[\"ptr<int>\",{\"1\":{\"3\":12}}],[\"ptr\",{\"1\":{\"2\":3,\"3\":7}}],[\"phone\",{\"1\":{\"501\":1,\"520\":1,\"560\":3}}],[\"phantom\",{\"1\":{\"171\":1}}],[\"pwd\",{\"1\":{\"480\":4}}],[\"pc\",{\"1\":{\"417\":2}}],[\"pc寄存器就是程序计数器\",{\"1\":{\"51\":1}}],[\"p2\",{\"1\":{\"388\":1,\"390\":2}}],[\"p1\",{\"1\":{\"388\":2,\"390\":3}}],[\"pdd\",{\"1\":{\"256\":1}}],[\"pdf\",{\"1\":{\"76\":1}}],[\"pdfview等\",{\"1\":{\"76\":1}}],[\"ps\",{\"1\":{\"247\":1,\"614\":1}}],[\"png\",{\"1\":{\"235\":1,\"598\":1}}],[\"px\",{\"1\":{\"205\":1}}],[\"picocontainer\",{\"1\":{\"168\":1}}],[\"peeklast\",{\"1\":{\"662\":2}}],[\"peek\",{\"1\":{\"655\":5,\"656\":1,\"657\":1,\"658\":1,\"729\":2}}],[\"permanently\",{\"1\":{\"775\":1}}],[\"permute\",{\"1\":{\"685\":1}}],[\"permission`\",{\"1\":{\"605\":1}}],[\"per\",{\"1\":{\"606\":1}}],[\"persistence\",{\"1\":{\"81\":1}}],[\"person<e>\",{\"1\":{\"457\":1}}],[\"person<string>\",{\"1\":{\"457\":2}}],[\"person1\",{\"1\":{\"457\":3}}],[\"persons\",{\"1\":{\"404\":7}}],[\"personcpy\",{\"1\":{\"390\":2}}],[\"person\",{\"1\":{\"67\":2,\"388\":3,\"390\":8,\"392\":3,\"404\":11,\"457\":6}}],[\"people\",{\"1\":{\"111\":3}}],[\"pause容器进入暂停状态\",{\"1\":{\"613\":1}}],[\"pass\",{\"1\":{\"605\":1}}],[\"password=yo\",{\"1\":{\"507\":1}}],[\"password=\",{\"1\":{\"501\":1,\"540\":1}}],[\"password\",{\"1\":{\"499\":1,\"501\":4,\"506\":1,\"512\":12,\"520\":1,\"562\":3,\"575\":1,\"583\":1,\"605\":2,\"617\":1}}],[\"packaging>\",{\"1\":{\"498\":1,\"540\":1}}],[\"package=\",{\"1\":{\"563\":3,\"572\":1,\"583\":1}}],[\"package\",{\"1\":{\"96\":4,\"99\":2,\"102\":5,\"105\":4,\"108\":5,\"111\":11,\"114\":6,\"117\":5,\"248\":1,\"396\":1}}],[\"pair<s>与pair<t>没有什么联系\",{\"1\":{\"461\":1}}],[\"pair<string>\",{\"1\":{\"461\":1}}],[\"pair<employee>\",{\"1\":{\"461\":1}}],[\"pair2\",{\"1\":{\"461\":1}}],[\"pair1\",{\"1\":{\"461\":1}}],[\"payload\",{\"1\":{\"209\":1}}],[\"path中出现重复的模块说明存在循环依赖\",{\"1\":{\"718\":1}}],[\"pathsum\",{\"1\":{\"672\":1}}],[\"path\",{\"1\":{\"607\":1,\"683\":7,\"685\":6,\"686\":10,\"688\":4,\"690\":13,\"715\":8,\"717\":6,\"718\":5}}],[\"pathroutepredicatefactory类来处理的\",{\"1\":{\"607\":1}}],[\"path=$path\",{\"1\":{\"616\":1}}],[\"path=\",{\"1\":{\"607\":2}}],[\"pathvariable\",{\"1\":{\"606\":1}}],[\"pathname\",{\"1\":{\"114\":5,\"475\":2}}],[\"patternproperties\",{\"1\":{\"603\":2}}],[\"pattern=\",{\"1\":{\"586\":1}}],[\"pattern>target\",{\"1\":{\"343\":1}}],[\"pattern>\",{\"1\":{\"327\":2,\"339\":2,\"343\":5}}],[\"pattern\",{\"1\":{\"98\":1,\"101\":1,\"104\":1,\"107\":1,\"110\":1,\"113\":1,\"116\":1,\"603\":1,\"607\":1}}],[\"pageinfo\",{\"1\":{\"542\":1}}],[\"pages=5\",{\"1\":{\"542\":3}}],[\"pagesizezero=false\",{\"1\":{\"542\":2}}],[\"pagesize=4\",{\"1\":{\"542\":3}}],[\"pagesize\",{\"1\":{\"542\":3}}],[\"pagenum=1\",{\"1\":{\"542\":3}}],[\"pagenum\",{\"1\":{\"542\":2}}],[\"page\",{\"1\":{\"111\":21,\"542\":2}}],[\"partial\",{\"1\":{\"770\":1,\"774\":1}}],[\"partition\",{\"1\":{\"688\":1}}],[\"park方法消耗许可证\",{\"1\":{\"271\":1}}],[\"park\",{\"1\":{\"270\":1,\"271\":1}}],[\"params\",{\"1\":{\"607\":2}}],[\"param2\",{\"1\":{\"512\":2}}],[\"param1\",{\"1\":{\"512\":2}}],[\"parametertype=\",{\"1\":{\"501\":2}}],[\"parametertype属性指明查询时使用的参数类型\",{\"1\":{\"501\":1}}],[\"parameters\",{\"1\":{\"488\":2,\"524\":1}}],[\"parameter\",{\"1\":{\"341\":1}}],[\"param>\",{\"1\":{\"327\":6}}],[\"param\",{\"1\":{\"114\":1,\"327\":6,\"331\":1,\"491\":2,\"504\":2,\"512\":3,\"514\":1,\"515\":1,\"519\":1,\"522\":1,\"525\":4,\"527\":1,\"531\":4,\"627\":4,\"655\":3,\"674\":2,\"690\":4,\"706\":3,\"707\":3,\"708\":3,\"709\":3}}],[\"parentfile\",{\"1\":{\"475\":2}}],[\"parent\",{\"1\":{\"147\":1,\"475\":4}}],[\"parent的pom文件中的配置来实现\",{\"1\":{\"82\":1}}],[\"parent还定义了许多属性\",{\"1\":{\"82\":1}}],[\"parent作为我们maven项目的父级时\",{\"1\":{\"82\":1}}],[\"parent是通过继承pom\",{\"1\":{\"82\":1}}],[\"parent是一个特殊的starter项目\",{\"1\":{\"82\":1}}],[\"parent是怎么实现它的功能的\",{\"0\":{\"82\":1}}],[\"parseint\",{\"1\":{\"55\":5,\"360\":1,\"424\":1,\"729\":1,\"730\":5}}],[\"p\",{\"1\":{\"86\":1,\"96\":3,\"102\":3,\"117\":5,\"312\":3,\"557\":1,\"614\":2,\"615\":1,\"649\":7,\"650\":2,\"702\":10,\"709\":16,\"729\":12,\"730\":1}}],[\"push\",{\"1\":{\"655\":12,\"656\":1,\"657\":2,\"658\":2,\"659\":1,\"661\":3,\"730\":1}}],[\"puppy\",{\"1\":{\"478\":1}}],[\"pubulic\",{\"1\":{\"351\":1}}],[\"public<\",{\"1\":{\"498\":2,\"540\":2}}],[\"public<k>\",{\"1\":{\"459\":1}}],[\"public<t\",{\"1\":{\"459\":1}}],[\"public\",{\"1\":{\"41\":1,\"45\":1,\"55\":4,\"63\":2,\"70\":4,\"78\":1,\"91\":2,\"96\":13,\"99\":4,\"102\":12,\"105\":17,\"108\":21,\"111\":34,\"114\":26,\"117\":13,\"123\":1,\"220\":1,\"225\":1,\"232\":3,\"233\":2,\"238\":2,\"239\":2,\"240\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"245\":1,\"246\":1,\"247\":1,\"248\":14,\"249\":2,\"251\":5,\"252\":2,\"253\":2,\"256\":5,\"262\":3,\"263\":2,\"268\":6,\"271\":6,\"291\":4,\"292\":2,\"297\":2,\"298\":3,\"300\":2,\"304\":1,\"306\":1,\"307\":1,\"308\":1,\"313\":2,\"330\":1,\"334\":2,\"339\":4,\"351\":3,\"352\":2,\"354\":2,\"368\":2,\"376\":2,\"377\":1,\"381\":6,\"382\":6,\"389\":1,\"390\":4,\"391\":13,\"397\":2,\"399\":2,\"402\":9,\"403\":10,\"404\":19,\"406\":3,\"411\":6,\"412\":1,\"413\":8,\"414\":8,\"415\":4,\"416\":5,\"417\":16,\"418\":11,\"419\":23,\"421\":8,\"425\":1,\"427\":6,\"428\":3,\"429\":2,\"430\":4,\"431\":2,\"433\":6,\"436\":6,\"439\":4,\"440\":12,\"443\":2,\"444\":2,\"445\":7,\"448\":2,\"451\":3,\"454\":7,\"457\":5,\"458\":1,\"459\":1,\"461\":2,\"466\":13,\"467\":4,\"468\":6,\"469\":3,\"470\":1,\"471\":9,\"475\":8,\"477\":12,\"478\":13,\"479\":5,\"480\":2,\"483\":2,\"485\":4,\"486\":7,\"490\":1,\"491\":2,\"499\":1,\"500\":1,\"501\":1,\"502\":2,\"504\":2,\"511\":1,\"512\":1,\"524\":1,\"530\":1,\"535\":1,\"540\":1,\"552\":2,\"555\":2,\"557\":14,\"559\":2,\"560\":9,\"563\":2,\"564\":8,\"565\":3,\"569\":10,\"572\":10,\"575\":2,\"576\":15,\"577\":8,\"583\":15,\"584\":6,\"586\":2,\"597\":2,\"598\":2,\"603\":4,\"606\":3,\"607\":3,\"620\":1,\"621\":1,\"622\":1,\"623\":2,\"624\":3,\"625\":2,\"626\":1,\"628\":1,\"629\":2,\"630\":2,\"631\":1,\"632\":1,\"634\":2,\"635\":12,\"636\":2,\"637\":2,\"638\":2,\"639\":3,\"640\":2,\"642\":1,\"643\":2,\"644\":1,\"645\":2,\"646\":1,\"647\":1,\"648\":3,\"649\":1,\"650\":2,\"652\":1,\"653\":1,\"655\":10,\"657\":5,\"658\":5,\"659\":1,\"660\":1,\"661\":4,\"662\":1,\"664\":2,\"666\":2,\"667\":2,\"668\":2,\"669\":2,\"671\":1,\"672\":2,\"674\":4,\"675\":4,\"677\":5,\"678\":4,\"683\":1,\"684\":1,\"685\":2,\"686\":2,\"687\":2,\"688\":1,\"689\":1,\"690\":1,\"693\":2,\"694\":1,\"695\":1,\"696\":1,\"697\":1,\"698\":1,\"699\":2,\"701\":2,\"702\":2,\"705\":1,\"706\":1,\"707\":1,\"708\":1,\"709\":11,\"712\":1,\"713\":1,\"715\":1,\"716\":1,\"717\":1,\"718\":2,\"720\":3,\"721\":4,\"724\":2,\"729\":3,\"730\":3,\"734\":1,\"737\":1,\"740\":1,\"742\":1}}],[\"put\",{\"1\":{\"102\":1,\"117\":1,\"448\":5,\"512\":2,\"626\":1,\"631\":2,\"648\":3,\"649\":3,\"671\":2,\"672\":3,\"689\":1,\"699\":2,\"701\":1,\"720\":15,\"721\":2,\"763\":1}}],[\"pull从服务拉取镜像\",{\"1\":{\"613\":1}}],[\"pull\",{\"1\":{\"86\":2}}],[\"pull的区别\",{\"0\":{\"86\":1}}],[\"pop时\",{\"1\":{\"655\":1}}],[\"pop\",{\"1\":{\"655\":15,\"656\":1,\"657\":1,\"658\":1,\"659\":1,\"661\":2,\"729\":1,\"730\":1}}],[\"population\",{\"1\":{\"160\":1}}],[\"ports\",{\"1\":{\"617\":2}}],[\"port\",{\"1\":{\"607\":1}}],[\"port=8847\",{\"1\":{\"605\":1}}],[\"port=8846\",{\"1\":{\"605\":1}}],[\"port=8845\",{\"1\":{\"605\":1}}],[\"port=8011\",{\"1\":{\"466\":1}}],[\"pointcut\",{\"1\":{\"583\":2}}],[\"pointer\",{\"1\":{\"3\":2}}],[\"pom\",{\"1\":{\"498\":2,\"540\":2,\"602\":1}}],[\"pom中添加依赖\",{\"1\":{\"83\":1}}],[\"pos\",{\"1\":{\"640\":2}}],[\"position\",{\"1\":{\"477\":1}}],[\"postordertraversal\",{\"1\":{\"664\":3}}],[\"postprocessafterinitialization\",{\"1\":{\"560\":2}}],[\"postprocessbeforeinitialization\",{\"1\":{\"560\":2}}],[\"post\",{\"1\":{\"161\":1,\"332\":1,\"763\":1}}],[\"postconstruct注解标记的方法\",{\"1\":{\"160\":1}}],[\"poly01\",{\"1\":{\"402\":3}}],[\"pollfirst\",{\"1\":{\"661\":1}}],[\"polllast\",{\"1\":{\"661\":1,\"662\":1}}],[\"poll\",{\"1\":{\"91\":1,\"656\":1,\"657\":2,\"658\":2,\"666\":1,\"669\":1,\"711\":1,\"712\":1,\"713\":1}}],[\"pooled\",{\"1\":{\"499\":1,\"506\":3}}],[\"pool\",{\"1\":{\"268\":6,\"562\":2,\"575\":1,\"583\":1}}],[\"prune\",{\"1\":{\"615\":1}}],[\"prerequisites\",{\"1\":{\"717\":7}}],[\"preordertraversal\",{\"1\":{\"664\":4,\"667\":4,\"668\":4}}],[\"pre的后一位即为倒数第n位\",{\"1\":{\"638\":1}}],[\"pre\",{\"1\":{\"634\":3,\"635\":14,\"636\":6,\"638\":5,\"672\":10,\"730\":3}}],[\"prepage=0\",{\"1\":{\"542\":1}}],[\"preparing\",{\"1\":{\"524\":1}}],[\"prefix=\",{\"1\":{\"529\":1,\"532\":1}}],[\"prefixoverrides\",{\"1\":{\"529\":1}}],[\"prefix\",{\"1\":{\"529\":1,\"603\":1,\"671\":6,\"674\":8}}],[\"prev=head\",{\"1\":{\"635\":1}}],[\"previous\",{\"1\":{\"443\":1}}],[\"prev\",{\"1\":{\"312\":2,\"635\":5}}],[\"pred\",{\"1\":{\"635\":10}}],[\"predicate\",{\"1\":{\"607\":1}}],[\"predicates\",{\"1\":{\"607\":2}}],[\"predicate<t>\",{\"1\":{\"129\":1}}],[\"predecessor\",{\"1\":{\"312\":1}}],[\"predestroy注解标记的方法\",{\"1\":{\"160\":1}}],[\"primary\",{\"1\":{\"605\":10}}],[\"price=\",{\"1\":{\"439\":1,\"440\":1}}],[\"price从小到大排序\",{\"1\":{\"433\":1}}],[\"price从大到小排序\",{\"1\":{\"433\":1}}],[\"price\",{\"1\":{\"256\":2,\"430\":2,\"433\":4,\"439\":5,\"440\":9}}],[\"priority\",{\"1\":{\"209\":1}}],[\"private修饰的属性是不能被子类访问的\",{\"1\":{\"399\":1}}],[\"private\",{\"1\":{\"96\":1,\"99\":2,\"102\":4,\"105\":4,\"108\":2,\"114\":6,\"117\":3,\"220\":1,\"247\":1,\"252\":3,\"256\":1,\"262\":2,\"291\":1,\"292\":2,\"300\":2,\"307\":1,\"397\":2,\"401\":1,\"404\":4,\"411\":1,\"414\":5,\"418\":3,\"419\":5,\"421\":2,\"429\":1,\"433\":2,\"439\":3,\"440\":3,\"445\":6,\"454\":2,\"461\":2,\"466\":3,\"468\":1,\"471\":2,\"477\":1,\"478\":1,\"486\":2,\"522\":4,\"557\":5,\"560\":1,\"564\":4,\"569\":1,\"575\":2,\"576\":5,\"577\":1,\"583\":1,\"586\":1,\"603\":5,\"645\":2,\"653\":1,\"655\":4,\"664\":4,\"667\":1,\"668\":1,\"674\":1,\"677\":1,\"678\":1,\"683\":2,\"687\":2,\"709\":5,\"716\":4,\"717\":3,\"720\":1,\"730\":1}}],[\"printname\",{\"1\":{\"557\":1}}],[\"printwriter\",{\"0\":{\"479\":1},\"1\":{\"479\":8}}],[\"printweak\",{\"1\":{\"96\":3}}],[\"printx\",{\"1\":{\"417\":2}}],[\"printinfo\",{\"1\":{\"390\":3}}],[\"printarray\",{\"1\":{\"123\":1}}],[\"printdecochar\",{\"1\":{\"117\":3}}],[\"printstream\",{\"0\":{\"479\":1},\"1\":{\"478\":1,\"479\":8}}],[\"printstrong\",{\"1\":{\"96\":3}}],[\"printstacktrace\",{\"1\":{\"111\":2,\"114\":3,\"117\":1,\"233\":1,\"248\":7,\"249\":1,\"256\":1,\"262\":1,\"268\":3,\"271\":3,\"298\":3,\"304\":2,\"466\":7,\"467\":2,\"468\":5,\"469\":2,\"471\":1,\"475\":3,\"477\":14,\"478\":13,\"479\":3,\"480\":2,\"483\":3,\"485\":2,\"486\":3}}],[\"printline\",{\"1\":{\"105\":3,\"114\":3}}],[\"println\",{\"1\":{\"55\":2,\"91\":1,\"96\":2,\"99\":3,\"102\":2,\"105\":3,\"108\":1,\"111\":2,\"114\":5,\"117\":3,\"232\":2,\"233\":3,\"248\":4,\"249\":4,\"253\":2,\"256\":4,\"262\":1,\"263\":3,\"268\":15,\"271\":12,\"291\":4,\"297\":2,\"298\":3,\"300\":2,\"304\":2,\"313\":4,\"334\":3,\"335\":3,\"351\":1,\"352\":2,\"354\":1,\"358\":2,\"359\":2,\"368\":2,\"376\":1,\"377\":1,\"381\":5,\"382\":2,\"390\":1,\"391\":4,\"396\":1,\"399\":1,\"402\":4,\"403\":2,\"404\":4,\"411\":5,\"413\":10,\"414\":3,\"415\":2,\"416\":1,\"417\":4,\"418\":10,\"419\":8,\"421\":1,\"424\":1,\"427\":1,\"428\":3,\"429\":2,\"430\":1,\"431\":3,\"433\":2,\"436\":22,\"439\":2,\"440\":8,\"443\":9,\"444\":1,\"448\":2,\"451\":1,\"454\":2,\"457\":3,\"459\":4,\"466\":6,\"467\":1,\"468\":7,\"469\":4,\"471\":7,\"475\":7,\"477\":3,\"478\":11,\"479\":1,\"480\":3,\"483\":5,\"485\":5,\"486\":2,\"490\":1,\"491\":2,\"502\":1,\"512\":1,\"524\":1,\"530\":1,\"552\":1,\"557\":2,\"559\":2,\"560\":5,\"563\":1,\"564\":3,\"565\":3,\"569\":2,\"572\":8,\"576\":3,\"577\":9,\"583\":9,\"645\":4,\"648\":1,\"718\":1,\"724\":1,\"730\":1}}],[\"printbanner\",{\"1\":{\"96\":3}}],[\"print\",{\"1\":{\"55\":2,\"96\":3,\"105\":8,\"114\":6,\"117\":1,\"376\":1,\"382\":1,\"430\":2,\"477\":3,\"479\":3,\"489\":1,\"729\":2}}],[\"profiles\",{\"1\":{\"602\":1,\"604\":1}}],[\"provider\",{\"1\":{\"598\":7}}],[\"proceed\",{\"1\":{\"572\":1}}],[\"proceedingjoinpoint\",{\"1\":{\"572\":3}}],[\"project>\",{\"1\":{\"498\":1,\"540\":1}}],[\"projectlombok<\",{\"1\":{\"498\":1,\"540\":1}}],[\"propagation=\",{\"1\":{\"583\":1}}],[\"propagation\",{\"1\":{\"582\":1}}],[\"propagate=\",{\"1\":{\"318\":2}}],[\"propagate\",{\"1\":{\"312\":2}}],[\"prop\",{\"1\":{\"562\":4}}],[\"property=\",{\"1\":{\"501\":2,\"522\":4,\"523\":20,\"524\":5,\"525\":14,\"527\":7}}],[\"property\",{\"1\":{\"501\":1,\"522\":1,\"523\":2,\"524\":1,\"527\":1,\"562\":2}}],[\"property>\",{\"1\":{\"67\":3,\"557\":26,\"560\":2,\"561\":1,\"562\":8,\"575\":5,\"583\":6}}],[\"properties>\",{\"1\":{\"498\":1,\"540\":1}}],[\"properties父类时hashtable\",{\"1\":{\"480\":1}}],[\"properties01\",{\"1\":{\"480\":1}}],[\"properties案例\",{\"1\":{\"480\":1}}],[\"properties类\",{\"0\":{\"480\":1}}],[\"properties类继承自hashtable类并且实现了map接口\",{\"1\":{\"450\":1}}],[\"properties文件\",{\"1\":{\"450\":1,\"605\":1}}],[\"properties\",{\"0\":{\"450\":1,\"507\":1},\"1\":{\"160\":1,\"451\":1,\"480\":13,\"507\":1,\"562\":1,\"603\":2,\"605\":1}}],[\"producer\",{\"1\":{\"210\":5}}],[\"productname\",{\"1\":{\"256\":8}}],[\"product\",{\"1\":{\"102\":18,\"117\":14}}],[\"programming\",{\"1\":{\"158\":1}}],[\"protection\",{\"1\":{\"786\":1}}],[\"protected\",{\"1\":{\"102\":4,\"111\":6,\"304\":1,\"307\":1,\"313\":2,\"334\":2,\"397\":2,\"442\":1}}],[\"protoname\",{\"1\":{\"117\":2}}],[\"proto\",{\"1\":{\"117\":5}}],[\"prototype\",{\"1\":{\"65\":1,\"93\":1,\"116\":1,\"559\":2}}],[\"proxyxx\",{\"1\":{\"492\":1}}],[\"proxyutils\",{\"1\":{\"419\":1}}],[\"proxygenerator\",{\"1\":{\"419\":1}}],[\"proxy\",{\"0\":{\"419\":1},\"1\":{\"72\":2,\"159\":2,\"419\":8,\"569\":4,\"605\":1}}],[\"problems\",{\"1\":{\"5\":1}}],[\"platform=mysql\",{\"1\":{\"605\":1}}],[\"placeholder>\",{\"1\":{\"562\":1}}],[\"placeholder\",{\"1\":{\"562\":1}}],[\"play\",{\"1\":{\"5\":1}}],[\"played\",{\"1\":{\"5\":8}}],[\"player\",{\"1\":{\"5\":11,\"49\":1}}],[\"plusone\",{\"1\":{\"713\":2}}],[\"plusdays\",{\"1\":{\"436\":1}}],[\"plus\",{\"1\":{\"436\":1}}],[\"plugins>\",{\"1\":{\"540\":1}}],[\"plugin>\",{\"1\":{\"540\":1}}],[\"plugin<\",{\"1\":{\"540\":1}}],[\"pluginrepositories>\",{\"1\":{\"498\":1,\"540\":1}}],[\"pluginrepository>\",{\"1\":{\"498\":1,\"540\":1}}],[\"plugin和maven\",{\"1\":{\"82\":1}}],[\"plugin\",{\"1\":{\"17\":1,\"82\":3}}],[\"please\",{\"1\":{\"368\":1}}],[\"essay\",{\"0\":{\"790\":1}}],[\"etc\",{\"1\":{\"617\":1}}],[\"eureka采用ap方式\",{\"1\":{\"600\":1}}],[\"eureka和nacos比较\",{\"0\":{\"600\":1}}],[\"eureka的地址信息\",{\"1\":{\"597\":1}}],[\"eureka的作用\",{\"1\":{\"597\":1}}],[\"eureka客户端依赖\",{\"1\":{\"597\":1}}],[\"eureka自然会把它从服务列表中剔除\",{\"1\":{\"597\":1}}],[\"eureka说白了就是一个注册服务中心\",{\"1\":{\"597\":1}}],[\"eureka就好比是滴滴\",{\"1\":{\"597\":1}}],[\"eureka\",{\"0\":{\"597\":1},\"1\":{\"592\":1,\"593\":2,\"595\":2,\"597\":3}}],[\"ehcache\",{\"0\":{\"538\":1}}],[\"eviction\",{\"1\":{\"536\":1}}],[\"eviction=\",{\"1\":{\"536\":1}}],[\"event\",{\"1\":{\"5\":12}}],[\"empty\",{\"1\":{\"655\":13,\"656\":1,\"657\":2,\"658\":2,\"711\":1}}],[\"empcolumns\",{\"1\":{\"532\":2}}],[\"emplist\",{\"1\":{\"525\":2,\"531\":4}}],[\"employee\",{\"1\":{\"486\":6,\"561\":1}}],[\"employ\",{\"1\":{\"445\":9}}],[\"empdeptbystepresultmap\",{\"1\":{\"523\":2,\"524\":1}}],[\"empdeptassresultmap\",{\"1\":{\"523\":1,\"527\":2,\"528\":1,\"529\":1,\"532\":1}}],[\"empdeptresultmap\",{\"1\":{\"523\":2}}],[\"empgender=\",{\"1\":{\"523\":1,\"530\":2,\"542\":8}}],[\"empgender\",{\"1\":{\"522\":1,\"523\":3,\"524\":1,\"525\":2,\"527\":4,\"528\":3,\"529\":3,\"530\":1,\"531\":1,\"532\":3}}],[\"empage=null\",{\"1\":{\"542\":8}}],[\"empage=21\",{\"1\":{\"530\":1}}],[\"empage=20\",{\"1\":{\"523\":1,\"530\":1}}],[\"empage\",{\"1\":{\"522\":1,\"523\":3,\"524\":1,\"525\":2,\"527\":4,\"528\":3,\"529\":3,\"530\":1,\"531\":1,\"532\":3}}],[\"empresultmap\",{\"1\":{\"522\":2}}],[\"empmapper\",{\"1\":{\"522\":1,\"523\":1,\"524\":5}}],[\"emp\",{\"1\":{\"522\":15,\"523\":26,\"524\":13,\"525\":16,\"527\":13,\"528\":5,\"529\":5,\"530\":11,\"531\":10,\"532\":9,\"535\":1,\"540\":2,\"542\":8,\"557\":5,\"561\":1}}],[\"empname=\",{\"1\":{\"523\":1,\"530\":2,\"542\":8}}],[\"empname\",{\"1\":{\"522\":3,\"523\":3,\"524\":1,\"525\":2,\"527\":4,\"528\":3,\"529\":3,\"530\":3,\"531\":1,\"532\":3}}],[\"empids\",{\"1\":{\"531\":5}}],[\"empid=4\",{\"1\":{\"542\":2}}],[\"empid=3\",{\"1\":{\"542\":2}}],[\"empid=2\",{\"1\":{\"542\":2}}],[\"empid=5\",{\"1\":{\"530\":1}}],[\"empid=1\",{\"1\":{\"523\":1,\"530\":1,\"542\":2}}],[\"empid\",{\"1\":{\"522\":7,\"523\":5,\"524\":1,\"525\":3,\"527\":1,\"531\":5}}],[\"email\",{\"1\":{\"501\":1,\"520\":1}}],[\"effectively\",{\"1\":{\"491\":1}}],[\"eager\",{\"1\":{\"598\":1}}],[\"eat\",{\"1\":{\"459\":1}}],[\"each或迭代器遍历\",{\"1\":{\"448\":1}}],[\"each遍历\",{\"1\":{\"443\":2}}],[\"each\",{\"1\":{\"439\":1,\"440\":1,\"444\":1}}],[\"early\",{\"1\":{\"163\":1}}],[\"equalsignorecase\",{\"1\":{\"429\":1}}],[\"equals\",{\"1\":{\"421\":1,\"429\":2,\"433\":1,\"445\":3,\"492\":3,\"607\":1,\"713\":1,\"729\":2}}],[\"equles\",{\"1\":{\"406\":3}}],[\"equles方法只能用来判断引用类型\",{\"1\":{\"406\":1}}],[\"equles方法\",{\"1\":{\"406\":1}}],[\"edge\",{\"1\":{\"717\":3}}],[\"editor\",{\"1\":{\"395\":1}}],[\"edureka\",{\"1\":{\"67\":2}}],[\"ee\",{\"1\":{\"168\":1}}],[\"error\",{\"1\":{\"126\":1,\"177\":1,\"424\":1,\"461\":2,\"777\":1}}],[\"error和exception的区别\",{\"0\":{\"126\":1},\"1\":{\"126\":1}}],[\"err\",{\"1\":{\"111\":1}}],[\"e\",{\"1\":{\"111\":5,\"114\":6,\"117\":2,\"233\":2,\"248\":14,\"249\":6,\"256\":2,\"262\":2,\"268\":6,\"271\":6,\"298\":6,\"304\":4,\"307\":3,\"313\":2,\"424\":4,\"436\":1,\"457\":3,\"459\":2,\"466\":14,\"467\":4,\"468\":10,\"469\":4,\"471\":2,\"475\":11,\"477\":36,\"478\":37,\"479\":10,\"480\":5,\"483\":6,\"485\":4,\"486\":6,\"709\":4}}],[\"element\",{\"1\":{\"657\":4,\"658\":4}}],[\"elementdata\",{\"1\":{\"442\":1}}],[\"elasticsearch\",{\"1\":{\"81\":1}}],[\"else语句\",{\"1\":{\"6\":1}}],[\"else\",{\"0\":{\"371\":1},\"1\":{\"3\":1,\"6\":2,\"99\":1,\"306\":1,\"307\":1,\"312\":1,\"339\":1,\"371\":3,\"382\":1,\"391\":2,\"471\":1,\"477\":1,\"530\":2,\"620\":2,\"621\":3,\"624\":1,\"625\":1,\"627\":3,\"629\":1,\"634\":1,\"635\":1,\"644\":1,\"648\":1,\"650\":2,\"659\":1,\"660\":1,\"661\":1,\"667\":1,\"668\":3,\"688\":1,\"693\":2,\"695\":3,\"696\":1,\"698\":1,\"700\":1,\"701\":1,\"702\":1,\"709\":2,\"713\":2,\"716\":1,\"718\":1,\"729\":1,\"730\":2}}],[\"extensions\",{\"1\":{\"769\":1}}],[\"extension\",{\"1\":{\"599\":1,\"602\":1}}],[\"extend01\",{\"1\":{\"399\":1}}],[\"extends\",{\"1\":{\"96\":1,\"102\":2,\"105\":2,\"111\":5,\"114\":2,\"117\":2,\"243\":1,\"244\":1,\"248\":12,\"251\":2,\"291\":1,\"304\":1,\"313\":1,\"334\":2,\"399\":3,\"402\":3,\"403\":1,\"404\":2,\"416\":1,\"417\":2,\"418\":1,\"424\":2,\"458\":1,\"460\":2,\"461\":1,\"466\":2,\"468\":1,\"469\":1,\"471\":1}}],[\"externalizable\",{\"1\":{\"478\":1}}],[\"exist\",{\"1\":{\"705\":1}}],[\"exists\",{\"1\":{\"5\":1,\"475\":4}}],[\"exit\",{\"1\":{\"434\":1}}],[\"ex\",{\"1\":{\"205\":1}}],[\"expose\",{\"1\":{\"616\":3}}],[\"exposeheaders\",{\"1\":{\"607\":1}}],[\"experimental\",{\"1\":{\"252\":1}}],[\"expire\",{\"1\":{\"205\":1}}],[\"expression=\",{\"1\":{\"563\":2,\"583\":1}}],[\"expression\",{\"1\":{\"60\":1,\"488\":1}}],[\"exec\",{\"1\":{\"201\":1,\"202\":3,\"614\":2}}],[\"execution\",{\"1\":{\"571\":2,\"572\":5,\"583\":1,\"598\":2}}],[\"executionexception\",{\"1\":{\"232\":2,\"233\":2,\"248\":1}}],[\"executors\",{\"1\":{\"249\":1,\"268\":4}}],[\"executorservice\",{\"1\":{\"132\":2,\"249\":1,\"268\":4}}],[\"executor\",{\"1\":{\"134\":1,\"238\":2,\"239\":2,\"247\":1,\"248\":6}}],[\"execute\",{\"1\":{\"63\":1,\"132\":1,\"555\":1,\"598\":1}}],[\"exclude\",{\"1\":{\"563\":1}}],[\"exclusive\",{\"1\":{\"312\":1}}],[\"exchange\",{\"1\":{\"209\":1,\"607\":5}}],[\"excite\",{\"1\":{\"111\":4}}],[\"exceptionally\",{\"1\":{\"249\":1}}],[\"exception分为编译时异常和运行时异常\",{\"1\":{\"126\":1}}],[\"exception\",{\"1\":{\"111\":1,\"126\":1,\"162\":1,\"232\":1,\"262\":1,\"271\":1,\"424\":3,\"479\":1}}],[\"example\",{\"1\":{\"108\":5,\"111\":25,\"114\":6,\"117\":10,\"327\":1,\"339\":1,\"605\":1,\"645\":2}}],[\"echarts\",{\"0\":{\"29\":1}}],[\"engine=innodb\",{\"1\":{\"605\":9}}],[\"english\",{\"1\":{\"252\":1,\"557\":1}}],[\"env\",{\"1\":{\"616\":5}}],[\"envsharedvalue\",{\"1\":{\"603\":1}}],[\"environments\",{\"1\":{\"506\":1}}],[\"environments>\",{\"1\":{\"499\":1,\"506\":1}}],[\"environment\",{\"0\":{\"506\":1},\"1\":{\"506\":1,\"617\":2}}],[\"environment>\",{\"1\":{\"499\":1,\"506\":1}}],[\"enviction策略可以保证数据不被丢失\",{\"1\":{\"192\":1}}],[\"enviction\",{\"1\":{\"192\":1}}],[\"en\",{\"1\":{\"499\":1,\"540\":1}}],[\"enablefeignclients\",{\"1\":{\"606\":2}}],[\"enabled\",{\"1\":{\"598\":1,\"605\":1,\"606\":1}}],[\"enabled>\",{\"1\":{\"498\":4,\"540\":4}}],[\"enabletransactionmanagement\",{\"1\":{\"584\":1}}],[\"enablesubpackages\",{\"1\":{\"540\":3}}],[\"enableasync注解\",{\"1\":{\"164\":2}}],[\"enableautoconfiguration\",{\"1\":{\"84\":1}}],[\"enableautoconfiguration等注解来开启自动扫描和自动装配的功能\",{\"1\":{\"68\":1}}],[\"encoding\",{\"1\":{\"771\":1}}],[\"encoding=\",{\"1\":{\"63\":1,\"327\":1,\"498\":1,\"499\":1,\"501\":1,\"504\":1,\"540\":2,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1,\"586\":1}}],[\"enclosing\",{\"1\":{\"491\":1}}],[\"entity\",{\"1\":{\"499\":1,\"504\":1,\"508\":3,\"540\":1,\"768\":1}}],[\"enter\",{\"1\":{\"368\":1,\"395\":1}}],[\"entrypoint\",{\"1\":{\"616\":5}}],[\"entry>\",{\"1\":{\"557\":2}}],[\"entry\",{\"1\":{\"124\":1,\"307\":1}}],[\"entryset\",{\"1\":{\"124\":1}}],[\"enum类已经重写过\",{\"1\":{\"421\":1}}],[\"enum01\",{\"1\":{\"421\":1}}],[\"enumeration<string>\",{\"1\":{\"330\":1}}],[\"enum\",{\"1\":{\"225\":1,\"372\":1,\"421\":1}}],[\"enhancer\",{\"1\":{\"492\":1}}],[\"enhance\",{\"1\":{\"17\":1}}],[\"end为遍历完所有的节点\",{\"1\":{\"712\":1}}],[\"endindex\",{\"1\":{\"676\":3}}],[\"end++\",{\"1\":{\"645\":1}}],[\"endrow=4\",{\"1\":{\"542\":3}}],[\"endtime\",{\"1\":{\"256\":4,\"416\":2,\"431\":7}}],[\"end表示case语句结束\",{\"1\":{\"6\":1}}],[\"end\",{\"1\":{\"6\":2,\"233\":1,\"291\":2,\"419\":2,\"624\":1,\"643\":4,\"645\":18,\"688\":2,\"698\":4,\"711\":1}}],[\"endl\",{\"1\":{\"3\":12}}],[\"i个节点\",{\"1\":{\"730\":2}}],[\"ii\",{\"0\":{\"646\":1,\"738\":2}}],[\"i<r\",{\"1\":{\"727\":1,\"728\":1}}],[\"i<n\",{\"1\":{\"724\":1}}],[\"i<index\",{\"1\":{\"635\":2}}],[\"i<=\",{\"1\":{\"635\":1}}],[\"i<\",{\"1\":{\"635\":1}}],[\"i=0\",{\"1\":{\"635\":4,\"724\":1,\"727\":1,\"728\":1}}],[\"irule\",{\"1\":{\"598\":1}}],[\"ir⋯\",{\"1\":{\"32\":1}}],[\"ip通信传输\",{\"0\":{\"750\":1}}],[\"ip分为4层\",{\"1\":{\"749\":1}}],[\"ip的分层管理\",{\"0\":{\"749\":1}}],[\"ips`\",{\"1\":{\"605\":1}}],[\"ip`\",{\"1\":{\"605\":4}}],[\"ip改为服务名称\",{\"1\":{\"597\":1}}],[\"ip\",{\"0\":{\"747\":1},\"1\":{\"483\":1,\"485\":1,\"605\":3,\"749\":1}}],[\"ip协议族\",{\"0\":{\"748\":1}}],[\"ip协议族的基础上运作的\",{\"1\":{\"747\":1}}],[\"ip协议\",{\"1\":{\"482\":1}}],[\"ipv4地址分类\",{\"1\":{\"482\":1}}],[\"ip地址指明了节点被分配到的地址\",{\"1\":{\"752\":1}}],[\"ip地址是用来标识网络中设备的逻辑地址\",{\"1\":{\"152\":1}}],[\"ip地址和mac地址区别\",{\"0\":{\"152\":1}}],[\"iusb<integer\",{\"1\":{\"458\":1}}],[\"iusb<string\",{\"1\":{\"458\":1}}],[\"iusb<u\",{\"1\":{\"458\":1}}],[\"i2\",{\"1\":{\"427\":1}}],[\"illegalaccessexception\",{\"1\":{\"419\":1,\"486\":1}}],[\"illegalthreadstateexception\",{\"1\":{\"220\":1}}],[\"ia\",{\"1\":{\"418\":6,\"458\":1}}],[\"ih0\",{\"1\":{\"417\":4}}],[\"ih1\",{\"1\":{\"417\":4}}],[\"i+1\",{\"1\":{\"382\":2,\"650\":1,\"709\":3}}],[\"i++\",{\"1\":{\"55\":4,\"91\":4,\"105\":2,\"114\":3,\"117\":1,\"262\":3,\"377\":1,\"381\":1,\"382\":4,\"416\":1,\"431\":3,\"440\":1,\"443\":1,\"444\":1,\"468\":1,\"469\":1,\"623\":1,\"624\":3,\"625\":1,\"627\":2,\"629\":2,\"630\":1,\"632\":1,\"635\":7,\"646\":2,\"648\":1,\"650\":2,\"652\":1,\"653\":2,\"659\":1,\"660\":1,\"661\":2,\"662\":1,\"671\":1,\"674\":2,\"677\":3,\"678\":3,\"683\":1,\"684\":1,\"685\":1,\"686\":3,\"687\":1,\"688\":2,\"689\":1,\"693\":2,\"694\":1,\"695\":1,\"696\":3,\"697\":1,\"698\":1,\"700\":3,\"701\":4,\"705\":1,\"706\":1,\"707\":1,\"708\":3,\"709\":9,\"711\":1,\"712\":1,\"713\":1,\"715\":2,\"716\":1,\"717\":2,\"718\":3,\"724\":1,\"727\":1,\"728\":1,\"729\":1,\"730\":2,\"737\":1}}],[\"ignore\",{\"1\":{\"220\":1}}],[\"i1\",{\"1\":{\"114\":2,\"427\":1}}],[\"i\",{\"0\":{\"735\":1},\"1\":{\"55\":16,\"91\":20,\"105\":4,\"114\":6,\"117\":2,\"186\":4,\"187\":3,\"192\":1,\"262\":6,\"359\":2,\"377\":3,\"381\":8,\"382\":23,\"403\":7,\"416\":3,\"427\":3,\"428\":7,\"430\":4,\"431\":9,\"440\":6,\"443\":3,\"444\":3,\"468\":2,\"469\":3,\"476\":1,\"583\":1,\"614\":2,\"622\":10,\"623\":5,\"624\":27,\"625\":9,\"627\":8,\"628\":13,\"629\":10,\"630\":6,\"631\":2,\"632\":9,\"635\":6,\"643\":6,\"646\":6,\"648\":3,\"650\":26,\"652\":6,\"653\":10,\"659\":3,\"660\":3,\"661\":10,\"662\":5,\"671\":3,\"674\":6,\"675\":4,\"677\":20,\"678\":20,\"683\":5,\"684\":4,\"685\":4,\"686\":11,\"687\":6,\"688\":8,\"689\":13,\"693\":14,\"694\":2,\"695\":10,\"696\":15,\"697\":7,\"698\":4,\"700\":22,\"701\":28,\"702\":14,\"704\":1,\"705\":13,\"706\":14,\"707\":14,\"708\":22,\"709\":80,\"711\":2,\"712\":2,\"713\":2,\"715\":12,\"716\":4,\"717\":8,\"718\":8,\"724\":2,\"727\":1,\"728\":1,\"729\":3,\"730\":23,\"734\":10,\"736\":2,\"737\":7}}],[\"img标签\",{\"1\":{\"332\":1}}],[\"img\",{\"1\":{\"76\":1,\"319\":1,\"598\":1,\"599\":1,\"624\":1,\"625\":1,\"666\":1,\"667\":2,\"695\":1,\"696\":1,\"705\":1,\"708\":1,\"709\":1,\"712\":1,\"715\":1}}],[\"impl\",{\"1\":{\"114\":11}}],[\"implements\",{\"1\":{\"70\":1,\"96\":1,\"108\":2,\"111\":2,\"114\":2,\"117\":1,\"232\":1,\"308\":1,\"339\":1,\"417\":6,\"418\":1,\"419\":4,\"458\":1,\"466\":4,\"467\":1,\"468\":1,\"471\":1,\"478\":1,\"535\":1,\"557\":1,\"564\":1,\"569\":1,\"575\":1,\"576\":1,\"577\":1,\"583\":1,\"607\":1}}],[\"import\",{\"1\":{\"55\":4,\"91\":4,\"99\":2,\"102\":9,\"111\":19,\"114\":2,\"117\":7,\"232\":3,\"233\":3,\"248\":2,\"249\":1,\"252\":4,\"253\":1,\"256\":7,\"262\":2,\"268\":10,\"297\":4,\"368\":1,\"396\":1,\"419\":3,\"433\":2,\"569\":4,\"586\":2,\"724\":2,\"729\":2,\"730\":4}}],[\"images\",{\"1\":{\"613\":1}}],[\"image\",{\"1\":{\"51\":1,\"60\":1,\"111\":1,\"114\":1,\"209\":1,\"231\":1,\"235\":1,\"237\":1,\"264\":1,\"312\":1,\"329\":1,\"339\":1,\"522\":1,\"552\":1,\"555\":1,\"562\":1,\"571\":1,\"582\":1,\"586\":1,\"611\":2,\"617\":2,\"748\":1,\"750\":2,\"753\":1,\"755\":1,\"757\":1,\"763\":8,\"765\":3,\"767\":2,\"768\":1,\"770\":2,\"773\":2,\"774\":1,\"775\":4,\"776\":1,\"779\":2,\"780\":3,\"781\":3,\"783\":2,\"784\":1,\"785\":2,\"786\":4}}],[\"io读取\",{\"1\":{\"485\":1}}],[\"io包下提供了各种\",{\"1\":{\"476\":1}}],[\"io流体系图\",{\"0\":{\"477\":1}}],[\"io流原理\",{\"1\":{\"476\":1}}],[\"io流原理及流的分类\",{\"0\":{\"476\":1}}],[\"io流\",{\"0\":{\"473\":1},\"1\":{\"450\":1,\"477\":1}}],[\"ioc的核心理念是将对象的创建\",{\"1\":{\"158\":1}}],[\"ioc的原理\",{\"0\":{\"63\":1}}],[\"ioc\",{\"0\":{\"547\":1,\"553\":1,\"554\":1,\"555\":1},\"1\":{\"61\":1,\"63\":1,\"158\":1,\"546\":1,\"554\":1,\"555\":7}}],[\"ioexception\",{\"1\":{\"55\":2,\"111\":2,\"114\":3,\"334\":2,\"339\":1,\"475\":3,\"477\":15,\"478\":12,\"479\":2,\"480\":2,\"485\":2,\"502\":1,\"512\":1,\"598\":1,\"730\":2}}],[\"io\",{\"0\":{\"54\":1},\"1\":{\"55\":3,\"91\":1,\"111\":2,\"114\":1,\"186\":2,\"187\":1,\"551\":1,\"730\":3}}],[\"itcast\",{\"1\":{\"607\":2}}],[\"iter2\",{\"1\":{\"443\":1}}],[\"iter1\",{\"1\":{\"443\":5}}],[\"iterator<customer>\",{\"1\":{\"456\":1}}],[\"iterator<string>\",{\"1\":{\"443\":1}}],[\"iterator接口的方法\",{\"1\":{\"439\":1}}],[\"iterator迭代器对象遍历\",{\"1\":{\"439\":1}}],[\"iterator\",{\"1\":{\"111\":6,\"124\":1,\"439\":5,\"443\":6,\"444\":5,\"448\":5,\"456\":2,\"720\":1}}],[\"item=\",{\"1\":{\"531\":3}}],[\"item\",{\"1\":{\"108\":2,\"111\":20}}],[\"items\",{\"1\":{\"108\":4}}],[\"it\",{\"1\":{\"15\":2,\"111\":6,\"614\":2}}],[\"iv\",{\"1\":{\"5\":1}}],[\"id`\",{\"1\":{\"605\":47}}],[\"ids\",{\"1\":{\"518\":1}}],[\"id属性值必须是唯一的\",{\"1\":{\"501\":1}}],[\"id表示主键字段\",{\"1\":{\"501\":1}}],[\"id>\",{\"1\":{\"498\":2,\"501\":1,\"522\":1,\"523\":5,\"524\":1,\"525\":4,\"527\":2,\"540\":2}}],[\"idea中的中文默认编码为unicode\",{\"1\":{\"480\":1}}],[\"idea快捷键\",{\"1\":{\"395\":1}}],[\"idea的使用\",{\"0\":{\"395\":1}}],[\"idea会帮你自动检测方法名\",{\"1\":{\"129\":1}}],[\"identity\",{\"1\":{\"251\":1,\"768\":1}}],[\"id的字符串\",{\"1\":{\"153\":1}}],[\"id++\",{\"1\":{\"102\":1}}],[\"idcardfactory\",{\"1\":{\"102\":3}}],[\"idcard\",{\"1\":{\"102\":8}}],[\"id=\",{\"1\":{\"63\":1,\"67\":1,\"499\":1,\"501\":10,\"504\":1,\"506\":1,\"511\":2,\"512\":4,\"517\":3,\"518\":1,\"519\":1,\"520\":1,\"522\":3,\"523\":7,\"524\":1,\"525\":4,\"527\":2,\"528\":1,\"529\":1,\"530\":1,\"531\":3,\"532\":2,\"540\":1,\"541\":1,\"552\":1,\"555\":1,\"557\":16,\"560\":3,\"561\":2,\"562\":2,\"563\":1,\"575\":2,\"583\":5}}],[\"id合成一个字段来查询\",{\"1\":{\"7\":1}}],[\"id来查出第二天登录表时\",{\"1\":{\"5\":1}}],[\"id\",{\"1\":{\"5\":19,\"7\":11,\"22\":1,\"102\":10,\"165\":6,\"178\":1,\"204\":1,\"252\":1,\"300\":1,\"501\":9,\"504\":5,\"506\":2,\"514\":3,\"515\":2,\"518\":1,\"520\":1,\"522\":4,\"523\":15,\"524\":5,\"525\":15,\"527\":4,\"528\":2,\"529\":2,\"531\":2,\"532\":4,\"557\":3,\"569\":2,\"577\":4,\"598\":1,\"605\":22,\"606\":3,\"607\":2,\"709\":28}}],[\"isbinarysearchtree\",{\"1\":{\"730\":2}}],[\"isbipartite\",{\"1\":{\"716\":1}}],[\"ismatch\",{\"1\":{\"702\":1}}],[\"ispalindrome\",{\"1\":{\"688\":2}}],[\"isnew\",{\"1\":{\"675\":3}}],[\"isvalid\",{\"1\":{\"659\":1}}],[\"islastpage=false\",{\"1\":{\"542\":1}}],[\"isfirstpage=true\",{\"1\":{\"542\":1}}],[\"isfile\",{\"1\":{\"475\":3}}],[\"is2\",{\"1\":{\"382\":4}}],[\"isheldexclusively\",{\"1\":{\"313\":1}}],[\"issymmetric\",{\"1\":{\"668\":1}}],[\"isshared\",{\"1\":{\"312\":1}}],[\"isstop\",{\"1\":{\"268\":3}}],[\"isalive\",{\"1\":{\"287\":1}}],[\"isinterrupted\",{\"1\":{\"268\":1}}],[\"isdirectory\",{\"1\":{\"475\":3}}],[\"isdone\",{\"1\":{\"235\":1}}],[\"isdone轮询方法\",{\"0\":{\"234\":1}}],[\"isdaemon\",{\"1\":{\"227\":1}}],[\"isolation\",{\"1\":{\"170\":1,\"582\":1}}],[\"isempty\",{\"1\":{\"91\":1,\"439\":1,\"656\":1,\"657\":2,\"658\":1,\"659\":2,\"661\":1,\"666\":1,\"669\":1,\"684\":1,\"712\":1,\"713\":1,\"717\":1,\"718\":1,\"730\":1}}],[\"is\",{\"1\":{\"3\":2,\"27\":2,\"67\":1,\"120\":1,\"203\":1,\"256\":2,\"291\":3,\"363\":1,\"382\":4,\"607\":1,\"645\":2,\"657\":1,\"658\":1,\"711\":1}}],[\"if>\",{\"1\":{\"527\":3,\"528\":3,\"529\":3,\"532\":3}}],[\"if1\",{\"1\":{\"417\":1}}],[\"if0\",{\"1\":{\"417\":6}}],[\"iframe标签\",{\"1\":{\"332\":1}}],[\"if\",{\"0\":{\"527\":1},\"1\":{\"3\":1,\"5\":1,\"91\":5,\"99\":1,\"114\":1,\"220\":2,\"249\":1,\"262\":1,\"268\":3,\"292\":2,\"306\":1,\"307\":4,\"312\":1,\"339\":1,\"371\":3,\"377\":1,\"381\":1,\"382\":1,\"391\":3,\"406\":1,\"414\":1,\"428\":1,\"440\":1,\"445\":2,\"466\":5,\"468\":3,\"471\":2,\"475\":1,\"477\":6,\"478\":4,\"479\":1,\"527\":1,\"530\":2,\"607\":1,\"620\":2,\"621\":5,\"622\":2,\"623\":2,\"624\":3,\"625\":3,\"626\":1,\"627\":4,\"628\":3,\"629\":1,\"630\":1,\"631\":1,\"632\":1,\"634\":2,\"635\":10,\"637\":1,\"638\":1,\"639\":2,\"640\":1,\"642\":1,\"644\":1,\"645\":1,\"648\":8,\"649\":5,\"650\":5,\"652\":3,\"653\":4,\"655\":1,\"659\":5,\"660\":2,\"661\":2,\"662\":2,\"664\":7,\"666\":3,\"667\":4,\"668\":5,\"669\":4,\"671\":1,\"672\":2,\"674\":5,\"675\":1,\"677\":2,\"678\":1,\"682\":1,\"683\":1,\"684\":2,\"685\":3,\"686\":1,\"687\":4,\"688\":4,\"689\":8,\"690\":4,\"693\":2,\"694\":2,\"695\":3,\"696\":4,\"697\":1,\"698\":3,\"699\":1,\"700\":1,\"701\":11,\"702\":5,\"704\":2,\"705\":3,\"706\":3,\"707\":3,\"708\":3,\"709\":16,\"711\":2,\"712\":4,\"713\":6,\"715\":2,\"716\":4,\"717\":3,\"718\":3,\"720\":3,\"721\":2,\"729\":1,\"730\":5,\"734\":1,\"740\":2,\"742\":3}}],[\"indices\",{\"1\":{\"721\":8}}],[\"index小于0\",{\"1\":{\"635\":1}}],[\"index>size\",{\"1\":{\"635\":1}}],[\"index>=size\",{\"1\":{\"635\":2}}],[\"index大于链表长度\",{\"1\":{\"635\":1}}],[\"index<0\",{\"1\":{\"635\":3}}],[\"index+1\",{\"1\":{\"635\":1}}],[\"index=\",{\"1\":{\"542\":1,\"557\":1}}],[\"indexof\",{\"1\":{\"429\":1,\"440\":1,\"651\":1}}],[\"index\",{\"1\":{\"179\":2,\"542\":2,\"605\":2,\"614\":2,\"635\":24,\"640\":5,\"721\":5,\"760\":2,\"762\":2}}],[\"indegree\",{\"1\":{\"91\":5}}],[\"inarea\",{\"1\":{\"704\":2}}],[\"inordertraversal\",{\"1\":{\"664\":3}}],[\"inc\",{\"1\":{\"676\":2}}],[\"increment\",{\"1\":{\"605\":9,\"677\":2,\"678\":2}}],[\"include>\",{\"1\":{\"532\":1}}],[\"include\",{\"1\":{\"3\":4,\"532\":1,\"563\":1}}],[\"inetaddress\",{\"1\":{\"483\":8,\"485\":1}}],[\"inetaddress01\",{\"1\":{\"483\":1}}],[\"inetaddress类\",{\"0\":{\"483\":1}}],[\"inherited\",{\"1\":{\"422\":1}}],[\"info`\",{\"1\":{\"605\":3}}],[\"info\",{\"1\":{\"391\":2,\"430\":2,\"475\":1,\"586\":4,\"605\":12}}],[\"information\",{\"1\":{\"117\":1}}],[\"inputstream\",{\"1\":{\"476\":1,\"478\":2,\"485\":4,\"502\":3}}],[\"inputstreamreader可以将inputstream\",{\"1\":{\"478\":1}}],[\"inputstreamreader\",{\"1\":{\"55\":2,\"478\":3,\"730\":2}}],[\"input\",{\"1\":{\"430\":2,\"478\":1}}],[\"inputdetail\",{\"1\":{\"368\":1}}],[\"init初始化方法\",{\"1\":{\"340\":1}}],[\"init\",{\"1\":{\"327\":1,\"328\":1,\"339\":1,\"560\":5}}],[\"initialize\",{\"1\":{\"657\":1,\"658\":1}}],[\"initialization\",{\"1\":{\"160\":1}}],[\"initialvalue\",{\"1\":{\"304\":1,\"307\":2}}],[\"innodb是mysql的默认存储引擎\",{\"1\":{\"183\":1}}],[\"innodb\",{\"1\":{\"183\":1}}],[\"innodb引入了间隙锁\",{\"1\":{\"178\":1}}],[\"innodb的默认隔离级别是read\",{\"1\":{\"178\":1}}],[\"innodb会根据事务的read\",{\"1\":{\"178\":1}}],[\"innodb使用undo日志来记录对数据行的修改\",{\"1\":{\"178\":1}}],[\"innerclass\",{\"1\":{\"418\":1}}],[\"inner02\",{\"1\":{\"418\":4}}],[\"inner01\",{\"1\":{\"418\":3}}],[\"inner\",{\"1\":{\"67\":1,\"418\":1}}],[\"injection\",{\"1\":{\"160\":1}}],[\"inverttree\",{\"1\":{\"667\":1}}],[\"inversion\",{\"1\":{\"158\":1}}],[\"invocationtargetexception\",{\"1\":{\"486\":1}}],[\"invocationhandler是一个接口\",{\"1\":{\"72\":1,\"159\":1}}],[\"invocationhandler\",{\"1\":{\"72\":2,\"159\":2,\"419\":4,\"492\":1,\"569\":3}}],[\"invoke\",{\"1\":{\"419\":2,\"486\":2,\"492\":1,\"569\":2}}],[\"invalid\",{\"1\":{\"3\":2}}],[\"in\",{\"1\":{\"55\":2,\"91\":1,\"160\":1,\"192\":1,\"256\":2,\"271\":6,\"298\":1,\"368\":1,\"430\":1,\"478\":2,\"491\":1,\"518\":1,\"531\":1,\"711\":1,\"718\":1,\"724\":1,\"727\":1,\"728\":1,\"729\":1,\"730\":1}}],[\"inside\",{\"1\":{\"668\":2}}],[\"inspect\",{\"1\":{\"615\":1}}],[\"instantiated\",{\"1\":{\"655\":1,\"674\":1}}],[\"instantiationexception\",{\"1\":{\"419\":1}}],[\"instantiation\",{\"1\":{\"160\":1}}],[\"instant\",{\"1\":{\"436\":3}}],[\"instant时间戳\",{\"1\":{\"436\":1}}],[\"instances\",{\"1\":{\"599\":1}}],[\"instanceof\",{\"1\":{\"307\":1,\"363\":2,\"367\":1,\"406\":1}}],[\"instance==null\",{\"1\":{\"292\":1}}],[\"instance2\",{\"1\":{\"99\":4,\"414\":3}}],[\"instance1\",{\"1\":{\"99\":4}}],[\"instance\",{\"1\":{\"63\":1,\"292\":4,\"327\":1,\"414\":3,\"498\":1,\"540\":1,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1}}],[\"install\",{\"1\":{\"49\":1,\"616\":1}}],[\"insertmoreemp\",{\"1\":{\"531\":2}}],[\"insert>\",{\"1\":{\"501\":2,\"520\":1,\"531\":1}}],[\"insertuser\",{\"1\":{\"500\":1,\"501\":3,\"502\":1,\"520\":1}}],[\"insert\",{\"1\":{\"5\":5,\"177\":1,\"395\":1,\"430\":2,\"501\":2,\"520\":1,\"531\":1,\"576\":1,\"577\":1,\"605\":2,\"674\":2,\"675\":2,\"721\":2}}],[\"ints\",{\"1\":{\"729\":4}}],[\"intvalue\",{\"1\":{\"406\":1,\"427\":1}}],[\"integration消息和事件驱动的解决方案的支持\",{\"1\":{\"81\":1}}],[\"integration\",{\"1\":{\"81\":1}}],[\"integer>\",{\"1\":{\"626\":1,\"631\":2,\"648\":4,\"649\":2,\"671\":2,\"672\":2,\"699\":2,\"720\":1,\"721\":2}}],[\"integer创建机制\",{\"1\":{\"428\":1}}],[\"integer类\",{\"0\":{\"428\":1}}],[\"integer中的equles方法\",{\"1\":{\"406\":1}}],[\"integercache\",{\"1\":{\"130\":2,\"428\":4}}],[\"integer\",{\"0\":{\"130\":2},\"1\":{\"46\":2,\"55\":5,\"102\":4,\"130\":9,\"232\":1,\"252\":1,\"360\":1,\"406\":3,\"424\":1,\"427\":10,\"428\":10,\"458\":2,\"501\":1,\"514\":1,\"515\":1,\"522\":3,\"524\":1,\"525\":2,\"531\":1,\"630\":4,\"648\":2,\"729\":1,\"730\":6}}],[\"internet\",{\"1\":{\"769\":1,\"777\":1}}],[\"intercept\",{\"1\":{\"492\":1,\"598\":1}}],[\"interceptorregistry\",{\"1\":{\"78\":1}}],[\"interrupt只是中断线程\",{\"1\":{\"468\":1}}],[\"interrupt\",{\"1\":{\"268\":1,\"468\":1}}],[\"interruptdemo\",{\"1\":{\"268\":3}}],[\"interruptedexception\",{\"1\":{\"232\":1,\"233\":2,\"248\":8,\"249\":1,\"256\":1,\"268\":3,\"271\":2,\"291\":1,\"298\":3,\"304\":2,\"313\":3,\"466\":7,\"467\":2,\"468\":5,\"469\":2,\"471\":1}}],[\"interger\",{\"1\":{\"130\":1}}],[\"interfaces\",{\"1\":{\"419\":2,\"569\":2}}],[\"interfacepolypass\",{\"1\":{\"417\":1}}],[\"interfacepolypara\",{\"1\":{\"417\":1}}],[\"interface01\",{\"1\":{\"417\":2}}],[\"interface\",{\"1\":{\"96\":1,\"108\":1,\"111\":1,\"114\":1,\"251\":4,\"330\":1,\"417\":6,\"418\":1,\"419\":2,\"456\":1,\"458\":3,\"490\":1,\"491\":1,\"500\":1,\"504\":1,\"511\":1,\"557\":1,\"569\":2,\"576\":1,\"577\":1,\"583\":1,\"606\":1}}],[\"interval\",{\"1\":{\"5\":1}}],[\"into\",{\"1\":{\"5\":5,\"501\":2,\"520\":1,\"531\":1,\"576\":1,\"577\":1,\"605\":2}}],[\"int\",{\"0\":{\"130\":1},\"1\":{\"3\":5,\"5\":6,\"44\":2,\"45\":3,\"46\":2,\"55\":18,\"91\":17,\"105\":3,\"114\":7,\"117\":3,\"130\":5,\"249\":1,\"262\":4,\"297\":1,\"300\":1,\"312\":6,\"313\":6,\"358\":3,\"359\":6,\"360\":2,\"362\":2,\"365\":1,\"366\":2,\"368\":1,\"372\":1,\"376\":3,\"377\":2,\"381\":16,\"382\":19,\"390\":3,\"391\":14,\"392\":3,\"399\":1,\"402\":2,\"403\":8,\"404\":14,\"411\":1,\"415\":2,\"417\":2,\"418\":1,\"424\":6,\"427\":4,\"428\":1,\"429\":2,\"430\":2,\"431\":3,\"433\":6,\"440\":2,\"443\":1,\"444\":1,\"445\":7,\"451\":1,\"452\":2,\"454\":2,\"466\":5,\"468\":3,\"469\":1,\"471\":1,\"477\":10,\"478\":1,\"485\":1,\"489\":2,\"491\":1,\"500\":1,\"501\":3,\"504\":2,\"531\":2,\"564\":1,\"569\":6,\"576\":1,\"577\":3,\"583\":4,\"605\":12,\"607\":1,\"620\":6,\"621\":11,\"622\":6,\"623\":11,\"624\":25,\"625\":11,\"626\":5,\"627\":7,\"628\":5,\"629\":12,\"630\":14,\"631\":5,\"632\":9,\"634\":4,\"635\":27,\"636\":3,\"637\":3,\"638\":4,\"639\":5,\"640\":2,\"642\":2,\"643\":8,\"645\":7,\"646\":3,\"647\":5,\"648\":5,\"649\":3,\"650\":7,\"652\":3,\"653\":8,\"655\":11,\"657\":3,\"658\":4,\"659\":1,\"660\":4,\"661\":10,\"662\":9,\"664\":3,\"666\":4,\"667\":3,\"668\":3,\"669\":7,\"671\":6,\"672\":8,\"674\":2,\"675\":5,\"677\":21,\"678\":17,\"683\":6,\"684\":3,\"685\":3,\"686\":11,\"687\":15,\"688\":5,\"689\":12,\"690\":4,\"693\":11,\"694\":6,\"695\":9,\"696\":10,\"697\":6,\"698\":12,\"699\":4,\"700\":11,\"701\":21,\"702\":6,\"704\":6,\"705\":5,\"706\":7,\"707\":10,\"708\":11,\"709\":52,\"711\":4,\"712\":4,\"713\":7,\"715\":7,\"716\":5,\"717\":11,\"718\":9,\"720\":14,\"721\":10,\"724\":6,\"727\":5,\"728\":6,\"729\":6,\"730\":14,\"734\":14,\"737\":7,\"740\":3,\"742\":1}}],[\"w+1\",{\"1\":{\"700\":1}}],[\"wt和val数组存的是第i个物品的重量和价值\",{\"1\":{\"700\":1}}],[\"wt\",{\"1\":{\"700\":4}}],[\"w\",{\"1\":{\"700\":9}}],[\"wxyz\",{\"1\":{\"684\":1}}],[\"wuchengen\",{\"1\":{\"439\":1,\"440\":1}}],[\"wrapperexercise02\",{\"1\":{\"428\":1}}],[\"wrapperexercise01\",{\"1\":{\"427\":1}}],[\"wrappertype\",{\"1\":{\"427\":2}}],[\"wrapper\",{\"1\":{\"427\":1}}],[\"writeobject\",{\"1\":{\"478\":1}}],[\"writeutf\",{\"1\":{\"478\":1}}],[\"writedouble\",{\"1\":{\"478\":1}}],[\"writechar\",{\"1\":{\"478\":1}}],[\"writeboolean\",{\"1\":{\"478\":1}}],[\"writebytes\",{\"1\":{\"477\":1}}],[\"writeint\",{\"1\":{\"478\":1}}],[\"writefile01\",{\"1\":{\"477\":1}}],[\"write\",{\"1\":{\"111\":1,\"180\":1,\"181\":1,\"477\":21,\"478\":4,\"479\":4,\"485\":1}}],[\"writer\",{\"1\":{\"111\":3,\"476\":1}}],[\"woo\",{\"1\":{\"402\":1,\"418\":1,\"454\":1}}],[\"working\",{\"1\":{\"576\":1}}],[\"work\",{\"1\":{\"417\":2}}],[\"workqueue\",{\"1\":{\"135\":1}}],[\"world\",{\"1\":{\"248\":3,\"351\":1,\"466\":3,\"477\":1,\"645\":2}}],[\"words\",{\"1\":{\"675\":3,\"705\":2}}],[\"word\",{\"1\":{\"674\":9,\"675\":6,\"705\":13}}],[\"word替换为指向锁记录的指针\",{\"1\":{\"139\":1}}],[\"word设置为指向当前线程的线程id\",{\"1\":{\"139\":1}}],[\"word是否为无锁状态\",{\"1\":{\"139\":1}}],[\"word字段为无锁状态\",{\"1\":{\"139\":1}}],[\"water\",{\"1\":{\"624\":1}}],[\"watcher机制\",{\"1\":{\"217\":1}}],[\"watch\",{\"1\":{\"202\":2}}],[\"wait队列\",{\"0\":{\"319\":1}}],[\"waitstatus\",{\"1\":{\"312\":4,\"318\":3}}],[\"wait\",{\"1\":{\"271\":1}}],[\"wait必须在同步代码块中使用\",{\"1\":{\"226\":1}}],[\"wait会释放锁\",{\"1\":{\"226\":1}}],[\"wait是object类的方法\",{\"1\":{\"226\":1}}],[\"wait和sleep方法的区别\",{\"0\":{\"226\":1}}],[\"waiting\",{\"1\":{\"225\":2,\"469\":3}}],[\"wal\",{\"1\":{\"180\":1}}],[\"warn\",{\"1\":{\"586\":2}}],[\"warning\",{\"1\":{\"117\":2}}],[\"war\",{\"1\":{\"82\":1}}],[\"will\",{\"1\":{\"655\":1,\"674\":1}}],[\"with\",{\"1\":{\"607\":1,\"645\":2}}],[\"withinitial\",{\"1\":{\"304\":1}}],[\"window\",{\"1\":{\"648\":5,\"649\":12,\"661\":5}}],[\"windows\",{\"1\":{\"98\":1,\"346\":1}}],[\"winter\",{\"1\":{\"421\":2}}],[\"width\",{\"1\":{\"105\":3,\"114\":3,\"630\":4,\"631\":4,\"709\":12}}],[\"while循环控制\",{\"0\":{\"374\":1,\"375\":1}}],[\"while\",{\"1\":{\"91\":1,\"111\":2,\"114\":1,\"268\":3,\"291\":1,\"298\":1,\"374\":1,\"375\":1,\"439\":1,\"443\":1,\"444\":1,\"448\":1,\"466\":5,\"467\":1,\"468\":3,\"469\":2,\"471\":1,\"477\":5,\"478\":3,\"485\":1,\"620\":1,\"621\":1,\"624\":1,\"625\":1,\"627\":6,\"630\":1,\"631\":1,\"632\":1,\"634\":1,\"636\":1,\"637\":1,\"638\":2,\"639\":4,\"640\":2,\"642\":1,\"643\":1,\"645\":6,\"647\":1,\"648\":1,\"649\":2,\"653\":2,\"655\":5,\"657\":1,\"658\":1,\"661\":1,\"662\":1,\"666\":2,\"669\":2,\"709\":4,\"711\":1,\"712\":1,\"713\":1,\"724\":1,\"727\":1,\"728\":1,\"729\":2,\"730\":2,\"734\":1,\"740\":1,\"742\":1}}],[\"whether\",{\"1\":{\"657\":1,\"658\":1}}],[\"where>\",{\"1\":{\"528\":1,\"530\":1}}],[\"where\",{\"0\":{\"528\":1},\"1\":{\"27\":1,\"184\":6,\"501\":3,\"504\":1,\"511\":2,\"512\":4,\"517\":3,\"518\":1,\"522\":2,\"523\":3,\"524\":1,\"525\":2,\"527\":1,\"528\":2,\"529\":1,\"531\":2,\"532\":1,\"577\":2,\"583\":3}}],[\"when>\",{\"1\":{\"530\":3}}],[\"whencomplete\",{\"1\":{\"249\":1}}],[\"when\",{\"0\":{\"530\":1},\"1\":{\"6\":2,\"70\":3,\"530\":1}}],[\"when用法\",{\"0\":{\"6\":1}}],[\"welcome\",{\"1\":{\"614\":1}}],[\"weight\",{\"1\":{\"607\":1}}],[\"weightedresponsetimerule\",{\"1\":{\"598\":2}}],[\"west\",{\"1\":{\"598\":1}}],[\"webflux\",{\"1\":{\"588\":2}}],[\"web工程下\",{\"1\":{\"339\":1}}],[\"webservlet\",{\"1\":{\"334\":2}}],[\"weblogic\",{\"1\":{\"324\":1}}],[\"web资源的分类\",{\"0\":{\"323\":1}}],[\"web服务进行soap风格的web服务的支持\",{\"1\":{\"81\":1}}],[\"web服务的支持\",{\"1\":{\"81\":2}}],[\"web服务的库\",{\"1\":{\"81\":1}}],[\"web启动器就能拥有web的功能\",{\"1\":{\"80\":1}}],[\"web启动器自动依赖其他组件\",{\"1\":{\"80\":1}}],[\"webmvcconfigureradapter\",{\"0\":{\"78\":1}}],[\"web\",{\"0\":{\"778\":1,\"787\":1},\"1\":{\"65\":1,\"81\":2,\"93\":1,\"168\":2,\"327\":2,\"545\":1,\"588\":1,\"778\":2,\"779\":1}}],[\"weak\",{\"1\":{\"2\":1,\"3\":3,\"536\":1}}],[\"w3\",{\"1\":{\"63\":1,\"327\":1,\"498\":1,\"540\":1,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1}}],[\"www\",{\"1\":{\"63\":4,\"111\":8,\"327\":1,\"482\":1,\"483\":1,\"498\":1,\"540\":1,\"552\":4,\"555\":4,\"557\":15,\"560\":14,\"561\":7,\"562\":17,\"563\":20,\"583\":13,\"607\":1,\"730\":1,\"760\":1}}],[\"ws\",{\"1\":{\"7\":2}}],[\"wp\",{\"1\":{\"3\":6}}],[\"所使用得语言\",{\"1\":{\"784\":1}}],[\"所有左子树和右子树自身必须也是二叉搜索树\",{\"1\":{\"730\":1}}],[\"所有可能路径\",{\"0\":{\"715\":1}}],[\"所有可能的分割方案\",{\"1\":{\"688\":1}}],[\"所有可能的全排列\",{\"1\":{\"685\":1}}],[\"所有位于边界的ｏ节点均与该虚拟节点相连接\",{\"1\":{\"709\":1}}],[\"所有子节点直接指向根节点\",{\"1\":{\"709\":2}}],[\"所有桶都被装满了\",{\"1\":{\"689\":1,\"701\":1}}],[\"所有长度为\",{\"1\":{\"650\":1}}],[\"所有字符的子串\",{\"1\":{\"648\":1}}],[\"所有字符的最小子串\",{\"1\":{\"648\":1}}],[\"所有元素\",{\"1\":{\"632\":1}}],[\"所有对象共享\",{\"1\":{\"411\":1}}],[\"所有阶段都用默认线程池\",{\"1\":{\"247\":1}}],[\"所有的java对象是天生携带monitor\",{\"1\":{\"260\":1}}],[\"所有的请求都会在\",{\"1\":{\"207\":1}}],[\"所有的依赖包都在一个jar包内\",{\"1\":{\"80\":1}}],[\"所有队列中的命令才会被执行\",{\"1\":{\"202\":1}}],[\"所有在await\",{\"1\":{\"144\":1}}],[\"所有父节点的值\",{\"1\":{\"90\":1}}],[\"所有依赖于它的对象都会得到通知被制动更新\",{\"1\":{\"73\":1}}],[\"所有引用reference的赋值操作\",{\"1\":{\"57\":1}}],[\"所有权\",{\"1\":{\"3\":2}}],[\"所以在传输大容量数据时\",{\"1\":{\"768\":1}}],[\"所以本体无法使用动态规划\",{\"1\":{\"739\":1}}],[\"所以本题依然可以使用0\",{\"1\":{\"701\":1}}],[\"所以结合⼆者的⻓处\",{\"1\":{\"720\":1}}],[\"所以赋false\",{\"1\":{\"701\":1}}],[\"所以赋true\",{\"1\":{\"701\":1}}],[\"所以可以不考虑第一次\",{\"1\":{\"698\":1}}],[\"所以最左一列和最上一行的dp数组值都为1\",{\"1\":{\"696\":1}}],[\"所以最多包含一个null\",{\"1\":{\"444\":1}}],[\"所以计算过程中保留一行的计算结果就行\",{\"1\":{\"687\":1}}],[\"所以这个和下面两个的操作只看queue1即可\",{\"1\":{\"657\":1}}],[\"所以用一个128位的数组来记录s中每个字符的出现次数\",{\"1\":{\"647\":1}}],[\"所以用两个指针指向数组两边\",{\"1\":{\"629\":1}}],[\"所以其长度为\",{\"1\":{\"647\":1}}],[\"所以使用数组来存储数据\",{\"1\":{\"721\":1}}],[\"所以使用stringbuilder\",{\"1\":{\"644\":1}}],[\"所以使用特殊值来表示共享模式可以节省一个字段\",{\"1\":{\"312\":1}}],[\"所以查找第\",{\"1\":{\"635\":1}}],[\"所以先排序再左右指针的方法不适用\",{\"1\":{\"626\":1}}],[\"所以第一次加载会耗费较长时间\",{\"1\":{\"598\":1}}],[\"所以第一个获取到资源的线程会将资源锁定起来\",{\"1\":{\"295\":1}}],[\"所以对于单例的对象\",{\"1\":{\"492\":1}}],[\"所以会出现舍入误差\",{\"1\":{\"492\":1}}],[\"所以会new一个类变量\",{\"1\":{\"428\":1}}],[\"所以我们需要用一个map来记录元素对应的索引\",{\"1\":{\"721\":1}}],[\"所以我们需要在读取nacos之前配置好nacos地址\",{\"1\":{\"602\":1}}],[\"所以我们可以直接调用\",{\"1\":{\"479\":1}}],[\"所以我们只需要一个简单的链表队列来保存正在等待条件的节点\",{\"1\":{\"312\":1}}],[\"所以要创建三个线程\",{\"1\":{\"466\":1,\"471\":1}}],[\"所以常用方法和collection接口一样\",{\"1\":{\"444\":1}}],[\"所以不在同一位置\",{\"1\":{\"429\":1}}],[\"所以不能复制给int类型\",{\"1\":{\"358\":1}}],[\"所以该方法的访问权限必须是public\",{\"1\":{\"412\":1}}],[\"所以改变内存\",{\"1\":{\"389\":1}}],[\"所以改变arr2的值\",{\"1\":{\"381\":1}}],[\"所以n1和1\",{\"1\":{\"359\":1}}],[\"所以兼容ascii码\",{\"1\":{\"356\":1}}],[\"所以输出一个斜杠需要打两个斜杆\",{\"1\":{\"353\":1}}],[\"所以把head的ws置为node\",{\"1\":{\"318\":2}}],[\"所以看到null的next字段并不一定意味着节点位于队列末尾\",{\"1\":{\"312\":1}}],[\"所以当前节点必须在释放或取消时唤醒其后继节点\",{\"1\":{\"312\":1}}],[\"所以效率更高\",{\"1\":{\"295\":1}}],[\"所以更新数据的时候不会对共享数据加锁\",{\"1\":{\"295\":1}}],[\"所以thread\",{\"1\":{\"267\":1}}],[\"所以刚释放的锁的线程在此刻再次获取同步状态的概率就非常大\",{\"1\":{\"262\":1}}],[\"所以引入了信道的概念\",{\"1\":{\"209\":1}}],[\"所以需要程序员自己来组合显示\",{\"1\":{\"436\":1}}],[\"所以需要额外指今\",{\"1\":{\"205\":1}}],[\"所以需要到一定阈值时再转换\",{\"1\":{\"124\":1}}],[\"所以说\",{\"1\":{\"201\":1}}],[\"所以\",{\"1\":{\"130\":1,\"187\":1,\"205\":1}}],[\"所以默认情况下\",{\"1\":{\"130\":1}}],[\"所以随机访问效率比arraylist低\",{\"1\":{\"122\":1}}],[\"所以builder的两个实现类\",{\"1\":{\"108\":1}}],[\"所以所有文件的处理必须通过唯一的实例来进行\",{\"1\":{\"98\":1}}],[\"所以每个人设计的对象结构都不尽相同\",{\"1\":{\"93\":1}}],[\"所以一定会执行一次\",{\"1\":{\"375\":1}}],[\"所以一般情况需要工程师根据业务需求开发handler\",{\"1\":{\"76\":1}}],[\"所以一旦一个shared\",{\"1\":{\"3\":1}}],[\"所以答案是\",{\"1\":{\"5\":1}}],[\"所指对象\",{\"1\":{\"3\":1}}],[\"与302的区别在于指明采用\",{\"1\":{\"775\":1}}],[\"与http关系密切的协议\",{\"0\":{\"751\":1}}],[\"与电话按键相同\",{\"1\":{\"684\":1}}],[\"与相遇处的指针同时运动\",{\"1\":{\"640\":1}}],[\"与前面的状态有什么关系\",{\"1\":{\"736\":1}}],[\"与前面的\",{\"1\":{\"628\":2}}],[\"与上面的过滤器的区别在于\",{\"1\":{\"607\":1}}],[\"与springboot有对应版本\",{\"1\":{\"595\":1}}],[\"与stringbuffer类类似\",{\"1\":{\"431\":1}}],[\"与其他持久层技术对比\",{\"0\":{\"496\":1}}],[\"与各自的线程相关联\",{\"1\":{\"303\":1}}],[\"与get\",{\"1\":{\"253\":1}}],[\"与thenapply\",{\"1\":{\"244\":1}}],[\"与集合类似\",{\"1\":{\"188\":1}}],[\"与聚簇索引不同\",{\"1\":{\"179\":1}}],[\"与标记\",{\"1\":{\"148\":1}}],[\"与通过对一个类进行实例化来构造新对象不同的是\",{\"1\":{\"116\":1}}],[\"与工厂模式的区别是\",{\"1\":{\"107\":1}}],[\"与单一职责原则冲突\",{\"1\":{\"98\":1}}],[\"与\",{\"0\":{\"778\":1},\"1\":{\"18\":1,\"364\":1,\"406\":1,\"496\":1,\"557\":1,\"588\":1,\"660\":1}}],[\"与unique\",{\"1\":{\"3\":1}}],[\"与所指对象的内存绑定紧密\",{\"1\":{\"3\":1}}],[\"同理id\",{\"1\":{\"709\":2}}],[\"同样是符合题意的答案\",{\"1\":{\"650\":1}}],[\"同样\",{\"1\":{\"399\":1}}],[\"同样形如其名\",{\"1\":{\"3\":1}}],[\"同包\",{\"1\":{\"397\":1}}],[\"同类\",{\"1\":{\"397\":1}}],[\"同break可以通过标签来指定跳过的循环\",{\"1\":{\"378\":1}}],[\"同上\",{\"1\":{\"364\":1}}],[\"同步代码块执行结束时释放锁\",{\"1\":{\"472\":1}}],[\"同步代码块\",{\"1\":{\"470\":1}}],[\"同步方法中执行了线程对象的wait\",{\"1\":{\"472\":1}}],[\"同步方法中出现了未处理的error或exception\",{\"1\":{\"472\":1}}],[\"同步方法中遇到break\",{\"1\":{\"472\":1}}],[\"同步方法\",{\"1\":{\"470\":1}}],[\"同步\",{\"1\":{\"292\":1}}],[\"同一款产品\",{\"1\":{\"255\":2}}],[\"同一时间最多只有一个凭证累加无效\",{\"1\":{\"271\":1}}],[\"同一时间\",{\"1\":{\"170\":1}}],[\"同一个网站可能存在多份相同内容的页面\",{\"1\":{\"771\":1}}],[\"同一个连通区域内的所有点的根节点是同一个\",{\"1\":{\"709\":1}}],[\"同一个单元格内的字母不允许被重复使用\",{\"1\":{\"705\":1}}],[\"同一个类中的方法可以直接调用\",{\"1\":{\"389\":1}}],[\"同一个锁\",{\"1\":{\"263\":1}}],[\"同一个服务可能部署在多台服务器上\",{\"1\":{\"216\":1}}],[\"同一个virtual\",{\"1\":{\"209\":1}}],[\"同一个\",{\"1\":{\"167\":1,\"534\":3}}],[\"同一堆分配对象的内存\",{\"1\":{\"3\":1}}],[\"同时记录遍历过的路径\",{\"1\":{\"715\":1}}],[\"同时向后移动cura和curb\",{\"1\":{\"639\":1}}],[\"同时题目还强调数组中无重复元素\",{\"1\":{\"620\":1}}],[\"同时其定义condition结构提供了wait\",{\"1\":{\"311\":1}}],[\"同时搜索出在同一个平台的所有卖家的售价\",{\"1\":{\"255\":1}}],[\"同时搜索出各个电商平台的售价\",{\"1\":{\"255\":1}}],[\"同时还会将从客户端收到的所有写命今缓存在内存中\",{\"1\":{\"204\":1}}],[\"同时在数据库中也不存在\",{\"1\":{\"197\":1}}],[\"同时对整个区域进行内存回收\",{\"1\":{\"148\":1}}],[\"同时阻塞该线程\",{\"1\":{\"141\":1,\"312\":1}}],[\"同时又能保证性能\",{\"1\":{\"116\":1}}],[\"同时也接收服务器返回的响应并转发给客户端\",{\"1\":{\"780\":1}}],[\"同时也增加了系统具体类的依赖\",{\"1\":{\"101\":1}}],[\"同时也会增加代码的复杂度\",{\"1\":{\"55\":1}}],[\"同时确保只有单个对象被创建\",{\"1\":{\"98\":1}}],[\"同时\",{\"1\":{\"82\":1,\"214\":2,\"492\":1,\"597\":1,\"698\":1}}],[\"拥有更高的填充度\",{\"1\":{\"172\":1}}],[\"拥有稳定的接口\",{\"1\":{\"116\":1}}],[\"拥有\",{\"1\":{\"3\":1}}],[\"窃取\",{\"1\":{\"3\":1}}],[\"而网关能使通信线路上的服务器提供非\",{\"1\":{\"780\":1}}],[\"而后判断是否有某个时间段的人数超过座位数\",{\"1\":{\"677\":1}}],[\"而后在浏览器访问\",{\"1\":{\"605\":1}}],[\"而globalfilter的逻辑需要自己写代码实现\",{\"1\":{\"607\":1}}],[\"而java是不允许多重继承的\",{\"1\":{\"492\":1}}],[\"而类中不具有而报错\",{\"1\":{\"461\":1}}],[\"而主线程中取到的却是null\",{\"1\":{\"304\":1}}],[\"而atomicreference则对应普通的对象引用\",{\"1\":{\"297\":1}}],[\"而aof日志记录的是内存数据修改的指令记录文本\",{\"1\":{\"189\":1}}],[\"而volatile关键字就可以禁止编译器对字节码进行重排序\",{\"1\":{\"292\":1}}],[\"而操作b又先行发生于操作c\",{\"1\":{\"284\":1}}],[\"而它们又共享同一个主内存\",{\"1\":{\"274\":1}}],[\"而高速缓存的读写速度与cpu的运算速度几乎相当\",{\"1\":{\"274\":1}}],[\"而每个java\",{\"1\":{\"260\":1}}],[\"而消息订阅者可以随时从指定的偏移量开始消费消息\",{\"1\":{\"213\":1}}],[\"而消息头则由一系列的可选属性组成\",{\"1\":{\"209\":1}}],[\"而当前只有\",{\"1\":{\"190\":1}}],[\"而执行命令依旧是单线程\",{\"1\":{\"187\":1}}],[\"而非叶子节点存储了索引键值及指向下一级节点的指针\",{\"1\":{\"179\":1}}],[\"而硬盘读取速度相对较慢\",{\"1\":{\"173\":1}}],[\"而无法拦截类内部方法之间的相互调用\",{\"1\":{\"166\":1}}],[\"而udp不提供这个保证\",{\"1\":{\"156\":1}}],[\"而udp则没有连接的概念\",{\"1\":{\"156\":1}}],[\"而udp是无连接的协议\",{\"1\":{\"156\":1}}],[\"而http不需要证书验证\",{\"1\":{\"154\":1}}],[\"而https默认使用443端口\",{\"1\":{\"154\":1}}],[\"而https通过使用ssl\",{\"1\":{\"154\":1}}],[\"而线程共享进程的资源\",{\"1\":{\"150\":1}}],[\"而release\",{\"1\":{\"144\":1}}],[\"而reentrantlock是显式锁\",{\"1\":{\"142\":1}}],[\"而completablefuture可以将多个异步任务进行复杂的组合\",{\"1\":{\"164\":1}}],[\"而countdown\",{\"1\":{\"144\":1}}],[\"而callable接口则通常与executorservice\",{\"1\":{\"133\":1}}],[\"而callable接口的call\",{\"1\":{\"133\":1}}],[\"而callable接口可以返回一个结果\",{\"1\":{\"133\":1}}],[\"而是从上次已经匹配的内容开始匹配\",{\"1\":{\"653\":1}}],[\"而是指针相等\",{\"1\":{\"639\":1}}],[\"而是需要实际的进行节点交换\",{\"1\":{\"637\":1}}],[\"而是把自己的需求告诉eureka\",{\"1\":{\"597\":1}}],[\"而是在获取对象时创建\",{\"1\":{\"559\":1}}],[\"而是在访问数据的时候\",{\"1\":{\"191\":1}}],[\"而是依赖于单独的实体\",{\"1\":{\"545\":1}}],[\"而是代表类型\",{\"1\":{\"456\":1}}],[\"而是被放到一个队列中\",{\"1\":{\"202\":1}}],[\"而是\",{\"1\":{\"187\":1}}],[\"而是存储了索引键及指向对应数据行的指针\",{\"1\":{\"179\":1}}],[\"而是继续访问自己工作内存中的变量副本\",{\"1\":{\"140\":1}}],[\"而是委托给其他的解析器进行处理\",{\"1\":{\"76\":1}}],[\"而linkedlist需要遍历链表才能找到指定位置的元素\",{\"1\":{\"122\":1}}],[\"而linkedlist在插入和删除元素时\",{\"1\":{\"122\":1}}],[\"而linkedlist是基于双向链表实现的\",{\"1\":{\"122\":1}}],[\"而对于没有接口的情况\",{\"1\":{\"492\":1}}],[\"而对于没有通过接口定义业务方法的类\",{\"1\":{\"72\":1}}],[\"而对于非拉丁字符\",{\"1\":{\"121\":1}}],[\"而其组合是经常变化的\",{\"1\":{\"107\":1}}],[\"而其组合经常变化的时候\",{\"1\":{\"107\":1}}],[\"而将一些步骤延迟到子类中\",{\"1\":{\"104\":1}}],[\"而不能保证代码块的原子性\",{\"1\":{\"299\":1}}],[\"而不能直接读写主内存中的数据\",{\"1\":{\"279\":1}}],[\"而不是\",{\"1\":{\"564\":1}}],[\"而不是从头开始复制一份\",{\"1\":{\"204\":1}}],[\"而不是每个独立的操作\",{\"1\":{\"181\":1}}],[\"而不是像传统的数据库系统一样先写日志文件再修改内存数据\",{\"1\":{\"181\":1}}],[\"而不是传统的加锁机制\",{\"1\":{\"125\":1}}],[\"而不包括\",{\"1\":{\"175\":2}}],[\"而不仅仅是所需的关键字\",{\"1\":{\"172\":1}}],[\"而不需要确保数据的完整性\",{\"1\":{\"156\":1}}],[\"而不需要到处找示例代\",{\"1\":{\"81\":1}}],[\"而不同进程之间的并发执行需要通过进程间通信进行数据交换\",{\"1\":{\"150\":1}}],[\"而不进行线程的阻塞和切换\",{\"1\":{\"143\":1}}],[\"而不会使用缓存中的旧值\",{\"1\":{\"128\":1}}],[\"而不用去管这辆汽车是怎么做出来的\",{\"1\":{\"101\":1}}],[\"而不关心外面怎么样来实例化\",{\"1\":{\"98\":1}}],[\"而且采用字节码增强技术\",{\"1\":{\"492\":1}}],[\"而且不显示调用\",{\"1\":{\"413\":1}}],[\"而且也不见得能及时地得到计算机资源\",{\"1\":{\"234\":1}}],[\"而且\",{\"1\":{\"195\":1}}],[\"而且在扩容时还要对红黑树重新的左旋右旋保持平衡\",{\"1\":{\"124\":1}}],[\"而且各个调用者可能都需要修改其值时\",{\"1\":{\"116\":1}}],[\"而且很多地方我们只能通过\",{\"1\":{\"70\":1}}],[\"而且一旦构造成功\",{\"1\":{\"3\":1}}],[\"而\",{\"1\":{\"69\":1,\"70\":1,\"93\":1,\"184\":1,\"628\":1}}],[\"而注解的实现方式则是使用各种注解\",{\"1\":{\"68\":1}}],[\"而在xml文件中定义bean虽然更加繁琐\",{\"1\":{\"62\":1}}],[\"而在xml文件中定义bean时\",{\"1\":{\"62\":2}}],[\"而在xml文件中\",{\"1\":{\"62\":1}}],[\"而解析xml文件\",{\"1\":{\"62\":1}}],[\"而bufferedreader只能够读取字符串类型的数据\",{\"1\":{\"55\":1}}],[\"而springcloudgateway是基于spring5中提供的webflux\",{\"1\":{\"607\":1}}],[\"而session的标识符\",{\"1\":{\"153\":1}}],[\"而session的生命周期与用户的会话相关\",{\"1\":{\"153\":1}}],[\"而session的存储容量相对较大\",{\"1\":{\"153\":1}}],[\"而session则将数据保存在服务器端的内存或者数据库中\",{\"1\":{\"153\":1}}],[\"而session保存在服务器端\",{\"1\":{\"153\":1}}],[\"而synchronized则相对简单\",{\"1\":{\"142\":1}}],[\"而scanner即可以基于字符流\",{\"1\":{\"55\":1}}],[\"而shared\",{\"1\":{\"3\":1}}],[\"而111\",{\"1\":{\"7\":1}}],[\"而使用weak\",{\"1\":{\"3\":1}}],[\"而从实现上讲\",{\"1\":{\"3\":1}}],[\"不对报文做任何处理加工\",{\"1\":{\"780\":1}}],[\"不对应任何字母\",{\"1\":{\"684\":1}}],[\"不进行编码\",{\"1\":{\"768\":1}}],[\"不包含重复值\",{\"1\":{\"716\":1}}],[\"不包含\",{\"1\":{\"716\":1}}],[\"不装这个数\",{\"1\":{\"701\":1}}],[\"不触动警报装置的情况下\",{\"1\":{\"697\":1}}],[\"不允许掉头或改变方向\",{\"1\":{\"677\":1}}],[\"不允许重复\",{\"1\":{\"451\":1}}],[\"不允许重复元素\",{\"1\":{\"444\":1}}],[\"不允许重复的元素\",{\"1\":{\"188\":1}}],[\"不减一\",{\"1\":{\"653\":1}}],[\"不匹配了\",{\"1\":{\"653\":1}}],[\"不匹配的时候\",{\"1\":{\"653\":1}}],[\"不考虑答案输出的顺序\",{\"1\":{\"649\":1}}],[\"不考虑隔离性产生很多问题\",{\"1\":{\"582\":1}}],[\"不支持连接池\",{\"1\":{\"606\":1}}],[\"不支持超时参数\",{\"1\":{\"205\":1}}],[\"不要求按特定顺序\",{\"1\":{\"715\":1}}],[\"不要访问其他微服务数据库\",{\"1\":{\"596\":1}}],[\"不要开发重复业务\",{\"1\":{\"596\":1}}],[\"不修改源代码\",{\"1\":{\"567\":1}}],[\"不加参数\",{\"1\":{\"564\":1}}],[\"不写属性有个默认值\",{\"1\":{\"559\":1}}],[\"不写index默认删除第一个节点\",{\"1\":{\"443\":1}}],[\"不提供开发人员进行使用\",{\"1\":{\"555\":1}}],[\"不提供这些特性\",{\"1\":{\"142\":1}}],[\"不成立则不拼接\",{\"1\":{\"528\":1}}],[\"不设置\",{\"1\":{\"501\":1}}],[\"不返回任何值\",{\"1\":{\"489\":1}}],[\"不适合多人开发\",{\"1\":{\"595\":1}}],[\"不适合传输大量数据\",{\"1\":{\"482\":1}}],[\"不适用于复合操作\",{\"1\":{\"138\":1}}],[\"不限于直接父类\",{\"1\":{\"460\":1}}],[\"不保证元素有序\",{\"1\":{\"445\":1}}],[\"不安全\",{\"1\":{\"442\":1}}],[\"不是在加载\",{\"1\":{\"559\":1}}],[\"不是泛型方法\",{\"1\":{\"459\":1}}],[\"不是通过数组\",{\"1\":{\"443\":1}}],[\"不是语法错误和逻辑错误\",{\"1\":{\"424\":1}}],[\"不是又给p2开辟了新的内存空间\",{\"1\":{\"388\":1}}],[\"不常用\",{\"1\":{\"421\":1}}],[\"不易维护\",{\"1\":{\"419\":1}}],[\"不断增加left指针缩小窗口范围\",{\"1\":{\"630\":1}}],[\"不断的递归\",{\"1\":{\"391\":1}}],[\"不断尝试获取锁\",{\"1\":{\"141\":1}}],[\"不管try代码块是否有异常\",{\"1\":{\"424\":1}}],[\"不管使用子类的哪个构造器\",{\"1\":{\"399\":1}}],[\"不管左边是否为真\",{\"1\":{\"364\":1}}],[\"不管是发布消息\",{\"1\":{\"209\":1}}],[\"不夸张地说\",{\"1\":{\"311\":1}}],[\"不同路径2\",{\"0\":{\"696\":1}}],[\"不同路径\",{\"0\":{\"695\":1}}],[\"不同命名空间内的服务\",{\"1\":{\"599\":1}}],[\"不同服务设备性能有差异\",{\"1\":{\"599\":1}}],[\"不同微服务\",{\"1\":{\"596\":1}}],[\"不同包\",{\"1\":{\"397\":1}}],[\"不同类的方法需要通过实例化对象来调用\",{\"1\":{\"389\":1}}],[\"不同平台有不同虚拟机\",{\"1\":{\"348\":1}}],[\"不同之处就在于atomicinteger是对整数的封装\",{\"1\":{\"297\":1}}],[\"不同线程之间也无法直接访问对方的工作内存中的变量\",{\"1\":{\"279\":1}}],[\"不同的\",{\"1\":{\"534\":1}}],[\"不同的接口要有不同的代理类实现\",{\"1\":{\"492\":1}}],[\"不同的事务之间彼此没有任何干扰\",{\"1\":{\"170\":1}}],[\"不同的线程可以同时访问不同的段\",{\"1\":{\"125\":1}}],[\"不按照申请锁的顺序获取锁\",{\"1\":{\"262\":1}}],[\"不想再从其他地方获取\",{\"1\":{\"189\":1}}],[\"不存在时\",{\"1\":{\"721\":1}}],[\"不存在平行边\",{\"1\":{\"716\":1}}],[\"不存在自环\",{\"1\":{\"716\":1}}],[\"不存在一个字典序更大的排列\",{\"1\":{\"628\":1}}],[\"不存在数据卷会自动创建\",{\"1\":{\"615\":1}}],[\"不存在加锁释放锁操作\",{\"1\":{\"186\":1}}],[\"不存在多线程导致的cpu切换\",{\"1\":{\"186\":1}}],[\"不用\",{\"1\":{\"547\":1}}],[\"不用每次变化字符串都更换地址\",{\"1\":{\"430\":1}}],[\"不用去考虑各种锁的问题\",{\"1\":{\"186\":1}}],[\"不用管里面具体怎么实现的\",{\"1\":{\"113\":1}}],[\"不可重复读和幻读的问题\",{\"1\":{\"171\":2}}],[\"不可重复读是指一个事务在读取了某个数据后\",{\"1\":{\"171\":1}}],[\"不可重复读\",{\"1\":{\"171\":1,\"582\":2}}],[\"不可能a扣了钱\",{\"1\":{\"170\":1}}],[\"不给予任何提示\",{\"1\":{\"134\":1}}],[\"不需要保存for循环计算的所有值\",{\"1\":{\"694\":1}}],[\"不需要删除即为新数组元素\",{\"1\":{\"623\":1}}],[\"不需要set方法\",{\"1\":{\"564\":2}}],[\"不需要参数\",{\"1\":{\"489\":1}}],[\"不需要声明参数类型\",{\"1\":{\"488\":1}}],[\"不需要握手连接\",{\"1\":{\"482\":1}}],[\"不需要建立连接\",{\"1\":{\"482\":1}}],[\"不需要对过期的数据做额外的处理\",{\"1\":{\"191\":1}}],[\"不需要在内部节点中进行遍历\",{\"1\":{\"172\":1}}],[\"不需要进行同步操作\",{\"1\":{\"139\":1}}],[\"不需要像arraylist那样进行大量的数据移动\",{\"1\":{\"122\":1}}],[\"不需要显式指定它们的类\",{\"1\":{\"110\":1}}],[\"不需要实例化该类的对象\",{\"1\":{\"98\":1}}],[\"不需要工程师开发\",{\"1\":{\"76\":3}}],[\"不会直接与数据源相连\",{\"1\":{\"478\":1}}],[\"不会释放锁\",{\"1\":{\"472\":1}}],[\"不会进入catch\",{\"1\":{\"424\":1}}],[\"不会调用\",{\"1\":{\"413\":1}}],[\"不会相互影响\",{\"1\":{\"391\":1}}],[\"不会导致数据不一致问题\",{\"1\":{\"296\":1}}],[\"不会导致运行时错误\",{\"1\":{\"3\":1}}],[\"不会因为外层已经获取的锁没有释放而阻塞\",{\"1\":{\"263\":1}}],[\"不会添加锁\",{\"1\":{\"258\":1}}],[\"不会报异常\",{\"1\":{\"253\":1}}],[\"不会过期\",{\"1\":{\"204\":1}}],[\"不会在自己本地落地磁盘了\",{\"1\":{\"204\":1}}],[\"不会对事务进行中断\",{\"1\":{\"201\":1}}],[\"不会被其他客户端发送来的命令请求所打断\",{\"1\":{\"201\":1}}],[\"不会\",{\"1\":{\"166\":1}}],[\"不会出现乱序的情况\",{\"1\":{\"156\":1}}],[\"不会自动merge\",{\"1\":{\"86\":1}}],[\"不过它仅仅在基于portlet\",{\"1\":{\"65\":1}}],[\"不能将节点分割成两个独立的子集\",{\"1\":{\"716\":1}}],[\"不能\",{\"1\":{\"686\":1}}],[\"不能重复\",{\"1\":{\"506\":1}}],[\"不能够重复使用\",{\"1\":{\"501\":1}}],[\"不能throws或catch泛型类的实例\",{\"1\":{\"461\":1}}],[\"不能直接用泛型定义类\",{\"1\":{\"458\":1}}],[\"不能是int\",{\"1\":{\"456\":1}}],[\"不能是变量\",{\"1\":{\"372\":1}}],[\"不能使用for加索引的方式来遍历\",{\"1\":{\"444\":1}}],[\"不能用\",{\"1\":{\"429\":1}}],[\"不能忽视\",{\"1\":{\"424\":1}}],[\"不能添加访问修饰符\",{\"1\":{\"418\":2}}],[\"不能修饰属性\",{\"1\":{\"416\":1}}],[\"不能在构造器中赋值\",{\"1\":{\"415\":1}}],[\"不能调用非静态成员\",{\"1\":{\"412\":1}}],[\"不能调用子类中的特有成员\",{\"1\":{\"402\":1}}],[\"不能完全一样\",{\"1\":{\"401\":1}}],[\"不能存在同一个构造器\",{\"1\":{\"399\":1}}],[\"不能写返回值\",{\"1\":{\"392\":1}}],[\"不能表示所有字符\",{\"1\":{\"356\":1}}],[\"不能保证代码块的原子性\",{\"1\":{\"299\":1}}],[\"不能保证原子性\",{\"1\":{\"128\":1}}],[\"不能有多个客户端创建同一个节点\",{\"1\":{\"217\":1}}],[\"不能被其他事务的操作所干扰\",{\"1\":{\"170\":1}}],[\"不能继承\",{\"1\":{\"98\":1,\"429\":1}}],[\"不能与其他unique\",{\"1\":{\"3\":1}}],[\"不能通过编译\",{\"1\":{\"3\":1}}],[\"mp\",{\"1\":{\"671\":6,\"672\":8}}],[\"mno\",{\"1\":{\"684\":1}}],[\"mn\",{\"1\":{\"614\":2,\"615\":1}}],[\"m02262204\",{\"1\":{\"551\":1}}],[\"mkdirs\",{\"1\":{\"475\":2}}],[\"mkdir\",{\"1\":{\"475\":1}}],[\"m1\",{\"1\":{\"471\":1,\"486\":2}}],[\"mm\",{\"1\":{\"436\":4,\"586\":1,\"607\":2}}],[\"m2\",{\"1\":{\"427\":1,\"471\":2,\"486\":2}}],[\"mq\",{\"1\":{\"207\":4}}],[\"mypow\",{\"1\":{\"742\":1}}],[\"mystack\",{\"1\":{\"657\":2,\"658\":2}}],[\"mysql2\",{\"1\":{\"480\":1}}],[\"mysql支持多种存储引擎\",{\"1\":{\"183\":1}}],[\"mysql支持事务的存储引擎\",{\"0\":{\"183\":1}}],[\"mysql怎么排查慢查询\",{\"0\":{\"182\":1}}],[\"mysql也可以使用重做日志来恢复数据\",{\"1\":{\"180\":1}}],[\"mysql使用了两个关键的日志文件\",{\"1\":{\"180\":1}}],[\"mysql的wal原则\",{\"0\":{\"180\":1}}],[\"mysql的默认隔离级别\",{\"0\":{\"171\":1}}],[\"mysql索引类型\",{\"0\":{\"179\":1}}],[\"mysql有哪些日志\",{\"0\":{\"177\":1}}],[\"mysql可能需要进行全表扫描来找到匹配的数据\",{\"1\":{\"173\":1}}],[\"mysql需要从硬盘读取数据\",{\"1\":{\"173\":1}}],[\"mysql行数多了为什么会变慢\",{\"0\":{\"173\":1},\"1\":{\"173\":1}}],[\"mysql\",{\"0\":{\"178\":1},\"1\":{\"171\":1,\"177\":2,\"207\":1,\"256\":2,\"300\":3,\"480\":1,\"499\":2,\"506\":2,\"507\":2,\"540\":2,\"562\":2,\"575\":2,\"583\":2,\"584\":2,\"605\":1,\"616\":1,\"617\":7}}],[\"mysql隔离级别\",{\"1\":{\"171\":1}}],[\"mysql数据库的索引结构为什么用b+树\",{\"0\":{\"172\":1},\"1\":{\"172\":1}}],[\"mysql数据库\",{\"0\":{\"169\":1}}],[\"mysql补完计划\",{\"0\":{\"4\":1}}],[\"myqueue\",{\"1\":{\"655\":7}}],[\"mylinkedlist\",{\"1\":{\"635\":4}}],[\"mybeanpost\",{\"1\":{\"560\":2}}],[\"mybatis3\",{\"1\":{\"541\":1}}],[\"mybatis3simple\",{\"1\":{\"540\":1}}],[\"mybatistest\",{\"1\":{\"502\":1}}],[\"mybatis<\",{\"1\":{\"498\":1,\"540\":1}}],[\"mybatis笔记\",{\"0\":{\"493\":1}}],[\"mybatis\",{\"0\":{\"494\":1,\"495\":1,\"497\":1,\"499\":1,\"503\":1,\"505\":2,\"510\":1,\"513\":1,\"516\":1,\"521\":1,\"533\":1,\"537\":1,\"539\":1},\"1\":{\"167\":1,\"168\":1,\"495\":1,\"496\":1,\"499\":5,\"501\":4,\"502\":1,\"504\":3,\"509\":1,\"510\":1,\"522\":1,\"524\":1,\"534\":1,\"540\":9}}],[\"mybatis的缓存机制\",{\"0\":{\"167\":1}}],[\"mydaemonthread\",{\"1\":{\"468\":3}}],[\"mydate\",{\"1\":{\"445\":6}}],[\"mymutex\",{\"1\":{\"313\":3}}],[\"mythread\",{\"1\":{\"232\":2,\"291\":4}}],[\"mytest\",{\"1\":{\"117\":1}}],[\"myrocks在mysql\",{\"1\":{\"183\":1}}],[\"myrocks是一个基于rocksdb引擎的存储引擎\",{\"1\":{\"183\":1}}],[\"myrocks\",{\"1\":{\"183\":1}}],[\"must\",{\"1\":{\"491\":1}}],[\"mustache\",{\"1\":{\"81\":1}}],[\"multipart\",{\"1\":{\"770\":1}}],[\"multipurpose\",{\"1\":{\"769\":1}}],[\"multiply\",{\"1\":{\"435\":1}}],[\"multilineinput\",{\"1\":{\"724\":1}}],[\"multivaluemap<string\",{\"1\":{\"607\":1}}],[\"multi\",{\"1\":{\"178\":1,\"202\":2}}],[\"multidisplay\",{\"1\":{\"114\":1}}],[\"mutex\",{\"1\":{\"139\":1,\"205\":1,\"313\":9}}],[\"mv\",{\"1\":{\"616\":1}}],[\"mvvm\",{\"1\":{\"93\":1}}],[\"mvcc机制在一定程度上避免了写操作之间的冲突\",{\"1\":{\"178\":1}}],[\"mvcc\",{\"0\":{\"178\":1},\"1\":{\"177\":1,\"178\":1}}],[\"mvc框架中的各个组件\",{\"1\":{\"162\":1}}],[\"mvc和rest\",{\"1\":{\"81\":1}}],[\"mvc中的控制器组件\",{\"1\":{\"69\":1}}],[\"mvc\",{\"1\":{\"61\":1}}],[\"method=\",{\"1\":{\"560\":4}}],[\"method=post\",{\"1\":{\"332\":2}}],[\"methodinterceptor\",{\"1\":{\"492\":1}}],[\"method01\",{\"1\":{\"486\":1}}],[\"method类的invoke方法允许你调用包装在当前method对象中的方法\",{\"1\":{\"486\":1}}],[\"method\",{\"1\":{\"419\":5,\"458\":1,\"475\":3,\"486\":2,\"569\":5,\"583\":1,\"607\":1}}],[\"meow\",{\"1\":{\"402\":1,\"418\":2}}],[\"message\",{\"1\":{\"117\":3,\"209\":1,\"213\":1,\"335\":1,\"490\":3,\"491\":3}}],[\"messagebox2\",{\"1\":{\"117\":2}}],[\"messagebox1\",{\"1\":{\"117\":2}}],[\"messagebox\",{\"1\":{\"117\":7}}],[\"mediator\",{\"1\":{\"93\":1}}],[\"memo\",{\"1\":{\"689\":4,\"701\":4,\"718\":1}}],[\"memory\",{\"0\":{\"275\":1},\"1\":{\"140\":2,\"146\":1}}],[\"memberwiseclone\",{\"1\":{\"116\":1}}],[\"mem\",{\"1\":{\"91\":3}}],[\"merge\",{\"1\":{\"86\":2}}],[\"mermaid\",{\"0\":{\"31\":1}}],[\"m\",{\"1\":{\"55\":6,\"89\":1,\"194\":1,\"391\":3,\"424\":1,\"427\":2,\"428\":2,\"470\":1,\"599\":1,\"695\":5,\"696\":7,\"702\":4,\"705\":1,\"706\":2,\"707\":2,\"708\":2,\"709\":5,\"734\":2}}],[\"msg\",{\"1\":{\"586\":1}}],[\"ms\",{\"1\":{\"40\":1}}],[\"movingcount\",{\"1\":{\"734\":1}}],[\"moved\",{\"1\":{\"775\":1}}],[\"move\",{\"1\":{\"3\":1}}],[\"mohoname\",{\"1\":{\"517\":3}}],[\"monotonicqueue\",{\"1\":{\"661\":3}}],[\"mono<void>\",{\"1\":{\"607\":1}}],[\"month\",{\"1\":{\"436\":4,\"445\":4}}],[\"monitor可以认为是一个同步对象\",{\"1\":{\"260\":1}}],[\"monitor\",{\"1\":{\"260\":4}}],[\"mongodb文档数据库的支持\",{\"1\":{\"81\":1}}],[\"mongodb\",{\"1\":{\"81\":1}}],[\"modified\",{\"1\":{\"775\":1}}],[\"modified`\",{\"1\":{\"605\":10}}],[\"modnum\",{\"1\":{\"718\":2}}],[\"module\",{\"1\":{\"208\":1}}],[\"mode\",{\"1\":{\"203\":2,\"209\":1,\"312\":2,\"617\":1}}],[\"modelversion>\",{\"1\":{\"498\":1,\"540\":1}}],[\"modelandview\",{\"1\":{\"161\":1}}],[\"model\",{\"0\":{\"275\":1},\"1\":{\"147\":1,\"409\":1}}],[\"more\",{\"1\":{\"39\":1}}],[\"mid\",{\"1\":{\"620\":6,\"621\":10}}],[\"misc\",{\"1\":{\"419\":1}}],[\"mister\",{\"1\":{\"27\":2}}],[\"mi1iseconds\",{\"1\":{\"205\":1}}],[\"mindepth\",{\"1\":{\"712\":1}}],[\"minimumlengthencoding\",{\"1\":{\"675\":1}}],[\"minaddtomakevalid\",{\"1\":{\"660\":1}}],[\"minlen\",{\"1\":{\"648\":5}}],[\"minwindow\",{\"1\":{\"648\":2}}],[\"minsubarraylen\",{\"1\":{\"630\":2}}],[\"minusone\",{\"1\":{\"713\":2}}],[\"minusminutes\",{\"1\":{\"436\":1}}],[\"minus\",{\"1\":{\"436\":1,\"648\":2}}],[\"minute\",{\"1\":{\"436\":2}}],[\"min\",{\"1\":{\"5\":3,\"46\":1,\"452\":1,\"461\":1,\"624\":4,\"625\":2,\"643\":1,\"730\":1}}],[\"mr\",{\"1\":{\"27\":1,\"35\":1}}],[\"md5\",{\"1\":{\"605\":3}}],[\"md\",{\"1\":{\"17\":1}}],[\"managed\",{\"1\":{\"506\":2}}],[\"management\",{\"1\":{\"466\":4}}],[\"manager\",{\"1\":{\"117\":8}}],[\"major\",{\"1\":{\"252\":1}}],[\"mac地址是网卡所属的固定地址\",{\"1\":{\"752\":1}}],[\"mac地址是设备出厂时就确定的\",{\"1\":{\"152\":1}}],[\"mac地址是用来标识网络设备的物理地址\",{\"1\":{\"152\":1}}],[\"matrix\",{\"1\":{\"727\":2,\"728\":2}}],[\"matches\",{\"1\":{\"702\":3}}],[\"mat\",{\"1\":{\"146\":1}}],[\"math类\",{\"0\":{\"432\":1}}],[\"math\",{\"1\":{\"91\":2,\"252\":1,\"557\":1,\"624\":8,\"625\":4,\"643\":1,\"647\":1,\"662\":1,\"693\":2,\"699\":3,\"700\":1,\"707\":1,\"718\":1,\"737\":2}}],[\"markoop\",{\"1\":{\"260\":1}}],[\"mark\",{\"1\":{\"114\":1,\"148\":1}}],[\"markdown\",{\"0\":{\"12\":1,\"13\":1,\"14\":1,\"15\":1},\"1\":{\"9\":1,\"12\":2,\"13\":3,\"14\":1,\"15\":3,\"16\":2,\"17\":1,\"18\":1,\"33\":1,\"40\":1,\"41\":2}}],[\"makerecently\",{\"1\":{\"720\":3}}],[\"makedir\",{\"1\":{\"475\":1}}],[\"makehtml\",{\"1\":{\"111\":7}}],[\"makeitems\",{\"1\":{\"108\":4}}],[\"makestring\",{\"1\":{\"108\":4}}],[\"maketitle\",{\"1\":{\"108\":4}}],[\"map记录前缀和出现的次数\",{\"1\":{\"671\":1}}],[\"map>\",{\"1\":{\"557\":1}}],[\"map类型注入\",{\"1\":{\"557\":1}}],[\"mapunderscoretocamelcase\",{\"1\":{\"522\":1}}],[\"map<treenode\",{\"1\":{\"699\":2}}],[\"map<long\",{\"1\":{\"672\":1}}],[\"map<character\",{\"1\":{\"648\":4}}],[\"map<string\",{\"1\":{\"514\":1}}],[\"map<integer\",{\"1\":{\"102\":2,\"626\":1,\"631\":1,\"671\":1,\"721\":1}}],[\"mapkey\",{\"0\":{\"514\":1},\"1\":{\"514\":1}}],[\"map接口实现类\",{\"0\":{\"449\":1,\"450\":1}}],[\"map接口和常用方法\",{\"0\":{\"448\":1}}],[\"map01\",{\"1\":{\"448\":1}}],[\"map中的key不能重复\",{\"1\":{\"448\":1}}],[\"map用于保存有映射关系的数据\",{\"1\":{\"448\":1}}],[\"mapping>\",{\"1\":{\"327\":2,\"339\":2}}],[\"mapper>\",{\"1\":{\"501\":1,\"504\":1,\"522\":1,\"523\":1,\"535\":1}}],[\"mapper\",{\"0\":{\"500\":1,\"501\":1},\"1\":{\"501\":6,\"504\":4,\"509\":3,\"522\":1,\"523\":2,\"524\":6,\"530\":2,\"535\":1,\"540\":2}}],[\"mappers>\",{\"1\":{\"499\":1,\"509\":1}}],[\"mappers\",{\"0\":{\"509\":1},\"1\":{\"499\":1,\"509\":2}}],[\"mapperscanner注解的类\",{\"1\":{\"83\":1}}],[\"mapperscanner\",{\"1\":{\"83\":1}}],[\"mapper注解\",{\"1\":{\"83\":1}}],[\"map\",{\"1\":{\"102\":1,\"256\":3,\"306\":3,\"307\":6,\"445\":1,\"448\":10,\"451\":1,\"492\":1,\"512\":5,\"514\":1,\"515\":1,\"648\":9,\"649\":10}}],[\"master在内存中直接创建rdb\",{\"1\":{\"204\":1}}],[\"master和slave都会保存一个replica\",{\"1\":{\"204\":1}}],[\"master如果发现有多人\",{\"1\":{\"204\":1}}],[\"master会启动一个后台线程\",{\"1\":{\"204\":1}}],[\"master分支的差别\",{\"1\":{\"86\":1}}],[\"master分支上\",{\"1\":{\"86\":1}}],[\"master\",{\"1\":{\"86\":5,\"203\":6,\"204\":8}}],[\"maven\",{\"0\":{\"498\":1},\"1\":{\"82\":2,\"498\":8,\"540\":10,\"588\":1}}],[\"mail\",{\"1\":{\"81\":1,\"769\":1}}],[\"main函数\",{\"1\":{\"428\":1}}],[\"main方法与一般static方法相同\",{\"1\":{\"412\":1}}],[\"main线程\",{\"1\":{\"223\":1,\"249\":1}}],[\"main\",{\"1\":{\"3\":2,\"55\":2,\"91\":2,\"96\":2,\"99\":2,\"102\":1,\"105\":2,\"108\":2,\"111\":2,\"232\":1,\"233\":1,\"249\":1,\"252\":1,\"253\":1,\"256\":1,\"262\":1,\"263\":1,\"268\":3,\"271\":3,\"291\":2,\"300\":1,\"304\":2,\"313\":1,\"351\":2,\"352\":2,\"354\":1,\"368\":1,\"376\":1,\"377\":1,\"381\":3,\"382\":3,\"390\":1,\"391\":3,\"399\":1,\"402\":3,\"403\":1,\"404\":1,\"411\":1,\"412\":1,\"413\":2,\"414\":2,\"415\":1,\"416\":1,\"417\":4,\"418\":1,\"419\":2,\"421\":1,\"427\":3,\"428\":1,\"429\":1,\"430\":2,\"431\":1,\"433\":1,\"436\":3,\"439\":1,\"440\":2,\"443\":1,\"444\":1,\"445\":1,\"448\":1,\"451\":1,\"454\":2,\"457\":1,\"466\":4,\"467\":1,\"468\":2,\"469\":1,\"471\":2,\"477\":1,\"478\":1,\"480\":1,\"483\":1,\"485\":2,\"486\":1,\"491\":1,\"540\":3,\"569\":1,\"586\":1,\"648\":1,\"677\":1,\"718\":2,\"724\":1,\"729\":1,\"730\":1}}],[\"maxdepth\",{\"1\":{\"669\":1,\"718\":6}}],[\"maxsubarray\",{\"1\":{\"693\":2}}],[\"maxsize\",{\"1\":{\"662\":4}}],[\"maxslidingwindow\",{\"1\":{\"661\":1}}],[\"maxlen\",{\"1\":{\"650\":4}}],[\"maxareaofisland\",{\"1\":{\"707\":1}}],[\"maxarea\",{\"1\":{\"625\":2}}],[\"maxage\",{\"1\":{\"607\":1}}],[\"maximumpoolsize\",{\"1\":{\"135\":1}}],[\"maxtime\",{\"1\":{\"91\":4}}],[\"max\",{\"1\":{\"46\":1,\"91\":1,\"452\":1,\"606\":2,\"624\":42,\"625\":2,\"630\":4,\"647\":1,\"648\":2,\"661\":2,\"662\":1,\"693\":12,\"697\":1,\"699\":3,\"700\":1,\"707\":1,\"718\":1,\"737\":2,\"739\":1}}],[\"=sc\",{\"1\":{\"724\":2}}],[\"=0\",{\"1\":{\"685\":1}}],[\"=true\",{\"1\":{\"650\":1}}],[\"=virtulhead\",{\"1\":{\"637\":1}}],[\"=nums\",{\"1\":{\"629\":1}}],[\"=12\",{\"1\":{\"445\":1}}],[\"=3\",{\"1\":{\"430\":1}}],[\"=等\",{\"1\":{\"365\":1}}],[\"==>\",{\"1\":{\"524\":2}}],[\"=========================================================\",{\"1\":{\"108\":2}}],[\"==\",{\"1\":{\"91\":4,\"99\":1,\"249\":1,\"292\":1,\"312\":2,\"318\":4,\"339\":1,\"363\":1,\"367\":1,\"377\":1,\"382\":2,\"391\":3,\"406\":5,\"414\":1,\"428\":3,\"429\":3,\"445\":2,\"466\":4,\"468\":1,\"477\":1,\"479\":1,\"492\":3,\"621\":2,\"622\":1,\"623\":1,\"624\":4,\"625\":2,\"627\":6,\"628\":2,\"630\":2,\"631\":1,\"634\":2,\"635\":1,\"637\":1,\"638\":1,\"639\":2,\"640\":1,\"642\":2,\"645\":2,\"648\":4,\"649\":3,\"650\":1,\"652\":1,\"653\":4,\"659\":3,\"660\":2,\"661\":1,\"662\":2,\"667\":2,\"668\":4,\"669\":1,\"672\":1,\"674\":6,\"675\":1,\"683\":1,\"684\":1,\"685\":2,\"686\":1,\"687\":2,\"688\":1,\"689\":3,\"690\":2,\"695\":4,\"696\":5,\"697\":1,\"698\":2,\"699\":1,\"701\":3,\"702\":4,\"705\":1,\"706\":2,\"707\":2,\"708\":2,\"709\":20,\"712\":3,\"713\":2,\"715\":2,\"716\":1,\"718\":1,\"729\":1,\"730\":2,\"734\":1,\"740\":2,\"742\":2}}],[\"=\",{\"1\":{\"3\":7,\"5\":1,\"18\":1,\"32\":1,\"44\":1,\"45\":1,\"46\":1,\"55\":22,\"63\":3,\"90\":1,\"91\":20,\"96\":2,\"99\":3,\"102\":9,\"105\":7,\"108\":4,\"111\":32,\"114\":14,\"117\":11,\"124\":1,\"176\":2,\"220\":3,\"232\":1,\"233\":1,\"247\":1,\"248\":5,\"249\":2,\"252\":2,\"253\":1,\"256\":5,\"262\":6,\"263\":1,\"268\":10,\"271\":4,\"291\":2,\"292\":1,\"297\":3,\"298\":4,\"300\":4,\"304\":5,\"306\":4,\"307\":10,\"308\":1,\"312\":11,\"313\":1,\"318\":2,\"334\":8,\"339\":3,\"350\":2,\"358\":11,\"359\":12,\"360\":4,\"362\":5,\"363\":1,\"365\":10,\"366\":4,\"367\":5,\"368\":4,\"369\":2,\"376\":4,\"377\":3,\"381\":17,\"382\":20,\"386\":2,\"387\":2,\"388\":2,\"390\":6,\"391\":4,\"392\":4,\"399\":6,\"402\":9,\"403\":3,\"404\":14,\"411\":4,\"413\":1,\"414\":10,\"415\":2,\"416\":4,\"417\":7,\"418\":8,\"419\":10,\"421\":7,\"424\":10,\"427\":10,\"428\":6,\"429\":9,\"430\":16,\"431\":15,\"433\":8,\"436\":17,\"439\":7,\"440\":16,\"443\":14,\"444\":15,\"445\":10,\"448\":5,\"451\":2,\"454\":4,\"456\":3,\"457\":3,\"460\":4,\"461\":3,\"466\":15,\"467\":3,\"468\":6,\"469\":3,\"471\":8,\"475\":7,\"477\":47,\"478\":38,\"479\":4,\"480\":5,\"483\":5,\"485\":10,\"486\":14,\"490\":1,\"491\":5,\"492\":1,\"502\":5,\"504\":1,\"511\":2,\"512\":12,\"519\":1,\"522\":2,\"523\":5,\"524\":5,\"525\":4,\"527\":10,\"528\":10,\"529\":10,\"530\":8,\"531\":1,\"532\":10,\"552\":2,\"555\":3,\"557\":7,\"559\":3,\"560\":3,\"563\":1,\"564\":6,\"565\":3,\"569\":5,\"572\":5,\"576\":7,\"577\":5,\"583\":10,\"584\":6,\"586\":1,\"597\":3,\"598\":4,\"603\":1,\"605\":14,\"606\":6,\"607\":3,\"620\":5,\"621\":7,\"622\":6,\"623\":8,\"624\":29,\"625\":10,\"626\":2,\"627\":8,\"628\":11,\"629\":11,\"630\":18,\"631\":11,\"632\":14,\"634\":16,\"635\":37,\"636\":11,\"637\":13,\"638\":13,\"639\":23,\"640\":12,\"642\":5,\"643\":11,\"644\":2,\"645\":20,\"646\":4,\"647\":7,\"648\":12,\"649\":8,\"650\":19,\"651\":4,\"652\":6,\"653\":11,\"655\":11,\"657\":5,\"658\":2,\"659\":11,\"660\":8,\"661\":9,\"662\":11,\"664\":12,\"666\":13,\"667\":13,\"668\":12,\"669\":12,\"671\":5,\"672\":7,\"674\":18,\"675\":11,\"677\":19,\"678\":16,\"683\":3,\"684\":7,\"685\":2,\"686\":10,\"687\":17,\"688\":8,\"689\":10,\"690\":6,\"693\":13,\"694\":11,\"695\":16,\"696\":12,\"697\":12,\"698\":13,\"699\":6,\"700\":12,\"701\":22,\"702\":11,\"704\":2,\"705\":7,\"706\":7,\"707\":7,\"708\":9,\"709\":53,\"711\":4,\"712\":7,\"713\":15,\"715\":4,\"716\":8,\"717\":17,\"718\":15,\"720\":5,\"721\":7,\"727\":5,\"728\":6,\"729\":24,\"730\":35,\"734\":5,\"737\":7,\"740\":4,\"742\":7}}],[\"n=sc\",{\"1\":{\"724\":1}}],[\"n之内\",{\"1\":{\"718\":1}}],[\"n皇后\",{\"1\":{\"681\":1}}],[\"n个数按一定规则全排列\",{\"1\":{\"681\":1}}],[\"n个数里面按一定规则找出k个数的集合\",{\"1\":{\"681\":1}}],[\"n个数的和问题通用解法\",{\"1\":{\"627\":1}}],[\"n+1\",{\"1\":{\"638\":1,\"700\":1}}],[\"n^2\",{\"1\":{\"632\":1}}],[\"nginx\",{\"1\":{\"605\":1,\"614\":3,\"615\":3}}],[\"nginx反向代理\",{\"1\":{\"605\":1}}],[\"nfloadbalancerruleclassname\",{\"1\":{\"598\":7,\"599\":1}}],[\"nfloadbalanceruleclassname\",{\"1\":{\"598\":1}}],[\"nickname\",{\"1\":{\"501\":1,\"520\":1}}],[\"nil\",{\"1\":{\"202\":1}}],[\"n2\",{\"1\":{\"358\":2,\"359\":7,\"365\":5,\"427\":2}}],[\"n1\",{\"1\":{\"358\":1,\"359\":5,\"360\":3,\"418\":3}}],[\"ns\",{\"1\":{\"327\":3}}],[\"nacos即可\",{\"1\":{\"605\":1}}],[\"nacos3\",{\"1\":{\"605\":2}}],[\"nacos2\",{\"1\":{\"605\":2}}],[\"nacos1\",{\"1\":{\"605\":2}}],[\"nacos的配置管理依赖\",{\"1\":{\"602\":1}}],[\"nacos提供的方法\",{\"1\":{\"602\":1}}],[\"nacos配置管理客户端的配置\",{\"1\":{\"602\":1}}],[\"nacos配置管理\",{\"0\":{\"601\":1}}],[\"nacos集群默认采用ap方式\",{\"1\":{\"600\":1}}],[\"nacos支持服务列表变更的消息推送模式\",{\"1\":{\"600\":1}}],[\"nacos支持服务端主动监测提供者的状态\",{\"1\":{\"600\":1}}],[\"nacos会主动询问是否健康\",{\"1\":{\"600\":1}}],[\"nacos和eureka的区别\",{\"1\":{\"600\":1}}],[\"nacos和eureka的共同点\",{\"1\":{\"600\":1}}],[\"nacos服务地址\",{\"1\":{\"599\":1}}],[\"nacos服务分级存储模型\",{\"1\":{\"599\":1}}],[\"nacos中服务存储和数据存储的最外层是一个名为namespace的东西\",{\"1\":{\"599\":1}}],[\"nacos中的服务id\",{\"1\":{\"598\":6}}],[\"nacos环境隔离\",{\"1\":{\"599\":1}}],[\"nacos控制台可以设置权重\",{\"1\":{\"599\":1}}],[\"nacosrule\",{\"1\":{\"599\":1}}],[\"nacos地址\",{\"1\":{\"599\":1,\"602\":1,\"605\":1,\"607\":1}}],[\"nacos客户端依赖包\",{\"1\":{\"599\":1}}],[\"nacos\",{\"0\":{\"599\":1},\"1\":{\"595\":2,\"598\":8,\"599\":5,\"602\":2,\"605\":14,\"607\":2,\"617\":3}}],[\"navigatepagenums=\",{\"1\":{\"542\":1}}],[\"navigatepages=5\",{\"1\":{\"542\":1}}],[\"navigatelastpage=5\",{\"1\":{\"542\":1}}],[\"navigatefirstpage=1\",{\"1\":{\"542\":1}}],[\"nancy\",{\"1\":{\"404\":1}}],[\"native\",{\"1\":{\"220\":1,\"223\":1,\"479\":1,\"551\":1}}],[\"native关键字表示这是一个本地方法\",{\"1\":{\"220\":1}}],[\"name`\",{\"1\":{\"605\":8}}],[\"name参数\",{\"1\":{\"564\":1}}],[\"name成员\",{\"1\":{\"486\":1}}],[\"name从长到短排序\",{\"1\":{\"433\":1}}],[\"name>adminfilter<\",{\"1\":{\"339\":2}}],[\"name>helloservlet<\",{\"1\":{\"327\":2}}],[\"name>password<\",{\"1\":{\"327\":1}}],[\"name>\",{\"1\":{\"327\":5,\"339\":2}}],[\"name>username<\",{\"1\":{\"327\":2}}],[\"name=ueno\",{\"1\":{\"760\":1}}],[\"name=\",{\"1\":{\"67\":3,\"439\":1,\"440\":1,\"454\":1,\"478\":1,\"499\":4,\"506\":4,\"508\":1,\"509\":1,\"522\":1,\"524\":2,\"540\":4,\"557\":27,\"560\":2,\"561\":1,\"562\":8,\"575\":5,\"583\":7,\"586\":1}}],[\"name\",{\"1\":{\"5\":1,\"67\":1,\"117\":2,\"252\":1,\"297\":1,\"300\":1,\"334\":2,\"341\":1,\"368\":3,\"390\":6,\"392\":7,\"399\":4,\"404\":14,\"411\":5,\"414\":12,\"418\":4,\"421\":5,\"424\":4,\"425\":1,\"430\":2,\"433\":4,\"439\":5,\"440\":9,\"445\":7,\"454\":5,\"458\":1,\"470\":1,\"478\":6,\"486\":9,\"522\":2,\"523\":6,\"524\":1,\"525\":4,\"527\":3,\"528\":1,\"529\":1,\"530\":1,\"532\":2,\"557\":20,\"564\":2,\"599\":2,\"602\":2,\"603\":1,\"604\":3,\"605\":6,\"607\":1,\"614\":2,\"615\":1}}],[\"namespace=\",{\"1\":{\"501\":1,\"504\":1,\"522\":1,\"523\":1,\"535\":1}}],[\"namespace\",{\"1\":{\"3\":2,\"501\":1,\"599\":2}}],[\"nx|xx\",{\"1\":{\"205\":1}}],[\"ndb\",{\"1\":{\"183\":2}}],[\"nosuchmethodexception\",{\"1\":{\"486\":1}}],[\"nowjava\",{\"1\":{\"551\":1}}],[\"now2\",{\"1\":{\"436\":1}}],[\"now\",{\"1\":{\"436\":7,\"603\":3}}],[\"noargsconstructor\",{\"1\":{\"252\":2,\"256\":1}}],[\"node采用nextwaiter组成单向链表\",{\"1\":{\"319\":1}}],[\"node仅仅会复制给slave\",{\"1\":{\"204\":1}}],[\"node\",{\"1\":{\"204\":10,\"312\":13,\"609\":1,\"664\":19,\"666\":1,\"667\":12,\"668\":1,\"669\":4,\"672\":6,\"674\":12,\"699\":14,\"711\":4,\"730\":15}}],[\"node的时候\",{\"1\":{\"204\":1}}],[\"nodes\",{\"1\":{\"190\":1}}],[\"no\",{\"1\":{\"192\":1,\"400\":1,\"599\":1,\"774\":1}}],[\"none\",{\"1\":{\"408\":2}}],[\"non\",{\"1\":{\"171\":1,\"179\":1}}],[\"notisland\",{\"1\":{\"709\":9}}],[\"notion\",{\"1\":{\"598\":1}}],[\"notify\",{\"1\":{\"271\":1}}],[\"note\",{\"1\":{\"477\":1}}],[\"notfound\",{\"1\":{\"155\":1}}],[\"not\",{\"1\":{\"5\":1,\"598\":1,\"605\":68,\"711\":2,\"775\":1,\"776\":1}}],[\"numcourses\",{\"1\":{\"717\":12}}],[\"numislands\",{\"1\":{\"706\":1}}],[\"numpassengersi\",{\"1\":{\"677\":2}}],[\"num=1\",{\"1\":{\"605\":1}}],[\"numberformatexception数字格式不正确异常\",{\"1\":{\"424\":1}}],[\"num\",{\"1\":{\"381\":2,\"391\":10,\"415\":3,\"416\":2,\"424\":1,\"491\":4,\"689\":2,\"701\":4}}],[\"num4\",{\"1\":{\"358\":1}}],[\"num3\",{\"1\":{\"358\":1}}],[\"num2\",{\"1\":{\"358\":1,\"424\":2}}],[\"num1\",{\"1\":{\"358\":2,\"424\":2}}],[\"nums=new\",{\"1\":{\"724\":1}}],[\"nums\",{\"1\":{\"55\":10,\"391\":2,\"620\":4,\"621\":5,\"623\":10,\"626\":5,\"627\":19,\"628\":21,\"629\":19,\"630\":11,\"661\":7,\"671\":3,\"677\":9,\"678\":7,\"685\":10,\"686\":17,\"687\":25,\"689\":17,\"693\":13,\"697\":12,\"698\":17,\"701\":23,\"718\":6,\"721\":12,\"724\":2}}],[\"null><\",{\"1\":{\"557\":1}}],[\"nullpointerexception空指针异常\",{\"1\":{\"424\":1}}],[\"nullpointerexception\",{\"1\":{\"312\":2,\"424\":1}}],[\"nullptr\",{\"1\":{\"3\":1}}],[\"null\",{\"1\":{\"111\":1,\"114\":3,\"117\":1,\"191\":1,\"249\":2,\"292\":1,\"298\":2,\"304\":1,\"306\":1,\"307\":4,\"308\":1,\"312\":2,\"318\":4,\"339\":1,\"414\":1,\"424\":1,\"445\":1,\"458\":2,\"477\":13,\"478\":15,\"479\":3,\"480\":1,\"520\":1,\"527\":3,\"528\":3,\"529\":3,\"530\":2,\"531\":1,\"532\":3,\"542\":8,\"598\":3,\"605\":91,\"621\":1,\"626\":1,\"634\":2,\"635\":1,\"636\":2,\"637\":3,\"638\":3,\"639\":6,\"640\":5,\"664\":7,\"666\":3,\"667\":5,\"668\":9,\"669\":6,\"672\":1,\"674\":6,\"675\":1,\"688\":1,\"699\":1,\"712\":5,\"720\":5,\"729\":3,\"730\":6}}],[\"need++\",{\"1\":{\"660\":1}}],[\"needlearr\",{\"1\":{\"652\":4}}],[\"needle\",{\"1\":{\"651\":6,\"652\":2,\"653\":8}}],[\"need\",{\"1\":{\"626\":4,\"648\":7,\"660\":5}}],[\"neo4j图形数据库的支持\",{\"1\":{\"81\":1}}],[\"neo4j\",{\"1\":{\"81\":1}}],[\"nextmod\",{\"1\":{\"718\":4}}],[\"next数组\",{\"1\":{\"653\":1}}],[\"next=tail\",{\"1\":{\"635\":1}}],[\"next的错误\",{\"1\":{\"635\":1}}],[\"nextpermutation\",{\"1\":{\"628\":1}}],[\"nextpage=2\",{\"1\":{\"542\":1}}],[\"next指向后一个节点\",{\"1\":{\"443\":1}}],[\"nextwaiter\",{\"1\":{\"312\":3}}],[\"nextdouble\",{\"1\":{\"256\":1,\"368\":1}}],[\"next\",{\"1\":{\"111\":2,\"312\":1,\"368\":2,\"430\":2,\"439\":2,\"443\":5,\"444\":3,\"448\":1,\"634\":8,\"635\":24,\"636\":6,\"637\":23,\"638\":12,\"639\":7,\"640\":8,\"653\":7,\"709\":6,\"720\":1,\"729\":14}}],[\"nextline\",{\"1\":{\"55\":2,\"727\":1,\"728\":1}}],[\"nextint\",{\"1\":{\"55\":1,\"91\":3,\"114\":1,\"249\":1,\"368\":1,\"718\":3,\"721\":1,\"724\":5,\"727\":2,\"728\":3}}],[\"network\",{\"0\":{\"793\":1}}],[\"netflix\",{\"1\":{\"597\":1,\"598\":8}}],[\"netstat\",{\"1\":{\"485\":1}}],[\"netstat指令\",{\"1\":{\"485\":1}}],[\"net包下提供了一系列的类或接口\",{\"1\":{\"482\":1}}],[\"netmallname\",{\"1\":{\"256\":1}}],[\"netmall\",{\"1\":{\"256\":11}}],[\"netmalls\",{\"1\":{\"256\":7}}],[\"net\",{\"1\":{\"49\":1,\"116\":1,\"396\":1}}],[\"newheights\",{\"1\":{\"662\":5}}],[\"newnode\",{\"1\":{\"635\":5}}],[\"newline\",{\"1\":{\"478\":3}}],[\"news3\",{\"1\":{\"475\":1}}],[\"news2\",{\"1\":{\"475\":1}}],[\"news1\",{\"1\":{\"475\":2}}],[\"newval\",{\"1\":{\"452\":1}}],[\"newarr\",{\"1\":{\"433\":1}}],[\"newproxyinstance\",{\"1\":{\"419\":1,\"569\":2}}],[\"newcondition\",{\"1\":{\"271\":1}}],[\"newfixedthreadpool\",{\"1\":{\"249\":1,\"268\":2}}],[\"newinstance\",{\"1\":{\"63\":1,\"111\":1,\"555\":1}}],[\"new\",{\"1\":{\"3\":3,\"44\":1,\"45\":2,\"46\":1,\"55\":7,\"63\":1,\"70\":4,\"91\":6,\"96\":1,\"99\":1,\"102\":3,\"105\":2,\"108\":4,\"111\":8,\"114\":3,\"116\":1,\"117\":4,\"130\":2,\"220\":1,\"225\":1,\"232\":3,\"233\":2,\"247\":1,\"252\":1,\"256\":4,\"262\":5,\"263\":2,\"268\":3,\"271\":8,\"291\":1,\"292\":1,\"297\":3,\"298\":4,\"300\":3,\"304\":2,\"306\":1,\"312\":2,\"313\":3,\"368\":1,\"381\":4,\"382\":5,\"387\":2,\"388\":1,\"390\":2,\"391\":3,\"399\":1,\"402\":5,\"403\":1,\"404\":6,\"411\":2,\"413\":2,\"414\":2,\"416\":1,\"417\":7,\"418\":4,\"419\":8,\"421\":4,\"424\":2,\"427\":5,\"428\":3,\"429\":4,\"430\":7,\"431\":2,\"433\":8,\"436\":3,\"439\":4,\"440\":6,\"443\":2,\"444\":1,\"445\":6,\"448\":1,\"451\":2,\"454\":9,\"456\":2,\"457\":2,\"460\":4,\"461\":1,\"466\":13,\"467\":2,\"468\":3,\"469\":2,\"471\":9,\"475\":12,\"477\":20,\"478\":20,\"479\":3,\"480\":3,\"485\":4,\"486\":2,\"502\":1,\"512\":1,\"530\":1,\"547\":1,\"552\":1,\"555\":1,\"557\":1,\"559\":1,\"560\":1,\"565\":1,\"569\":2,\"576\":2,\"583\":1,\"584\":4,\"597\":1,\"598\":1,\"622\":1,\"624\":2,\"626\":2,\"627\":2,\"629\":2,\"631\":1,\"632\":1,\"634\":1,\"635\":5,\"637\":1,\"638\":1,\"643\":1,\"644\":1,\"645\":1,\"646\":1,\"647\":1,\"648\":2,\"649\":3,\"650\":1,\"653\":1,\"655\":5,\"657\":2,\"658\":1,\"659\":2,\"661\":4,\"662\":2,\"664\":1,\"666\":3,\"669\":2,\"671\":1,\"672\":1,\"674\":4,\"675\":4,\"677\":4,\"678\":4,\"683\":3,\"684\":3,\"685\":3,\"686\":6,\"687\":1,\"688\":3,\"689\":1,\"690\":2,\"693\":1,\"694\":1,\"695\":1,\"696\":1,\"697\":1,\"698\":1,\"699\":2,\"700\":1,\"701\":2,\"702\":1,\"709\":5,\"712\":1,\"713\":5,\"715\":4,\"716\":2,\"717\":4,\"718\":5,\"720\":2,\"721\":3,\"727\":2,\"728\":2,\"729\":5,\"730\":6,\"734\":1,\"737\":1}}],[\"n\",{\"1\":{\"44\":1,\"45\":1,\"46\":1,\"55\":8,\"89\":1,\"90\":1,\"91\":13,\"108\":9,\"111\":12,\"124\":1,\"193\":1,\"353\":1,\"391\":5,\"408\":1,\"427\":1,\"428\":2,\"486\":2,\"586\":1,\"624\":12,\"625\":7,\"627\":6,\"630\":1,\"632\":12,\"638\":3,\"645\":3,\"646\":3,\"661\":5,\"676\":1,\"678\":6,\"683\":9,\"690\":6,\"693\":1,\"694\":14,\"695\":5,\"696\":7,\"698\":3,\"700\":4,\"701\":5,\"702\":4,\"705\":1,\"706\":2,\"707\":2,\"708\":2,\"709\":13,\"715\":2,\"716\":2,\"718\":2,\"724\":1,\"730\":5,\"734\":2,\"737\":4,\"740\":6,\"742\":2}}],[\"sgml\",{\"1\":{\"746\":1}}],[\"s由英文字母\",{\"1\":{\"647\":1}}],[\"sb\",{\"1\":{\"645\":25,\"684\":7}}],[\"sky\",{\"1\":{\"645\":2}}],[\"sqrt\",{\"1\":{\"629\":1}}],[\"sqlmapgenerator>\",{\"1\":{\"540\":1}}],[\"sql>\",{\"1\":{\"532\":1}}],[\"sql语句的执行顺序\",{\"0\":{\"184\":1}}],[\"sqlsessionutil\",{\"1\":{\"512\":1,\"524\":1,\"530\":1}}],[\"sqlsessionfactory\",{\"1\":{\"502\":3,\"535\":2}}],[\"sqlsessionfactorybuilder\",{\"1\":{\"502\":4}}],[\"sqlsession\",{\"1\":{\"167\":3,\"502\":3,\"512\":3,\"524\":3,\"530\":3,\"534\":7,\"535\":3,\"537\":2}}],[\"sql\",{\"0\":{\"502\":1,\"526\":1,\"532\":1},\"1\":{\"5\":1,\"184\":5,\"207\":1,\"495\":1,\"496\":5,\"501\":1,\"522\":3,\"523\":1,\"524\":1,\"525\":1,\"526\":1,\"532\":1,\"577\":4,\"578\":1,\"583\":6,\"609\":1}}],[\"src\",{\"1\":{\"480\":1,\"540\":3}}],[\"srcfilepath\",{\"1\":{\"478\":4}}],[\"ssl\",{\"1\":{\"780\":1}}],[\"ssl=false\",{\"1\":{\"466\":1}}],[\"sss\",{\"1\":{\"586\":1,\"607\":1}}],[\"ss\",{\"1\":{\"436\":2,\"586\":1,\"607\":1,\"730\":4}}],[\"sdf\",{\"1\":{\"436\":2}}],[\"s4\",{\"1\":{\"429\":1}}],[\"s3\",{\"1\":{\"429\":1,\"598\":1}}],[\"smith\",{\"1\":{\"404\":1}}],[\"switch\",{\"1\":{\"372\":2}}],[\"switch分支结构\",{\"0\":{\"372\":1}}],[\"swappairs\",{\"1\":{\"637\":1}}],[\"swap\",{\"1\":{\"143\":1,\"295\":1,\"452\":1,\"639\":2}}],[\"s>\",{\"1\":{\"304\":1}}],[\"safevarargs标注来消除限制\",{\"1\":{\"461\":1}}],[\"sanguoyanyi\",{\"1\":{\"439\":1}}],[\"saymessage\",{\"1\":{\"490\":2,\"491\":2}}],[\"say\",{\"1\":{\"404\":6}}],[\"salutation\",{\"1\":{\"491\":2}}],[\"sal\",{\"1\":{\"445\":4}}],[\"salary\",{\"1\":{\"368\":3,\"404\":10,\"486\":8}}],[\"sale\",{\"1\":{\"262\":4}}],[\"saleticketdemo\",{\"1\":{\"262\":1}}],[\"save保存镜像为一个压缩包\",{\"1\":{\"613\":1}}],[\"savegeneratedfiles\",{\"1\":{\"419\":1}}],[\"save\",{\"1\":{\"204\":1}}],[\"s2\",{\"1\":{\"248\":4,\"429\":1,\"675\":2}}],[\"s1\",{\"1\":{\"248\":4,\"429\":1,\"430\":1,\"675\":2}}],[\"s\",{\"1\":{\"248\":4,\"256\":4,\"419\":4,\"430\":3,\"457\":6,\"479\":4,\"486\":2,\"489\":2,\"491\":2,\"614\":2,\"630\":3,\"642\":9,\"643\":9,\"644\":3,\"645\":9,\"646\":2,\"647\":7,\"648\":17,\"649\":15,\"650\":10,\"653\":6,\"659\":7,\"660\":8,\"688\":7,\"702\":8,\"713\":6,\"730\":7}}],[\"sleuth\",{\"1\":{\"593\":2}}],[\"sleep\",{\"1\":{\"233\":1,\"248\":7,\"249\":1,\"256\":1,\"262\":1,\"268\":3,\"291\":2,\"298\":3,\"304\":2,\"313\":2,\"466\":7,\"467\":2,\"468\":5,\"469\":2,\"471\":1}}],[\"sleep可以在任何地方使用\",{\"1\":{\"226\":1}}],[\"sleep不会释放锁\",{\"1\":{\"226\":1}}],[\"sleep是thread类的方法\",{\"1\":{\"226\":1}}],[\"slf4j\",{\"1\":{\"586\":2}}],[\"slot\",{\"1\":{\"203\":1}}],[\"slow++\",{\"1\":{\"642\":1,\"643\":1}}],[\"slow指针在途中相遇\",{\"1\":{\"640\":1}}],[\"slow指针每次移动一个节点\",{\"1\":{\"640\":1}}],[\"slowindex++\",{\"1\":{\"623\":1}}],[\"slowindex\",{\"1\":{\"623\":2}}],[\"slow\",{\"1\":{\"177\":1,\"640\":8,\"642\":4,\"643\":4}}],[\"slave会让master从上次的\",{\"1\":{\"204\":1}}],[\"slave\",{\"1\":{\"203\":4,\"204\":11}}],[\"snapshots>\",{\"1\":{\"498\":2,\"540\":2}}],[\"snapshot<\",{\"1\":{\"498\":1,\"540\":1}}],[\"snapshot\",{\"1\":{\"178\":1}}],[\"sync\",{\"1\":{\"204\":2}}],[\"synchronized还可以放在方法声明中\",{\"1\":{\"470\":1}}],[\"synchronized就是java中悲观锁的典型实现\",{\"1\":{\"295\":1}}],[\"synchronized分析\",{\"0\":{\"260\":1}}],[\"synchronized后面括号括起来的部分\",{\"1\":{\"259\":1}}],[\"synchronized是java中的关键字\",{\"1\":{\"259\":1}}],[\"synchronized是隐式锁\",{\"1\":{\"142\":1}}],[\"synchronized\",{\"0\":{\"261\":1},\"1\":{\"220\":1,\"261\":5,\"263\":3,\"271\":2,\"292\":1,\"470\":3,\"471\":8}}],[\"synchronized的性能通常比reentrantlock好\",{\"1\":{\"142\":1}}],[\"synchronized锁升级过程\",{\"1\":{\"139\":1}}],[\"synchronized锁升级过程和实现原理\",{\"0\":{\"139\":1}}],[\"synchronized实现原理\",{\"1\":{\"139\":1}}],[\"synchronized关键字使用的锁\",{\"1\":{\"263\":1}}],[\"synchronized关键字和reentrantlock都是可重入锁\",{\"1\":{\"263\":1}}],[\"synchronized关键字和lock的实现类都是悲观锁\",{\"1\":{\"258\":1}}],[\"synchronized关键字在加锁和释放锁过程中会自动进行线程间的内存同步\",{\"1\":{\"138\":1}}],[\"synchronized关键字用于修饰方法或代码块\",{\"1\":{\"138\":1}}],[\"sychronized和reentrantlock区别\",{\"0\":{\"142\":1}}],[\"system类\",{\"0\":{\"434\":1}}],[\"system\",{\"1\":{\"55\":6,\"91\":2,\"96\":2,\"99\":3,\"102\":2,\"105\":7,\"108\":1,\"111\":2,\"114\":7,\"117\":4,\"232\":2,\"233\":3,\"248\":4,\"249\":4,\"253\":2,\"256\":8,\"262\":1,\"263\":3,\"268\":15,\"271\":12,\"291\":4,\"297\":2,\"298\":3,\"300\":2,\"304\":2,\"313\":4,\"334\":3,\"351\":1,\"352\":2,\"354\":1,\"358\":2,\"359\":2,\"368\":3,\"376\":2,\"377\":1,\"381\":5,\"382\":3,\"390\":1,\"391\":4,\"396\":1,\"399\":1,\"402\":4,\"403\":2,\"404\":4,\"411\":5,\"413\":10,\"414\":3,\"415\":2,\"416\":3,\"417\":4,\"418\":10,\"419\":9,\"421\":1,\"424\":1,\"427\":1,\"428\":3,\"429\":2,\"430\":4,\"431\":9,\"433\":2,\"436\":22,\"439\":2,\"440\":8,\"443\":9,\"444\":1,\"448\":2,\"451\":1,\"454\":2,\"457\":3,\"459\":4,\"466\":6,\"467\":1,\"468\":7,\"469\":4,\"471\":7,\"475\":7,\"477\":6,\"478\":13,\"479\":3,\"480\":4,\"483\":5,\"485\":5,\"486\":2,\"489\":1,\"490\":1,\"491\":2,\"502\":1,\"512\":1,\"524\":1,\"530\":1,\"552\":1,\"557\":2,\"559\":2,\"560\":5,\"563\":1,\"564\":3,\"565\":3,\"569\":2,\"572\":8,\"576\":3,\"577\":9,\"583\":9,\"586\":1,\"645\":4,\"648\":1,\"662\":1,\"718\":2,\"724\":2,\"727\":1,\"728\":1,\"729\":3,\"730\":2}}],[\"systemctl\",{\"1\":{\"49\":2}}],[\"solve\",{\"1\":{\"709\":2}}],[\"solution\",{\"1\":{\"620\":1,\"621\":1,\"622\":1,\"623\":2,\"624\":3,\"625\":2,\"626\":1,\"627\":1,\"628\":1,\"629\":2,\"630\":2,\"631\":1,\"632\":1,\"634\":1,\"636\":1,\"637\":1,\"638\":1,\"639\":1,\"640\":1,\"642\":1,\"643\":1,\"644\":1,\"645\":1,\"646\":1,\"647\":1,\"648\":1,\"649\":1,\"650\":1,\"652\":1,\"653\":1,\"659\":1,\"660\":1,\"661\":1,\"662\":1,\"664\":1,\"666\":1,\"667\":1,\"668\":1,\"669\":2,\"671\":1,\"672\":1,\"675\":1,\"677\":1,\"678\":1,\"683\":1,\"684\":1,\"685\":1,\"686\":2,\"687\":2,\"688\":1,\"689\":1,\"690\":1,\"693\":2,\"694\":1,\"695\":1,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"701\":2,\"702\":1,\"705\":1,\"706\":1,\"707\":1,\"708\":1,\"709\":2,\"712\":1,\"713\":1,\"715\":1,\"716\":1,\"717\":1,\"734\":1,\"737\":1,\"740\":1,\"742\":1}}],[\"sockettimeout=3000\",{\"1\":{\"605\":1}}],[\"sockettcp01client\",{\"1\":{\"485\":1}}],[\"sockettcp02server\",{\"1\":{\"485\":1}}],[\"socket允许程序把网络连接当成一个流\",{\"1\":{\"484\":1}}],[\"socket\",{\"0\":{\"484\":1},\"1\":{\"485\":13}}],[\"source`\",{\"1\":{\"605\":1}}],[\"source>\",{\"1\":{\"498\":1,\"540\":1}}],[\"source>8<\",{\"1\":{\"498\":1,\"540\":1}}],[\"source\",{\"1\":{\"422\":1,\"605\":7}}],[\"sout模板\",{\"1\":{\"395\":1}}],[\"son\",{\"1\":{\"399\":6}}],[\"soft\",{\"1\":{\"167\":1,\"536\":1}}],[\"sof\",{\"1\":{\"126\":1}}],[\"sortedsquares\",{\"1\":{\"629\":2}}],[\"sortedset\",{\"0\":{\"193\":1}}],[\"sorted\",{\"1\":{\"188\":1,\"199\":3}}],[\"sort\",{\"1\":{\"45\":1,\"433\":6,\"452\":2,\"628\":2,\"675\":1}}],[\"sh\",{\"1\":{\"599\":1,\"602\":1}}],[\"shuffle\",{\"1\":{\"452\":1}}],[\"shuihuzhuan\",{\"1\":{\"440\":1}}],[\"shutdown\",{\"1\":{\"249\":1}}],[\"shinaian\",{\"1\":{\"440\":1}}],[\"shop3\",{\"1\":{\"466\":2}}],[\"shop2\",{\"1\":{\"466\":2}}],[\"shop1\",{\"1\":{\"466\":9,\"471\":8}}],[\"short\",{\"1\":{\"358\":1,\"359\":2,\"372\":1}}],[\"show\",{\"1\":{\"457\":3}}],[\"showcase\",{\"1\":{\"117\":3}}],[\"showwithaster\",{\"1\":{\"96\":2}}],[\"showwithparen\",{\"1\":{\"96\":2}}],[\"share\",{\"1\":{\"3\":1,\"614\":1,\"615\":2}}],[\"shared挂载到队尾阻塞\",{\"1\":{\"318\":1}}],[\"shared\",{\"1\":{\"2\":1,\"3\":5,\"312\":2}}],[\"si==si+1\",{\"1\":{\"650\":1}}],[\"singly\",{\"1\":{\"634\":1,\"636\":1,\"637\":1,\"638\":1,\"639\":1,\"640\":1}}],[\"singleton02\",{\"1\":{\"414\":1}}],[\"singleton01\",{\"1\":{\"414\":1}}],[\"singleton类对外提供一个getinstance方法来获取类的实例\",{\"1\":{\"99\":1}}],[\"singleton\",{\"1\":{\"65\":1,\"98\":1,\"99\":11,\"559\":2}}],[\"simpledateformat\",{\"1\":{\"436\":3}}],[\"signal被触发后\",{\"1\":{\"319\":1}}],[\"signal等待唤醒机制\",{\"1\":{\"311\":1}}],[\"signal\",{\"1\":{\"271\":1,\"312\":2}}],[\"size遍历完即一层的节点已经遍历完\",{\"1\":{\"666\":1,\"669\":1}}],[\"size++\",{\"1\":{\"635\":2}}],[\"size存储链表元素的个数\",{\"1\":{\"635\":1}}],[\"size`\",{\"1\":{\"605\":4}}],[\"size=4\",{\"1\":{\"542\":1}}],[\"size=\",{\"1\":{\"536\":1}}],[\"size\",{\"1\":{\"91\":1,\"439\":1,\"440\":4,\"536\":1,\"623\":5,\"631\":1,\"635\":13,\"648\":1,\"656\":1,\"658\":3,\"661\":2,\"666\":5,\"669\":5,\"683\":3,\"685\":1,\"686\":2,\"711\":2,\"712\":3,\"713\":3,\"718\":3,\"720\":1,\"721\":4}}],[\"sz\",{\"1\":{\"91\":2,\"711\":2}}],[\"such\",{\"1\":{\"655\":1,\"674\":1}}],[\"suffixoverrides=\",{\"1\":{\"529\":1,\"532\":1}}],[\"suffixoverrides\",{\"1\":{\"529\":1}}],[\"suffix\",{\"1\":{\"529\":1}}],[\"sun\",{\"1\":{\"419\":1,\"466\":4}}],[\"subsets\",{\"1\":{\"686\":2}}],[\"substring产生的字符串并不在常量池中\",{\"1\":{\"429\":1}}],[\"substring\",{\"1\":{\"429\":3,\"648\":1,\"650\":1,\"688\":1}}],[\"subarraysum\",{\"1\":{\"671\":1}}],[\"subremain方法\",{\"1\":{\"583\":1}}],[\"subremain\",{\"1\":{\"583\":3}}],[\"sublist\",{\"1\":{\"440\":2}}],[\"subtract\",{\"1\":{\"435\":1}}],[\"sub\",{\"1\":{\"402\":2,\"627\":2}}],[\"submit\",{\"1\":{\"132\":1}}],[\"suspend\",{\"1\":{\"267\":1}}],[\"supresswarnings\",{\"1\":{\"422\":1}}],[\"suppresswarnings\",{\"1\":{\"307\":1}}],[\"supplier\",{\"1\":{\"238\":2,\"251\":1,\"304\":1}}],[\"supplier<\",{\"1\":{\"304\":1}}],[\"supplier<u>\",{\"1\":{\"238\":2}}],[\"supplier<t>\",{\"1\":{\"129\":1,\"251\":1}}],[\"supplyasync\",{\"1\":{\"238\":2,\"248\":8,\"249\":1,\"253\":1,\"256\":1}}],[\"supplyasync方法\",{\"0\":{\"238\":1}}],[\"super和this的比较\",{\"1\":{\"400\":1}}],[\"super的访问遵循就近原则\",{\"1\":{\"400\":1}}],[\"super的访问不限于父类\",{\"1\":{\"400\":1}}],[\"super代表父类的引用\",{\"1\":{\"400\":1}}],[\"super关键字\",{\"0\":{\"400\":1}}],[\"super在使用时\",{\"1\":{\"399\":1}}],[\"super\",{\"1\":{\"96\":1,\"111\":5,\"114\":2,\"243\":1,\"244\":1,\"245\":1,\"248\":12,\"251\":3,\"399\":1,\"400\":3,\"404\":4,\"413\":1,\"417\":1,\"418\":1,\"460\":2,\"560\":2}}],[\"surefire\",{\"1\":{\"82\":1}}],[\"summer\",{\"1\":{\"421\":2}}],[\"sum1\",{\"1\":{\"403\":3}}],[\"sum\",{\"1\":{\"44\":1,\"391\":3,\"403\":3,\"627\":3,\"630\":8,\"687\":11,\"689\":4,\"694\":3,\"701\":8,\"734\":3}}],[\"see\",{\"1\":{\"775\":1}}],[\"seatsi\",{\"1\":{\"678\":2}}],[\"searchprefix\",{\"1\":{\"674\":3}}],[\"search\",{\"1\":{\"620\":1,\"621\":1,\"674\":2}}],[\"season\",{\"1\":{\"421\":11}}],[\"sed\",{\"1\":{\"614\":2}}],[\"separator=\",{\"1\":{\"531\":3}}],[\"separator\",{\"1\":{\"531\":1}}],[\"sell\",{\"1\":{\"471\":2}}],[\"select=\",{\"1\":{\"523\":1,\"524\":1}}],[\"selectalluser\",{\"1\":{\"501\":1}}],[\"select>\",{\"1\":{\"501\":2,\"504\":1,\"511\":2,\"512\":4,\"517\":3,\"519\":1,\"522\":2,\"523\":3,\"525\":2,\"527\":1,\"528\":1,\"529\":1,\"530\":1,\"532\":1}}],[\"selectuserbyid\",{\"1\":{\"501\":1}}],[\"selectbyid\",{\"1\":{\"419\":2}}],[\"select\",{\"1\":{\"177\":1,\"184\":2,\"419\":8,\"501\":2,\"504\":1,\"511\":2,\"512\":4,\"517\":3,\"519\":1,\"522\":2,\"523\":4,\"524\":2,\"525\":2,\"527\":1,\"528\":1,\"529\":1,\"530\":1,\"532\":1}}],[\"se标准类库\",{\"1\":{\"350\":1}}],[\"sentinel\",{\"1\":{\"203\":1,\"595\":1}}],[\"semaphore利用aqs提供的同步机制\",{\"1\":{\"144\":1}}],[\"semaphore内部使用了一个计数器\",{\"1\":{\"144\":1}}],[\"semaphore的实现原理也是基于aqs\",{\"1\":{\"144\":1}}],[\"semaphore常用于限制资源的并发访问量\",{\"1\":{\"144\":1}}],[\"semaphore是一种计数信号量\",{\"1\":{\"144\":1}}],[\"semaphore\",{\"0\":{\"144\":1},\"1\":{\"144\":1}}],[\"secure\",{\"1\":{\"598\":1}}],[\"security的支持\",{\"1\":{\"81\":1}}],[\"security\",{\"1\":{\"81\":1,\"593\":1}}],[\"second\",{\"1\":{\"167\":1,\"436\":2}}],[\"seconds\",{\"1\":{\"135\":1,\"205\":1,\"233\":1,\"249\":1,\"256\":1,\"268\":3,\"298\":3,\"313\":2}}],[\"segments\",{\"1\":{\"214\":1}}],[\"segment\",{\"1\":{\"125\":1}}],[\"serializable>\",{\"1\":{\"461\":1}}],[\"serializable\",{\"1\":{\"116\":1,\"171\":1,\"478\":2,\"535\":1}}],[\"servletresponse\",{\"1\":{\"339\":1}}],[\"servletrequest\",{\"1\":{\"339\":1}}],[\"servlet2\",{\"1\":{\"334\":1}}],[\"servletexception\",{\"1\":{\"334\":2,\"339\":2}}],[\"servlet请求转发\",{\"0\":{\"334\":1}}],[\"servletcontext是一个域对象\",{\"1\":{\"331\":1}}],[\"servletcontext类\",{\"0\":{\"331\":1}}],[\"servletcontext\",{\"1\":{\"330\":1}}],[\"servletconfig\",{\"1\":{\"330\":1}}],[\"servletconfig类\",{\"0\":{\"330\":1}}],[\"servlet的继承体系\",{\"0\":{\"329\":1}}],[\"servlet的生命周期\",{\"0\":{\"328\":1}}],[\"servlet>\",{\"1\":{\"327\":1}}],[\"servlet是运行在服务器上的java小程序\",{\"1\":{\"326\":1}}],[\"servlet是javaee规范之一\",{\"1\":{\"326\":1}}],[\"servlet技术\",{\"0\":{\"326\":1}}],[\"servlet程序的配置信息\",{\"1\":{\"330\":1}}],[\"servlet程序\",{\"1\":{\"323\":1}}],[\"servlet\",{\"0\":{\"325\":1},\"1\":{\"168\":2,\"327\":4,\"328\":1,\"334\":2,\"588\":1}}],[\"serverhttprequest\",{\"1\":{\"607\":1}}],[\"serverwebexchange\",{\"1\":{\"607\":1}}],[\"servertimezone=utc\",{\"1\":{\"605\":1}}],[\"servertimezone=gmt\",{\"1\":{\"499\":1,\"506\":1,\"507\":1,\"540\":1}}],[\"serversocket\",{\"1\":{\"485\":5}}],[\"server\",{\"1\":{\"81\":1,\"192\":1,\"485\":1,\"593\":1,\"599\":2,\"602\":1,\"605\":9,\"607\":2,\"611\":1,\"617\":1,\"777\":1}}],[\"service中orderapplication类中\",{\"1\":{\"598\":1}}],[\"servicename\",{\"1\":{\"598\":3}}],[\"service项目启动类orderapplication中的resttemplate添加负载均衡注解\",{\"1\":{\"597\":1}}],[\"service完成拉取服务\",{\"1\":{\"597\":1}}],[\"service的orderapplication中注册resttemplate\",{\"1\":{\"596\":1}}],[\"service方法每次访问都会调用\",{\"1\":{\"328\":1}}],[\"services\",{\"1\":{\"81\":1,\"617\":1}}],[\"serviceimpl3\",{\"1\":{\"70\":1}}],[\"serviceimpl2\",{\"1\":{\"70\":1}}],[\"serviceimpl1\",{\"1\":{\"70\":1}}],[\"serviceimpl\",{\"1\":{\"70\":1}}],[\"service注解的类扫描到spring容器中\",{\"1\":{\"69\":1}}],[\"service和\",{\"1\":{\"69\":1}}],[\"service\",{\"0\":{\"69\":1,\"166\":1},\"1\":{\"64\":1,\"69\":1,\"161\":1,\"164\":1,\"166\":1,\"328\":1,\"557\":2,\"563\":4,\"564\":7,\"575\":2,\"576\":2,\"581\":1,\"583\":6,\"584\":2,\"597\":1,\"607\":2,\"617\":2,\"777\":1}}],[\"set<string>\",{\"1\":{\"713\":2}}],[\"set<node>\",{\"1\":{\"711\":1}}],[\"set<character>\",{\"1\":{\"659\":1}}],[\"set<integer>\",{\"1\":{\"91\":1}}],[\"setpassword\",{\"1\":{\"584\":1}}],[\"setpriority\",{\"1\":{\"468\":1}}],[\"setprice\",{\"1\":{\"440\":1}}],[\"setproperty\",{\"1\":{\"419\":1,\"480\":4}}],[\"seturl\",{\"1\":{\"584\":1}}],[\"setuser\",{\"1\":{\"597\":1}}],[\"setuserstatus\",{\"1\":{\"576\":2}}],[\"setusername\",{\"1\":{\"576\":2,\"584\":1}}],[\"setuserid\",{\"1\":{\"576\":2}}],[\"setuserdao\",{\"1\":{\"557\":1}}],[\"setoname\",{\"1\":{\"560\":1}}],[\"setout0\",{\"1\":{\"479\":1}}],[\"setout\",{\"1\":{\"479\":2}}],[\"set>\",{\"1\":{\"557\":1}}],[\"set类型注入\",{\"1\":{\"557\":1}}],[\"setgender\",{\"1\":{\"557\":1}}],[\"setloop\",{\"1\":{\"467\":2}}],[\"set01\",{\"1\":{\"444\":1}}],[\"set接口实现类\",{\"0\":{\"445\":1,\"446\":1,\"447\":1}}],[\"set接口时collection子接口\",{\"1\":{\"444\":1}}],[\"set接口和常用方法\",{\"0\":{\"444\":1}}],[\"set1\",{\"1\":{\"443\":1}}],[\"setdatasource\",{\"1\":{\"584\":2}}],[\"setdaemon\",{\"1\":{\"227\":1,\"468\":1}}],[\"setdriverclassname\",{\"1\":{\"584\":1}}],[\"setdept\",{\"1\":{\"557\":1}}],[\"setdesc\",{\"1\":{\"421\":1}}],[\"setstatuscode\",{\"1\":{\"607\":1}}],[\"setsalary\",{\"1\":{\"404\":1,\"486\":1}}],[\"setscore\",{\"1\":{\"404\":1}}],[\"setaccessible\",{\"1\":{\"486\":1}}],[\"setauthor\",{\"1\":{\"440\":1}}],[\"setage\",{\"1\":{\"404\":1}}],[\"setattribute\",{\"1\":{\"334\":1}}],[\"settings>\",{\"1\":{\"522\":1,\"524\":1}}],[\"settings\",{\"1\":{\"395\":1}}],[\"setcharat\",{\"1\":{\"645\":2}}],[\"setcharacterencoding\",{\"1\":{\"333\":1,\"335\":1}}],[\"setcomplete\",{\"1\":{\"607\":1}}],[\"setcontenttype\",{\"1\":{\"335\":1}}],[\"setcorepoolsize\",{\"1\":{\"134\":1}}],[\"setinitialvalue\",{\"1\":{\"307\":2}}],[\"setid\",{\"1\":{\"252\":2}}],[\"set方法\",{\"0\":{\"306\":1}}],[\"setmajor\",{\"1\":{\"252\":2}}],[\"setmaximumpoolsize\",{\"1\":{\"134\":1}}],[\"setname\",{\"1\":{\"252\":2,\"404\":1,\"414\":1,\"440\":1,\"468\":1,\"471\":2,\"486\":1,\"557\":2}}],[\"setnx\",{\"1\":{\"205\":6}}],[\"set\",{\"1\":{\"66\":1,\"188\":2,\"199\":5,\"202\":1,\"268\":1,\"297\":1,\"304\":2,\"306\":2,\"307\":1,\"440\":5,\"443\":1,\"444\":15,\"445\":4,\"448\":1,\"451\":1,\"486\":1,\"492\":1,\"501\":1,\"557\":1,\"560\":3,\"577\":1,\"583\":3,\"721\":1,\"785\":1}}],[\"session一结束会自动销毁\",{\"1\":{\"217\":1}}],[\"session\",{\"1\":{\"65\":3,\"104\":2,\"165\":7,\"167\":2,\"208\":1,\"339\":2}}],[\"sc=new\",{\"1\":{\"724\":1}}],[\"scan>\",{\"1\":{\"563\":3,\"572\":1,\"583\":1}}],[\"scan\",{\"1\":{\"563\":3,\"572\":1,\"583\":1}}],[\"scanner类默认的分隔符就是空格\",{\"1\":{\"724\":1}}],[\"scannerexample\",{\"1\":{\"55\":1}}],[\"scanner\",{\"1\":{\"55\":7,\"91\":2,\"368\":4,\"430\":5,\"718\":2,\"724\":3,\"727\":2,\"728\":2,\"729\":5}}],[\"scanner可以方便地进行分词等操作\",{\"1\":{\"55\":1}}],[\"scanner则需要对输入进行解析\",{\"1\":{\"55\":1}}],[\"sc1\",{\"1\":{\"368\":5}}],[\"script标签\",{\"1\":{\"332\":1}}],[\"sc\",{\"1\":{\"91\":4,\"718\":4,\"724\":1}}],[\"score\",{\"1\":{\"199\":1,\"404\":10}}],[\"scott\",{\"1\":{\"67\":1}}],[\"scope>\",{\"1\":{\"498\":1,\"540\":2,\"599\":1}}],[\"scopes有\",{\"1\":{\"65\":1}}],[\"scope\",{\"0\":{\"65\":1},\"1\":{\"65\":1,\"491\":1,\"559\":4}}],[\"schema`\",{\"1\":{\"605\":1}}],[\"schemalocation=\",{\"1\":{\"63\":1,\"327\":1,\"498\":1,\"540\":1,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1}}],[\"schema\",{\"1\":{\"63\":3,\"552\":3,\"555\":3,\"557\":12,\"560\":12,\"561\":6,\"562\":15,\"563\":18,\"583\":12}}],[\"svg\",{\"1\":{\"27\":1}}],[\"stereotype\",{\"1\":{\"563\":2}}],[\"step++\",{\"1\":{\"711\":1,\"713\":1}}],[\"step\",{\"1\":{\"525\":2,\"711\":2,\"713\":2}}],[\"stu\",{\"1\":{\"557\":2}}],[\"student\",{\"1\":{\"67\":1,\"252\":8,\"404\":5,\"557\":2}}],[\"studentbean\",{\"1\":{\"67\":1}}],[\"store\",{\"1\":{\"480\":2}}],[\"stop容器停止\",{\"1\":{\"613\":1}}],[\"stop\",{\"1\":{\"49\":1,\"267\":1,\"417\":3}}],[\"stack<treenode>\",{\"1\":{\"730\":1}}],[\"stack<linknode>\",{\"1\":{\"729\":1}}],[\"stack<>\",{\"1\":{\"659\":1,\"729\":1,\"730\":1}}],[\"stack<character>\",{\"1\":{\"659\":1}}],[\"stack<integer>\",{\"1\":{\"655\":4}}],[\"stack\",{\"1\":{\"655\":20,\"657\":3,\"658\":3,\"662\":6,\"729\":6,\"730\":1}}],[\"standalone\",{\"1\":{\"599\":1,\"617\":1}}],[\"standardcharsets\",{\"1\":{\"477\":1,\"485\":1}}],[\"staff\",{\"1\":{\"443\":6}}],[\"stampedreference\",{\"1\":{\"300\":8}}],[\"start为root节点\",{\"1\":{\"712\":1}}],[\"start+1\",{\"1\":{\"687\":2}}],[\"start++\",{\"1\":{\"645\":3}}],[\"startswith\",{\"1\":{\"674\":2}}],[\"starty++\",{\"1\":{\"632\":1}}],[\"starty\",{\"1\":{\"632\":3}}],[\"startx++\",{\"1\":{\"632\":1}}],[\"startx\",{\"1\":{\"632\":3}}],[\"start容器从停止恢复到运行状态\",{\"1\":{\"613\":1}}],[\"startup\",{\"1\":{\"599\":1,\"605\":1}}],[\"startrow=1\",{\"1\":{\"542\":1}}],[\"startrow=0\",{\"1\":{\"542\":2}}],[\"start底层会创建一个新线程\",{\"1\":{\"468\":1}}],[\"startindex来记录下一层递归\",{\"1\":{\"683\":1}}],[\"startindex\",{\"1\":{\"429\":1,\"676\":3,\"683\":2,\"686\":4,\"688\":6}}],[\"starttime\",{\"1\":{\"256\":4,\"416\":2,\"431\":7}}],[\"start0\",{\"1\":{\"220\":2,\"223\":1}}],[\"started\",{\"1\":{\"220\":3}}],[\"starters命名\",{\"1\":{\"81\":1}}],[\"starters包含了许多项目中\",{\"1\":{\"81\":1}}],[\"starters可以理解为启动器\",{\"1\":{\"81\":1}}],[\"starters是什么\",{\"1\":{\"81\":1}}],[\"starter\",{\"0\":{\"82\":1},\"1\":{\"80\":2,\"81\":38,\"82\":5,\"597\":1,\"599\":1,\"602\":1,\"606\":1}}],[\"start\",{\"0\":{\"220\":1},\"1\":{\"220\":1,\"232\":1,\"233\":2,\"249\":1,\"262\":3,\"263\":1,\"268\":8,\"271\":6,\"291\":1,\"298\":2,\"304\":1,\"313\":2,\"417\":3,\"419\":2,\"466\":8,\"467\":1,\"468\":3,\"469\":1,\"471\":5,\"627\":4,\"643\":5,\"645\":16,\"684\":2,\"687\":4,\"688\":2,\"689\":2,\"695\":1,\"696\":1,\"698\":10,\"701\":2,\"711\":3}}],[\"stage\",{\"1\":{\"163\":1,\"248\":2}}],[\"statements\",{\"1\":{\"488\":1}}],[\"state枚举表示了线程的几种状态\",{\"1\":{\"469\":1}}],[\"state\",{\"1\":{\"225\":1,\"469\":1,\"598\":1}}],[\"state表示锁的可用数量等\",{\"1\":{\"141\":1}}],[\"state=1表示锁已被占用\",{\"1\":{\"141\":1}}],[\"state=0表示锁未被占用\",{\"1\":{\"141\":1}}],[\"state的具体含义可以由使用者自行定义和扩展\",{\"1\":{\"141\":1}}],[\"state的高16位表示持有锁的线程数\",{\"1\":{\"141\":1}}],[\"status=\",{\"1\":{\"586\":1}}],[\"status\",{\"1\":{\"70\":2}}],[\"static的\",{\"1\":{\"417\":1}}],[\"static代码块作用是对类进行初始化\",{\"1\":{\"413\":1}}],[\"static可以使虚拟机在执行main方法时不必创建对象\",{\"1\":{\"412\":1}}],[\"static\",{\"1\":{\"55\":2,\"63\":2,\"91\":1,\"96\":1,\"99\":3,\"102\":1,\"105\":1,\"108\":1,\"111\":2,\"120\":1,\"232\":1,\"233\":1,\"238\":2,\"239\":2,\"247\":1,\"249\":1,\"251\":1,\"252\":1,\"253\":1,\"256\":4,\"262\":1,\"263\":1,\"268\":5,\"271\":3,\"291\":3,\"292\":2,\"300\":1,\"304\":2,\"312\":7,\"313\":1,\"351\":2,\"352\":2,\"354\":1,\"368\":1,\"376\":1,\"377\":1,\"381\":3,\"382\":3,\"390\":1,\"391\":3,\"396\":1,\"399\":1,\"402\":3,\"403\":1,\"404\":1,\"411\":2,\"412\":1,\"413\":7,\"414\":6,\"415\":5,\"416\":1,\"417\":4,\"418\":1,\"419\":2,\"421\":5,\"427\":3,\"428\":2,\"429\":1,\"430\":2,\"431\":1,\"433\":1,\"436\":3,\"439\":1,\"440\":2,\"443\":1,\"444\":1,\"445\":1,\"448\":1,\"451\":1,\"454\":2,\"457\":1,\"461\":2,\"466\":4,\"467\":1,\"468\":2,\"469\":1,\"471\":7,\"477\":1,\"478\":1,\"479\":1,\"480\":1,\"483\":1,\"485\":2,\"486\":1,\"491\":2,\"555\":2,\"569\":1,\"586\":2,\"598\":1,\"648\":4,\"677\":1,\"709\":1,\"718\":5,\"724\":1,\"729\":2,\"730\":2,\"734\":1}}],[\"structure\",{\"1\":{\"657\":1,\"658\":1}}],[\"strstr\",{\"0\":{\"651\":1},\"1\":{\"651\":2,\"652\":1,\"653\":1}}],[\"strlist\",{\"1\":{\"456\":2}}],[\"strdis\",{\"1\":{\"105\":2}}],[\"str\",{\"1\":{\"105\":6,\"108\":4,\"117\":5,\"363\":1,\"430\":4,\"477\":2,\"688\":9,\"729\":2}}],[\"stringandstringbuffer\",{\"1\":{\"430\":1}}],[\"string与stringbuffer相互转换\",{\"1\":{\"430\":1}}],[\"string变量指向常量池中的helloabc\",{\"1\":{\"429\":1}}],[\"string01\",{\"1\":{\"429\":1}}],[\"string是final类\",{\"1\":{\"429\":1}}],[\"string对象用于保存字符串\",{\"1\":{\"429\":1}}],[\"string类实现了serializable接口\",{\"1\":{\"429\":1}}],[\"string类较常用的构造器\",{\"1\":{\"429\":1}}],[\"string类的理解和创建对象\",{\"1\":{\"429\":1}}],[\"string类\",{\"0\":{\"429\":1}}],[\"string转基本类型\",{\"1\":{\"360\":1}}],[\"strings\",{\"1\":{\"121\":1}}],[\"string的内部使用字符数组来存储字符串的字符序列\",{\"1\":{\"121\":1}}],[\"stringbuffer和stringbuilder类的选择\",{\"1\":{\"431\":1}}],[\"stringbuffer和stringbuilder的区别\",{\"0\":{\"120\":1}}],[\"stringbufferexercise\",{\"1\":{\"430\":1}}],[\"stringbuffer3\",{\"1\":{\"430\":3}}],[\"stringbuffer1\",{\"1\":{\"430\":3}}],[\"stringbuffer是可变长度的\",{\"1\":{\"430\":1}}],[\"stringbuffer类\",{\"0\":{\"430\":1}}],[\"stringbuffer的所有public\",{\"1\":{\"120\":1}}],[\"stringbuffer\",{\"1\":{\"108\":3,\"111\":4,\"120\":1,\"430\":14,\"431\":4}}],[\"stringbuilder的方法没有做互斥处理\",{\"1\":{\"431\":1}}],[\"stringbuilder类\",{\"0\":{\"431\":1}}],[\"stringbuilder线程不安全\",{\"1\":{\"120\":1}}],[\"stringbuilder\",{\"1\":{\"107\":1,\"431\":4,\"644\":6,\"645\":6,\"646\":6,\"684\":2,\"690\":3}}],[\"stringdisplayimpl\",{\"1\":{\"114\":2}}],[\"stringdisplay\",{\"1\":{\"105\":3}}],[\"string>\",{\"1\":{\"102\":2,\"491\":1,\"607\":1}}],[\"string\",{\"1\":{\"55\":4,\"63\":1,\"91\":1,\"96\":12,\"99\":1,\"102\":6,\"105\":3,\"108\":12,\"111\":32,\"114\":11,\"117\":5,\"188\":1,\"232\":1,\"233\":1,\"248\":4,\"249\":1,\"252\":3,\"253\":1,\"256\":7,\"262\":1,\"263\":1,\"268\":3,\"271\":3,\"291\":1,\"297\":1,\"300\":2,\"304\":1,\"313\":1,\"330\":3,\"334\":2,\"351\":2,\"352\":2,\"354\":1,\"360\":2,\"363\":1,\"368\":2,\"372\":1,\"376\":1,\"377\":1,\"381\":3,\"382\":3,\"390\":3,\"391\":4,\"392\":3,\"399\":5,\"402\":3,\"403\":1,\"404\":7,\"406\":1,\"411\":3,\"412\":2,\"413\":2,\"414\":8,\"415\":1,\"416\":1,\"417\":4,\"418\":3,\"419\":6,\"421\":7,\"424\":2,\"425\":1,\"427\":3,\"428\":1,\"429\":17,\"430\":12,\"431\":7,\"433\":3,\"436\":5,\"439\":6,\"440\":11,\"443\":1,\"444\":1,\"445\":3,\"448\":1,\"451\":3,\"454\":5,\"457\":1,\"460\":1,\"466\":4,\"467\":1,\"468\":2,\"469\":1,\"470\":1,\"471\":2,\"475\":8,\"477\":17,\"478\":18,\"479\":1,\"480\":3,\"483\":3,\"485\":3,\"486\":8,\"489\":2,\"490\":1,\"491\":4,\"501\":1,\"511\":1,\"512\":8,\"519\":1,\"522\":2,\"555\":1,\"557\":6,\"560\":5,\"564\":1,\"569\":5,\"576\":9,\"577\":4,\"578\":1,\"583\":9,\"586\":1,\"597\":1,\"598\":2,\"603\":4,\"606\":1,\"607\":1,\"643\":3,\"644\":2,\"645\":3,\"646\":2,\"647\":1,\"648\":4,\"649\":2,\"650\":2,\"652\":2,\"653\":3,\"659\":1,\"660\":1,\"674\":4,\"675\":3,\"677\":1,\"684\":4,\"688\":4,\"702\":4,\"705\":1,\"713\":12,\"718\":1,\"724\":1,\"729\":3,\"730\":3}}],[\"string等\",{\"1\":{\"55\":1}}],[\"stream\",{\"1\":{\"44\":1,\"256\":4,\"687\":4}}],[\"str2\",{\"1\":{\"7\":1,\"429\":3}}],[\"str1\",{\"1\":{\"7\":1,\"360\":3,\"429\":1}}],[\"still\",{\"1\":{\"3\":3}}],[\"std\",{\"1\":{\"3\":2}}],[\"spiring\",{\"1\":{\"574\":1}}],[\"spinlockdemo\",{\"1\":{\"298\":3}}],[\"springcloud集成了各种微服务组件\",{\"1\":{\"595\":1}}],[\"springcloudgateway\",{\"1\":{\"595\":2}}],[\"springcloudconfig\",{\"1\":{\"595\":2}}],[\"springcloudalibaba兼容前两种架构\",{\"1\":{\"595\":1}}],[\"springcloudalibaba\",{\"1\":{\"595\":1}}],[\"springcloud\",{\"0\":{\"593\":1},\"1\":{\"595\":2,\"598\":7,\"607\":1}}],[\"springconfig\",{\"1\":{\"565\":2}}],[\"springwebflux\",{\"0\":{\"587\":1},\"1\":{\"588\":1}}],[\"spring5\",{\"0\":{\"585\":1},\"1\":{\"586\":2,\"588\":1}}],[\"spring源码下载\",{\"1\":{\"551\":1}}],[\"spring实战\",{\"0\":{\"543\":1}}],[\"spring根据循环依赖链的深度进行逐级清理\",{\"1\":{\"163\":1}}],[\"spring将真正创建好的bean对象放置到singletonobjects缓存中\",{\"1\":{\"163\":1}}],[\"spring将正在创建的bean对象存放在早期暴露的对象缓存earlysingletonobjects\",{\"1\":{\"163\":1}}],[\"spring开始解决循环依赖\",{\"1\":{\"163\":1}}],[\"spring继续创建bean的过程\",{\"1\":{\"163\":1}}],[\"spring怎么解决循环依赖问题\",{\"0\":{\"163\":1}}],[\"spring框架的核心思想是ioc\",{\"1\":{\"158\":1}}],[\"spring框架\",{\"0\":{\"157\":1}}],[\"spring框架缓存抽象层的支持\",{\"1\":{\"81\":1}}],[\"spring框架用到了哪些设计模式\",{\"0\":{\"73\":1}}],[\"springboot应用中没有添加\",{\"1\":{\"164\":1}}],[\"springboot应用中需要添加\",{\"1\":{\"164\":1}}],[\"springbootapplication\",{\"0\":{\"84\":1}}],[\"springboot集成mybatis这类的包\",{\"0\":{\"83\":1}}],[\"springboot中的starters\",{\"0\":{\"81\":1}}],[\"springboot特点\",{\"0\":{\"80\":1}}],[\"springboot\",{\"0\":{\"79\":1},\"1\":{\"588\":1,\"592\":1}}],[\"springmvc框架提供了很多的view视图类型\",{\"1\":{\"76\":1}}],[\"springmvc提供了不同的映射器实现不同的映射方式\",{\"1\":{\"76\":1}}],[\"springmvc流程\",{\"0\":{\"76\":1}}],[\"springmvc就相当于是struts2加上spring的整合\",{\"1\":{\"75\":1}}],[\"springmvc=struts2+spring\",{\"1\":{\"75\":1}}],[\"springmvc是一个mvc的开源框架\",{\"1\":{\"75\":1}}],[\"springmvc是什么\",{\"0\":{\"75\":1}}],[\"springmvc\",{\"0\":{\"74\":1},\"1\":{\"588\":5}}],[\"spring会为该类创建一个代理对象\",{\"1\":{\"166\":1}}],[\"spring会调用销毁回调方法\",{\"1\":{\"160\":1}}],[\"spring会调用初始化回调方法\",{\"1\":{\"160\":1}}],[\"spring会使用依赖注入\",{\"1\":{\"160\":1}}],[\"spring会根据配置文件或注解创建bean的实例\",{\"1\":{\"160\":1}}],[\"spring会根据注解名称的不同\",{\"1\":{\"69\":1}}],[\"spring会在应用启动时对bean进行一些基本的错误检查\",{\"1\":{\"62\":1}}],[\"spring在进行组件扫描时\",{\"1\":{\"69\":1}}],[\"spring中使用多线程\",{\"0\":{\"164\":1}}],[\"spring中两个或多个\",{\"1\":{\"163\":1}}],[\"spring中listener的实现\",{\"1\":{\"73\":1}}],[\"spring中实现自动装配的方式有两种\",{\"1\":{\"68\":1}}],[\"spring中最常用的bean\",{\"1\":{\"65\":1}}],[\"spring有哪些自动装配方式\",{\"0\":{\"68\":1}}],[\"spring支持哪几种bean\",{\"0\":{\"65\":1}}],[\"spring的\",{\"0\":{\"166\":1}}],[\"spring的核心思想\",{\"0\":{\"158\":1}}],[\"spring的aop功能用到了jdk的动态代理和cglib字节码生成技术\",{\"1\":{\"73\":1}}],[\"spring的配置方式\",{\"0\":{\"64\":1}}],[\"spring的jdbc抽象层提供了一个异常层次结构\",{\"1\":{\"61\":1}}],[\"springframework\",{\"1\":{\"63\":3,\"551\":1,\"552\":3,\"555\":3,\"557\":12,\"560\":12,\"561\":6,\"562\":15,\"563\":20,\"575\":1,\"583\":14,\"597\":1,\"606\":1,\"607\":1}}],[\"spring负责创建和管理bean对象的生命周期和配置\",{\"1\":{\"61\":1}}],[\"spring\",{\"0\":{\"58\":1,\"59\":1,\"60\":1,\"61\":1,\"63\":1,\"66\":1,\"82\":1,\"160\":1,\"544\":1,\"545\":1,\"546\":1,\"549\":1,\"551\":1},\"1\":{\"59\":4,\"60\":5,\"63\":1,\"70\":4,\"80\":6,\"81\":40,\"82\":3,\"104\":1,\"161\":1,\"168\":1,\"421\":3,\"506\":1,\"545\":4,\"546\":3,\"547\":1,\"551\":2,\"552\":2,\"555\":3,\"557\":7,\"558\":1,\"559\":4,\"560\":4,\"561\":2,\"562\":5,\"563\":6,\"571\":1,\"572\":2,\"575\":1,\"583\":4,\"592\":1,\"593\":11,\"602\":1,\"604\":4,\"605\":2,\"607\":2}}],[\"spector\",{\"1\":{\"7\":1}}],[\"split\",{\"1\":{\"55\":2,\"429\":1,\"729\":1,\"730\":2}}],[\"spl\",{\"1\":{\"3\":1}}],[\"sp\",{\"1\":{\"3\":3}}],[\"sp2\",{\"1\":{\"3\":7}}],[\"sp1\",{\"1\":{\"3\":8}}],[\"uf\",{\"1\":{\"709\":11}}],[\"ubuntu\",{\"1\":{\"616\":1}}],[\"uri定位资源\",{\"0\":{\"762\":1}}],[\"uri的格式\",{\"1\":{\"757\":1}}],[\"uri和url\",{\"0\":{\"756\":1}}],[\"uri\",{\"0\":{\"757\":1},\"1\":{\"598\":2,\"607\":2,\"775\":1,\"779\":1}}],[\"urlencoded\",{\"1\":{\"760\":1}}],[\"urlconnection\",{\"1\":{\"606\":1}}],[\"url路径\",{\"1\":{\"597\":1,\"606\":1}}],[\"url=jdbc\",{\"1\":{\"507\":1}}],[\"url>\",{\"1\":{\"498\":2,\"540\":2}}],[\"url\",{\"1\":{\"111\":10,\"161\":2,\"327\":1,\"339\":1,\"343\":3,\"499\":1,\"506\":1,\"540\":1,\"562\":3,\"575\":1,\"583\":1,\"597\":3,\"598\":1,\"605\":1,\"606\":2,\"746\":1}}],[\"ui\",{\"1\":{\"551\":1}}],[\"u\",{\"1\":{\"248\":3,\"458\":5,\"716\":10}}],[\"u>\",{\"1\":{\"243\":1,\"244\":1,\"248\":9}}],[\"udp\",{\"1\":{\"482\":1,\"749\":1}}],[\"udp支持广播和多播\",{\"1\":{\"156\":1}}],[\"udp适合用于实时应用\",{\"1\":{\"156\":1}}],[\"udp没有这些机制\",{\"1\":{\"156\":1}}],[\"udp不提供这些特性\",{\"1\":{\"156\":1}}],[\"udp用在哪些地方\",{\"0\":{\"156\":1},\"1\":{\"156\":1}}],[\"unavailable\",{\"1\":{\"777\":1}}],[\"unauthorized\",{\"1\":{\"607\":1,\"776\":1}}],[\"unsigned\",{\"1\":{\"605\":16}}],[\"unsafe类\",{\"0\":{\"296\":1}}],[\"unsafe\",{\"1\":{\"295\":1}}],[\"untitled\",{\"1\":{\"598\":1}}],[\"unpause\",{\"1\":{\"613\":1}}],[\"unpark方法增加凭证\",{\"1\":{\"271\":1}}],[\"unpark\",{\"1\":{\"270\":1,\"271\":1}}],[\"unpooled\",{\"1\":{\"506\":2}}],[\"unknownhostexception\",{\"1\":{\"483\":3}}],[\"unchecked\",{\"1\":{\"307\":1}}],[\"uncommitted\",{\"1\":{\"171\":1}}],[\"unlock\",{\"1\":{\"262\":1,\"271\":2,\"298\":4}}],[\"unwatch\",{\"1\":{\"202\":1}}],[\"undo日志存储了旧版本的数据值\",{\"1\":{\"178\":1}}],[\"undo日志\",{\"1\":{\"178\":1}}],[\"undo\",{\"1\":{\"177\":1,\"180\":2}}],[\"underlinepen\",{\"1\":{\"117\":1}}],[\"unix\",{\"1\":{\"768\":1}}],[\"union\",{\"1\":{\"709\":5}}],[\"unicode\",{\"1\":{\"480\":1}}],[\"unicode码\",{\"1\":{\"356\":1}}],[\"unirunstage\",{\"1\":{\"247\":1}}],[\"unit\",{\"1\":{\"135\":1}}],[\"uniquepathswithobstacles\",{\"1\":{\"696\":1}}],[\"uniquepaths\",{\"1\":{\"695\":1}}],[\"unique\",{\"1\":{\"2\":1,\"3\":5,\"605\":10}}],[\"ul>\",{\"1\":{\"111\":2}}],[\"utf8\",{\"1\":{\"480\":1}}],[\"utf\",{\"1\":{\"63\":1,\"327\":1,\"333\":1,\"335\":1,\"356\":1,\"477\":1,\"478\":1,\"485\":1,\"498\":1,\"499\":1,\"501\":1,\"504\":1,\"540\":2,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1,\"586\":1,\"614\":1}}],[\"util=\",{\"1\":{\"557\":1,\"560\":2,\"561\":1,\"562\":2,\"563\":2}}],[\"util包\",{\"1\":{\"396\":1}}],[\"util\",{\"1\":{\"55\":1,\"91\":1,\"102\":2,\"111\":4,\"114\":1,\"117\":1,\"128\":1,\"222\":1,\"232\":3,\"233\":3,\"248\":1,\"249\":1,\"253\":1,\"256\":6,\"262\":2,\"268\":10,\"297\":1,\"368\":2,\"396\":1,\"419\":1,\"433\":2,\"557\":6,\"560\":8,\"561\":4,\"562\":8,\"563\":8,\"569\":1,\"724\":2,\"729\":2,\"730\":1}}],[\"usr\",{\"1\":{\"614\":1,\"615\":2,\"616\":1}}],[\"usbinterface\",{\"1\":{\"417\":7}}],[\"us\",{\"1\":{\"111\":4,\"598\":1}}],[\"usessl=false\",{\"1\":{\"605\":1}}],[\"useunicode=true\",{\"1\":{\"605\":1}}],[\"use`\",{\"1\":{\"605\":1}}],[\"usegeneratedkeys=\",{\"1\":{\"501\":1,\"520\":1}}],[\"usegeneratedkeys\",{\"1\":{\"501\":1}}],[\"use类中属性的类型\",{\"1\":{\"501\":1}}],[\"usecommonpool\",{\"1\":{\"247\":1}}],[\"use\",{\"1\":{\"102\":5,\"117\":4,\"160\":1,\"563\":2}}],[\"used\",{\"1\":{\"91\":3,\"192\":2,\"689\":11,\"701\":11}}],[\"user开头\",{\"1\":{\"607\":1}}],[\"userclient\",{\"1\":{\"606\":2}}],[\"usercontroller\",{\"1\":{\"603\":2}}],[\"user`\",{\"1\":{\"605\":4}}],[\"userlog\",{\"1\":{\"586\":2}}],[\"userbalance=userbalance\",{\"1\":{\"583\":1}}],[\"userbalance=userbalance+\",{\"1\":{\"583\":1}}],[\"userbalance=\",{\"1\":{\"583\":1}}],[\"users\",{\"1\":{\"605\":1}}],[\"userstatus=\",{\"1\":{\"577\":1}}],[\"userstatus\",{\"1\":{\"576\":5}}],[\"userservice接口的实现类\",{\"1\":{\"419\":1}}],[\"userserviceproxy\",{\"1\":{\"419\":5}}],[\"userserviceimpl\",{\"1\":{\"419\":13}}],[\"userservice\",{\"1\":{\"63\":2,\"419\":11,\"555\":2,\"557\":4,\"563\":3,\"564\":4,\"565\":8,\"597\":1,\"598\":3,\"599\":2,\"602\":1,\"603\":2,\"604\":2,\"606\":3,\"607\":1,\"617\":1}}],[\"userproxy\",{\"1\":{\"572\":3}}],[\"userdaoproxy\",{\"1\":{\"569\":3}}],[\"userdao接口\",{\"1\":{\"557\":1}}],[\"userdaoimpl2\",{\"1\":{\"564\":3}}],[\"userdaoimpl1\",{\"1\":{\"564\":3,\"569\":2}}],[\"userdaoimpl实现类\",{\"1\":{\"557\":1}}],[\"userdaoimpl\",{\"1\":{\"557\":5,\"564\":1}}],[\"userdao\",{\"1\":{\"557\":9,\"564\":13,\"569\":9,\"571\":2}}],[\"userimpl\",{\"1\":{\"557\":1}}],[\"userid=\",{\"1\":{\"540\":1,\"577\":2,\"583\":1}}],[\"userid\",{\"1\":{\"504\":1,\"576\":5}}],[\"user类中的属性\",{\"1\":{\"501\":1}}],[\"usermap\",{\"1\":{\"501\":3}}],[\"usermapperimpl\",{\"1\":{\"502\":2,\"512\":2,\"518\":1,\"519\":1}}],[\"usermapper\",{\"1\":{\"499\":1,\"500\":2,\"501\":2,\"502\":3,\"509\":1,\"511\":3,\"512\":3}}],[\"username单个参数里面输什么无所谓\",{\"1\":{\"511\":1}}],[\"username=root\",{\"1\":{\"507\":1}}],[\"username=\",{\"1\":{\"501\":1,\"577\":1,\"583\":3}}],[\"username\",{\"1\":{\"334\":8,\"499\":1,\"501\":6,\"506\":1,\"511\":4,\"512\":12,\"517\":3,\"520\":1,\"562\":3,\"575\":1,\"576\":5,\"583\":1,\"605\":2}}],[\"user\",{\"1\":{\"63\":3,\"297\":5,\"339\":3,\"480\":4,\"499\":2,\"501\":7,\"508\":2,\"511\":4,\"512\":15,\"517\":6,\"518\":1,\"519\":2,\"520\":1,\"552\":10,\"555\":3,\"557\":2,\"569\":3,\"572\":7,\"576\":20,\"577\":16,\"583\":16,\"597\":5,\"598\":1,\"605\":5,\"606\":6,\"607\":3,\"617\":1}}],[\"userfactory\",{\"1\":{\"63\":5,\"555\":5}}],[\"useradd\",{\"1\":{\"63\":7,\"555\":7}}],[\"using\",{\"1\":{\"3\":2,\"605\":2}}],[\"up\",{\"1\":{\"617\":1,\"713\":4}}],[\"upstream\",{\"1\":{\"605\":1}}],[\"updatebankuser\",{\"1\":{\"583\":1}}],[\"update方法\",{\"1\":{\"577\":1,\"583\":1}}],[\"update>\",{\"1\":{\"501\":1}}],[\"updateuser\",{\"1\":{\"501\":1}}],[\"update\",{\"1\":{\"177\":1,\"419\":10,\"501\":1,\"557\":4,\"569\":3,\"576\":3,\"577\":12,\"583\":15}}],[\"up3\",{\"1\":{\"3\":4}}],[\"up2\",{\"1\":{\"3\":1}}],[\"up1\",{\"1\":{\"3\":6}}],[\"<root\",{\"1\":{\"586\":1}}],[\"<ref\",{\"1\":{\"557\":2}}],[\"<result\",{\"1\":{\"501\":1,\"522\":3,\"523\":13,\"524\":3,\"525\":8,\"527\":4}}],[\"<resultmap\",{\"1\":{\"501\":1,\"522\":1,\"523\":4,\"524\":1,\"525\":2,\"527\":1}}],[\"<releases>\",{\"1\":{\"498\":2,\"540\":2}}],[\"<repository>\",{\"1\":{\"498\":1,\"540\":1}}],[\"<repositories>\",{\"1\":{\"498\":1,\"540\":1}}],[\"<loggers>\",{\"1\":{\"586\":1}}],[\"<list>\",{\"1\":{\"557\":2}}],[\"<li>\",{\"1\":{\"111\":1}}],[\"<li><a\",{\"1\":{\"111\":1}}],[\"<javaclientgenerator\",{\"1\":{\"540\":1}}],[\"<javamodelgenerator\",{\"1\":{\"540\":1}}],[\"<jdbcconnection\",{\"1\":{\"540\":1}}],[\"<generatorconfiguration>\",{\"1\":{\"540\":1}}],[\"<groupid>io\",{\"1\":{\"606\":1}}],[\"<groupid>com\",{\"1\":{\"599\":2,\"602\":1}}],[\"<groupid>log4j<\",{\"1\":{\"540\":1}}],[\"<groupid>mysql<\",{\"1\":{\"498\":1,\"540\":2}}],[\"<groupid>junit<\",{\"1\":{\"498\":1,\"540\":1}}],[\"<groupid>org\",{\"1\":{\"498\":2,\"540\":6,\"597\":1,\"606\":1}}],[\"<groupid>ymk\",{\"1\":{\"498\":1,\"540\":1}}],[\"<foreach\",{\"1\":{\"531\":3}}],[\"<filter\",{\"1\":{\"339\":4}}],[\"<filter>\",{\"1\":{\"339\":1}}],[\"<cache\",{\"1\":{\"535\":1,\"536\":1}}],[\"<choose>\",{\"1\":{\"530\":1}}],[\"<collection\",{\"1\":{\"525\":2}}],[\"<console\",{\"1\":{\"586\":1}}],[\"<constructor\",{\"1\":{\"557\":2}}],[\"<configuration\",{\"1\":{\"586\":1}}],[\"<configuration>\",{\"1\":{\"499\":1}}],[\"<context\",{\"1\":{\"327\":2,\"540\":1,\"541\":1,\"562\":1,\"563\":5,\"572\":1,\"583\":1}}],[\"<when\",{\"1\":{\"530\":3}}],[\"<where>\",{\"1\":{\"528\":1,\"530\":1}}],[\"<web\",{\"1\":{\"327\":1}}],[\"<appenderref\",{\"1\":{\"586\":1}}],[\"<appenders>\",{\"1\":{\"586\":1}}],[\"<aop\",{\"1\":{\"572\":1,\"583\":3}}],[\"<array>\",{\"1\":{\"557\":1}}],[\"<artifactid>feign\",{\"1\":{\"606\":1}}],[\"<artifactid>spring\",{\"1\":{\"597\":1,\"599\":2,\"602\":1,\"606\":1}}],[\"<artifactid>log4j<\",{\"1\":{\"540\":1}}],[\"<artifactid>lombok<\",{\"1\":{\"498\":1,\"540\":1}}],[\"<artifactid>junit\",{\"1\":{\"540\":1}}],[\"<artifactid>junit<\",{\"1\":{\"498\":1,\"540\":1}}],[\"<artifactid>mysql\",{\"1\":{\"498\":1,\"540\":2}}],[\"<artifactid>mybatis<\",{\"1\":{\"498\":1,\"540\":1}}],[\"<artifactid>mybatis\",{\"1\":{\"498\":1,\"540\":4}}],[\"<association\",{\"1\":{\"523\":2,\"524\":1,\"527\":1}}],[\"<delete\",{\"1\":{\"501\":1,\"518\":1,\"531\":2}}],[\"<dependency>\",{\"1\":{\"498\":4,\"540\":9,\"597\":1,\"599\":2,\"602\":1,\"606\":1}}],[\"<dependencies>\",{\"1\":{\"498\":1,\"540\":2}}],[\"<datasource\",{\"1\":{\"499\":1,\"506\":1}}],[\"<entry\",{\"1\":{\"557\":2}}],[\"<environment\",{\"1\":{\"499\":1,\"506\":1}}],[\"<environments\",{\"1\":{\"499\":1,\"506\":1}}],[\"<enabled>false<\",{\"1\":{\"498\":2,\"540\":2}}],[\"<enabled>true<\",{\"1\":{\"498\":2,\"540\":2}}],[\"<optional>true<\",{\"1\":{\"498\":1,\"540\":1}}],[\"<object\",{\"1\":{\"460\":1}}],[\"<value>红楼梦<\",{\"1\":{\"557\":1}}],[\"<value>水浒<\",{\"1\":{\"557\":1}}],[\"<value>天龙八部<\",{\"1\":{\"557\":1}}],[\"<value>三国<\",{\"1\":{\"557\":1}}],[\"<value>pe<\",{\"1\":{\"557\":3}}],[\"<value>english<\",{\"1\":{\"557\":3}}],[\"<value>math<\",{\"1\":{\"557\":3}}],[\"<value><\",{\"1\":{\"557\":1}}],[\"<version>2\",{\"1\":{\"599\":1}}],[\"<version>release<\",{\"1\":{\"540\":1}}],[\"<version>8\",{\"1\":{\"498\":1,\"540\":2}}],[\"<version>4\",{\"1\":{\"498\":1,\"540\":1}}],[\"<version>3\",{\"1\":{\"498\":1,\"540\":1}}],[\"<version>1\",{\"1\":{\"498\":1,\"540\":5}}],[\"<v>\",{\"1\":{\"251\":2}}],[\"<map>\",{\"1\":{\"557\":1}}],[\"<mapper\",{\"1\":{\"499\":1,\"501\":1,\"504\":1,\"509\":2,\"522\":1,\"523\":1,\"535\":1}}],[\"<mappers>\",{\"1\":{\"499\":1,\"509\":1}}],[\"<maven\",{\"1\":{\"498\":2,\"540\":2}}],[\"<modelversion>4\",{\"1\":{\"498\":1,\"540\":1}}],[\"<memory>\",{\"1\":{\"3\":2}}],[\"<type>pom<\",{\"1\":{\"599\":1}}],[\"<typealias\",{\"1\":{\"499\":1,\"508\":2}}],[\"<typealiases>\",{\"1\":{\"499\":1,\"508\":1}}],[\"<tx\",{\"1\":{\"583\":3}}],[\"<table\",{\"1\":{\"540\":2}}],[\"<trim\",{\"1\":{\"529\":1,\"532\":1}}],[\"<transactionmanager\",{\"1\":{\"499\":1,\"506\":1}}],[\"<t\",{\"1\":{\"457\":1,\"458\":1,\"459\":1,\"461\":1}}],[\"<t>只能是引用类型\",{\"1\":{\"456\":1}}],[\"<t>\",{\"1\":{\"123\":1,\"251\":1}}],[\"<==\",{\"1\":{\"524\":1}}],[\"<=\",{\"1\":{\"363\":1,\"367\":1,\"376\":2,\"416\":1,\"428\":1,\"466\":1,\"468\":2,\"471\":1,\"477\":2,\"620\":1,\"621\":4,\"629\":1,\"630\":6,\"635\":1,\"645\":1,\"649\":1,\"650\":1,\"683\":1,\"686\":1,\"693\":2,\"694\":1,\"698\":1,\"700\":2,\"701\":4,\"702\":2,\"704\":2,\"709\":1,\"730\":2}}],[\"<if\",{\"1\":{\"527\":3,\"528\":3,\"529\":3,\"532\":3}}],[\"<id\",{\"1\":{\"501\":1,\"522\":1,\"523\":5,\"524\":1,\"525\":4,\"527\":2}}],[\"<id>aliyun\",{\"1\":{\"498\":2,\"540\":2}}],[\"<include\",{\"1\":{\"532\":1}}],[\"<insert\",{\"1\":{\"501\":2,\"520\":1,\"531\":1}}],[\"<init\",{\"1\":{\"327\":1}}],[\"<iostream>\",{\"1\":{\"3\":2}}],[\"<scope>import<\",{\"1\":{\"599\":1}}],[\"<scope>compile<\",{\"1\":{\"540\":1}}],[\"<scope>test<\",{\"1\":{\"498\":1,\"540\":1}}],[\"<sqlmapgenerator\",{\"1\":{\"540\":1}}],[\"<sql\",{\"1\":{\"532\":1}}],[\"<set>\",{\"1\":{\"557\":1}}],[\"<setting\",{\"1\":{\"522\":1,\"524\":2}}],[\"<settings>\",{\"1\":{\"522\":1,\"524\":1}}],[\"<select\",{\"1\":{\"501\":2,\"504\":1,\"511\":2,\"512\":4,\"517\":3,\"519\":1,\"522\":2,\"523\":3,\"525\":2,\"527\":1,\"528\":1,\"529\":1,\"530\":1,\"532\":1}}],[\"<servlet\",{\"1\":{\"327\":4}}],[\"<servlet>\",{\"1\":{\"327\":1}}],[\"<snapshots>\",{\"1\":{\"498\":2,\"540\":2}}],[\"<string\",{\"1\":{\"460\":1}}],[\"<s>\",{\"1\":{\"304\":1}}],[\"<plugin>\",{\"1\":{\"540\":1}}],[\"<plugins>\",{\"1\":{\"540\":1}}],[\"<pluginrepository>\",{\"1\":{\"498\":1,\"540\":1}}],[\"<pluginrepositories>\",{\"1\":{\"498\":1,\"540\":1}}],[\"<patternlayout\",{\"1\":{\"586\":1}}],[\"<package\",{\"1\":{\"508\":1,\"509\":1}}],[\"<packaging>jar<\",{\"1\":{\"498\":1,\"540\":1}}],[\"<param\",{\"1\":{\"327\":6}}],[\"<properties\",{\"1\":{\"507\":1}}],[\"<properties>\",{\"1\":{\"498\":1,\"540\":1}}],[\"<property\",{\"1\":{\"67\":3,\"499\":4,\"506\":4,\"540\":4,\"557\":26,\"560\":2,\"561\":1,\"562\":8,\"575\":5,\"583\":6}}],[\"<project\",{\"1\":{\"498\":1,\"540\":1}}],[\"<util\",{\"1\":{\"557\":1}}],[\"<update\",{\"1\":{\"501\":1}}],[\"<url>https\",{\"1\":{\"498\":2,\"540\":2}}],[\"<url\",{\"1\":{\"327\":1,\"339\":1,\"343\":3}}],[\"<u\",{\"1\":{\"248\":3}}],[\"<u>\",{\"1\":{\"238\":2,\"243\":1,\"244\":1,\"248\":6}}],[\"<ul>\",{\"1\":{\"111\":2}}],[\"<html>\",{\"1\":{\"760\":1}}],[\"<html><body>\",{\"1\":{\"335\":1}}],[\"<html><head><title>\",{\"1\":{\"111\":1}}],[\"<head><meta\",{\"1\":{\"614\":1}}],[\"<head>\",{\"1\":{\"614\":1}}],[\"<hr><address>\",{\"1\":{\"111\":1}}],[\"<h1>\",{\"1\":{\"111\":1,\"335\":1}}],[\"<build>\",{\"1\":{\"540\":1}}],[\"<body>\",{\"1\":{\"111\":1}}],[\"<bean\",{\"1\":{\"63\":1,\"67\":2,\"552\":1,\"555\":1,\"557\":15,\"560\":3,\"561\":2,\"562\":2,\"563\":1,\"575\":2,\"583\":3}}],[\"<beans\",{\"1\":{\"63\":1,\"552\":1,\"555\":1,\"557\":3,\"560\":2,\"561\":1,\"562\":2,\"563\":2,\"583\":1}}],[\"<\",{\"1\":{\"55\":8,\"63\":3,\"67\":4,\"91\":6,\"105\":2,\"111\":8,\"114\":3,\"117\":1,\"262\":3,\"318\":3,\"327\":12,\"335\":2,\"339\":3,\"343\":1,\"363\":1,\"367\":1,\"377\":2,\"381\":2,\"382\":6,\"431\":3,\"440\":2,\"443\":1,\"444\":1,\"460\":5,\"468\":1,\"469\":1,\"498\":22,\"499\":9,\"501\":42,\"504\":5,\"506\":7,\"507\":1,\"508\":3,\"509\":5,\"511\":4,\"512\":7,\"517\":3,\"518\":1,\"519\":2,\"520\":1,\"522\":7,\"523\":11,\"524\":4,\"525\":6,\"527\":7,\"528\":5,\"529\":5,\"530\":6,\"531\":6,\"532\":6,\"535\":1,\"540\":49,\"552\":3,\"555\":3,\"557\":53,\"560\":8,\"561\":6,\"562\":10,\"563\":9,\"575\":5,\"583\":20,\"586\":6,\"597\":2,\"599\":3,\"602\":2,\"606\":4,\"620\":1,\"621\":3,\"622\":1,\"623\":3,\"624\":6,\"625\":4,\"626\":1,\"627\":10,\"628\":3,\"629\":2,\"630\":4,\"631\":1,\"632\":2,\"635\":5,\"642\":1,\"643\":2,\"645\":3,\"646\":2,\"647\":1,\"648\":3,\"649\":2,\"650\":4,\"652\":3,\"653\":2,\"659\":1,\"660\":1,\"661\":4,\"662\":2,\"671\":1,\"674\":2,\"677\":5,\"678\":4,\"684\":1,\"685\":1,\"686\":2,\"687\":2,\"688\":2,\"689\":2,\"693\":2,\"694\":1,\"695\":2,\"696\":4,\"697\":1,\"698\":1,\"700\":3,\"701\":4,\"704\":2,\"705\":4,\"706\":4,\"707\":4,\"708\":6,\"709\":21,\"711\":1,\"712\":1,\"713\":2,\"715\":2,\"716\":1,\"717\":2,\"718\":4,\"727\":1,\"728\":1,\"729\":1,\"734\":2,\"737\":1,\"742\":1}}],[\"<<\",{\"1\":{\"3\":25,\"105\":1,\"367\":1,\"689\":2,\"701\":2}}],[\"几个简单例子\",{\"0\":{\"3\":1}}],[\"cin\",{\"1\":{\"727\":5,\"728\":6}}],[\"cf\",{\"1\":{\"684\":1}}],[\"cfh\",{\"1\":{\"102\":1}}],[\"ce\",{\"1\":{\"684\":1}}],[\"centos\",{\"1\":{\"616\":1}}],[\"centos7\",{\"0\":{\"49\":1}}],[\"cba\",{\"1\":{\"649\":1}}],[\"cbaebabacd\",{\"1\":{\"649\":1}}],[\"cdefgab\",{\"1\":{\"646\":1}}],[\"cd\",{\"1\":{\"614\":1,\"616\":1,\"684\":1}}],[\"cdata\",{\"1\":{\"557\":1}}],[\"cmd\",{\"1\":{\"599\":1,\"605\":1,\"616\":2}}],[\"cmpxchg指令\",{\"1\":{\"295\":1}}],[\"cj\",{\"1\":{\"499\":1,\"506\":1,\"507\":1,\"540\":1}}],[\"cuttingrope\",{\"1\":{\"737\":1,\"740\":1}}],[\"curmax\",{\"1\":{\"737\":3}}],[\"curdepth++\",{\"1\":{\"712\":2}}],[\"curdepth\",{\"1\":{\"712\":3}}],[\"curwidth\",{\"1\":{\"662\":2}}],[\"curheight\",{\"1\":{\"662\":2}}],[\"cura\",{\"1\":{\"639\":15}}],[\"curb\",{\"1\":{\"639\":13}}],[\"curb指向链表b的头结点\",{\"1\":{\"639\":1}}],[\"cur后移两位\",{\"1\":{\"637\":1}}],[\"cur\",{\"1\":{\"635\":7,\"636\":7,\"637\":11,\"638\":9,\"666\":3,\"669\":3,\"674\":13,\"675\":5,\"711\":3,\"712\":7,\"713\":5}}],[\"currentnode\",{\"1\":{\"635\":4}}],[\"currenttimemillens\",{\"1\":{\"434\":1}}],[\"currenttimemillis\",{\"1\":{\"256\":4,\"416\":2,\"431\":6}}],[\"currentthread\",{\"1\":{\"233\":3,\"249\":1,\"262\":1,\"268\":13,\"271\":12,\"298\":5,\"304\":2,\"306\":1,\"307\":2,\"313\":4,\"466\":4,\"468\":2,\"471\":5}}],[\"current\",{\"1\":{\"249\":1,\"256\":1,\"605\":12}}],[\"customers\",{\"1\":{\"456\":1}}],[\"c=\",{\"1\":{\"436\":1}}],[\"c指向一个string变量\",{\"1\":{\"429\":1}}],[\"cr+lf\",{\"1\":{\"768\":1}}],[\"cry\",{\"1\":{\"402\":5,\"418\":6}}],[\"create`\",{\"1\":{\"605\":9}}],[\"createrequest\",{\"1\":{\"598\":1}}],[\"create03\",{\"1\":{\"475\":1}}],[\"create02\",{\"1\":{\"475\":1}}],[\"create01\",{\"1\":{\"475\":1}}],[\"createnewfile\",{\"1\":{\"475\":4}}],[\"createmap\",{\"1\":{\"306\":2,\"307\":1}}],[\"createclone\",{\"1\":{\"117\":2}}],[\"createpage\",{\"1\":{\"111\":4}}],[\"createproduct\",{\"1\":{\"102\":3}}],[\"createtray\",{\"1\":{\"111\":6}}],[\"createlink\",{\"1\":{\"111\":10}}],[\"createyahoopage\",{\"1\":{\"111\":2}}],[\"create\",{\"1\":{\"5\":1,\"102\":4,\"117\":2,\"605\":13,\"615\":1}}],[\"ctrl\",{\"1\":{\"395\":6}}],[\"c++\",{\"1\":{\"376\":1}}],[\"c++11\",{\"1\":{\"2\":1}}],[\"c2\",{\"1\":{\"358\":2,\"359\":2}}],[\"c1\",{\"1\":{\"358\":2,\"359\":1}}],[\"css\",{\"1\":{\"323\":1}}],[\"cpp\",{\"0\":{\"788\":1}}],[\"cpp补完计划\",{\"0\":{\"1\":1}}],[\"cpyp\",{\"1\":{\"390\":2}}],[\"cpu在执行指令前\",{\"1\":{\"274\":1}}],[\"cpu在运行时\",{\"1\":{\"274\":1}}],[\"cpu会将计算所得数据写入内存\",{\"1\":{\"274\":1}}],[\"cpu多核\",{\"1\":{\"224\":1}}],[\"cpu一核\",{\"1\":{\"224\":1}}],[\"cpu\",{\"1\":{\"187\":2}}],[\"c\",{\"1\":{\"175\":3,\"176\":1,\"262\":1,\"318\":1,\"366\":5,\"376\":5,\"417\":2,\"419\":1,\"424\":4,\"429\":1,\"436\":14,\"475\":1,\"477\":1,\"542\":2,\"644\":3,\"645\":3,\"648\":1,\"649\":3,\"659\":6,\"660\":2,\"674\":8,\"675\":4,\"684\":3,\"704\":12,\"727\":1,\"728\":3}}],[\"chunked\",{\"1\":{\"768\":1}}],[\"choose>\",{\"1\":{\"530\":1}}],[\"choose\",{\"0\":{\"530\":1},\"1\":{\"530\":1}}],[\"chou\",{\"1\":{\"486\":1}}],[\"children\",{\"1\":{\"674\":6,\"675\":4}}],[\"child2\",{\"1\":{\"411\":4}}],[\"child1\",{\"1\":{\"411\":4}}],[\"child\",{\"1\":{\"411\":7,\"475\":4}}],[\"childgame\",{\"1\":{\"411\":1}}],[\"chengfabiao\",{\"1\":{\"376\":1}}],[\"checkloginbymap\",{\"1\":{\"512\":2}}],[\"checklogin\",{\"1\":{\"512\":7}}],[\"checkio\",{\"1\":{\"479\":1}}],[\"check\",{\"1\":{\"3\":4,\"202\":1,\"260\":1}}],[\"chain\",{\"1\":{\"252\":1,\"339\":2,\"607\":2}}],[\"channel\",{\"1\":{\"209\":1,\"210\":1}}],[\"chararray\",{\"1\":{\"650\":3}}],[\"character\",{\"1\":{\"649\":1}}],[\"characterencoding=utf8\",{\"1\":{\"605\":1}}],[\"charat\",{\"1\":{\"256\":1,\"429\":1,\"645\":7,\"647\":3,\"648\":9,\"649\":10,\"653\":8,\"659\":1,\"660\":1,\"674\":2,\"675\":1,\"684\":1,\"688\":2,\"702\":4}}],[\"charset=\",{\"1\":{\"614\":1}}],[\"charset=utf8\",{\"1\":{\"605\":9}}],[\"charset\",{\"1\":{\"480\":1,\"771\":1}}],[\"chars\",{\"1\":{\"477\":2}}],[\"char类型可以保存int的常量值\",{\"1\":{\"359\":1}}],[\"char变量不能赋值给byte\",{\"1\":{\"359\":1}}],[\"chardis\",{\"1\":{\"105\":2}}],[\"chardisplay\",{\"1\":{\"105\":3}}],[\"char\",{\"1\":{\"105\":2,\"117\":2,\"358\":3,\"359\":6,\"365\":1,\"372\":1,\"429\":3,\"477\":12,\"605\":1,\"642\":2,\"643\":3,\"644\":1,\"645\":2,\"646\":1,\"648\":2,\"650\":1,\"652\":2,\"659\":2,\"660\":1,\"674\":4,\"675\":1,\"684\":1,\"705\":4,\"706\":2,\"709\":4,\"713\":2}}],[\"ch\",{\"1\":{\"105\":5,\"477\":2,\"643\":5,\"646\":4,\"713\":10}}],[\"cl\",{\"1\":{\"486\":5}}],[\"clear\",{\"1\":{\"439\":1,\"477\":1}}],[\"cluster\",{\"1\":{\"183\":3,\"203\":4,\"599\":2,\"602\":1,\"605\":2}}],[\"clustered\",{\"1\":{\"179\":2}}],[\"cloud<\",{\"1\":{\"597\":1,\"599\":2,\"602\":1,\"606\":1}}],[\"cloud\",{\"1\":{\"592\":1,\"593\":5,\"597\":1,\"599\":5,\"602\":2,\"605\":1,\"606\":1,\"607\":3}}],[\"cloneobject\",{\"1\":{\"390\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"117\":1}}],[\"clone\",{\"1\":{\"116\":3,\"117\":4,\"421\":1}}],[\"cloneable之类的\",{\"1\":{\"120\":1}}],[\"cloneable\",{\"1\":{\"116\":3,\"117\":1}}],[\"closedisland\",{\"1\":{\"708\":1}}],[\"close=\",{\"1\":{\"531\":1}}],[\"close\",{\"1\":{\"105\":4,\"108\":4,\"111\":1,\"114\":5,\"368\":1,\"477\":9,\"478\":7,\"479\":2,\"485\":5,\"531\":1,\"535\":1,\"560\":1}}],[\"clients\",{\"1\":{\"598\":1,\"606\":1}}],[\"clienthttprequestexecution\",{\"1\":{\"598\":1}}],[\"clienthttpresponse\",{\"1\":{\"598\":1}}],[\"client<\",{\"1\":{\"597\":1}}],[\"client依赖都可以完成注册\",{\"1\":{\"597\":1}}],[\"client依赖\",{\"1\":{\"597\":1}}],[\"client2\",{\"1\":{\"419\":1}}],[\"client1\",{\"1\":{\"419\":1}}],[\"client\",{\"1\":{\"81\":1,\"597\":1,\"611\":1}}],[\"clazz\",{\"1\":{\"63\":2,\"555\":2}}],[\"classpathxmlapplicationcontext\",{\"1\":{\"552\":1,\"557\":1,\"559\":1,\"560\":2,\"576\":1,\"583\":1}}],[\"class类\",{\"1\":{\"486\":1}}],[\"class类本身就是一种泛型\",{\"1\":{\"461\":1}}],[\"classcastexception类型转换异常\",{\"1\":{\"424\":1}}],[\"class对象如同堆中其他对象一样存在gc堆中\",{\"1\":{\"411\":1}}],[\"class>\",{\"1\":{\"327\":1,\"339\":1}}],[\"class>com\",{\"1\":{\"327\":1,\"339\":1}}],[\"classloader\",{\"1\":{\"147\":1,\"419\":4}}],[\"classnotfoundexception\",{\"1\":{\"111\":1,\"147\":1,\"478\":1}}],[\"classname\",{\"1\":{\"111\":3}}],[\"class属性值\",{\"1\":{\"63\":1,\"555\":1}}],[\"classvalue\",{\"1\":{\"63\":2,\"555\":2}}],[\"class=\",{\"1\":{\"63\":1,\"67\":2,\"552\":1,\"555\":1,\"557\":15,\"560\":3,\"561\":2,\"562\":2,\"563\":1,\"575\":2,\"583\":3}}],[\"class\",{\"1\":{\"55\":2,\"63\":6,\"70\":2,\"72\":1,\"91\":1,\"96\":3,\"99\":2,\"102\":5,\"105\":4,\"108\":4,\"111\":11,\"114\":5,\"117\":5,\"232\":2,\"233\":1,\"248\":1,\"249\":1,\"252\":2,\"253\":1,\"256\":2,\"262\":2,\"263\":1,\"268\":3,\"271\":3,\"291\":2,\"292\":2,\"297\":2,\"298\":1,\"300\":2,\"308\":1,\"312\":1,\"313\":2,\"334\":2,\"339\":1,\"346\":1,\"351\":1,\"352\":3,\"354\":1,\"368\":1,\"376\":1,\"381\":3,\"382\":3,\"390\":2,\"391\":8,\"392\":1,\"399\":5,\"402\":8,\"403\":3,\"404\":4,\"411\":2,\"413\":5,\"414\":4,\"415\":2,\"416\":3,\"417\":11,\"418\":10,\"419\":9,\"421\":1,\"422\":1,\"424\":3,\"427\":3,\"428\":1,\"429\":1,\"430\":2,\"431\":1,\"433\":2,\"436\":3,\"439\":2,\"440\":3,\"443\":1,\"444\":1,\"445\":3,\"448\":1,\"451\":1,\"454\":4,\"456\":1,\"457\":3,\"458\":1,\"459\":2,\"461\":1,\"466\":10,\"467\":2,\"468\":4,\"469\":2,\"471\":5,\"475\":3,\"477\":5,\"478\":5,\"479\":1,\"480\":1,\"483\":1,\"485\":2,\"486\":5,\"491\":1,\"492\":1,\"502\":2,\"512\":1,\"524\":1,\"530\":1,\"535\":1,\"552\":2,\"555\":6,\"557\":6,\"559\":3,\"560\":2,\"563\":1,\"564\":3,\"565\":4,\"569\":5,\"572\":3,\"575\":2,\"576\":5,\"577\":1,\"583\":4,\"584\":4,\"586\":2,\"597\":1,\"603\":3,\"606\":5,\"607\":1,\"620\":1,\"621\":1,\"622\":1,\"623\":2,\"624\":3,\"625\":2,\"626\":1,\"627\":1,\"628\":1,\"629\":2,\"630\":2,\"631\":1,\"632\":1,\"634\":2,\"635\":4,\"636\":2,\"637\":2,\"638\":2,\"639\":2,\"640\":2,\"642\":1,\"643\":1,\"644\":1,\"645\":1,\"646\":1,\"647\":1,\"648\":1,\"649\":1,\"650\":1,\"652\":1,\"653\":1,\"655\":2,\"657\":1,\"658\":1,\"659\":1,\"660\":1,\"661\":2,\"662\":1,\"664\":2,\"666\":2,\"667\":2,\"668\":2,\"669\":2,\"671\":1,\"672\":2,\"674\":2,\"675\":3,\"677\":2,\"678\":2,\"683\":1,\"684\":1,\"685\":1,\"686\":2,\"687\":2,\"688\":1,\"689\":1,\"690\":1,\"693\":2,\"694\":1,\"695\":1,\"696\":1,\"697\":1,\"698\":1,\"699\":2,\"701\":2,\"702\":1,\"705\":1,\"706\":1,\"707\":1,\"708\":1,\"709\":4,\"712\":1,\"713\":1,\"715\":1,\"716\":1,\"717\":1,\"718\":1,\"720\":1,\"721\":1,\"724\":1,\"729\":2,\"730\":2,\"734\":1,\"737\":1,\"740\":1,\"742\":1}}],[\"canfinish\",{\"1\":{\"717\":1}}],[\"canpartition\",{\"1\":{\"689\":1,\"701\":2}}],[\"cancelled\",{\"1\":{\"312\":2}}],[\"cap\",{\"1\":{\"720\":3}}],[\"capacity`\",{\"1\":{\"605\":2}}],[\"capacity\",{\"1\":{\"605\":2,\"677\":5,\"720\":5}}],[\"caption\",{\"1\":{\"111\":20}}],[\"carpooling\",{\"1\":{\"677\":1}}],[\"car\",{\"1\":{\"443\":1}}],[\"card3\",{\"1\":{\"102\":2}}],[\"card2\",{\"1\":{\"102\":2}}],[\"card1\",{\"1\":{\"102\":2}}],[\"caoxueqin\",{\"1\":{\"439\":1}}],[\"camera\",{\"1\":{\"417\":3}}],[\"cat<t\",{\"1\":{\"459\":1}}],[\"cat\",{\"1\":{\"352\":4,\"387\":7,\"402\":2,\"414\":13,\"417\":2,\"418\":4,\"454\":2,\"466\":6}}],[\"catch细节\",{\"1\":{\"424\":1}}],[\"catch来捕获异常并处理\",{\"1\":{\"133\":1}}],[\"catch\",{\"1\":{\"111\":3,\"114\":3,\"117\":1,\"220\":1,\"233\":1,\"248\":7,\"249\":1,\"256\":1,\"262\":1,\"268\":3,\"271\":3,\"298\":3,\"304\":2,\"313\":2,\"424\":4,\"466\":7,\"467\":2,\"468\":5,\"469\":2,\"471\":1,\"475\":3,\"477\":14,\"478\":13,\"479\":3,\"480\":2,\"483\":3,\"485\":2,\"486\":3}}],[\"calender\",{\"1\":{\"436\":1}}],[\"calendar\",{\"1\":{\"436\":15}}],[\"calendar01\",{\"1\":{\"436\":1}}],[\"calendar是一个抽象类\",{\"1\":{\"436\":1}}],[\"calendar类\",{\"1\":{\"436\":1}}],[\"calcsum\",{\"1\":{\"734\":3}}],[\"calctimes\",{\"1\":{\"416\":2}}],[\"calcprice\",{\"1\":{\"256\":3}}],[\"called\",{\"1\":{\"645\":2,\"655\":1,\"674\":1}}],[\"callerrunspolicy\",{\"1\":{\"134\":1}}],[\"call\",{\"1\":{\"132\":1,\"232\":2}}],[\"callable<integer>\",{\"1\":{\"232\":1}}],[\"callabledemo\",{\"1\":{\"232\":1}}],[\"callable的区别\",{\"1\":{\"133\":1}}],[\"callable\",{\"0\":{\"133\":1},\"1\":{\"132\":4,\"232\":1}}],[\"ca\",{\"1\":{\"154\":1}}],[\"cas在操作的时候会检查变量的值是否被更改过\",{\"1\":{\"299\":1}}],[\"cas的缺点\",{\"0\":{\"299\":1}}],[\"cas手写自旋锁\",{\"0\":{\"298\":1}}],[\"cas核心类\",{\"1\":{\"296\":1}}],[\"cas底层原理\",{\"1\":{\"295\":1}}],[\"cas是什么\",{\"0\":{\"295\":1},\"1\":{\"295\":1}}],[\"cas机制就是乐观锁的典型实现\",{\"1\":{\"295\":1}}],[\"cas机制\",{\"0\":{\"294\":1}}],[\"cas算法\",{\"1\":{\"258\":1}}],[\"cas操作\",{\"1\":{\"143\":1}}],[\"cas\",{\"1\":{\"125\":1,\"202\":1}}],[\"case与end之间可以有多个when\",{\"1\":{\"6\":1}}],[\"case的简单函数使用简便\",{\"1\":{\"6\":1}}],[\"case\",{\"0\":{\"6\":1},\"1\":{\"6\":2,\"70\":1,\"372\":3,\"624\":1,\"689\":1,\"701\":1}}],[\"cachemapper\",{\"1\":{\"535\":1}}],[\"cacheenabled=\",{\"1\":{\"535\":1}}],[\"cache\",{\"1\":{\"81\":1,\"167\":2,\"428\":1,\"720\":12}}],[\"cglib动态代理\",{\"1\":{\"419\":1,\"492\":1}}],[\"cglib\",{\"1\":{\"72\":4,\"159\":2,\"492\":2,\"568\":1}}],[\"cnt++\",{\"1\":{\"632\":4}}],[\"cnt\",{\"1\":{\"390\":1,\"392\":1,\"631\":8,\"632\":1}}],[\"cn\",{\"1\":{\"5\":1,\"111\":2,\"607\":1}}],[\"coding\",{\"1\":{\"768\":1}}],[\"codeblockdetail\",{\"1\":{\"413\":2}}],[\"code\",{\"1\":{\"72\":1,\"416\":3}}],[\"copy\",{\"1\":{\"452\":1,\"616\":5}}],[\"copyof\",{\"1\":{\"433\":2}}],[\"copying\",{\"1\":{\"148\":1}}],[\"cookie技术通过在请求和响应报文中写入cookie信息来控制客户端状态\",{\"1\":{\"765\":1}}],[\"cookie\",{\"0\":{\"785\":1},\"1\":{\"165\":6,\"607\":1,\"785\":4}}],[\"cookie的首部字段信息\",{\"1\":{\"765\":1}}],[\"cookie的数据会通过http请求自动发送给服务器\",{\"1\":{\"153\":1}}],[\"cookie的存储容量有限制\",{\"1\":{\"153\":1}}],[\"cookie可以设置过期时间\",{\"1\":{\"153\":1}}],[\"cookie以键值对的形式存储在客户端的浏览器中\",{\"1\":{\"153\":1}}],[\"cookie保存在客户端\",{\"1\":{\"153\":1}}],[\"cookie和session的差别\",{\"0\":{\"153\":1}}],[\"coursename\",{\"1\":{\"557\":4}}],[\"course\",{\"1\":{\"557\":7}}],[\"course2\",{\"1\":{\"557\":2}}],[\"course1\",{\"1\":{\"557\":3}}],[\"coursesset\",{\"1\":{\"557\":1}}],[\"coursesmap\",{\"1\":{\"557\":1}}],[\"courseslist\",{\"1\":{\"557\":2}}],[\"coursesarray\",{\"1\":{\"557\":1}}],[\"count`\",{\"1\":{\"605\":4}}],[\"count=true\",{\"1\":{\"542\":2}}],[\"count\",{\"1\":{\"402\":3,\"411\":6,\"429\":1,\"466\":4,\"468\":5,\"542\":1,\"607\":1}}],[\"countdown\",{\"1\":{\"144\":2}}],[\"countdownlatch等都基于aqs实现\",{\"1\":{\"311\":1}}],[\"countdownlatch的实现原理是基于aqs提供的同步工具\",{\"1\":{\"144\":1}}],[\"countdownlatch使用了aqs\",{\"1\":{\"144\":1}}],[\"countdownlatch通常用于等待一组线程完成某项任务\",{\"1\":{\"144\":1}}],[\"countdownlatch是一种计数器\",{\"1\":{\"144\":1}}],[\"countdownlatch\",{\"0\":{\"144\":1},\"1\":{\"144\":1}}],[\"countdisplay\",{\"1\":{\"114\":2}}],[\"cout\",{\"1\":{\"3\":12}}],[\"co\",{\"1\":{\"111\":2}}],[\"corpflightbookings\",{\"1\":{\"678\":1}}],[\"corsconfigurations\",{\"1\":{\"607\":1}}],[\"corsregistry\",{\"1\":{\"78\":1}}],[\"core<\",{\"1\":{\"540\":2}}],[\"corepoolsize\",{\"1\":{\"135\":1}}],[\"core\",{\"1\":{\"60\":1,\"575\":1,\"583\":1}}],[\"collate=utf8\",{\"1\":{\"605\":9}}],[\"collect\",{\"1\":{\"256\":3}}],[\"collectors\",{\"1\":{\"256\":4}}],[\"collectiontype\",{\"1\":{\"557\":6,\"559\":4}}],[\"collection=\",{\"1\":{\"531\":3}}],[\"collection>\",{\"1\":{\"525\":2}}],[\"collection下有3个子接口\",{\"1\":{\"492\":1}}],[\"collection接口\",{\"1\":{\"451\":1}}],[\"collection接口和常用方法\",{\"0\":{\"439\":1}}],[\"collectioniterator\",{\"1\":{\"439\":1}}],[\"collection\",{\"1\":{\"148\":1,\"439\":1,\"448\":1,\"492\":1,\"525\":1}}],[\"collections是一个操作set\",{\"1\":{\"452\":1}}],[\"collections工具类\",{\"0\":{\"452\":1}}],[\"collections\",{\"1\":{\"46\":2}}],[\"col\",{\"1\":{\"439\":6}}],[\"cols\",{\"1\":{\"376\":2}}],[\"color\",{\"1\":{\"27\":1,\"716\":6}}],[\"column对应\",{\"1\":{\"522\":1}}],[\"column=\",{\"1\":{\"501\":2,\"522\":4,\"523\":19,\"524\":5,\"525\":12,\"527\":6}}],[\"column\",{\"1\":{\"5\":1,\"501\":1,\"523\":1,\"524\":1}}],[\"com的dns可解析域名也可以是ip地址\",{\"1\":{\"757\":1}}],[\"com就是域名\",{\"1\":{\"754\":1}}],[\"com和miaosha\",{\"1\":{\"607\":1}}],[\"com和www\",{\"1\":{\"607\":1}}],[\"com将ip地址映射成域名\",{\"1\":{\"482\":1}}],[\"com是一级目录\",{\"1\":{\"396\":1}}],[\"come\",{\"1\":{\"271\":6,\"298\":1}}],[\"combine\",{\"1\":{\"248\":1,\"683\":1}}],[\"command\",{\"1\":{\"615\":1}}],[\"commons\",{\"1\":{\"551\":2}}],[\"commonpool\",{\"1\":{\"238\":1,\"239\":2,\"247\":1}}],[\"comment=\",{\"1\":{\"605\":9}}],[\"comment\",{\"1\":{\"354\":2,\"605\":76}}],[\"committed隔离级别\",{\"1\":{\"178\":1}}],[\"committed\",{\"1\":{\"171\":1,\"178\":1}}],[\"compress\",{\"1\":{\"768\":1}}],[\"compiler\",{\"1\":{\"498\":4,\"540\":4}}],[\"computer\",{\"1\":{\"417\":4}}],[\"compose文件\",{\"1\":{\"617\":1}}],[\"compose\",{\"1\":{\"251\":1,\"617\":3}}],[\"componentscan\",{\"1\":{\"70\":1,\"84\":1,\"565\":1,\"584\":1}}],[\"componentscan或\",{\"1\":{\"68\":1}}],[\"component的衍生注解\",{\"1\":{\"69\":1}}],[\"component是最基础的注解\",{\"1\":{\"69\":1}}],[\"component和\",{\"1\":{\"69\":1,\"164\":1}}],[\"component\",{\"0\":{\"69\":1,\"70\":1},\"1\":{\"64\":1,\"69\":2,\"70\":6,\"563\":8,\"572\":4,\"583\":2,\"603\":1,\"607\":1}}],[\"completionstage<\",{\"1\":{\"248\":6}}],[\"completionstage<v>\",{\"1\":{\"248\":3}}],[\"completionstage<u>\",{\"1\":{\"248\":6}}],[\"completionstage接口源码demo\",{\"1\":{\"248\":1}}],[\"completionstage接口源码\",{\"1\":{\"248\":1}}],[\"completionstage分析\",{\"0\":{\"248\":1}}],[\"complete\",{\"1\":{\"242\":1}}],[\"complete方法\",{\"0\":{\"242\":1}}],[\"completablefuturemall\",{\"1\":{\"252\":1,\"253\":1,\"256\":1}}],[\"completablefutureuse\",{\"1\":{\"249\":1}}],[\"completablefuture使用例子\",{\"0\":{\"249\":1}}],[\"completablefuture使用场景\",{\"1\":{\"235\":1}}],[\"completablefuturedemo\",{\"1\":{\"248\":1}}],[\"completablefuture<string>\",{\"1\":{\"248\":1,\"253\":1}}],[\"completablefuture<void>\",{\"1\":{\"239\":2,\"245\":1,\"246\":1,\"247\":1,\"268\":4}}],[\"completablefuture<u>\",{\"1\":{\"238\":2,\"243\":1,\"244\":1}}],[\"completablefuture继承实现关系\",{\"1\":{\"237\":1}}],[\"completablefuture介绍\",{\"0\":{\"237\":1}}],[\"completablefuture源码分析\",{\"0\":{\"236\":1}}],[\"completablefuture提供了一种观察者模式类似的机制\",{\"1\":{\"235\":1}}],[\"completablefuture的优化方法\",{\"1\":{\"235\":1}}],[\"completablefuture优化future\",{\"0\":{\"235\":1}}],[\"completablefuture\",{\"0\":{\"228\":1},\"1\":{\"248\":8,\"249\":1,\"253\":5,\"256\":2,\"268\":6}}],[\"completablefuture是对feature的增强\",{\"1\":{\"164\":1}}],[\"compact\",{\"1\":{\"121\":1,\"148\":1}}],[\"comparable\",{\"1\":{\"461\":1}}],[\"comparable<t>\",{\"1\":{\"123\":1}}],[\"comparator<object>\",{\"1\":{\"433\":3}}],[\"comparator<t>\",{\"1\":{\"45\":1}}],[\"comparator\",{\"1\":{\"433\":1,\"451\":1,\"452\":1}}],[\"compareto比较两个字符串的大小\",{\"1\":{\"429\":1}}],[\"compareto\",{\"1\":{\"421\":1}}],[\"compareandsetstate\",{\"1\":{\"313\":2}}],[\"compareandset\",{\"1\":{\"297\":1,\"298\":2,\"300\":1}}],[\"compare\",{\"1\":{\"45\":1,\"143\":1,\"295\":1,\"431\":1,\"433\":3,\"451\":1}}],[\"com\",{\"1\":{\"27\":2,\"63\":1,\"67\":2,\"96\":4,\"99\":3,\"102\":11,\"105\":4,\"108\":5,\"111\":31,\"114\":6,\"117\":10,\"396\":2,\"483\":1,\"498\":2,\"499\":1,\"501\":1,\"506\":1,\"540\":3,\"551\":1,\"552\":1,\"555\":1,\"557\":15,\"559\":4,\"560\":3,\"561\":2,\"562\":3,\"563\":3,\"565\":1,\"571\":2,\"572\":6,\"575\":2,\"583\":4,\"584\":2,\"598\":10,\"599\":2,\"607\":1,\"730\":1}}],[\"conf文件\",{\"1\":{\"605\":1}}],[\"conf\",{\"1\":{\"605\":2,\"617\":2}}],[\"configidtag`\",{\"1\":{\"605\":1}}],[\"configinfotag\",{\"1\":{\"605\":1}}],[\"configinfobeta\",{\"1\":{\"605\":1}}],[\"configinfoaggr\",{\"1\":{\"605\":1}}],[\"configinfo\",{\"1\":{\"605\":1}}],[\"configtagrelation\",{\"1\":{\"605\":1}}],[\"config<\",{\"1\":{\"602\":1}}],[\"config>\",{\"1\":{\"583\":2}}],[\"config\",{\"0\":{\"505\":1},\"1\":{\"339\":1,\"499\":3,\"502\":1,\"540\":1,\"592\":1,\"593\":2,\"599\":1,\"602\":1,\"605\":17}}],[\"configuredefaultservlethandling\",{\"1\":{\"78\":1}}],[\"configurer\",{\"1\":{\"78\":2}}],[\"configurecontentnegotiation\",{\"1\":{\"78\":1}}],[\"configureviewresolvers\",{\"1\":{\"78\":1}}],[\"configurationproperties\",{\"1\":{\"603\":1}}],[\"configuration>\",{\"1\":{\"499\":1,\"586\":1}}],[\"configuration\",{\"1\":{\"70\":1,\"84\":1,\"499\":1,\"540\":1,\"565\":1,\"584\":1,\"606\":1}}],[\"configuration类中的\",{\"1\":{\"64\":1}}],[\"confirm\",{\"1\":{\"211\":1}}],[\"connect\",{\"1\":{\"763\":1}}],[\"connected\",{\"1\":{\"709\":3}}],[\"connecttimeout=1000\",{\"1\":{\"605\":1}}],[\"connecttimeout\",{\"1\":{\"598\":1}}],[\"connector\",{\"1\":{\"498\":1,\"540\":2}}],[\"connections\",{\"1\":{\"606\":2}}],[\"connectionurl=\",{\"1\":{\"540\":1}}],[\"connection\",{\"1\":{\"209\":1,\"760\":1}}],[\"connectivity\",{\"1\":{\"168\":1}}],[\"convert\",{\"1\":{\"491\":1}}],[\"converter<integer\",{\"1\":{\"491\":1}}],[\"consul\",{\"1\":{\"595\":1}}],[\"consumer<\",{\"1\":{\"245\":1,\"251\":1}}],[\"consumer<t>\",{\"1\":{\"129\":1,\"251\":3}}],[\"consumer\",{\"1\":{\"214\":1}}],[\"console>\",{\"1\":{\"586\":1}}],[\"console\",{\"1\":{\"586\":2}}],[\"consistent\",{\"1\":{\"178\":1}}],[\"consistency\",{\"1\":{\"170\":1}}],[\"constructor\",{\"1\":{\"557\":2}}],[\"constructor对象\",{\"1\":{\"486\":1}}],[\"construct\",{\"1\":{\"108\":2}}],[\"const\",{\"1\":{\"18\":1,\"260\":1}}],[\"containername\",{\"1\":{\"614\":1}}],[\"container\",{\"1\":{\"611\":1}}],[\"contain\",{\"1\":{\"598\":1}}],[\"containskey\",{\"1\":{\"448\":1,\"626\":1,\"648\":4,\"649\":2,\"671\":1,\"672\":1,\"689\":1,\"701\":1,\"720\":2,\"721\":2}}],[\"containsall\",{\"1\":{\"439\":1}}],[\"contains\",{\"1\":{\"91\":1,\"439\":1,\"440\":5,\"659\":1,\"685\":1,\"713\":3,\"718\":1}}],[\"control\",{\"1\":{\"158\":1,\"178\":1}}],[\"controller类\",{\"1\":{\"603\":1}}],[\"controller执行完成返回modelandview\",{\"1\":{\"76\":1}}],[\"controller是用于定义控制器\",{\"1\":{\"69\":1}}],[\"controller\",{\"0\":{\"69\":1},\"1\":{\"69\":2,\"76\":1,\"161\":3,\"162\":1,\"563\":1}}],[\"controller等\",{\"1\":{\"64\":1}}],[\"continue\",{\"0\":{\"378\":1},\"1\":{\"91\":1,\"378\":1,\"685\":1,\"688\":1,\"689\":2,\"701\":2,\"713\":1}}],[\"content\",{\"1\":{\"111\":3,\"605\":3,\"607\":1,\"760\":4,\"770\":2,\"771\":1,\"774\":2}}],[\"contentnegotiationconfigurer\",{\"1\":{\"78\":1}}],[\"context=\",{\"1\":{\"562\":1,\"563\":2,\"583\":1}}],[\"context>\",{\"1\":{\"540\":1}}],[\"context对象\",{\"1\":{\"341\":1}}],[\"context\",{\"1\":{\"60\":1,\"64\":1,\"327\":2,\"331\":1,\"552\":2,\"557\":2,\"559\":3,\"560\":3,\"562\":5,\"563\":11,\"565\":2,\"572\":1,\"576\":2,\"583\":7,\"584\":2}}],[\"concurrency\",{\"1\":{\"178\":1}}],[\"concurrent包的简称\",{\"1\":{\"222\":1}}],[\"concurrenthashmap使用volatile变量来保证多个线程之间的可见性\",{\"1\":{\"125\":1}}],[\"concurrenthashmap在进行插入\",{\"1\":{\"125\":1}}],[\"concurrenthashmap将整个哈希表分割成多个独立的段\",{\"1\":{\"125\":1}}],[\"concurrenthashmap如何保证线程安全\",{\"0\":{\"125\":1}}],[\"concurrent\",{\"1\":{\"57\":1,\"128\":1,\"232\":3,\"233\":3,\"248\":1,\"249\":1,\"253\":1,\"256\":3,\"262\":2,\"268\":10,\"297\":1}}],[\"concat\",{\"1\":{\"7\":1,\"429\":1,\"517\":2}}],[\"conditionobject机制如上图\",{\"1\":{\"319\":1}}],[\"conditionobject\",{\"0\":{\"319\":1}}],[\"condition\",{\"1\":{\"6\":1,\"271\":4,\"312\":2}}],[\"智能指针还包括了weak\",{\"1\":{\"3\":1}}],[\"智能指针\",{\"0\":{\"2\":1},\"1\":{\"3\":1}}],[\"1<=n<=100000\",{\"1\":{\"730\":1}}],[\"1→l2→ln\",{\"1\":{\"729\":1}}],[\"1→ln\",{\"1\":{\"729\":1}}],[\"1=1\",{\"1\":{\"720\":3}}],[\"1背包模板\",{\"1\":{\"701\":1}}],[\"1背包的模板\",{\"1\":{\"701\":1}}],[\"1背包问题的模板\",{\"1\":{\"701\":1}}],[\"1背包问题\",{\"1\":{\"687\":1}}],[\"160\",{\"0\":{\"639\":1}}],[\"16\",{\"0\":{\"741\":1},\"1\":{\"616\":1,\"629\":3,\"760\":1}}],[\"1623824544221\",{\"1\":{\"598\":1}}],[\"16位\",{\"1\":{\"358\":2}}],[\"1无法精确表示\",{\"1\":{\"492\":1}}],[\"1表示读取完毕\",{\"1\":{\"477\":2}}],[\"1的毫秒数\",{\"1\":{\"434\":1}}],[\"1在\",{\"1\":{\"428\":1}}],[\"1退出\",{\"1\":{\"408\":2}}],[\"198\",{\"0\":{\"697\":1}}],[\"1989\",{\"1\":{\"486\":1}}],[\"1997\",{\"1\":{\"445\":1}}],[\"1998\",{\"1\":{\"445\":1}}],[\"19\",{\"0\":{\"638\":1},\"1\":{\"404\":1,\"427\":1}}],[\"19th\",{\"1\":{\"20\":1}}],[\"1800\",{\"1\":{\"607\":1}}],[\"18\",{\"0\":{\"627\":1},\"1\":{\"404\":1,\"427\":1,\"524\":3}}],[\"1会变成double类型计算\",{\"1\":{\"359\":1}}],[\"1默认为double类型\",{\"1\":{\"359\":1}}],[\"1位\",{\"1\":{\"358\":1}}],[\"1f\",{\"1\":{\"358\":2}}],[\"1l\",{\"1\":{\"358\":2}}],[\"1byte\",{\"1\":{\"358\":1}}],[\"1beta\",{\"1\":{\"354\":1}}],[\"1层\",{\"1\":{\"263\":2}}],[\"1字符集中的字符\",{\"1\":{\"121\":1}}],[\"146\",{\"0\":{\"720\":1}}],[\"142\",{\"0\":{\"640\":1}}],[\"144\",{\"1\":{\"616\":1}}],[\"14\",{\"0\":{\"73\":1,\"735\":1,\"738\":1},\"1\":{\"726\":1}}],[\"131\",{\"0\":{\"688\":1}}],[\"13905142704\",{\"1\":{\"501\":1}}],[\"130\",{\"0\":{\"709\":1},\"1\":{\"359\":1}}],[\"13\",{\"0\":{\"72\":1,\"309\":1,\"310\":1,\"311\":1,\"312\":1,\"313\":1,\"314\":1,\"315\":1,\"316\":1,\"317\":1,\"318\":1,\"319\":1,\"732\":1}}],[\"138\",{\"1\":{\"27\":1}}],[\"1254\",{\"0\":{\"708\":1}}],[\"1252480844\",{\"1\":{\"501\":1}}],[\"121\",{\"1\":{\"629\":1}}],[\"1212\",{\"1\":{\"362\":1}}],[\"12<\",{\"1\":{\"498\":1,\"540\":1}}],[\"12000\",{\"1\":{\"445\":2}}],[\"123546\",{\"1\":{\"628\":3}}],[\"123564\",{\"1\":{\"628\":2}}],[\"123465\",{\"1\":{\"628\":4}}],[\"123456\",{\"1\":{\"501\":1,\"628\":1}}],[\"123\",{\"1\":{\"360\":1,\"617\":1}}],[\"126\",{\"1\":{\"359\":1}}],[\"12e4\",{\"1\":{\"358\":1}}],[\"127和128直接return缓存区的类\",{\"1\":{\"428\":1}}],[\"127位都与ascii码相同\",{\"1\":{\"356\":1}}],[\"127\",{\"1\":{\"130\":1,\"597\":1,\"605\":7}}],[\"128在范围外\",{\"1\":{\"428\":1}}],[\"128个字符\",{\"1\":{\"356\":1}}],[\"128\",{\"1\":{\"130\":1,\"428\":2,\"605\":22,\"647\":1}}],[\"12\",{\"0\":{\"70\":1,\"71\":1,\"542\":1,\"705\":1},\"1\":{\"362\":2,\"381\":1,\"429\":1,\"440\":2,\"478\":1}}],[\"1094\",{\"0\":{\"677\":1}}],[\"104\",{\"0\":{\"669\":1}}],[\"101\",{\"0\":{\"668\":1}}],[\"10^5\",{\"1\":{\"630\":2}}],[\"10^9\",{\"1\":{\"630\":1}}],[\"1024\",{\"1\":{\"478\":1,\"485\":1,\"605\":1}}],[\"1001\",{\"1\":{\"677\":1}}],[\"10010\",{\"1\":{\"607\":1,\"617\":2}}],[\"10086\",{\"1\":{\"597\":1}}],[\"100\",{\"1\":{\"404\":1,\"433\":1,\"466\":3,\"467\":1,\"468\":1,\"471\":1,\"478\":1,\"583\":1,\"584\":1,\"629\":3,\"724\":1}}],[\"1000000007\",{\"1\":{\"740\":2}}],[\"10000\",{\"1\":{\"467\":1}}],[\"1000\",{\"1\":{\"248\":2,\"291\":1,\"304\":2,\"466\":4,\"468\":2,\"469\":1}}],[\"10\",{\"0\":{\"68\":1,\"301\":1,\"302\":1,\"303\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":1,\"335\":1,\"533\":1,\"534\":1,\"535\":1,\"536\":1,\"537\":1,\"538\":1,\"702\":1,\"714\":1},\"1\":{\"114\":1,\"232\":1,\"262\":1,\"298\":1,\"304\":2,\"359\":5,\"360\":1,\"365\":2,\"377\":1,\"381\":1,\"382\":1,\"402\":1,\"403\":4,\"408\":1,\"424\":1,\"427\":2,\"439\":1,\"440\":5,\"443\":1,\"444\":1,\"454\":2,\"457\":1,\"469\":1,\"486\":1,\"492\":1,\"569\":1,\"583\":1,\"605\":13,\"629\":1,\"678\":6,\"724\":1,\"734\":2,\"760\":1}}],[\"17<\",{\"1\":{\"540\":1}}],[\"17\",{\"0\":{\"684\":1},\"1\":{\"49\":1,\"524\":3}}],[\"151\",{\"0\":{\"645\":1}}],[\"15\",{\"1\":{\"27\":1,\"468\":1,\"669\":2,\"726\":2,\"760\":1}}],[\"1ock\",{\"1\":{\"3\":1}}],[\"111\",{\"0\":{\"712\":1}}],[\"1109\",{\"0\":{\"678\":1}}],[\"116\",{\"1\":{\"408\":2}}],[\"112\",{\"1\":{\"408\":1}}],[\"118\",{\"1\":{\"408\":1}}],[\"11\",{\"0\":{\"69\":1,\"336\":1,\"539\":1,\"540\":1,\"541\":1,\"625\":1,\"719\":1},\"1\":{\"3\":3,\"362\":2,\"524\":3,\"629\":1,\"701\":2}}],[\"1\",{\"0\":{\"2\":1,\"3\":2,\"5\":1,\"44\":1,\"49\":1,\"51\":1,\"53\":1,\"55\":1,\"59\":1,\"75\":1,\"80\":1,\"86\":1,\"89\":1,\"219\":1,\"220\":2,\"221\":1,\"222\":2,\"223\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"229\":1,\"231\":1,\"237\":1,\"251\":1,\"255\":1,\"258\":1,\"266\":1,\"267\":2,\"268\":1,\"270\":1,\"273\":1,\"277\":1,\"281\":1,\"290\":1,\"295\":1,\"302\":1,\"306\":1,\"310\":1,\"315\":1,\"322\":2,\"323\":1,\"324\":1,\"326\":1,\"338\":1,\"463\":1,\"494\":1,\"495\":2,\"496\":1,\"498\":1,\"504\":1,\"506\":1,\"511\":1,\"514\":1,\"517\":1,\"522\":1,\"527\":1,\"534\":1,\"540\":1,\"544\":1,\"545\":2,\"546\":1,\"547\":2,\"548\":1,\"549\":1,\"551\":1,\"554\":1,\"557\":1,\"567\":1,\"574\":1,\"580\":1,\"586\":1,\"588\":1,\"594\":1,\"595\":2,\"596\":1,\"597\":1,\"598\":1,\"599\":1,\"600\":1,\"602\":1,\"609\":1,\"619\":1,\"626\":1,\"721\":1,\"723\":1,\"727\":1,\"745\":1,\"747\":1,\"751\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":1,\"767\":1,\"773\":1,\"779\":1,\"783\":1},\"1\":{\"5\":11,\"6\":1,\"7\":17,\"11\":12,\"18\":1,\"23\":1,\"25\":1,\"40\":2,\"55\":6,\"63\":1,\"70\":1,\"76\":2,\"83\":1,\"90\":1,\"91\":3,\"98\":3,\"101\":2,\"104\":2,\"107\":4,\"113\":2,\"116\":6,\"176\":1,\"186\":1,\"187\":1,\"194\":2,\"196\":1,\"210\":1,\"217\":1,\"239\":1,\"249\":1,\"252\":1,\"256\":1,\"259\":1,\"264\":1,\"268\":1,\"298\":1,\"299\":1,\"300\":4,\"312\":2,\"313\":7,\"318\":2,\"327\":1,\"334\":2,\"335\":1,\"340\":1,\"351\":1,\"354\":1,\"358\":7,\"359\":3,\"362\":3,\"365\":1,\"369\":1,\"376\":2,\"381\":4,\"382\":9,\"391\":8,\"399\":1,\"400\":1,\"403\":1,\"404\":1,\"408\":4,\"414\":1,\"416\":1,\"417\":1,\"418\":1,\"419\":1,\"424\":1,\"427\":1,\"428\":4,\"429\":2,\"430\":2,\"433\":1,\"434\":1,\"436\":4,\"439\":3,\"440\":5,\"443\":2,\"448\":1,\"471\":3,\"475\":1,\"477\":8,\"478\":6,\"479\":1,\"480\":1,\"485\":1,\"486\":1,\"489\":1,\"491\":1,\"495\":1,\"498\":1,\"499\":1,\"501\":3,\"504\":1,\"509\":1,\"524\":3,\"540\":4,\"542\":2,\"551\":6,\"552\":2,\"555\":1,\"557\":7,\"559\":1,\"560\":5,\"561\":1,\"562\":2,\"563\":2,\"576\":1,\"583\":2,\"586\":1,\"595\":1,\"597\":3,\"598\":2,\"599\":2,\"605\":7,\"606\":1,\"607\":3,\"620\":4,\"621\":8,\"622\":6,\"623\":2,\"624\":23,\"625\":5,\"627\":5,\"628\":20,\"629\":7,\"630\":7,\"631\":17,\"632\":4,\"634\":5,\"635\":3,\"636\":1,\"639\":2,\"640\":2,\"642\":2,\"643\":2,\"645\":10,\"647\":4,\"648\":6,\"649\":5,\"650\":9,\"651\":3,\"652\":3,\"653\":5,\"658\":1,\"659\":1,\"660\":3,\"661\":17,\"662\":5,\"667\":5,\"668\":3,\"669\":1,\"671\":2,\"672\":3,\"675\":2,\"677\":13,\"678\":14,\"683\":5,\"684\":4,\"686\":9,\"687\":32,\"688\":3,\"689\":11,\"690\":7,\"693\":10,\"694\":15,\"695\":7,\"696\":21,\"697\":16,\"698\":16,\"700\":14,\"701\":20,\"702\":11,\"704\":6,\"705\":9,\"706\":17,\"707\":6,\"708\":38,\"709\":17,\"713\":5,\"715\":3,\"716\":4,\"717\":7,\"718\":17,\"720\":19,\"721\":5,\"724\":4,\"729\":2,\"730\":11,\"734\":7,\"736\":1,\"737\":3,\"740\":2,\"742\":3,\"760\":8,\"762\":6,\"779\":2}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
