const l=JSON.parse('{"key":"v-53cc0e56","path":"/essay/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86.html","title":"面经整理","lang":"zh-CN","frontmatter":{"title":"面经整理","author":"jimowo","icon":"write","date":"2023-08-20T00:00:00.000Z","order":3,"category":["面经"],"tag":["Java"],"description":"面经整理 Java基础 Java中的继承和多态 接口和抽象类的区别 StringBuffer和StringBuilder的区别 继承和多态 继承是子类继承父类的除了静态方法和静态字段的所有方法和字段。 多态分为类的多态和方法的多态。类的多态体现为继承，方法的多态体现为对方法的重载。 接口和抽象类的区别 抽象类中可以有构造函数和非抽象方法，接口不能实例化，且所有方法都是抽象方法，jdk1.8中出现了default修饰的方法。接口中的所有成员变量都是public static final修饰的。 接口是行为的抽象，cloneable之类的，是Like A 的关系； 抽象类是类的抽象，是一种模板设计，是**Is A **的关系 StringBuffer 和StringBuilder的区别 StringBuilder线程不安全，效率比StringBuffer 高； StringBuffer的所有public 方法都是synchronized 修饰的。 底层是默认长度为16的字符数组，每次扩容为数组原长度的2倍+2","head":[["meta",{"property":"og:url","content":"https://jimowo.github.io/essay/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"博客|随笔|项目"}],["meta",{"property":"og:title","content":"面经整理"}],["meta",{"property":"og:description","content":"面经整理 Java基础 Java中的继承和多态 接口和抽象类的区别 StringBuffer和StringBuilder的区别 继承和多态 继承是子类继承父类的除了静态方法和静态字段的所有方法和字段。 多态分为类的多态和方法的多态。类的多态体现为继承，方法的多态体现为对方法的重载。 接口和抽象类的区别 抽象类中可以有构造函数和非抽象方法，接口不能实例化，且所有方法都是抽象方法，jdk1.8中出现了default修饰的方法。接口中的所有成员变量都是public static final修饰的。 接口是行为的抽象，cloneable之类的，是Like A 的关系； 抽象类是类的抽象，是一种模板设计，是**Is A **的关系 StringBuffer 和StringBuilder的区别 StringBuilder线程不安全，效率比StringBuffer 高； StringBuffer的所有public 方法都是synchronized 修饰的。 底层是默认长度为16的字符数组，每次扩容为数组原长度的2倍+2"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jimowo.github.io/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-23T13:17:23.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"面经整理"}],["meta",{"property":"article:author","content":"jimowo"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2023-08-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-23T13:17:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面经整理\\",\\"image\\":[\\"https://jimowo.github.io/\\"],\\"datePublished\\":\\"2023-08-20T00:00:00.000Z\\",\\"dateModified\\":\\"2023-08-23T13:17:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"jimowo\\"}]}"]]},"headers":[{"level":2,"title":"Java基础","slug":"java基础","link":"#java基础","children":[{"level":3,"title":"Java中的继承和多态 接口和抽象类的区别 StringBuffer和StringBuilder的区别","slug":"java中的继承和多态-接口和抽象类的区别-stringbuffer和stringbuilder的区别","link":"#java中的继承和多态-接口和抽象类的区别-stringbuffer和stringbuilder的区别","children":[]},{"level":3,"title":"说一下String内部结构，JDK9及之后的有什么变化","slug":"说一下string内部结构-jdk9及之后的有什么变化","link":"#说一下string内部结构-jdk9及之后的有什么变化","children":[]},{"level":3,"title":"ArrayList和LinkedList区别","slug":"arraylist和linkedlist区别","link":"#arraylist和linkedlist区别","children":[]},{"level":3,"title":"什么是泛型 泛型的作用 泛型的使用方式有哪几种","slug":"什么是泛型-泛型的作用-泛型的使用方式有哪几种","link":"#什么是泛型-泛型的作用-泛型的使用方式有哪几种","children":[]},{"level":3,"title":"HashMap的遍历方式有哪几种 ?HashMap与HashTable的区别? HashMap底层?(为什么是8和64没答出来 为什么选择红黑树这种数据结构 介绍一下红黑树)","slug":"hashmap的遍历方式有哪几种-hashmap与hashtable的区别-hashmap底层-为什么是8和64没答出来-为什么选择红黑树这种数据结构-介绍一下红黑树","link":"#hashmap的遍历方式有哪几种-hashmap与hashtable的区别-hashmap底层-为什么是8和64没答出来-为什么选择红黑树这种数据结构-介绍一下红黑树","children":[]},{"level":3,"title":"ConcurrentHashMap如何保证线程安全","slug":"concurrenthashmap如何保证线程安全","link":"#concurrenthashmap如何保证线程安全","children":[]},{"level":3,"title":"error和exception的区别 怎么处理exception","slug":"error和exception的区别-怎么处理exception","link":"#error和exception的区别-怎么处理exception","children":[]},{"level":3,"title":"final关键字有什么作用","slug":"final关键字有什么作用","link":"#final关键字有什么作用","children":[]},{"level":3,"title":"volatile关键字有什么作用","slug":"volatile关键字有什么作用","link":"#volatile关键字有什么作用","children":[]},{"level":3,"title":"Lambda表达式","slug":"lambda表达式","link":"#lambda表达式","children":[]},{"level":3,"title":"通过静态工厂 Integer.valueOf(int) 来创建 Integer 对象有什么好处","slug":"通过静态工厂-integer-valueof-int-来创建-integer-对象有什么好处","link":"#通过静态工厂-integer-valueof-int-来创建-integer-对象有什么好处","children":[]}]},{"level":2,"title":"Java多线程","slug":"java多线程","link":"#java多线程","children":[{"level":3,"title":"Java中实现多线程","slug":"java中实现多线程","link":"#java中实现多线程","children":[]},{"level":3,"title":"Runnable、Callable 区别，如何接收这两个线程异常","slug":"runnable、callable-区别-如何接收这两个线程异常","link":"#runnable、callable-区别-如何接收这两个线程异常","children":[]},{"level":3,"title":"如何创建一个线程池,拒绝策略有什么,怎么设置线程池的大小(动态修改)","slug":"如何创建一个线程池-拒绝策略有什么-怎么设置线程池的大小-动态修改","link":"#如何创建一个线程池-拒绝策略有什么-怎么设置线程池的大小-动态修改","children":[]},{"level":3,"title":"线程池7个参数？提交任务流程？为什么不先创建临时线程而是先放进阻塞队列？","slug":"线程池7个参数-提交任务流程-为什么不先创建临时线程而是先放进阻塞队列","link":"#线程池7个参数-提交任务流程-为什么不先创建临时线程而是先放进阻塞队列","children":[]},{"level":3,"title":"核心线程能否被回收","slug":"核心线程能否被回收","link":"#核心线程能否被回收","children":[]},{"level":3,"title":"线程池配置无界队列了之后，拒绝策略怎么搞，什么时候用到无界对列","slug":"线程池配置无界队列了之后-拒绝策略怎么搞-什么时候用到无界对列","link":"#线程池配置无界队列了之后-拒绝策略怎么搞-什么时候用到无界对列","children":[]},{"level":3,"title":"volatile和sychronized的区别","slug":"volatile和sychronized的区别","link":"#volatile和sychronized的区别","children":[]},{"level":3,"title":"synchronized锁升级过程和实现原理","slug":"synchronized锁升级过程和实现原理","link":"#synchronized锁升级过程和实现原理","children":[]},{"level":3,"title":"讲讲jmm内存模型，volatile作用，实现原理，为什么 volatile 能防止指令重排，为什么有可见性问题","slug":"讲讲jmm内存模型-volatile作用-实现原理-为什么-volatile-能防止指令重排-为什么有可见性问题","link":"#讲讲jmm内存模型-volatile作用-实现原理-为什么-volatile-能防止指令重排-为什么有可见性问题","children":[]},{"level":3,"title":"ReentrantLock 实现原理，AQS实现原理","slug":"reentrantlock-实现原理-aqs实现原理","link":"#reentrantlock-实现原理-aqs实现原理","children":[]},{"level":3,"title":"sychronized和ReentrantLock区别","slug":"sychronized和reentrantlock区别","link":"#sychronized和reentrantlock区别","children":[]},{"level":3,"title":"AQS队列为空时线程加入队列发生什么","slug":"aqs队列为空时线程加入队列发生什么","link":"#aqs队列为空时线程加入队列发生什么","children":[]},{"level":3,"title":"CountDownLatch Semaphore 使用和实现原理","slug":"countdownlatch-semaphore-使用和实现原理","link":"#countdownlatch-semaphore-使用和实现原理","children":[]}]},{"level":2,"title":"JVM","slug":"jvm","link":"#jvm","children":[{"level":3,"title":"有没有遇到过OOM,如何排查","slug":"有没有遇到过oom-如何排查","link":"#有没有遇到过oom-如何排查","children":[]},{"level":3,"title":"双亲委派机制的作用（JVM）","slug":"双亲委派机制的作用-jvm","link":"#双亲委派机制的作用-jvm","children":[]},{"level":3,"title":"JVM垃圾回收机制","slug":"jvm垃圾回收机制","link":"#jvm垃圾回收机制","children":[]}]},{"level":2,"title":"操作系统与计算机网络","slug":"操作系统与计算机网络","link":"#操作系统与计算机网络","children":[{"level":3,"title":"进程线程的区别,提示资源分配,空间占用方面","slug":"进程线程的区别-提示资源分配-空间占用方面","link":"#进程线程的区别-提示资源分配-空间占用方面","children":[]},{"level":3,"title":"并发和并行的区别","slug":"并发和并行的区别","link":"#并发和并行的区别","children":[]},{"level":3,"title":"IP地址和MAC地址区别","slug":"ip地址和mac地址区别","link":"#ip地址和mac地址区别","children":[]},{"level":3,"title":"Cookie和Session的差别","slug":"cookie和session的差别","link":"#cookie和session的差别","children":[]},{"level":3,"title":"HTTP和HTTPs的差别","slug":"http和https的差别","link":"#http和https的差别","children":[]},{"level":3,"title":"http状态码，https怎么建立连接的","slug":"http状态码-https怎么建立连接的","link":"#http状态码-https怎么建立连接的","children":[]},{"level":3,"title":"tcp和udp区别，udp用在哪些地方","slug":"tcp和udp区别-udp用在哪些地方","link":"#tcp和udp区别-udp用在哪些地方","children":[]}]},{"level":2,"title":"Spring框架","slug":"spring框架","link":"#spring框架","children":[{"level":3,"title":"你最擅长的Java框架,介绍一下 Spring的核心思想","slug":"你最擅长的java框架-介绍一下-spring的核心思想","link":"#你最擅长的java框架-介绍一下-spring的核心思想","children":[]},{"level":3,"title":"什么是动态代理 什么是CGI","slug":"什么是动态代理-什么是cgi","link":"#什么是动态代理-什么是cgi","children":[]},{"level":3,"title":"Spring Bean 生命周期","slug":"spring-bean-生命周期","link":"#spring-bean-生命周期","children":[]},{"level":3,"title":"讲讲一个http请求发到controller的过程","slug":"讲讲一个http请求发到controller的过程","link":"#讲讲一个http请求发到controller的过程","children":[]},{"level":3,"title":"DispatcherServlet是干嘛的","slug":"dispatcherservlet是干嘛的","link":"#dispatcherservlet是干嘛的","children":[]},{"level":3,"title":"Spring怎么解决循环依赖问题","slug":"spring怎么解决循环依赖问题","link":"#spring怎么解决循环依赖问题","children":[]},{"level":3,"title":"Spring中使用多线程","slug":"spring中使用多线程","link":"#spring中使用多线程","children":[]},{"level":3,"title":"登录系统的Cookie和Session如何设计？","slug":"登录系统的cookie和session如何设计","link":"#登录系统的cookie和session如何设计","children":[]},{"level":3,"title":"Spring的@Transaction，假如我一个@Service，里面有两个public方法A和B，A上面没有@Transaction，B有，A方法调用B方法，事务会生效吗？","slug":"spring的-transaction-假如我一个-service-里面有两个public方法a和b-a上面没有-transaction-b有-a方法调用b方法-事务会生效吗","link":"#spring的-transaction-假如我一个-service-里面有两个public方法a和b-a上面没有-transaction-b有-a方法调用b方法-事务会生效吗","children":[]},{"level":3,"title":"MyBatis的缓存机制，有哪些缓存策略","slug":"mybatis的缓存机制-有哪些缓存策略","link":"#mybatis的缓存机制-有哪些缓存策略","children":[]},{"level":3,"title":"如果没有Spring怎么开发","slug":"如果没有spring怎么开发","link":"#如果没有spring怎么开发","children":[]}]},{"level":2,"title":"MySQL数据库","slug":"mysql数据库","link":"#mysql数据库","children":[{"level":3,"title":"事务特性","slug":"事务特性","link":"#事务特性","children":[]},{"level":3,"title":"数据库的事务,并发事务会带来哪些问题,MySQL的默认隔离级别 如何在数据库中实现数据的备份和恢复","slug":"数据库的事务-并发事务会带来哪些问题-mysql的默认隔离级别-如何在数据库中实现数据的备份和恢复","link":"#数据库的事务-并发事务会带来哪些问题-mysql的默认隔离级别-如何在数据库中实现数据的备份和恢复","children":[]},{"level":3,"title":"MySQL数据库的索引结构为什么用b+树，b树缺点？","slug":"mysql数据库的索引结构为什么用b-树-b树缺点","link":"#mysql数据库的索引结构为什么用b-树-b树缺点","children":[]},{"level":3,"title":"MySQL行数多了为什么会变慢 加索引为什么会快","slug":"mysql行数多了为什么会变慢-加索引为什么会快","link":"#mysql行数多了为什么会变慢-加索引为什么会快","children":[]},{"level":3,"title":"怎么设计数据库索引","slug":"怎么设计数据库索引","link":"#怎么设计数据库索引","children":[]},{"level":3,"title":"最左匹配原则是什么，以及为什么这样就可以用到联合索引","slug":"最左匹配原则是什么-以及为什么这样就可以用到联合索引","link":"#最左匹配原则是什么-以及为什么这样就可以用到联合索引","children":[]},{"level":3,"title":"联合索引为什么要遵守前缀匹配？","slug":"联合索引为什么要遵守前缀匹配","link":"#联合索引为什么要遵守前缀匹配","children":[]},{"level":3,"title":"MySQL有哪些日志，分别起什么作用","slug":"mysql有哪些日志-分别起什么作用","link":"#mysql有哪些日志-分别起什么作用","children":[]},{"level":3,"title":"MySQL MVCC  原理","slug":"mysql-mvcc-原理","link":"#mysql-mvcc-原理","children":[]},{"level":3,"title":"MySQL索引类型，什么是聚簇索引，什么是非聚簇索引","slug":"mysql索引类型-什么是聚簇索引-什么是非聚簇索引","link":"#mysql索引类型-什么是聚簇索引-什么是非聚簇索引","children":[]},{"level":3,"title":"MySQL的WAL原则","slug":"mysql的wal原则","link":"#mysql的wal原则","children":[]},{"level":3,"title":"MySQL怎么排查慢查询","slug":"mysql怎么排查慢查询","link":"#mysql怎么排查慢查询","children":[]},{"level":3,"title":"MySQL支持事务的存储引擎","slug":"mysql支持事务的存储引擎","link":"#mysql支持事务的存储引擎","children":[]},{"level":3,"title":"SQL语句的执行顺序","slug":"sql语句的执行顺序","link":"#sql语句的执行顺序","children":[]}]},{"level":2,"title":"Redis 缓存","slug":"redis-缓存","link":"#redis-缓存","children":[{"level":3,"title":"Redis 为什么快，为什么能处理高并发？","slug":"redis-为什么快-为什么能处理高并发","link":"#redis-为什么快-为什么能处理高并发","children":[]},{"level":3,"title":"Redis 为什么采用单线程","slug":"redis-为什么采用单线程","link":"#redis-为什么采用单线程","children":[]},{"level":3,"title":"Redis 基本类型","slug":"redis-基本类型","link":"#redis-基本类型","children":[]},{"level":3,"title":"Redis 持久化方式","slug":"redis-持久化方式","link":"#redis-持久化方式","children":[]},{"level":3,"title":"Redis 的扩容方式","slug":"redis-的扩容方式","link":"#redis-的扩容方式","children":[]},{"level":3,"title":"Redis 过期键的删除策略","slug":"redis-过期键的删除策略","link":"#redis-过期键的删除策略","children":[]},{"level":3,"title":"Redis 的缓存淘汰策略","slug":"redis-的缓存淘汰策略","link":"#redis-的缓存淘汰策略","children":[]},{"level":3,"title":"为何 Redis 使用跳表而非红黑树实现 SortedSet （zset）？","slug":"为何-redis-使用跳表而非红黑树实现-sortedset-zset","link":"#为何-redis-使用跳表而非红黑树实现-sortedset-zset","children":[]},{"level":3,"title":"布隆过滤器原理","slug":"布隆过滤器原理","link":"#布隆过滤器原理","children":[]},{"level":3,"title":"缓存与数据库一致性问题","slug":"缓存与数据库一致性问题","link":"#缓存与数据库一致性问题","children":[]},{"level":3,"title":"解决缓存与数据库一致性问题","slug":"解决缓存与数据库一致性问题","link":"#解决缓存与数据库一致性问题","children":[]},{"level":3,"title":"什么是缓存穿透 怎么解决","slug":"什么是缓存穿透-怎么解决","link":"#什么是缓存穿透-怎么解决","children":[]},{"level":3,"title":"什么是缓存雪崩 怎么解决","slug":"什么是缓存雪崩-怎么解决","link":"#什么是缓存雪崩-怎么解决","children":[]},{"level":3,"title":"Redis的Set元素过多怎么办","slug":"redis的set元素过多怎么办","link":"#redis的set元素过多怎么办","children":[]},{"level":3,"title":"Redis内存不够了怎么办","slug":"redis内存不够了怎么办","link":"#redis内存不够了怎么办","children":[]},{"level":3,"title":"Redis 事务的概念","slug":"redis-事务的概念","link":"#redis-事务的概念","children":[]},{"level":3,"title":"Redis 事务相关指令","slug":"redis-事务相关指令","link":"#redis-事务相关指令","children":[]},{"level":3,"title":"Redis 集群方式，哨兵选举过程","slug":"redis-集群方式-哨兵选举过程","link":"#redis-集群方式-哨兵选举过程","children":[]},{"level":3,"title":"主从复制的原理","slug":"主从复制的原理","link":"#主从复制的原理","children":[]},{"level":3,"title":"Redis 实现分布式锁","slug":"redis-实现分布式锁","link":"#redis-实现分布式锁","children":[]}]},{"level":2,"title":"RabbitMQ 消息队列","slug":"rabbitmq-消息队列","link":"#rabbitmq-消息队列","children":[{"level":3,"title":"为什么使用消息队列","slug":"为什么使用消息队列","link":"#为什么使用消息队列","children":[]},{"level":3,"title":"AMQP 三层协议","slug":"amqp-三层协议","link":"#amqp-三层协议","children":[]},{"level":3,"title":"RabbitMQ 构造","slug":"rabbitmq-构造","link":"#rabbitmq-构造","children":[]},{"level":3,"title":"消费消息的流程","slug":"消费消息的流程","link":"#消费消息的流程","children":[]},{"level":3,"title":"如何保证消息可靠性","slug":"如何保证消息可靠性","link":"#如何保证消息可靠性","children":[]},{"level":3,"title":"如何保证 RabbitMQ 消息队列高可用","slug":"如何保证-rabbitmq-消息队列高可用","link":"#如何保证-rabbitmq-消息队列高可用","children":[]},{"level":3,"title":"RabbitMQ 和kafka 区别","slug":"rabbitmq-和kafka-区别","link":"#rabbitmq-和kafka-区别","children":[]},{"level":3,"title":"为什么Kafka吞吐量高","slug":"为什么kafka吞吐量高","link":"#为什么kafka吞吐量高","children":[]}]},{"level":2,"title":"微服务","slug":"微服务","link":"#微服务","children":[{"level":3,"title":"分布式锁使用场景","slug":"分布式锁使用场景","link":"#分布式锁使用场景","children":[]},{"level":3,"title":"zookeeper分布式锁实现原理","slug":"zookeeper分布式锁实现原理","link":"#zookeeper分布式锁实现原理","children":[]}]}],"git":{"createdTime":1690897971000,"updatedTime":1692796643000,"contributors":[{"name":"jimowo","email":"1252480844@qq.com","commits":10}]},"readingTime":{"minutes":88.39,"words":26517},"filePathRelative":"essay/面经整理.md","localizedDate":"2023年8月20日","excerpt":"<h1> 面经整理</h1>\\n<h2> Java基础</h2>\\n<h3> Java中的继承和多态 接口和抽象类的区别 StringBuffer和StringBuilder的区别</h3>\\n<ul>\\n<li>\\n<p>继承和多态</p>\\n<p>继承是子类继承父类的除了静态方法和静态字段的所有方法和字段。<br>\\n多态分为类的多态和方法的多态。类的多态体现为继承，方法的多态体现为对方法的重载。</p>\\n</li>\\n<li>\\n<p>接口和抽象类的区别</p>\\n<p>抽象类中可以有构造函数和非抽象方法，接口不能实例化，且所有方法都是抽象方法，jdk1.8中出现了default修饰的方法。接口中的所有成员变量都是public static final修饰的。<br>\\n接口是行为的抽象，cloneable之类的，是<strong>Like A</strong> 的关系；<br>\\n抽象类是类的抽象，是一种模板设计，是**Is A **的关系</p>\\n</li>\\n<li>\\n<p>StringBuffer 和StringBuilder的区别</p>\\n<p>StringBuilder线程不安全，效率比StringBuffer 高；<br>\\nStringBuffer的所有public 方法都是synchronized 修饰的。<br>\\n底层是默认长度为16的字符数组，每次扩容为数组原长度的2倍+2</p>\\n</li>\\n</ul>","autoDesc":true}');export{l as data};
